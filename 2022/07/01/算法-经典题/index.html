<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>算法-题 | ValcanoZz Blog</title><meta name="keywords" content="基础"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="剑指offer03-数组中重复的数字(E)找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 123456输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;&#x3D; n &lt;&#x3D; 100000  解： 只需返回">
<meta property="og:type" content="article">
<meta property="og:title" content="算法-题">
<meta property="og:url" content="http://example.com/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%A2%98/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="剑指offer03-数组中重复的数字(E)找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 123456输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 限制：2 &lt;&#x3D; n &lt;&#x3D; 100000  解： 只需返回">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg">
<meta property="article:published_time" content="2022-07-01T10:00:12.000Z">
<meta property="article:modified_time" content="2023-05-18T00:35:20.876Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%A2%98/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '算法-题',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-18 08:35:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">33</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">16</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">算法-题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-07-01T10:00:12.000Z" title="发表于 2022-07-01 18:00:12">2022-07-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-18T00:35:20.876Z" title="更新于 2023-05-18 08:35:20">2023-05-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>70分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="算法-题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><h2 id="03-数组中重复的数字-E"><a href="#03-数组中重复的数字-E" class="headerlink" title="03-数组中重复的数字(E)"></a>03-数组中重复的数字(E)</h2><p>找出数组中重复的数字。</p>
<p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br><span class="line">输出：2 或 3 </span><br><span class="line"></span><br><span class="line">限制：</span><br><span class="line">2 &lt;= n &lt;= 100000</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>只需返回第一个出现重复的数字即可。使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前的数字是重复数字。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">repeat</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                repeat = num;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="04-二维数组中的查找-M"><a href="#04-二维数组中的查找-M" class="headerlink" title="04-二维数组中的查找(M)"></a>04-二维数组中的查找(M)</h2><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。<br>请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br>例：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    [1,   4,  7, 11, 15],</span><br><span class="line">    [2,   5,  8, 12, 19],</span><br><span class="line">    [3,   6,  9, 16, 22],</span><br><span class="line">    [10, 13, 14, 17, 24],</span><br><span class="line">    [18, 21, 23, 26, 30]</span><br><span class="line">]</span><br><span class="line">给定 target = 5，返回 true。</span><br><span class="line">给定 target = 20，返回 false。</span><br></pre></td></tr></table></figure>

<p>解：</p>
<p>由于给定的二维数组具备每行从左到右递增以及每列从上到下递增的特点，当访问到一个元素时，可以排除数组中的部分元素：</p>
<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 true。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行。</p>
<blockquote>
<p>可以证明这种方法不会错过目标值。如果当前元素大于目标值，说明当前元素的下边的所有元素都一定大于目标值，因此往下查找不可能找到目标值，往左查找可能找到目标值。如果当前元素小于目标值，说明当前元素的左边的所有元素都一定小于目标值，因此往左查找不可能找到目标值，往下查找可能找到目标值。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length, m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = m - <span class="number">1</span>; i &lt; n &amp;&amp; j &gt;= <span class="number">0</span>; ) &#123;</span><br><span class="line"><span class="comment">//            System.out.println(matrix[i][j]);</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">Solution</span>().findNumberIn2DArray(<span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;</span><br><span class="line">                &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">                &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">                &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">                &#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;</span><br><span class="line">        &#125;, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="05-替换空格-E"><a href="#05-替换空格-E" class="headerlink" title="05-替换空格(E)"></a>05-替换空格(E)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//    请实现一个函数，把字符串 s 中的每个空格替换成&quot;%20&quot;。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    示例 1：</span></span><br><span class="line"><span class="comment">//    输入：s = &quot;We are happy.&quot;</span></span><br><span class="line"><span class="comment">//    输出：&quot;We%20are%20happy.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    限制：  0 &lt;= s 的长度 &lt;= 10000</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] array = <span class="keyword">new</span> <span class="title class_">char</span>[length * <span class="number">3</span>];	<span class="comment">//将一个字符换成3个字符，所以大小要3倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                array[size++] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                array[size++] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                array[size++] = c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(array, <span class="number">0</span>, size);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//        StringBuffer sb = new StringBuffer(&quot;&quot;);</span></span><br><span class="line"><span class="comment">//        int n = s.length();</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (s.charAt(i) == &#x27; &#x27;) &#123;</span></span><br><span class="line"><span class="comment">//                sb.append(&quot;%20&quot;);</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                sb.append(s.charAt(i));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return sb.toString();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="06-从尾到头打印链表-E"><a href="#06-从尾到头打印链表-E" class="headerlink" title="06-从尾到头打印链表(E)"></a>06-从尾到头打印链表(E)</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br><span class="line"></span><br><span class="line">限制：0 &lt;= 链表长度 &lt;= 10000</span><br></pre></td></tr></table></figure>

<ol>
<li><p>使用栈</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">            stack.push(temp);</span><br><span class="line">            temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> stack.size();</span><br><span class="line">        <span class="type">int</span>[] print = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            print[i] = stack.pop().val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> print;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        recursion(head, list);</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[list.size()];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> list.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = list.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recursion</span><span class="params">(ListNode head, List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        recursion(head.next, list);</span><br><span class="line">        list.add(head.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先遍历出链表长度，再从尾到头赋值，无需借助Stack和ArrayList</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">currNode</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(currNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            len ++;</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//再次遍历链表，将值倒序填充至结果数组</span></span><br><span class="line">        currNode = head;</span><br><span class="line">        <span class="keyword">while</span>(currNode != <span class="literal">null</span>)&#123;</span><br><span class="line">            result[len - <span class="number">1</span>] = currNode.val;</span><br><span class="line">            len --;</span><br><span class="line">            currNode = currNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先翻转链表</p>
</li>
</ol>
<h1 id="代码随想录"><a href="#代码随想录" class="headerlink" title="代码随想录"></a>代码随想录</h1><h1 id="leetcode"><a href="#leetcode" class="headerlink" title="leetcode"></a>leetcode</h1><h2 id="2-两数相加-M"><a href="#2-两数相加-M" class="headerlink" title="2.两数相加(M)"></a>2.两数相加(M)</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>要注意的点：</p>
<p>节点和大于9，要注意进位；</p>
<p>最后一个节点进位要额外新加一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            list.val %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> list;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1 != <span class="literal">null</span> ? l1.val : l2.val);</span><br><span class="line">                l1 = l1 != <span class="literal">null</span> ? l1.next : l1;</span><br><span class="line">                l2 = l2 != <span class="literal">null</span> ? l2.next : l2;</span><br><span class="line">            &#125;</span><br><span class="line">            list = list.next;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                list.val++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                list.val %= <span class="number">10</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="3-无重复字符的最长子串-M"><a href="#3-无重复字符的最长子串-M" class="headerlink" title="3.无重复字符的最长子串(M)"></a>3.无重复字符的最长子串(M)</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>思路：</p>
<p>使用滑动窗口：每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p>
<p>使用哈希集合判断是否有字符重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashSet&lt;Character&gt; set= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                set.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r + <span class="number">1</span>&lt; n &amp;&amp; !set.contains(s.charAt(r + <span class="number">1</span>)))&#123;</span><br><span class="line">                set.add(s.charAt(r + <span class="number">1</span>));</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, r - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-寻找两个正序数组的中位数-D"><a href="#4-寻找两个正序数组的中位数-D" class="headerlink" title="4.寻找两个正序数组的中位数(D)"></a>4.寻找两个正序数组的中位数(<strong>D</strong>)</h2><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，中位数 <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>方法一：</p>
<p>暴力法：直接将两个数组加入到一个新数组，排序，再求中位数</p>
<p>时间复杂度：O（(m+n)*log(m+n) )；空间：O（m+n）</p>
<p>将两个数组的值从小到大 合并到新数组，再求中位数</p>
<p>时间复杂度：O（m+n )；空间：O（m+n）</p>
<p>方法二：</p>
<p>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。</p>
<p>时间复杂度：O（m+n )；空间：O（1）</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><p>这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)&#x2F;2 或 (m+n)&#x2F;2+1。</p>
<p>找到第 k 个元素，我们可以比较 A[k&#x2F;2-1] 和B[k&#x2F;2-1]，</p>
<p>可以归纳出三种情况：</p>
<ul>
<li><p>如果 A[k&#x2F;2-1] &lt; B[k&#x2F;2-1]，则比 A[k&#x2F;2−1] 小的数最多只有 A 的前 k&#x2F;2−1 个数和 B 的前 k&#x2F;2−1 个数，即比 A[k&#x2F;2−1] 小的数最多只有 k-2 个，因此 A[k&#x2F;2−1] 不可能是第 k 个数，A[0] 到 A[k&#x2F;2−1] 也都不可能是第 k 个数，可以全部排除。</p>
</li>
<li><p>如果 A[k&#x2F;2−1]&gt;B[k&#x2F;2−1]，则可以排除 B[0] 到 B[k&#x2F;2−1]。</p>
</li>
<li><p>如果 A[k&#x2F;2−1]&#x3D;B[k&#x2F;2−1]，则可以归入第一种情况处理。</p>
</li>
</ul>
<p>可以看到，比较 A[k&#x2F;2−1] 和 B[k&#x2F;2−1] 之后，可以排除 k&#x2F;2k&#x2F;2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p>
<p>有以下三种情况需要特殊处理：</p>
<ul>
<li><p>如果 A[k&#x2F;2−1] 或者B[k&#x2F;2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k&#x2F;2。</p>
</li>
<li><p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</p>
</li>
<li><p>如果 k&#x3D;1，我们只要返回两个数组首元素的最小值即可。</p>
</li>
</ul>
<p>用一个例子说明：</p>
<p>A: 1 3 <strong>4</strong> 9<br>B: 1 2 <strong>3</strong> 4 5 6 7 8 9</p>
<blockquote>
<p>k &#x3D; (4 + 9 ) &#x2F; 2 + 1 &#x3D; 7;</p>
<p>比较两个数组下标为k &#x2F; 2 - 1 &#x3D; 2的数，即A[2] 和B[2]</p>
<p>由于A[2] &gt; B[2] ，所以排除B[0] 到B[2]，数组B的下标偏移变为3，同时更新k的值：K &#x3D; K - K &#x2F; 2 &#x3D; 4;</p>
<p>下一步寻找，比较下标为 K &#x2F; 2 - 1 &#x3D; 1的数，即A[1] 和B[4] </p>
</blockquote>
<p>A: 1 <strong>3</strong> 4 9<br>B: <del>1 2 3</del> 4 <strong>5</strong> 6 7 8 9</p>
<blockquote>
<p>由于 A[1] &lt; B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k &#x3D; k - k&#x2F;2&#x3D;2。</p>
<p>下一步寻找，比较两个有序数组中下标为 k&#x2F;2-1&#x3D;0 的数，即比较 A[2] 和 B[3]</p>
</blockquote>
<p>A: <del>1 3</del> <strong>4</strong> 9<br>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p>
<blockquote>
<p>由于A[2]&#x3D;B[3]，根据之前的规则，排除A 中的元素，因此排除 A[2]，即数组 A 的下标偏移变为 3，同时更新 k 的值： k&#x3D;k-k&#x2F;2&#x3D;1。</p>
<p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3] &gt; B[3]，因此第 k 个数是 B[3]&#x3D;4。</p>
</blockquote>
<p>A: <del>1 3 4</del> <strong>9</strong> </p>
<p>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（log(m+n) )；空间：O（1）</p>
<h3 id="划分数组"><a href="#划分数组" class="headerlink" title="划分数组"></a><strong>划分数组</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// 为了保证第一个数组比第二个数组小(或者相等)</span></span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数</span></span><br><span class="line">        <span class="comment">//的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLeft</span> <span class="operator">=</span> (leftLength + rightLength + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> leftLength;</span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j]</span></span><br><span class="line">        <span class="comment">//  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// 循环条件结束的条件为指针重合，即分割线已找到</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置</span></span><br><span class="line">            <span class="comment">// 此处+1首先是为了不出现死循环，即left永远小于right的情况</span></span><br><span class="line">            <span class="comment">// left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right</span></span><br><span class="line">            <span class="comment">// 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了</span></span><br><span class="line">            <span class="comment">// i不会取到0值，即i-1不会小于0(另一说法：此处+1是为了避免出现死循环，同时+1后，不会出现下标越界的情况)</span></span><br><span class="line">            <span class="comment">// 此时i也代表着在一个数组中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和</span></span><br><span class="line">            <span class="comment">// 此时j就是第二个元素中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">            <span class="comment">// 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值</span></span><br><span class="line">            <span class="comment">// 说明又指针应该左移，即-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环时left一定等于right，所以此时等于left和right都可以</span></span><br><span class="line">        <span class="comment">// 为什么left一定不会大于right?因为left=i。</span></span><br><span class="line">        <span class="comment">// 此时i代表分割线在第一个数组中所在的位置</span></span><br><span class="line">        <span class="comment">// nums1[i]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums[i-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 此时j代表分割线在第二个数组中的位置</span></span><br><span class="line">        <span class="comment">// nums2[j]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums2[j-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">        <span class="comment">// 当i=0时，说明第一个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1LeftMax</span> <span class="operator">=</span> i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1RightMin</span> <span class="operator">=</span> i == leftLength ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="comment">// 当j=0时，说明第二个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LeftMax</span> <span class="operator">=</span> j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2RightMin</span> <span class="operator">=</span> j == rightLength ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        <span class="comment">// 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可</span></span><br><span class="line">        <span class="keyword">if</span> (((leftLength + rightLength) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一</span></span><br><span class="line">            <span class="comment">// 此处不能被向下取整，所以要强制转换为double类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（log min(m+n) )；空间：O（1）</p>
<h2 id="5-最长回文子串-M"><a href="#5-最长回文子串-M" class="headerlink" title="5.最长回文子串(M)"></a>5.最长回文子串(M)</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">输入：s = <span class="string">&quot;ac&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h3><p>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p>
<ul>
<li>首先往左寻找与当期位置相同的字符，直到遇到不相等为止。</li>
<li>然后往右寻找与当期位置相同的字符，直到遇到不相等为止。</li>
<li>最后左右双向扩散，直到左和右不相等。</li>
</ul>
<p>每个位置向两边扩散都会出现一个窗口大小（templen）。如果 templen &gt; maxLen，则更新 maxLen 的值。<br>因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 maxLen 时的起始，结尾位置（也可以只记录初始位置，结尾位置 &#x3D; 初始位置 + maxlen - 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> &amp;&amp; s.charAt(<span class="number">0</span>) == s.charAt(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>, templen = <span class="number">0</span>, lIndex = <span class="number">0</span>, rIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">1</span>; mid &lt; n - <span class="number">1</span>; mid++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid - <span class="number">1</span>, j = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == s.charAt(mid))&#123;</span><br><span class="line">                i--;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp;s.charAt(j) == s.charAt(mid))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    templen += <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxlen &lt; templen)&#123;</span><br><span class="line">                maxlen = templen;</span><br><span class="line">                lIndex = i + <span class="number">1</span>;</span><br><span class="line">                rIndex = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            templen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(lIndex, rIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n^2）空间复杂度： O（1）</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。</p>
<p><strong>边界条件：</strong>子串长度小于2 时一定为回文串，即 ： j - 1 - ( i + 1 ) + 1 &lt; 2 ,整理得 <strong>j - i &#x3D; 3</strong> </p>
<p><strong>状态转移方程：</strong></p>
<p><strong>dp[ i ] [ j ] &#x3D; ( s [ i ] &#x3D;&#x3D; s [ j ] ) and ( j - i &lt; 3 or dp[ i + 1] [j - 1] )</strong></p>
<p>由于dp [ i ] [ j ] 参考它左下方的值，所以应该<strong>按列升序</strong>填写</p>
<p>例如： </p>
<table>
<thead>
<tr>
<th>字符</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>子串右边界</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>子串左边界</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
<td>false</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
<td>false</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>true</td>
<td>flase</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n^2）空间复杂度： O（n^2）</p>
<h3 id="Manacher-马拉车-算法"><a href="#Manacher-马拉车-算法" class="headerlink" title="Manacher (马拉车)算法"></a>Manacher (马拉车)算法</h3><p>专门用于查找最长回文子串的算法，时间复杂度：O（n）</p>
<h2 id="10-正则表达式匹配-D"><a href="#10-正则表达式匹配-D" class="headerlink" title="10.正则表达式匹配(D)"></a>10.正则表达式匹配(D)</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘ . ‘ 和 ‘ * ‘ 的正则表达式匹配。</p>
<p>‘ . ‘ 匹配任意单个字符<br>‘ * ‘ 匹配零个或多个前面的那一个元素</p>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>从左往右扫的话</p>
<ul>
<li>字符后面是否跟着星号会影响结果，分析起来有点复杂。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/073085fa67286871f76e8e9daa162bdb291a101b4314666c75379a7b0441cad6-image.png" alt="image.png"></li>
</ul>
<p>所以选择从右往左扫描：</p>
<ul>
<li>星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/5e7b1748039a2a779d7378bebc4926ef3e584e88cc22b67f3a4e18c0590bcc55-image.png" alt="image.png"></p>
<ul>
<li>s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。</li>
<li>只是最右端可能是特殊符号，需要分情况讨论而已。</li>
</ul>
<p><strong>通用地表示出子问题：</strong></p>
<ul>
<li>大子串是否匹配，和剩余子串是否匹配，是规模不一样的同一问题。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/e1bcac2ad07a3a5c959bf0fe5c8ceea9bbd033c3066e7ec7f384aedd98cd95aa-image.png" alt="image.png"></li>
</ul>
<p>*<em>情况1：s[i-1] 和 <em>p</em>[<em>j</em>−1] 是匹配的</em>*</p>
<ul>
<li>最右端的字符是匹配的，那么，大问题的答案 &#x3D; 剩余子串是否匹配。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202305180835289.png" alt="image.png"></li>
</ul>
<p><strong>情况2：s[i-1] 和 p[j-1] 是不匹配的</strong></p>
<ul>
<li>右端不匹配，还不能判死刑——可能是 p[j-1]<em>p</em>[<em>j</em>−1] 为星号造成的不匹配，星号不是真实字符，它不匹配不算数。</li>
<li>如果 p[j-1]<em>p</em>[<em>j</em>−1] 不是星号，那就真的不匹配了。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image.png" alt="image.png"></li>
</ul>
<p><strong>p[j-1] &#x3D;&#x3D;”∗”，且 s[i-1] 和 p[j-2] 匹配</strong></p>
<ul>
<li>p[j-1]<em>p</em>[<em>j</em>−1]是星号，并且 s[i-1] 和 p[j-2] 匹配，要考虑三种情况：<ul>
<li>p[j-1] 星号可以让 p[j-2]在 p 串中消失、出现 1 次、出现 &gt;&#x3D;2 次。</li>
<li>只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image.png" alt="image.png"></li>
<li>a3 情况：假设 s 的右端是一个 a，p 的右端是a* ，* 让 a 重复 &gt;&#x3D; 2 次<ul>
<li>星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。</li>
<li>星号拷贝了 &gt;&#x3D;2 个 a，拿掉一个，剩下 &gt;&#x3D;1 个a，p 末端依旧是 a* 没变。</li>
<li>s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>p[j-1] &#x3D;&#x3D; “∗”，但 s[i-1] 和 p[j-2] 不匹配</p>
<ul>
<li>s[i-1] 和 p[j−2] 不匹配，还有救，p[j−1] 星号可以干掉 p[j−2]，继续考察 s(0 , i-1) 和 p(0 , j-3)。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image.png" alt="image.png"></li>
</ul>
<p>注意：</p>
<ul>
<li>p为空串，s不为空串，肯定不匹配。</li>
<li>s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。</li>
<li>s、p都为空串，肯定匹配。<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/140597adfd5f03dd481e136163d98e7160cce4761c7cb8227010d828f24b7498-image.png" alt="image.png"></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;  </span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();    </span><br><span class="line">        <span class="type">char</span>[] cp = p.toCharArray();    </span><br><span class="line">        <span class="comment">// dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配  </span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[cs.length + <span class="number">1</span>][cp.length + <span class="number">1</span>];   </span><br><span class="line">        <span class="comment">// 初期值  </span></span><br><span class="line">        <span class="comment">// s为空，p为空，能匹配上 </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">// p为空，s不为空，必为false(boolean数组默认值为false，无需处理) </span></span><br><span class="line">        <span class="comment">// s为空，p不为空，由于*可以匹配0个字符，所以有可能为true     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;   </span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];   </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 填格子   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cs.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;  </span><br><span class="line">                <span class="comment">// 文本串和模式串末位字符能匹配上  </span></span><br><span class="line">                <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">1</span>] || cp[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;    </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];     </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 模式串末位是*  </span></span><br><span class="line">                    <span class="comment">// 模式串*的前一个字符能够跟文本串的末位匹配上    </span></span><br><span class="line">                    <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">2</span>] || cp[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;     </span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>]      <span class="comment">// *匹配0次的情况   </span></span><br><span class="line">                            || dp[i - <span class="number">1</span>][j];     <span class="comment">// *匹配1次或多次的情况  </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模式串*的前一个字符不能够跟文本串的末位匹配     </span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];     <span class="comment">// *只能匹配0次     </span></span><br><span class="line">                    &#125;          </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> dp[cs.length][cp.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="29-两数相除-M"><a href="#29-两数相除-M" class="headerlink" title="29.两数相除(M)"></a>29.两数相除(M)</h2><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，<strong>要求不使用乘法、除法和 mod 运算符</strong>。</p>
<p><strong>返回</strong> 被除数 dividend 除以 除数 divisor 得到的<strong>商</strong>。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<blockquote>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<p>指数递增</p>
<p>由于题目规定只能存储32位整数，所以<strong>只能使用int</strong>，要考虑除法结果溢出。</p>
<p>对于<strong>溢出或容易出错的边界</strong>情况：</p>
<ul>
<li>当<strong>被除数</strong>是32位有符号数的<strong>最小值-2的31次方</strong>时：<ul>
<li>如果除数为1，那么直接返回答案-2的31次方；</li>
<li>如果除数为-1，那么答案为2的31次方，产生了溢出。</li>
</ul>
</li>
<li>当<strong>除数</strong>为32位有符号整数的<strong>最小值-2的31次方</strong>：<ul>
<li>如果被除数同样为-2的31次方，那么直接返回答案1；</li>
<li>对于其余情况，直接返回0；</li>
</ul>
</li>
<li>当被除数为0时，直接返回答案0；</li>
</ul>
<p>对于<strong>除数和被除数的符号</strong>，需要考虑4种情况，为了方便，使 除数和被除数符号 符号相同，这样就只需考虑一种符号的情况，由于都取整数的话可能会溢出，因此将除数和被除数<strong>都取为负数</strong>。</p>
<p>方法一：二分法</p>
<h3 id="指数递增步长"><a href="#指数递增步长" class="headerlink" title="指数递增步长"></a>指数递增步长</h3><p>方法二：<strong>指数递增步长</strong>（类二分查找，快速加）：</p>
<ul>
<li>我们首先不断地将 Y 乘以 2（通过加法运算实现），并将这些结果放入数组中，其中数组的<strong>第 i 项</strong>就等于 <strong>Y * 2的 i 次方</strong>；这一过程直到 Y 的两倍严格小于 X 为止。</li>
<li>对数组进行逆序遍历。当遍历到第 i 项时，如果大于等于X， 就将答案增加2的 i 次方，并且将X减去这一项的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;        <span class="comment">// 考虑被除数为最小值的情况     </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;            </span><br><span class="line">            &#125;        </span><br><span class="line">    	&#125;        </span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE) &#123;           </span><br><span class="line">            <span class="type">return</span> <span class="variable">dividend</span> <span class="operator">=</span>= Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找       </span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况       </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="literal">false</span>;       </span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;           </span><br><span class="line">            dividend = -dividend;       </span><br><span class="line">            rev = !rev;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            divisor = -divisor;    </span><br><span class="line">            rev = !rev;     </span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();       	</span><br><span class="line">        candidates.add(divisor);   </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="comment">//填充数组，第i项相当于Y*2的i次方（Y为除数）;     </span></span><br><span class="line">        <span class="comment">// 注意溢出:判断A+B是否小于C时，A+B可能溢出，因此改为A&lt;C-B   </span></span><br><span class="line">        <span class="comment">// (任意两个负数的差一定在[-2的31次方+1,2的31次方-1]范围内)      </span></span><br><span class="line">        <span class="keyword">while</span> (candidates.get(index) &gt;= dividend - candidates.get(index)) &#123;     </span><br><span class="line">            candidates.add(candidates.get(index) + candidates.get(index));        </span><br><span class="line">            ++index;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candidates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (candidates.get(i) &gt;= dividend) &#123;      </span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i;          </span><br><span class="line">                dividend -= candidates.get(i);    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="166-分数到小数-M"><a href="#166-分数到小数-M" class="headerlink" title="166.分数到小数(M)"></a>166.分数到小数(M)</h2><p>给定两个整数，分别表示分数的<strong>分子 numerator</strong> 和<strong>分母 denominator</strong>，以 字符串形式返回小数 。</p>
<p>如果小数部分为循环小数，则<strong>将循环的部分括在括号内</strong>。</p>
<p>如果存在多个答案，只需返回任意一个 。</p>
<p>对于所有给定的输入，保证答案字符串的长度小于104。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：numerator = <span class="number">4</span>, denominator = <span class="number">333</span>输出：<span class="string">&quot;0.(012)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="模拟长除法"><a href="#模拟长除法" class="headerlink" title="模拟长除法"></a>模拟长除法</h3><p>计算分子和分母相除的结果，可能有：整数，有限小数，无限循环小数；</p>
<p>如果分子可以被分母整除，则结果为整数</p>
<p>如果分子不能被分母整除，则为有限&#x2F;无限循环小数，需用模拟长除法 的方式来计算：</p>
<ol>
<li>先根据分子，分母的正负 决定结果的正负，并将分子，分母都转为正数；</li>
<li>先计算整数部分，并将整数部分和小数点拼接到结果中；</li>
<li>再计算小数部分：每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。<ul>
<li>如果余数为0，则结果为有限小数</li>
<li>如果找到循环节，则在循环节开始和结束位置加上括号；</li>
<li>判断循环节：因为相同的余数，计算得到的小数的下一位数字一定相同，所以如果有余数在之前已经出现过，则认为找到循环节；（用哈希表存储每个余数第一次出现的下标）</li>
</ul>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2.png" alt="fig2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">numeratorLong</span> <span class="operator">=</span> (<span class="type">long</span>) numerator;    </span><br><span class="line">        <span class="type">long</span> <span class="variable">denominatorLong</span> <span class="operator">=</span> (<span class="type">long</span>) denominator;    </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(numeratorLong / denominatorLong);  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();     </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">            sb.append(<span class="string">&#x27;-&#x27;</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">//整数部分  </span></span><br><span class="line">        numeratorLong = Math.abs(numeratorLong); </span><br><span class="line">        denominatorLong = Math.abs(denominatorLong);    </span><br><span class="line">        <span class="type">long</span> <span class="variable">integerPart</span> <span class="operator">=</span> numeratorLong / denominatorLong;     </span><br><span class="line">        sb.append(integerPart);  </span><br><span class="line">        sb.append(<span class="string">&#x27;.&#x27;</span>);    </span><br><span class="line">        <span class="comment">//小数部分    </span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">fractionPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">        Map&lt;Long, Integer&gt; remainderIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();   </span><br><span class="line">        <span class="type">long</span> <span class="variable">remainder</span> <span class="operator">=</span> numeratorLong % denominatorLong;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.containsKey(remainder)) &#123;   </span><br><span class="line">            remainderIndexMap.put(remainder, index);   </span><br><span class="line">            remainder *= <span class="number">10</span>;     </span><br><span class="line">            fractionPart.append(remainder / denominatorLong); </span><br><span class="line">            remainder %= denominator;   </span><br><span class="line">            index++;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;   <span class="comment">//有循环节      </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> remainderIndexMap.get(remainder); </span><br><span class="line">            fractionPart.insert(insertIndex, <span class="string">&#x27;(&#x27;</span>);     </span><br><span class="line">            fractionPart.append(<span class="string">&#x27;)&#x27;</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">        sb.append(fractionPart.toString());  </span><br><span class="line">        <span class="keyword">return</span> sb.toString();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="187-重复的DNA序列（M"><a href="#187-重复的DNA序列（M" class="headerlink" title="187.重复的DNA序列（M)"></a>187.重复的DNA序列（M)</h2><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span>输出：[<span class="string">&quot;AAAAACCCCC&quot;</span>,<span class="string">&quot;CCCCCAAAAA&quot;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口-哈希表"><a href="#滑动窗口-哈希表" class="headerlink" title="滑动窗口+哈希表"></a>滑动窗口+哈希表</h3><p>从左到右处理字符串 ss，使用滑动窗口得到每个以 s[i]s[i] 为结尾且长度为 1010 的子串，同时使用哈希表记录每个子串的出现次数，如果该子串出现次数超过一次，则加入答案。</p>
<p>时间复杂度：O(NL)，其中 N 是字符串 s 的长度，L&#x3D;10即目标子串的长度。</p>
<p>空间复杂度：O(NL)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;    </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    </span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">10</span> &lt;= n; i++)&#123;     </span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> s.substring(i, i + <span class="number">10</span>);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(cur, <span class="number">0</span>);    </span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) list.add(cur);     </span><br><span class="line">            map.put(cur, cnt + <span class="number">1</span>);    </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位运算-滑动窗口-哈希表"><a href="#位运算-滑动窗口-哈希表" class="headerlink" title="位运算+滑动窗口+哈希表"></a>位运算+滑动窗口+哈希表</h3><p>因为只有4种字符，所以可以将<strong>每个字符用2个比特表示</strong>，即：</p>
<p>A：00		C：01		G：10		T：11</p>
<p>这样，长为10个字符的字符串就可以用20个比特表示，这里<strong>用 int整数（有32）的低20位</strong>来表示它，</p>
<p>如果我们对每个长为 10 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 O(NL)。为了优化时间复杂度，我们可以用一个大小固定为 10 的滑动窗口来计算子串的整数表示。</p>
<p>设当前滑动窗口对应的整数表示为 x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：</p>
<ul>
<li>滑动窗口向右移动一位：x &#x3D; x &lt;&lt; 2，由于每个字符用 2 个比特表示，所以要左移 2 位；</li>
<li>一个新的字符 ch 进入窗口：x &#x3D; x | bin[ch]，这里 bin[ch] 为字符 ch 的对应二进制；</li>
<li>窗口最左边的字符离开窗口：x &#x3D; x &amp; ((1 &lt;&lt; 20) - 1)，由于我们只考虑 x 的低 20 位比特，需要将其余位置零，即与上 (1 &lt;&lt; 20) - 1。</li>
</ul>
<p>上面三步合并，就可以用O（1）的时间算出下一个子串的整数表示，即 x &#x3D; ((x &lt;&lt; 2) | bin[ch]) &amp; ((1 &lt;&lt; 20) - 1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">    Map&lt;Character, Integer&gt; bin = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line">        &#123;      </span><br><span class="line">            put(<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>);   </span><br><span class="line">            put(<span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>);     </span><br><span class="line">            put(<span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;   </span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();    </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= L) &#123;     </span><br><span class="line">            <span class="keyword">return</span> ans;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; L - <span class="number">1</span>; ++i) &#123;   </span><br><span class="line">            x = (x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i));     </span><br><span class="line">        &#125;      </span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - L; ++i) &#123;   </span><br><span class="line">            x = ((x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i + L - <span class="number">1</span>))) &amp; ((<span class="number">1</span> &lt;&lt; (L * <span class="number">2</span>)) - <span class="number">1</span>); </span><br><span class="line">            cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);    </span><br><span class="line">            <span class="keyword">if</span> (cnt.get(x) == <span class="number">2</span>) &#123;         </span><br><span class="line">                ans.add(s.substring(i, i + L));    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="223-矩形面积-E"><a href="#223-矩形面积-E" class="headerlink" title="223.矩形面积(E)"></a>223.矩形面积(E)</h2><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的 矩形</strong>，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>
<p>第一个矩形由其<strong>左下顶点 (ax1, ay1)</strong> 和<strong>右上顶点 (ax2, ay2)</strong> 定义。<br>第二个矩形由其<strong>左下顶点 (bx1, by1)</strong> 和<strong>右上顶点 (bx2, by2)</strong> 定义。</p>
<p>方法 ：直接计算重叠面积</p>
<p>如果两个矩形重叠，则两个矩形的重叠部分也是矩形，重叠部分的面积可以根据重叠部分的边界计算。</p>
<p>两个矩形的水平边投影到 x<em>x</em> 轴上的线段分别为[<em>ax</em>1,<em>ax</em>2] 和 [<em>bx</em>1,<em>bx</em>2]，竖直边投影到 y<em>y</em> 轴上的线段分别为[<em>ay</em>1,<em>ay</em>2] 和 [<em>by</em>1,<em>by</em>2]。如果两个矩形重叠，则重叠部分的水平边投影到 x 轴上的线段为 [max(ax1, bx1) , min(ax2, bx2)] , 竖直边投影到 <em>y</em> 轴上的线段为 [max(ay1, by1) , min(ay2, by2)] , 根据重叠部分的水平边投影到 x 轴上的线段长度和竖直边投影到 y 轴上的线段长度即可计算重叠部分的面积。只有当两条线段的长度都大于 0 时，重叠部分的面积才大于 0，否则重叠部分的面积为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">area1</span> <span class="operator">=</span> (ax2 - ax1) * (ay2 - ay1), area2 = (bx2 - bx1) * (by2 - by1); </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapWidth</span> <span class="operator">=</span> Math.min(ax2, bx2) - Math.max(ax1, bx1), overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapArea</span> <span class="operator">=</span> Math.max(overlapWidth, <span class="number">0</span>) * Math.max(overlapHeight, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> area1 + area2 - overlapArea; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="229-求众数2-M"><a href="#229-求众数2-M" class="headerlink" title="229.求众数2(M)"></a>229.求众数2(M)</h2><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 n&#x2F;3  次的元素。</p>
<blockquote>
<p> 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p>
</blockquote>
<p>哈希表计数：</p>
<p>一个朴素的做法是使用「哈希表」进行计数，在计数完成后将所有出现次数超过 n &#x2F; 3<em>n</em>&#x2F;3 的元素加入答案。</p>
<p>时间和空间复杂度都为O(n)</p>
<hr>
<h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>摩尔投票法的核心思想为<strong>对拼消耗</strong>。</p>
<p>最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 1&#x2F;2  的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实：</p>
<ul>
<li><strong>每次</strong>从序列里<strong>选择两个不相同的数字删除掉</strong>（或称为「抵消」），<strong>最后剩下</strong>一个数字或几个相同的数字，<strong>就是出现次数大于总数一半的那个元素</strong>。</li>
</ul>
<p>题目要求找出出现超过n&#x2F;3次的元素，可以用反证法推出满足条件的元素最多只有2个。所以可以利用摩尔投票法的核心思想，<strong>每次选择三个互不相同的元素进行删除</strong>（或称为「抵消」）。</p>
<p>摩尔投票法最后还需要计数阶段，来确定选出来的元素是否满足条件；</p>
<p>时间复杂度：O(n)，空间复杂度：O(1)，只使用了常数个元素来存储关键元素和统计次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">        <span class="comment">// 摩尔投票：抵消阶段  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个元素的值     </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//第二个元素的值    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="comment">//第一个元素的可抵消个数    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote2</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="comment">//第二个元素的可抵消个数    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123; </span><br><span class="line">                <span class="comment">//如果该元素为第一个元素，则计数加1   </span></span><br><span class="line">                vote1++;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; <span class="comment">//如果该元素为第二个元素，则计数加1 </span></span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote1 == <span class="number">0</span>) &#123; <span class="comment">// 第一元素为空，则选择第一个元素      </span></span><br><span class="line">                element1 = num;     </span><br><span class="line">                vote1++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 == <span class="number">0</span>) &#123; <span class="comment">// 选择第二个元素       </span></span><br><span class="line">                element2 = num;        </span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果三个元素均不相同，则相互抵消1次      </span></span><br><span class="line">                vote1--;        </span><br><span class="line">                vote2--;         </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// 摩尔投票：计数阶段   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;   </span><br><span class="line">                cnt1++;        </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; </span><br><span class="line">                cnt2++;       </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="comment">// 检测元素出现的次数是否满足要求   </span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();      </span><br><span class="line">        <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="number">3</span>) &#123;      </span><br><span class="line">            ans.add(element1);     </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="number">3</span>) &#123;     </span><br><span class="line">            ans.add(element2);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="230-二叉搜索树中第k小的元素-M"><a href="#230-二叉搜索树中第k小的元素-M" class="headerlink" title="230.二叉搜索树中第k小的元素(M)"></a>230.二叉搜索树中第k小的元素(M)</h2><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 10的4次方</code></li>
<li><code>0 &lt;= Node.val &lt;= 10的4次方</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
</blockquote>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>由于题目中的树为搜索树，即树中左子节点小于当前节点，右子节点大于当前节点，各子树本身也是二叉搜索树；因此中序遍历二叉搜索树得到的结果是排序的；</p>
<p>时间复杂度：O(H + k)：H为树的高度</p>
<p>空间复杂度：O(H)：栈中最多存储H个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();    </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;   </span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;     </span><br><span class="line">                stack.push(root);       </span><br><span class="line">                root = root.left;   </span><br><span class="line">            &#125;     </span><br><span class="line">            root = stack.poll(); </span><br><span class="line">            k--;       </span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;    </span><br><span class="line">                <span class="keyword">break</span>;     </span><br><span class="line">            &#125;          </span><br><span class="line">            root = root.right;   </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> root.val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="记录子树的节点数"><a href="#记录子树的节点数" class="headerlink" title="记录子树的节点数"></a>记录子树的节点数</h3><blockquote>
<p>如果要频繁地查找第k小的值，该如何优化？</p>
</blockquote>
<p>中序遍历中，以为我们不知道子树的节点数量，不得不通过遍历子树来获得前k个元素；</p>
<p>因此，我们可以记录下<strong>每个节点为根结点的子树的结点数</strong>，并在查找第 k 小的值时，使用如下方法搜索：</p>
<ul>
<li><p>令 node 等于根结点，开始搜索。</p>
</li>
<li><p>对当前结点 node 进行如下操作：</p>
<ul>
<li>如果 node 的左子树的结点数 left 小于 k-1，则第 k 小的元素一定在node 的右子树中，令 node 等于其的右子结点，k 等于 k - left−1，并继续搜索；</li>
<li>如果 node 的左子树的结点数 left 等于 k-1，则第 k 小的元素即为 node ，结束搜索并返回 node 即可；</li>
<li>如果 node 的左子树的结点数 left 大于 k-1，则第 k 小的元素一定在 node 的左子树中，令 node 等于其左子结点，并继续搜索。</li>
</ul>
</li>
</ul>
<p>可以再每个节点中存在子树节点数，也可以用哈希表记录；</p>
<p>时间复杂度：预处理的时间为O(N)：N为树中节点的总数（需要遍历所有节点来统计每个节点的为根的子树节点数）；搜索的时间为O（H)，H为树高；</p>
<p>空间复杂度 ：O(N)，哈希表存储每个节点的子树节点数信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">MyBst</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBst</span>(root); </span><br><span class="line">        <span class="keyword">return</span> bst.kthSmallest(k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBst</span> &#123; </span><br><span class="line">    TreeNode root;  </span><br><span class="line">    Map&lt;TreeNode, Integer&gt; nodeNum; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBst</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.root = root;   </span><br><span class="line">        <span class="built_in">this</span>.nodeNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, Integer&gt;();    </span><br><span class="line">        countNodeNum(root);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 返回二叉搜索树中第k小的元素   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;   </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getNodeNum(node.left);     </span><br><span class="line">            <span class="keyword">if</span> (left &lt; k - <span class="number">1</span>) &#123;    </span><br><span class="line">                node = node.right;   </span><br><span class="line">                k -= left + <span class="number">1</span>;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == k - <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = node.left;     </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> node.val; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 统计以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countNodeNum</span><span class="params">(TreeNode node)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;     </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">        &#125;      </span><br><span class="line">        nodeNum.put(node, <span class="number">1</span> + countNodeNum(node.left) + countNodeNum(node.right)); </span><br><span class="line">        <span class="keyword">return</span> nodeNum.get(node);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 获取以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> nodeNum.getOrDefault(node, <span class="number">0</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><blockquote>
<p>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <em>k</em> 小的值，你将如何优化算法？</p>
</blockquote>
<ul>
<li>平衡二叉搜索树中每个节点的左子树和右子树高度最多相差1；</li>
<li>其子树也是平衡二叉搜索树；</li>
<li>一棵存有n个节点的平衡二叉搜索树的高度为O(logn);</li>
</ul>
<p>在方法二中，其搜索的时间复杂度为O(H)，当树是平衡树时，时间复杂度可取到O(logN)；</p>
<p>时间复杂度：预处理的时间复杂度为 O(N)，其中 N 是树中结点的总数。插入、删除和搜索的时间复杂度均为 O(log N)。</p>
<p>空间复杂度：O(N)，用于存储平衡二叉搜索树。</p>
<h2 id="260-只出现一次的数字III-M"><a href="#260-只出现一次的数字III-M" class="headerlink" title="260.只出现一次的数字III (M)"></a>260.只出现一次的数字III (M)</h2><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p>
<blockquote>
<p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure>

<p>方法一：用哈希映射统计数组中每一个元素出现的次数。在统计完成后，对哈希映射进行遍历，将所有只出现了一次的数放入答案中。</p>
<p>时间复杂度：O(n)；空间复杂度：O(n)</p>
<hr>
<p>方法二：位运算</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>假设数组 nums 中只出现一次的元素分别是x1和x2，如果<strong>把nums 中的所有元素全部异或起来，得到结果 x，则x &#x3D; x1异或x2</strong>，因为数组中出现两次的元素都会因为异或运算而被抵消掉（如：a异或b异或b&#x3D;a）。</p>
<p>因为x1和x2不等，所以x不会等于0。此时，<strong>利用 x &amp; -x 得到 x 的最低有效位lowbit</strong>，即x二进制表示中最低位的1，设这个1在第i位；</p>
<p>这样，数组中的元素就可以分为两类：一类是二进制表示中第i位为1的，另一类是第i位为0的，而x1和x2不会在同一类里（因为只有x1和x2的第i位不同，异或得到的第i位才为1）；然后<strong>将同一类的元素全部异或起来，那么其中一类最终会得到x1，另一类得到x2</strong>（出现两次的元素都会被异或运算抵消，最后只留下x1或x2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xorNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            xorNum ^= num;      <span class="comment">//最终xor=x1异或x2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lowBit</span> <span class="operator">=</span> (xorNum == Integer.MIN_VALUE ? xorNum : xorNum &amp; (-xorNum));</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">0</span>, x2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lowBit &amp; num) != <span class="number">0</span>) &#123;      <span class="comment">//将同属一类的元素异或起来，最后得到x1</span></span><br><span class="line">                x1 ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1, x2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="335-交叉路径-D"><a href="#335-交叉路径-D" class="headerlink" title="335.交叉路径(D)"></a>335.交叉路径(D)</h2><p>给定一个整数数组distance；</p>
<p>从X-Y平面上的原点（0，0）开始，每四个数字一组，分别向北，西，南，东移动。</p>
<p>判断你所经过的路径是否相交，如果相交，返回true，否则，返回false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"><span class="comment">//画图</span></span><br></pre></td></tr></table></figure>



<h3 id="归纳法-找规律"><a href="#归纳法-找规律" class="headerlink" title="归纳法(找规律)"></a>归纳法(找规律)</h3><p>首先，至少需要4条边才可能存在相交路径，如果distance长度小于4，可直接返回fasle；</p>
<p>对可能相交情况进行分情况讨论，设当前枚举到的边为 d[ i ] ，(画图理解！)</p>
<ol>
<li>d[i] 与 d[i - 3] 发生相交：此时满足 d[i] &gt;&#x3D; d[i - 2]，同时 d[i - 1] &lt;&#x3D; d[i - 3]；</li>
<li>d[i] 与 d[i - 4] 发生相交：此时满足 d[i - 1] &gt;&#x3D; d[i - 3]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]；</li>
<li>d[i] 与 d[i - 5] 发生相交：此时满足 d[i - 1] &lt;&#x3D; d[i - 3]，同时 d[i - 2] &gt; d[i - 4]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]，同时 d[i - 1] + d[i - 5] &gt;&#x3D; d[i - 3]</li>
</ol>
<p>综上，d[i] 不会与d[i - 1] 和 d[i - 2] 发生相交，而 d[i] 在与d[i - x] (x&gt;5)发生相交前，必然先与d[i - y] (3&lt;&#x3D;y&lt;5) 发生相交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSelfCrossing</span><span class="params">(<span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> d.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">4</span> &amp;&amp; d[i - <span class="number">1</span>] == d[i - <span class="number">3</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">5</span> &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>] &amp;&amp; d[i - <span class="number">2</span>] &gt; d[i - <span class="number">4</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] + d[i - <span class="number">5</span>] &gt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="352-将数据流变为多个不相交区间-D"><a href="#352-将数据流变为多个不相交区间-D" class="headerlink" title="352.将数据流变为多个不相交区间(D)"></a>352.将数据流变为多个不相交区间(D)</h2><p> 给你一个由非负整数 a1, a2, …, an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p>
<p>（如：arr[1,2,3,7] ，则将其分为：[1,3]，[7,7]  ）</p>
<blockquote>
<p>实现 SummaryRanges 类：</p>
<p>SummaryRanges()：使用一个空数据流初始化对象。<br>void addNum(int val) ：向数据流中加入整数 val 。<br>int[][] getIntervals()： 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。</p>
</blockquote>
<h3 id="有序映射（TreeMap"><a href="#有序映射（TreeMap" class="headerlink" title="有序映射（TreeMap)"></a>有序映射（TreeMap)</h3><p>使用某一数据结构维护这些不相交的区间，在设计具体的数据结构之前，我们需要先明确 void addNum(int val) 这一操作会使得当前的区间集合发生的变化：</p>
<ul>
<li><p>情况一：如果存在一个区间 [ l , r ]，它完全包含 val，即 l ≤ val ≤ r，那么在加入 val 之后，区间集合不会有任何变化；</p>
</li>
<li><p>情况二：如果存在一个区间 [ l , r ]，它的右边界 r「紧贴着」val，即 r + 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l , r+1 ]；</p>
</li>
<li><p>情况三：如果存在一个区间 [ l , r ]，它的左边界 l「紧贴着」val，即 l - 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l−1 , r ]；</p>
</li>
<li><p>情况四：如果情况二和情况三同时满足，即存在一个区间 [ l0 , r0] 满足 r0 + 1 &#x3D; val， 并且存在一个区间 [ l1, r1] 满足 l1 - 1 &#x3D; val，那么在加入val后，这两个区间会合并成一个大区间；</p>
</li>
<li><p>情况五：在上述四种情况均不满足的情况下，val 会单独形成一个新的区间 [ val , val ]。</p>
</li>
</ul>
<p>一种可以<strong>找到「最近」区间</strong>的数据结构是<strong>有序映射</strong>。有序映射中的键和值分别表示区间的左边界 l 和右边界 r。由于有序映射支持查询「最大的比某个元素小的键」以及「最小的比某个元素大的键」这两个操作，因此我们可以快速地定位区间 [ l0 , r0 ] 和[ l1 , r1]；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; intervals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        intervals = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 l1 最小的且满足 l1 &gt; val 的区间 interval1 = [l1, r1]</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval1 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval1 = intervals.ceilingEntry(val + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 找到 l0 最大的且满足 l0 &lt;= val 的区间 interval0 = [l0, r0]</span></span><br><span class="line">        <span class="comment">// 在有序集合中，interval0 就是 interval1 的前一个区间</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval0 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval0 = intervals.floorEntry(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interval0 != <span class="literal">null</span> &amp;&amp; interval0.getKey() &lt;= val &amp;&amp; val &lt;= interval0.getValue()) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">leftAside</span> <span class="operator">=</span> interval0 != <span class="literal">null</span> &amp;&amp; interval0.getValue() + <span class="number">1</span> == val;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">rightAside</span> <span class="operator">=</span> interval1 != <span class="literal">null</span> &amp;&amp; interval1.getKey() - <span class="number">1</span> == val;</span><br><span class="line">            <span class="keyword">if</span> (leftAside &amp;&amp; rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况四</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval0.getKey(), right = interval1.getValue();</span><br><span class="line">                intervals.remove(interval0.getKey());</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(left, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftAside) &#123;</span><br><span class="line">                <span class="comment">// 情况二</span></span><br><span class="line">                intervals.put(interval0.getKey(), interval0.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况三</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> interval1.getValue();</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(val, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况五</span></span><br><span class="line">                intervals.put(val, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : intervals.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> entry.getKey(), right = entry.getValue();</span><br><span class="line">            ans[index][<span class="number">0</span>] = left;</span><br><span class="line">            ans[index][<span class="number">1</span>] = right;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="405-数字转换为十六进制数-E"><a href="#405-数字转换为十六进制数-E" class="headerlink" title="405.数字转换为十六进制数(E)"></a>405.数字转换为十六进制数(E)</h2><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p>
<p>注意:</p>
<blockquote>
<ol>
<li>十六进制中所有字母(a-f)都必须是小写。</li>
<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li>
<li>给定的数确保在32位有符号整数范围内。</li>
<li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li>
</ol>
</blockquote>
<p><strong>模拟+进制转换</strong></p>
<p>利用通用的进制转换思路来做，不断循环 num % k 和 num &#x2F; k 的操作来构造出 k 进制每一位。</p>
<p>但需要处理「补码」问题：对于负数的 num，我们需要先在 num 基础上加上 2^32 的偏移量，再进行进制转换。</p>
<p>（将有符号整数 转化为 无符号整数，其二进制表示方式不变，十进制则相当于原数字加上2的n次方，n为二进制的位数，同样的，其十六进制表示方式也不变）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) temp = (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, <span class="number">32</span>) + num);        <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;            <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> temp % <span class="number">16</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            temp /= <span class="number">16</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>位运算 + 分组换算</strong></p>
<p>将长度为 32 的二进制转换为 16 进制数，本质是对长度为 32 的二进制数进行分组，</p>
<p>由于我们是直接对长度为 32 的二进制进行分组转算（4 个为一组，共 8 组），而长度为 32 的二进制本身就是使用补码规则来表示的，因此我们无须额外处理「补码」问题。</p>
<p>具体的，我们将 num 与 15的二进制 进行 &amp; 运算，然后对 num 进行无符号右移 4 位来实现每 4 位处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> num &amp; <span class="number">15</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            num &gt;&gt;&gt;= <span class="number">4</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h2 id="437-路径总和III-M"><a href="#437-路径总和III-M" class="headerlink" title="437.路径总和III(M)"></a>437.路径总和III(M)</h2><p>给定一个二叉树的根节点 <strong>root</strong> ，和一个整数 <strong>targetSum</strong> ，求该二叉树里<strong>节点值之和等于 targetSum 的 路径</strong> 的<strong>数目</strong>。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：root =[10,5,-3,3,2,null,11,3,-2,null,1]，targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和，就是到达当前元素的路径上，之前所有元素的和。</p>
<p>如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target，也就是说A和B之间的路径符合题目要求</p>
<p><strong>算法思路：</strong></p>
<p>抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。</p>
<p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;  </span><br><span class="line">        <span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数    </span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 前缀和为0的一条路径    </span></span><br><span class="line">        <span class="keyword">return</span> recursionPathSum(root, prefixSumCount, sum, <span class="number">0</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recursionPathSum</span><span class="params">(TreeNode node, Map&lt;Integer, Integer&gt; prefixSumCount, <span class="type">int</span> target, <span class="type">int</span> currSum)</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        currSum += node.val;   </span><br><span class="line">        <span class="comment">//如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了        res += prefixSumCount.getOrDefault(currSum - target, 0);    </span></span><br><span class="line">        <span class="comment">// 更新路径上当前节点前缀和的个数     </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);   </span><br><span class="line">        res += recursionPathSum(node.left, prefixSumCount, target, currSum);   </span><br><span class="line">        res += recursionPathSum(node.right, prefixSumCount, target, currSum);</span><br><span class="line">        <span class="comment">//回到本层，恢复状态，去除当前节点的前缀和数量  </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（N），每个节点只遍历一次</p>
<p>；空间复杂度：O（N），用了一个hashMap</p>
<p>476.数字的补数(E)</p>
<p>对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。</p>
<ul>
<li>例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。（无视了前导零）</li>
</ul>
<p>给你一个整数 num ，输出它的补数。</p>
<blockquote>
<p>1 &lt;&#x3D; num &lt; 2的31次方</p>
</blockquote>
<p>模拟(lowbit)</p>
<p>如果 num 的二进制表示中最高位 1 的位置为 s 的话，那么实际上我们只需要对 num 的前 s - 1 位进行取反即是答案（第 s 位的取反结果始终为 0）。</p>
<p>因此我们可以先使用 lowbit 操作来得到 num 二进制表示中最高位 1 的位置为 1，其余位为 0 时所代表的数字 x。</p>
<p>然后 x - 1 即是二进制表示中前 s - 1 位均为 1，其余位为 0 的数字，将其与 num 的取反数执行「按位与」操作，即可达到「仅对 num 的前 s - 1 位进行取反」的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i != <span class="number">0</span>; i -= i &amp; -i) x = i;      </span><br><span class="line">        <span class="keyword">return</span> ~num &amp; (x - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用这种：</p>
<p>找到二进制表示最高位的 1 ：第 i (0≤i≤30) 位，后，</p>
<p>我们可以遍历 num 的第 0 ∼ i 个二进制位，将它们依次进行取反。也可以用更高效的方式，构造掩码 mask &#x3D; 2<br>的i+1次方 - 1，它是一个 i+1 位的二进制数，并且每一位都是 1。我们将 num 与mask 进行异或运算，即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">highbit</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &lt;&lt; i) &#123;      </span><br><span class="line">                highbit = i;      </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;          </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> highbit == <span class="number">30</span> ? <span class="number">0x7fffffff</span> : (<span class="number">1</span> &lt;&lt; (highbit + <span class="number">1</span>)) - <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> num ^ mask;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="483-密钥格式化-E"><a href="#483-密钥格式化-E" class="headerlink" title="483.密钥格式化(E)"></a>483.密钥格式化(E)</h2><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span>输出：<span class="string">&quot;5F3Z-2E9W&quot;</span>解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure>

<p><strong>模拟</strong></p>
<p>简单字符串模拟，从后往前处理，避免对首个分区的分情况讨论和取余操作。（注意答案字符串首部不要加上‘-’）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">licenseKeyFormatting</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, cnt = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="583-两个字符串的删除操作-M"><a href="#583-两个字符串的删除操作-M" class="headerlink" title="583.两个字符串的删除操作(M)"></a>583.两个字符串的删除操作(M)</h2><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>该问题等价于求解量字符的「最长公共子序列」，若两者长度分别为 n 和 m，而最长公共子序列长度为 max，则 n - max + m - maxn 即为答案。</p>
<p>f[i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符</p>
<p>当有了「状态定义」之后，基本上「转移方程」就是呼之欲出：</p>
<ul>
<li><strong>s1[i]&#x3D;&#x3D;s2[j] : f [i] [j] &#x3D; f [i-1] [j-1] +1</strong> </li>
<li><strong>s1[i] !&#x3D; s2[j] : f [i] [j]&#x3D;max( f [i-1] [j], f [i] [j-1] )</strong></li>
</ul>
<p>不加哨兵空格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>])</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f[n][m] + m - f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加哨兵空格：</p>
<p>可以往字符串头部追加一个空格，以减少边界判断（使下标从 1 开始，并很容易构造出可滚动的「有效值」）。但实现上，不用真的往字符串中最佳空格，只需在初始化动规值时假定存在首部空格，以及对最后的 LCS 长度进行减一操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 假定存在哨兵空格，初始化 f[0][x] 和 f[x][0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>]) f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> f[n][m] - <span class="number">1</span>; <span class="comment">// 减去哨兵空格</span></span><br><span class="line">        <span class="keyword">return</span> n - max + m - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>更加契合题意的状态定义是根据「最长公共子序列（LCS）」的原始状态定义进行微调：定义 f [i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符（最终字符串不一定包含 s1[i] 或 s2[j]）时形成相同字符串的最小删除次数。</p>
<p>则转移方程 f [i] [j] 计算：</p>
<ul>
<li><strong>s1[i] &#x3D;&#x3D; s2[j]：f [i] [j] &#x3D; f [i - 1] [j - 1]，代表可以不用必然删掉 s1[i] 和 s2[j] 形成相同字符串；</strong></li>
<li><strong>s1[i] !&#x3D; s2[j]：f[i] [j] &#x3D; min(f[i - 1] [j] + 1, f[i] [j - 1] + 1)，代表至少一个删除 s1[i] 和 s2[j] 中的其中一个。</strong></li>
</ul>
<p>f [i] [j] 为上述方案中的最小值，最终答案为 f [n] [m]。</p>
<p><strong>动态规划的边界：</strong></p>
<p>当i 或 j &#x3D; 0 时，其中一个字符串为空，空字符串和任何字符串要变成相同，只有将另一个字符串的字符全部删除，所以 <strong>dp[i] [0] &#x3D; i</strong> 以及 <strong>dp[0] [j] &#x3D; j</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray(), c2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638.大礼包"></a>638.大礼包</h2><p>在 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>
<p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <strong><code>price[i]</code> 是第 i 件物品的价格</strong>。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <strong><code>needs[i]</code> 是需要购买第 i 件物品的数量</strong>。</p>
<p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 n + 1 ，其中 <strong><code>special[i][j]</code> 表示第 i 个大礼包中内含第 j 件物品的数量</strong>，且 <strong><code>special[i][n]</code> （也就是数组中的最后一个整数）为第 i 个大礼包的价格</strong>。</p>
<p>返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>
<blockquote>
<p>输入：price &#x3D; [2,3,4], special &#x3D; [[1,1,0,4],[2,2,1,9]], needs &#x3D; [1,2,1]<br>输出：11<br>解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。<br>可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。<br>需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。<br>不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</p>
</blockquote>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>因为大礼包中可能包含多个物品，所以并不是所有状态都可以得到。因此，我们使用记忆化搜索而不是完全遍历的方法，来计算出满足每个购物清单 needs 所需花费的最低价格。</p>
<ul>
<li><p>首先，我们过滤掉不需要计算的大礼包。</p>
<p>如果大礼包完全没有优惠（大礼包的价格大于等于原价购买大礼包内所有物品的价格），或者大礼包内不包含任何的物品，那么购买这些大礼包不可能使整体价格降低。因此，我们可以不考虑这些大礼包，并将它们过滤掉，以提高效率和方便编码。</p>
</li>
<li><p>然后，计算满足购物清单所需花费的最低价格：</p>
<p>用 dp[needs] 表示满足购物清单 needs 所需花费的最低价格。在进行状态转移时，我们考虑在满足购物清单 needs 时的最后一次购买；其中，将原价购买购物清单中的所有物品也视作一次购买。则有两种情况：</p>
<ul>
<li><p>一，购买大礼包，状态转移方程为：</p>
<p>dp[needs] &#x3D; min{price<del>i</del> +dp[ needs - needs<del>i</del> ]} ( i ∈ K )，</p>
<ul>
<li><p>K 表示所有可以购买的大礼包的下标集合，i 表示其中一个大礼包的下标，</p>
</li>
<li><p>price<del>i</del> 表示第 i 个大礼包的价格，</p>
</li>
<li><p>needs<del>i</del> 表示大礼包中包含的物品清单，</p>
</li>
<li><p>needs−needs<del>i</del> 表示购物清单 needs 减去第 i 个大礼包中包含的物品清单后剩余的物品清单。</p>
</li>
</ul>
</li>
<li><p>二，不购买任何大礼包，原价购买购物清单中的所有物品，此时 dp [needs] 可以直接求出。</p>
</li>
</ul>
<p>对此，要求出当前购物清单 <code>cur_needs</code> 所需花费的最低价格 <code>min_price</code> ，具体做法为：</p>
<ul>
<li><p>将 min_price 初始化为原价购买购物清单cur_needs 中的所有物品的花费；</p>
</li>
<li><p>逐个遍历所有可以购买的大礼包，不妨设当前遍历的大礼包为 cur_special，其价格为special_price：</p>
<ul>
<li><p>计算购买大礼包 cur_special 后新的购物清单 next_needs，并递归地计算满足购物清单 next_needs 所需花费的最低价格 next_price；</p>
</li>
<li><p>计算满足当前购物清单 cur_needs 所需花费的最低价格 cur_price &#x3D; special_price + next_price；</p>
</li>
<li><p>如果 cur_price &lt; min_price，则将 min_price 更新为 cur_price。</p>
</li>
</ul>
</li>
<li><p>返回计算满足购物清单 cur_needs 所需花费的最低价格 min_price。</p>
</li>
</ul>
</li>
</ul>
<p>时间复杂度：O ( n × k × m^n^ )：k为大礼包数量，m为每种物品的需求量(等于最大需求量加1)，n表示物品数量</p>
<p>空间复杂度：O ( n × m^n^ )：用于存储记忆化搜索中 m^n^个状态的计算结果，每个状态需要存储 n  个商品的需求量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储 某个状态的清单~~它所需花费的最低值 的键值对</span></span><br><span class="line">    Map&lt;List&lt;Integer&gt;, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;List&lt;Integer&gt;, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> price.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; filterSpecial = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; sp : special) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp.get(i);</span><br><span class="line">                totalPrice += sp.get(i) * price.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp.get(n)) &#123;</span><br><span class="line">                filterSpecial.add(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(price, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; curNeeds, List&lt;List&lt;Integer&gt;&gt; filterSpecial, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(curNeeds)) &#123;      <span class="comment">//传进来的清单 还没有计算出最低花费</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds.get(i) * price.get(i); <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">specialPrice</span> <span class="operator">=</span> curSpecial.get(n);   <span class="comment">//sepcialPrice = 当前礼包的费用</span></span><br><span class="line">                List&lt;Integer&gt; nextNeeds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">//nextNeeds = 当前清单各物品数 - 礼包各物品数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial.get(i) &gt; curNeeds.get(i)) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextNeeds.add(curNeeds.get(i) - curSpecial.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nextNeeds.size() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = Math.min(minPrice, dfs(price, nextNeeds, filterSpecial, n) + specialPrice);  </span><br><span class="line">                    <span class="comment">//当递归到一个礼包都不能购买时，dfs返回的就是当时清单的各物品原价</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo.put(curNeeds, minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.get(curNeeds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="869-重新排序得到2的幂-M-待理解！"><a href="#869-重新排序得到2的幂-M-待理解！" class="headerlink" title="869.重新排序得到2的幂(M)  ~~ ~~ 待理解！"></a>869.重新排序得到2的幂(M)  ~~ ~~ 待理解！</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%A2%98/">http://example.com/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2022/07/04/Nginx%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" src="https://img.sj33.cn/uploads/202009/7-200923141040512.jpg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Nginx学习</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/"><img class="next-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">算法2.0</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2021/05/25/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="C语言"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151628461.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">C语言</div></div></a></div><div><a href="/Notes/2021/05/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/" title="汇编语言"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151557250.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">汇编语言</div></div></a></div><div><a href="/Notes/2021/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151622912.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">数据结构</div></div></a></div><div><a href="/Notes/2021/05/25/%E7%AE%97%E6%B3%95/" title="算法"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">算法</div></div></a></div><div><a href="/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/" title="算法2.0"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-07</div><div class="title">算法2.0</div></div></a></div><div><a href="/Notes/2021/05/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191722753.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-25</div><div class="title">计算机组成原理</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%91%E6%8C%87offer"><span class="toc-number">1.</span> <span class="toc-text">剑指offer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97-E"><span class="toc-number">1.1.</span> <span class="toc-text">03-数组中重复的数字(E)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE-M"><span class="toc-number">1.2.</span> <span class="toc-text">04-二维数组中的查找(M)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-E"><span class="toc-number">1.3.</span> <span class="toc-text">05-替换空格(E)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-E"><span class="toc-number">1.4.</span> <span class="toc-text">06-从尾到头打印链表(E)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E9%9A%8F%E6%83%B3%E5%BD%95"><span class="toc-number">2.</span> <span class="toc-text">代码随想录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#leetcode"><span class="toc-number">3.</span> <span class="toc-text">leetcode</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-M"><span class="toc-number">3.1.</span> <span class="toc-text">2.两数相加(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">模拟</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2-M"><span class="toc-number">3.2.</span> <span class="toc-text">3.无重复字符的最长子串(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.2.1.</span> <span class="toc-text">滑动窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-D"><span class="toc-number">3.3.</span> <span class="toc-text">4.寻找两个正序数组的中位数(D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">3.3.1.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%92%E5%88%86%E6%95%B0%E7%BB%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">划分数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-M"><span class="toc-number">3.4.</span> <span class="toc-text">5.最长回文子串(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BF%83%E6%89%A9%E6%95%A3"><span class="toc-number">3.4.1.</span> <span class="toc-text">中心扩散</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">3.4.2.</span> <span class="toc-text">动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Manacher-%E9%A9%AC%E6%8B%89%E8%BD%A6-%E7%AE%97%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">Manacher (马拉车)算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-D"><span class="toc-number">3.5.</span> <span class="toc-text">10.正则表达式匹配(D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-1"><span class="toc-number">3.5.1.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%B8%A4%E6%95%B0%E7%9B%B8%E9%99%A4-M"><span class="toc-number">3.6.</span> <span class="toc-text">29.两数相除(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E6%95%B0%E9%80%92%E5%A2%9E%E6%AD%A5%E9%95%BF"><span class="toc-number">3.6.1.</span> <span class="toc-text">指数递增步长</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#166-%E5%88%86%E6%95%B0%E5%88%B0%E5%B0%8F%E6%95%B0-M"><span class="toc-number">3.7.</span> <span class="toc-text">166.分数到小数(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E9%95%BF%E9%99%A4%E6%B3%95"><span class="toc-number">3.7.1.</span> <span class="toc-text">模拟长除法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#187-%E9%87%8D%E5%A4%8D%E7%9A%84DNA%E5%BA%8F%E5%88%97%EF%BC%88M"><span class="toc-number">3.8.</span> <span class="toc-text">187.重复的DNA序列（M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.8.1.</span> <span class="toc-text">滑动窗口+哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">3.8.2.</span> <span class="toc-text">位运算+滑动窗口+哈希表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#223-%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF-E"><span class="toc-number">3.9.</span> <span class="toc-text">223.矩形面积(E)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#229-%E6%B1%82%E4%BC%97%E6%95%B02-M"><span class="toc-number">3.10.</span> <span class="toc-text">229.求众数2(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E6%B3%95"><span class="toc-number">3.10.1.</span> <span class="toc-text">摩尔投票法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#230-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACk%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0-M"><span class="toc-number">3.11.</span> <span class="toc-text">230.二叉搜索树中第k小的元素(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.11.1.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E5%AD%90%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E6%95%B0"><span class="toc-number">3.11.2.</span> <span class="toc-text">记录子树的节点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">3.11.3.</span> <span class="toc-text">平衡二叉搜索树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#260-%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97III-M"><span class="toc-number">3.12.</span> <span class="toc-text">260.只出现一次的数字III (M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">3.12.1.</span> <span class="toc-text">位运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#335-%E4%BA%A4%E5%8F%89%E8%B7%AF%E5%BE%84-D"><span class="toc-number">3.13.</span> <span class="toc-text">335.交叉路径(D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E6%B3%95-%E6%89%BE%E8%A7%84%E5%BE%8B"><span class="toc-number">3.13.1.</span> <span class="toc-text">归纳法(找规律)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#352-%E5%B0%86%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8F%98%E4%B8%BA%E5%A4%9A%E4%B8%AA%E4%B8%8D%E7%9B%B8%E4%BA%A4%E5%8C%BA%E9%97%B4-D"><span class="toc-number">3.14.</span> <span class="toc-text">352.将数据流变为多个不相交区间(D)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%98%A0%E5%B0%84%EF%BC%88TreeMap"><span class="toc-number">3.14.1.</span> <span class="toc-text">有序映射（TreeMap)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#405-%E6%95%B0%E5%AD%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E6%95%B0-E"><span class="toc-number">3.15.</span> <span class="toc-text">405.数字转换为十六进制数(E)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#437-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8CIII-M"><span class="toc-number">3.16.</span> <span class="toc-text">437.路径总和III(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C"><span class="toc-number">3.16.1.</span> <span class="toc-text">前缀和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#483-%E5%AF%86%E9%92%A5%E6%A0%BC%E5%BC%8F%E5%8C%96-E"><span class="toc-number">3.17.</span> <span class="toc-text">483.密钥格式化(E)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#583-%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C-M"><span class="toc-number">3.18.</span> <span class="toc-text">583.两个字符串的删除操作(M)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.18.1.</span> <span class="toc-text">最长公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-2"><span class="toc-number">3.18.2.</span> <span class="toc-text">动态规划</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#638-%E5%A4%A7%E7%A4%BC%E5%8C%85"><span class="toc-number">3.19.</span> <span class="toc-text">638.大礼包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2"><span class="toc-number">3.19.1.</span> <span class="toc-text">记忆化搜索</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#869-%E9%87%8D%E6%96%B0%E6%8E%92%E5%BA%8F%E5%BE%97%E5%88%B02%E7%9A%84%E5%B9%82-M-%E5%BE%85%E7%90%86%E8%A7%A3%EF%BC%81"><span class="toc-number">3.20.</span> <span class="toc-text">869.重新排序得到2的幂(M)  ~~ ~~ 待理解！</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2024 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/#/Integrated/index')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>