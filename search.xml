<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法2.0</title>
      <link href="/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/"/>
      <url>/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>关于右移 &gt;&gt; 和 &gt;&gt;&gt;</p><ul><li>&gt;&gt; 是带符号右移，用符号位补位</li><li>&gt;&gt;&gt; 是不带符号右移，用0补位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.MIN_VALUE 的十进制和二进制</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//Integer.MIN_VALUE &gt;&gt; 1 的十进制和二进制</span></span><br><span class="line">-<span class="number">1073741824</span></span><br><span class="line"><span class="number">11000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//Integer.MIN_VALUE &gt;&gt;&gt; 1 的十进制和二进制</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line"><span class="number">01000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>例1：打印一个数字的32位二进制形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print((n &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2： Integer.MIN_VALUE，即 -2^31^，它的负数还是它自己。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h2><p>leetcode25. </p><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><blockquote><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p>思路：这道题不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091520079.png" alt="image-20220609152053978"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091521871.png" alt="image-20220609152109809"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091521279.png" alt="image-20220609152128213"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> getKGroupEnd(start, k);</span><br><span class="line">    <span class="keyword">if</span> (end == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head = end;</span><br><span class="line">    reverse(start, end);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lastEnd</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="keyword">while</span> (lastEnd.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        start = lastEnd.next;</span><br><span class="line">        end = getKGroupEnd(start, k);</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(start, end);</span><br><span class="line">        lastEnd.next = end;</span><br><span class="line">        lastEnd = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getKGroupEnd</span><span class="params">(ListNode start, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; start != <span class="literal">null</span>)&#123;</span><br><span class="line">        start = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode start, ListNode end)</span>&#123;</span><br><span class="line">    end = end.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != end)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    start.next = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(7-&gt;1-&gt;6) + (5-&gt;9-&gt;2)，即617 + 295</span><br><span class="line">输出：2-&gt;1-&gt;9，即912</span><br></pre></td></tr></table></figure><blockquote><p>假设这些数位是正向存放的，又该如何解决呢? （翻转链表，或使用栈，将数字压入栈中，再依次取出相加）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(6-&gt;1-&gt;7) + (2-&gt;9-&gt;5)，即617 + 295</span><br><span class="line">输出：9-&gt;1-&gt;2，即912</span><br></pre></td></tr></table></figure></blockquote><p>思路：同时遍历两个链表，逐位相加，并且加上上一位的进位，对于短的链表，可以认为其后是若干0。最后，如果遍历结束后进位不为0，还要再加一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumber</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, tail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//表示进位</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> head1 != <span class="literal">null</span> ? head1.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> head2 != <span class="literal">null</span> ? head2.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n1 + n2 + carry;  <span class="comment">//每一位数都等于两个链表节点的值以及进位的和</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (head1 != <span class="literal">null</span>) head1 = head1.next;</span><br><span class="line">        <span class="keyword">if</span> (head2 != <span class="literal">null</span>) head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表遍历结束后，如还有进位，则需要再加一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>leetcode21. </p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p>思路1：迭代，谁小就指向谁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode head1, ListNode head2)</span>&#123;</span><br><span class="line">    <span class="comment">//先建立一个哨兵节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> ans;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//谁小就指向谁</span></span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt;= head2.val)&#123;</span><br><span class="line">            pre.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当有一方遍历完，且另一链表剩下部分是有序的，则pre可以直接指向剩下的部分</span></span><br><span class="line">    pre.next = head1 != <span class="literal">null</span> ? head1 : head2;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并有序链表数组"><a href="#合并有序链表数组" class="headerlink" title="合并有序链表数组"></a>合并有序链表数组</h3><p>leetcode 剑指offer II 078. 合并排序链表</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="morris遍历"><a href="#morris遍历" class="headerlink" title="morris遍历"></a>morris遍历</h2><p>morris遍历二叉树，时间复杂度O(N)，空间复杂度O(1)。</p><h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><p>设cur为当前节点，一开始cur指向树的根节点，循环执行以下流程：</p><ol><li><p>如果cur无左树，cur &#x3D; cur.right；</p></li><li><p>如果cur有左树，找到左树最右的节点，记为mostright；</p><ol><li><p>如果mostright的右指针指向null，使mostright.right &#x3D; cur，cur &#x3D; cur.left；</p></li><li><p>如果mostright的右指针指向cur，mostright.right &#x3D; null，cur &#x3D; cur.right （由于有2.1的操作，所以mostright的右指针可能是指向cur的）</p></li></ol></li></ol><p>当cur为null时，流程结束。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//看cur是否有左树</span></span><br><span class="line">         mostRight = cur.left;</span><br><span class="line">         <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">//找cur的左树的最右节点</span></span><br><span class="line">             <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                 mostRight = mostRight.right;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//情况2.1</span></span><br><span class="line">             <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                 mostRight.right = cur;</span><br><span class="line">                 cur = cur.left;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//情况2.2</span></span><br><span class="line">                 mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                 cur = cur.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//情况1</span></span><br><span class="line">             cur = cur.right;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="前中后遍历"><a href="#前中后遍历" class="headerlink" title="前中后遍历"></a>前中后遍历</h3><p>morris特点：有左树的节点会遍历两次，其他节点均只遍历一次。即符合2.1情况的节点是第一个遍历，符合2.2情况的节点是第二次遍历。 </p><blockquote><p>比如，递归遍历二叉树会经过节点三次，在不同的经过时机进行打印，就是前序、中序、后序遍历二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的x序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历，即第一次经过</span></span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    <span class="comment">//中序遍历，即第二次经过</span></span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="comment">//后序遍历，即第三次经过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>而morris的遍历时机：</p><ul><li>前序遍历：在第一次遍历节点时打印</li><li>中序遍历：对于会遍历两次的节点，在其第二次遍历时打印，其他的照常打印。</li><li>后序遍历：对于会遍历两次的节点，分别逆序打印其左树的右边界，最后在逆序打印整棵树的右边界(根节点的右边界)（右边界是指这个节点一直向右走下去的路径，包括它自己）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况2.1</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//System.out.print(cur.val + &quot; &quot;); //先序遍历</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况2.2</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//System.out.print(cur.val + &quot; &quot;); //中序遍历</span></span><br><span class="line">                <span class="comment">//printEdge(cur.left);    //后序遍历，打印左树的右边界,</span></span><br><span class="line">                <span class="comment">//注：由于后序遍历是打印节点的右边界，应该在最右节点的右节点为null，不然它的右节点还会指向其他地方，致使多打印</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="comment">//System.out.print(cur.val + &quot; &quot;); //先序、中序遍历都要这个打印</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printEdge(head);  //后序遍历，打印整个树的右边界(即根节点的右边界)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历需要：逆序打印节点的右边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> reverseEdge(head);  <span class="comment">//翻转链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(tail); <span class="comment">//再翻转回来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历需要：翻转右边界(链表)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseEdge</span><span class="params">(Node from)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>由于图本身的数据结构表达多种多样，为了不用在和图有关的算法上使用不同种数据结构去实现。所以可以考虑只使用一种兼容性好的结构，用到的时候，将题目中的数据结构转换为常用的这个结构，就不用考虑多种结构的算法实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> in;  <span class="comment">//入读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> out; <span class="comment">//出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts; <span class="comment">//点集：直接邻居，从自己出发能到达的第一个节点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges; <span class="comment">//边集：从自己出去的边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;<span class="comment">//权重</span></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node from, Node to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span> &#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个图的数据结构为 [weight，from，to]，则以下是结构的转换过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(Integer[][] matrix)</span>&#123;</span><br><span class="line">    <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> matrix[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> matrix[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果点集中没有这个点，就新建一个加进去</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(from))&#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(from));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(to))&#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(to));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到from点和to点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">        <span class="comment">//建边</span></span><br><span class="line">        <span class="type">Edge</span> <span class="variable">newEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">        <span class="comment">//to点是from点的直接邻居</span></span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        fromNode.out++;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        <span class="comment">//新边是from点的出边</span></span><br><span class="line">        fromNode.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>深度优先遍历DFS和广度优先遍历BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从node出发，进行宽度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    queue.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">//出队列时打印</span></span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="comment">//将所有没加入过的直接邻居 加入集合和队列中</span></span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next))&#123;</span><br><span class="line">                set.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                <span class="comment">//先将当前元素入栈，再入栈直接邻居，然后beak</span></span><br><span class="line">                <span class="comment">//目的是为了保留元素，以便回来往其他方向深度搜索</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                <span class="comment">//入栈时打印</span></span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p><blockquote><p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p></blockquote><p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现<code>一次</code>。</li><li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p><p><strong>代码思想为：</strong></p><p>新建node类，包含节点数值和它的指向；</p><p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p><p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p><p>重复上述操作，直到栈为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">    <span class="comment">//key为某个node，value为剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录每个点的入度，并将入度为0的点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>)&#123;</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//result存放拓扑排序的结果</span></span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="comment">//遍历cur的直接邻居，使其入度-1，并将入度变为0的节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (Node next: cur.nexts)&#123;</span><br><span class="line">             inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">             <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>)&#123;</span><br><span class="line">                 zeroInQueue.add(next);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a>普里姆(prim)算法</h3><p>（从顶点 考虑）</p><ol><li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li><li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li><li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li><li>重复步骤2，3，知道V-S为空集</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101100065.png" alt="image-20220610110015537"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prim最小生成树算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">primMST</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">    <span class="comment">//解锁的边进入小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Edge&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge o1, Edge o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//外层for循环，是为了预防森林，没有森林的话可以去掉</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">//随便一个点开始</span></span><br><span class="line">        <span class="comment">//node是开始点</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">            set.add(node);</span><br><span class="line">            priorityQueue.addAll(node.edges); <span class="comment">//将开始点的所有边加入最小堆</span></span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll(); <span class="comment">//弹出现有的最小边</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;  <span class="comment">//看to点是否在集合中，不在的话也将它的边加入最小堆</span></span><br><span class="line">                <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                    set.add(toNode);</span><br><span class="line">                    result.add(edge);   <span class="comment">//加入结果集</span></span><br><span class="line">                    priorityQueue.addAll(toNode.edges);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="克鲁斯卡尔-kruskal-算法"><a href="#克鲁斯卡尔-kruskal-算法" class="headerlink" title="克鲁斯卡尔(kruskal)算法"></a><strong>克鲁斯卡尔(kruskal)算法</strong></h3><p>（从边 考虑）</p><ol><li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li><li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li><li>直到图中所有的顶点都在同一个顶点集为止</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101102846.png" alt="image-20220610110252139"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="comment">//用并查集实现kruskal算法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">kruskalMST</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line"><span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">unionFind.makeSets(graph.nodes.values());</span><br><span class="line"><span class="comment">// 从小的边到大的边，依次弹出，小根堆！</span></span><br><span class="line">PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Edge&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge o1, Edge o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">priorityQueue.add(edge);  <span class="comment">// O(logM)</span></span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="comment">// M 条边</span></span><br><span class="line"><span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line"><span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">result.add(edge);</span><br><span class="line">unionFind.union(edge.from, edge.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union-Find Set，并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="comment">// key 某一个节点， value key节点往上的节点</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line"><span class="comment">// key 某一个集合的代表节点, value key所在集合的节点个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line">sizeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">fatherMap.clear();</span><br><span class="line">sizeMap.clear();</span><br><span class="line"><span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">fatherMap.put(node, node);</span><br><span class="line">sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到这个集合的代表</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">findFather</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">Stack&lt;Node&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(n != fatherMap.get(n)) &#123;</span><br><span class="line">path.add(n);</span><br><span class="line">n = fatherMap.get(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!path.isEmpty()) &#123;</span><br><span class="line">fatherMap.put(path.pop(), n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断两个点是否在同一个集合中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(Node a, Node b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个点并入同一个集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Node a, Node b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">aDai</span> <span class="operator">=</span> findFather(a);</span><br><span class="line"><span class="type">Node</span> <span class="variable">bDai</span> <span class="operator">=</span> findFather(b);</span><br><span class="line"><span class="keyword">if</span> (aDai != bDai) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">aSetSize</span> <span class="operator">=</span> sizeMap.get(aDai);</span><br><span class="line"><span class="type">int</span> <span class="variable">bSetSize</span> <span class="operator">=</span> sizeMap.get(bDai);</span><br><span class="line"><span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">fatherMap.put(aDai, bDai);</span><br><span class="line">sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">sizeMap.remove(aDai);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fatherMap.put(bDai, aDai);</span><br><span class="line">sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">sizeMap.remove(bDai);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="暴力递归-从左往右的尝试模型"><a href="#暴力递归-从左往右的尝试模型" class="headerlink" title="暴力递归-从左往右的尝试模型"></a>暴力递归-从左往右的尝试模型</h2><blockquote><p>尝试就是接解题的步骤，也可以说尝试就是暴力递归。</p><p>从左往右，就是坐标逐步往后移动，解决问题。</p></blockquote><p>例1：打印一个字符串的全部子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：打印一个字符串的全部子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> index, List&lt;String&gt; ans, String path)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">no</span> <span class="operator">=</span> path;</span><br><span class="line">process1(str,  index + <span class="number">1</span>, ans, no);</span><br><span class="line"><span class="type">String</span> <span class="variable">yes</span> <span class="operator">=</span> path + String.valueOf(str[index]);</span><br><span class="line">process1(str, index + <span class="number">1</span>, ans, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：打印一个字符串的全排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, ArrayList&lt;String&gt; res)</span> &#123;</span><br><span class="line">       <span class="comment">//在终止位置加入</span></span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">res.add(String.valueOf(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; str.length; j++) &#123;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">process2(str, i+<span class="number">1</span>,res);</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例3：打印一个字符串的全排列，要求不要出现重复的排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process3</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, ArrayList&lt;String&gt; res)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">res.add(String.valueOf(str));</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//用于判断本次循环中是否出现了重复字母，即这个字母的情况已经罗列过了，可以剪枝掉</span></span><br><span class="line"><span class="type">boolean</span>[] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; str.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visit[str[i] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">visit[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">process2(str, i+<span class="number">1</span>,res);</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例4：（facebook面试题）</p><p>规定1和A对应、2和B对应、3和C对应……那么一个数字字符串比如”111”就可以转化为：  “AAA”、”KA”和”AK”；<br>给定一个只有数字字符组成的字符串str, 返回有多少转化结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//di&#x27;gui</span></span><br><span class="line"><span class="comment">//i之前的位置，如何转化已经做过决定，不用再关心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process4</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//单独的‘0’是无效的，0只能和10和20在一起才有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字母最多到26，所以要考虑十几和二十几的情况</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> process4(str,  i + <span class="number">1</span>);  <span class="comment">//i自己作为单独的数，后续有多少种方案</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length) &#123;</span><br><span class="line">res += process4(str, i + <span class="number">2</span>);  <span class="comment">//i和i+1作为一个二位数，后续有多少种方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> process4(str,  i + <span class="number">1</span>);<span class="comment">//i自己作为单独的数，后续有多少种方案</span></span><br><span class="line"><span class="comment">//i和i+1这个数，不能超过26</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">res += process4(str, i + <span class="number">2</span>); <span class="comment">//i和i+1作为一个二位数，后续有多少种方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str[i] == &#x27;3&#x27; ~ &#x27;9&#x27;</span></span><br><span class="line"><span class="keyword">return</span> process4(str, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA方法"><a href="#JAVA方法" class="headerlink" title="JAVA方法"></a>JAVA方法</h1><h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h2><p>Math.random会<strong>等概率</strong>地返回Double类型的 [0, 1) 的随机数，应用：</p><ul><li><p>随机返回 [0, k) 的数： Math.random() * k</p></li><li><p>随机返回 [0, k] 的整数： (int) Math.random() * (k+1)</p></li><li><p>设x属于 [0, 1) ，原本 x 在[0, x) 上出现的概率是 x，如果要将出现的概率改为 x^2^ ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(Math.random(), Math.random())</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5随机到1-7随机"><a href="#1-5随机到1-7随机" class="headerlink" title="1-5随机到1-7随机"></a>1-5随机到1-7随机</h3><p>例1：设有一个方法f1()，它等概率返回 [1,5]，现要求将其改成等概率返回 [1,7] 的方法：</p><p>思路：先将f1改成 01等概率方法f2，则f2可以表示一位二进制位，已知三个二进制位可表示 [0,7]，所以利用位运算可以得到一个等概率的3位二进制数，再将等于0的机会均分给其他的数即可。</p><blockquote><p>改造成01等概率，有奇数个则将某个数的概率均分给其他数，有偶数个直接平分即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//f1()功能：随机返回 [1,5]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f2()功能：将f1()改造成随机返回 0、1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans = f1();</span><br><span class="line">        &#125; <span class="keyword">while</span> (ans == <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将等于3的概率均分给1245</span></span><br><span class="line">        <span class="comment">//当f()为12时返回0， 为45时返回1</span></span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">3</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f3()功能：将f2的结果作为一个二进制位，三位即可返回[0,7]，再将等于0的概率均分给其他数，即可等概率得到[1，7]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans = (f2() &lt;&lt; <span class="number">2</span>) + (f2() &lt;&lt; <span class="number">1</span>) + f2();</span><br><span class="line">        &#125; <span class="keyword">while</span> (ans == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//f3也可以先等到[0,6]，再+1</span></span><br></pre></td></tr></table></figure><h3 id="01不等概率到01等概率"><a href="#01不等概率到01等概率" class="headerlink" title="01不等概率到01等概率"></a>01不等概率到01等概率</h3><p>例2：设方法f1()返回0的概率是p，返回1的概率是1- p，只使用f1()，写出能等概率返回01的方法。</p><p>思路：调用俩次f1，组成一个二位的二进制数，则01和10的概率均为 p(1- p)，而00概率p^2^，11概率(1- p)^2^。所以取01和10作为 0和1返回，00和11直接舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01不等概率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Math.random() &gt; <span class="number">0.7</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//01等概率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">int</span> ans;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           ans = f1();</span><br><span class="line">       &#125;<span class="keyword">while</span> (ans == f1());</span><br><span class="line">       <span class="comment">//f1调用两次，当第一次等于第二次时，重新选值。</span></span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>对数器：有一个能随机生成符合要求的数组的方法，一个用于复制的方法，一个验证正误的方法；</p><p>在比赛中，一般只会给出一两道简单的例子，不能验证算法是否正确，所以就可以用对数器进行大量例子验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个值和长度都随机的数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lenAndValueRandom(<span class="type">int</span> maxLen, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() + maxLen);  <span class="comment">//长度随机，范围在[0, maxLen-1]</span></span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           ans[i] = (<span class="type">int</span>) (Math.random() * maxValue);  <span class="comment">//值随机，范围在[0,maxValue-1]</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//复制一份，用于出错后比较</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copy(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           ans[i] = arr[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断使用了算法的数组是否达到预期要求</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="comment">//具体内容根据题目要求而定</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写出来的算法，需要验证</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">algorithm1</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">//测试次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">           <span class="type">int</span>[] arr1 = lenAndValueRandom(maxLen, maxValue);</span><br><span class="line">           <span class="type">int</span>[] arr2 = copy(arr1);</span><br><span class="line">           <span class="comment">//当算法不符合要求时，根据情况进行打印，可以方便分析</span></span><br><span class="line">           <span class="keyword">if</span> (!judge(arr1))&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;算法出错了&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> k : arr2) &#123;</span><br><span class="line">                   System.out.print(k + <span class="string">&quot; &quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> k : arr1) &#123;</span><br><span class="line">                   System.out.print(k + <span class="string">&quot; &quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>动态数组每次容量不够时，ArrayList会扩容至1.5倍，而Vector容量会扩至2倍，并将旧数据拷贝进去；不管是ArrayList还是Vector，多次扩容的时间代价是一个等比数列，所以扩容的时间复杂度是O(N)，当每一步扩容均摊到算法计算过程中，可以当作常数操作，所以使用动态数组不影响时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Notes/2022/06/05/%E9%97%AE%E9%A2%981/"/>
      <url>/Notes/2022/06/05/%E9%97%AE%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<ol><li><p>get请求的参数中带有英文点号，导致的请求错误：</p><p>在Spring MVC框架中，会将地址中的最后一个点号截断为后缀名，从而判断其请求消费的内容类型，在不改变此策略的情况下，修改请求方式与地址也能达到正确处理的目标。</p><p>如果请求的url中带有含有 英文点号 的参数，如地址、邮箱等，可以在请求方式中最后再加一个点号，或者修改后端的MVC框架策略，或者将 @PathVariable改为@RequestParam</p></li><li><p>vue中设置 &lt;form @submit.prevent&gt; ，取消表单提交后的默认跳转</p></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英语学习</title>
      <link href="/Notes/2022/05/16/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
      <url>/Notes/2022/05/16/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="六级便携版（1500词汇）"><a href="#六级便携版（1500词汇）" class="headerlink" title="六级便携版（1500词汇）"></a>六级便携版（1500词汇）</h3><ol><li><p>assume </p><blockquote><p>vt. 假定，承担，呈现</p><p>vi. 多管闲事</p></blockquote></li><li><p>facility</p><blockquote><p>n. 设备，灵巧</p></blockquote></li><li><p>perspective</p><blockquote><p>n. 观点，想法； </p><p>​远景，前途；</p><p>​希望，透视图；</p></blockquote></li><li><p>monopoly</p><blockquote><p>n. 垄断；垄断者；专卖权</p></blockquote></li><li><p>sheer</p><blockquote><p>adj. 完全的；陡峭的； 轻的，透明的</p><p>adv. 垂直地，陡峭地；</p><p>vi. 避开</p></blockquote></li><li><p>convention</p><blockquote><p>n. 大会； 协定； 惯例；公约</p></blockquote></li><li><p>ascribe</p><blockquote><p>vt. 归因于，归咎于</p></blockquote></li><li><p>despise</p><blockquote><p>vt. 轻视，鄙视</p></blockquote></li><li><p>loom</p><blockquote><p>n. 织布机； 若隐若现的景象；</p><p>vi. 隐约出现，隐约可见</p></blockquote></li><li><p>assimilate</p><blockquote><p>vi&amp;vt. 吸收，消化，同化</p></blockquote></li><li><p>paradox</p><blockquote><p>n. 悖论</p></blockquote></li><li><p>imitate</p><blockquote><p>vt. 模仿</p></blockquote></li><li><p>demonstrate</p><blockquote><p>vt. 证明，演示；</p><p>vi. 示威；</p></blockquote></li><li><p>setback</p><blockquote><p>n. 挫折； </p><p>​    退步；</p></blockquote></li><li><p>fabricate</p><blockquote><p>vt. 编造，虚构；</p></blockquote></li><li><p>strain</p><blockquote><p>n. 张力；拉紧；</p><p>​    血缘；</p><p>​    负担；</p><p>​    扭伤；</p><p>vi. 拉紧； 尽力；</p></blockquote></li><li><p>luxury</p><blockquote><p>n. 奢侈； 奢侈品</p><p>adj. 奢侈的</p></blockquote></li><li><p>candidate</p><blockquote><p>n. 候选人，报考者</p></blockquote></li><li><p>constant</p><blockquote><p>adj. 不变的，恒定的；</p><p>​       经常的；</p><p>n. 常数；恒量</p></blockquote></li><li><p>arrogant</p><blockquote><p>adj. 自大的，傲慢的；</p></blockquote></li><li><p>harmony</p><blockquote><p>n. 协调，融洽，和睦；</p></blockquote></li><li><p>dignity</p><blockquote><p>n. 尊严，高贵</p></blockquote></li><li><p>casual</p><blockquote><p>adj. 随意的； 偶然的；</p><p>​       临时的，非正式的；</p><p>n. 临时工人；便装；待命士兵；</p></blockquote></li><li><p>casualty</p><blockquote><p>n. 伤亡人员，受害者；损毁物；</p><p>​     急诊室；</p></blockquote></li><li><p>premier</p><blockquote><p>adj. 最初的，第一的；</p><p>n. 总理，首相；</p></blockquote></li><li><p>recipe</p><blockquote><p>n. 食谱；处方[医]；秘诀；</p></blockquote></li><li><p>authorize</p><blockquote><p>vt. 授权，批准；委托</p></blockquote></li><li><p>lure</p><blockquote><p>n. 诱惑物，诱惑；</p><p>vt. 诱惑；</p></blockquote></li><li><p>emergency</p><blockquote><p>n.紧急情况，非常时刻</p></blockquote></li><li><p>proceed</p><blockquote><p>vi. 开始，继续进行；</p><p>​      发生，进行；</p></blockquote></li><li><p>conspicuous</p><blockquote><p>adj. 显眼的；醒目的；</p></blockquote></li><li><p>propel</p><blockquote><p>vt. 推进；驱动，驱策；</p><p>​      激励；</p></blockquote></li><li><p>controversy</p><blockquote><p>n. 争论，辩论</p></blockquote></li><li><p>privilege</p><blockquote><p>n. 荣幸；特权；</p><p>vt. 给予特权；</p></blockquote></li><li><p>substitute</p></li></ol><pre><code>&gt; vi.&amp;vt. 替代</code></pre><ol start="36"><li>spoil</li></ol><pre><code>&gt;  vt. 溺爱；糟蹋；掠夺；&gt;&gt; vi. 变坏；掠夺；腐败；</code></pre><ol start="37"><li>accommodate</li></ol><pre><code>&gt;  vt. 容纳； 向..提供住处；&gt;&gt; ​       使适应；</code></pre><ol start="38"><li>artery</li></ol><pre><code>&gt;  n. 动脉；&gt;&gt; ​      主干道，主流；</code></pre><ol start="39"><li>spouse</li></ol><pre><code>&gt;  n. 配偶&gt;&gt; vt. 和...结婚</code></pre><ol start="40"><li>feeble</li></ol><pre><code>&gt;  adj. 微弱的；虚弱的；</code></pre><ol start="41"><li><p>nourish</p><blockquote><p> vt. 滋养，喂养</p></blockquote></li><li><p>foremost</p><blockquote><p> adj. 最先的，最重要的</p><p> adv. 首先，居于首位的</p></blockquote></li><li><p>ponder</p><blockquote><p> vt. 仔细考虑；衡量</p><p> vi. 沉思；考虑</p></blockquote></li><li><p>marsh</p><blockquote><p> n. 湿地；沼泽</p><p> adj. 沼泽的；生长在沼泽地的</p></blockquote></li><li><p>patron</p></li></ol><pre><code>&gt; n. 赞助人；主顾</code></pre><ol start="46"><li>desirable</li></ol><pre><code>&gt;  adj. 令人满意的； 有吸引力的；</code></pre><ol start="47"><li><p>dispatch</p><blockquote><p> n. 派遣；急件</p><p> vt. 派遣；[计算机]分派</p></blockquote></li><li><p>aspiration</p></li></ol><pre><code>&gt;  *n.* 强烈的愿望, 志向, 抱负</code></pre><ol start="49"><li><p>convict</p><blockquote><p> <em>vt.</em> 宣判有罪</p><p> <em>n.</em> 囚犯</p></blockquote></li><li><p>stack</p><blockquote><p> n. 堆；堆叠</p><p> vt. 使堆叠；把…堆积起来</p><p> vi. 堆积，堆叠</p></blockquote></li><li><p>attribute</p><blockquote><p><em>vt.</em> 认为…是；归因于…</p><p>​ 认为某事[物]属于某人[物]</p><p><em>n.</em> 属性，特性</p></blockquote></li><li><p>invert</p><blockquote><p>vt. 使…转化；使…颠倒</p><p>n. 倒置物；倒悬者</p><p>adj. 转化的</p></blockquote></li><li><p>preclude</p><blockquote><p>vt. 妨碍， 阻止</p></blockquote></li><li><p>radical</p><blockquote><p>adj. 根本的；彻底的</p><p>​激进的，激进派的</p></blockquote></li><li><p>preliminary</p><blockquote><p><em>adj.</em> 初步的, 预备的, 开端的</p><p><em>n.</em> 准备工作, 初步行动</p></blockquote></li><li><p>subconscious</p><blockquote><p>adj. 下意识的</p></blockquote></li><li><p>strategy</p><blockquote><p>n. 战略，策略；</p></blockquote></li><li><p>maneuver</p><blockquote><p>n. 策略；演习；调遣；机动</p><p>vi. 调遣；演习；用计谋；机动</p><p>vt. 演习；调遣；用计；机动</p></blockquote></li><li><p>apparatus</p><blockquote><p><em>n.</em> 运动器械, 器具, 仪器</p><p>​机构, 组织</p><p>​器官</p></blockquote></li><li><p>grope</p><blockquote><p>vi. 探索</p></blockquote></li><li><p>encounter</p><blockquote><p>vt. 遭遇，邂逅</p><p>n. 突然遇到</p></blockquote></li><li><p>ascend</p><blockquote><p>vi. 上升；登高；追溯</p><p>vt. 攀登，上升</p></blockquote></li><li><p>ascertain</p><blockquote><p><em>vt.</em> 弄清, 确定, 查明</p></blockquote></li><li><p>elaborate</p><blockquote><p><em>vi.</em> 详尽说明</p><p><em>vt.</em> 详细制定</p><p><em>adj.</em> 复杂的；精心制作的</p></blockquote></li><li><p>suspend</p><blockquote><p>v. 延迟； 使悬浮，竞赛</p></blockquote></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络2.0</title>
      <link href="/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/"/>
      <url>/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/</url>
      
        <content type="html"><![CDATA[<h3 id="缩写简称"><a href="#缩写简称" class="headerlink" title="缩写简称"></a>缩写简称</h3><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p></li><li><p>HTTP —— 超文本传输协议， HyperText Transfer Protocol</p></li><li><p>ARP协议 —— 地址解析协议 （Address Resolution Protocol）</p></li><li><p>MSS  —— TCP最大报文段长度</p></li><li><p>QUIC —— 快速UDP互联网连接（Quick UDP Internet Connection）</p></li><li><p>SSL&#x2F;TLS —— </p><blockquote><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p></blockquote></li><li><p>RTT —— 往返时间 （Round-Trip Time）</p></li></ul><h1 id="TCP-x2F-IP网络模型"><a href="#TCP-x2F-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户直接接触到的就是应⽤层（Application Layer），当两个不同设备的应⽤需要通信的时候，应用就把应用数据传给下⼀层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><blockquote><p>应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。</p></blockquote><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层（Transport Layer）是为应用层提供网络支持的。</p><p>传输层有两个重要协议：TCP和UDP</p><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p><p>大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证 数据包能可靠地传输给对方。</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p><p>UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率 也高。</p></li></ul><p>MSS —— TCP最大报文段长度</p><p>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP段（TCP Segment）。</p><p>端口：</p><p>⼀台设备上可能会有很多应用在接收或者传输数 据，因此需要用一个编号将应用区分开来，这个编号就是端口。</p><p>传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>公认的默认端口：</p><p>0 ~ 1023 是系统端口号，即已经公认定义或为将要公认定义的软件保留的，1024-49151用户端口号 ，49152-65535 是动态端口号 或称私有端口，不能被正式注册占用。</p><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>20 &#x2F;TCP,UDP</td><td>FTP [Default Data]</td><td>文件传输协议 - 默认数据端口</td></tr><tr><td>21 &#x2F;TCP,UDP</td><td>FTP [Control]</td><td>文件传输协议 - 控制端口</td></tr><tr><td>22 &#x2F;TCP,UDP</td><td>SSH</td><td>SSH（Secure Shell） - 远程登录协议，用于安全登录文件传输（SCP，SFTP）及端口重新定向</td></tr><tr><td>23 &#x2F;TCP,UDP</td><td>Telnet</td><td>Telnet终端仿真协议 - 未加密文本通信</td></tr><tr><td>25 &#x2F;TCP,UDP</td><td>SMTP</td><td>SMTP（简单邮件传输协议） - 用于邮件服务器间的电子邮件传递</td></tr><tr><td>43 &#x2F;TCP</td><td>WHOIS</td><td>WHOIS协议（who is ，查询域名的相关信息）</td></tr><tr><td>53 &#x2F;TCP,UDP</td><td>DNS</td><td>DNS（域名服务系统）</td></tr><tr><td>67 &#x2F;UDP</td><td>BOOTPs</td><td>BOOTP服务；同时用于动态主机设置协议 （BootStrap协议，引导程序协议，是DHCP的前身）</td></tr><tr><td>68 &#x2F;UDP</td><td>BOOTPc</td><td>BOOTP客户端；同时用于动态主机设定协议</td></tr><tr><td>69 &#x2F;UDP</td><td>TFTP</td><td>小型文件传输协议（小型文件传输协议）</td></tr><tr><td>80 &#x2F;TCP</td><td>Http</td><td>超文本传输协议（超文本传输协议）- 用于传输网页</td></tr><tr><td>110 &#x2F;TCP</td><td>POP3</td><td>邮局协议，“邮局协议”，第3版 - 用于接收电子邮件</td></tr><tr><td>113 &#x2F;TCP</td><td>Windows验证服务</td><td>Ident - 旧的服务器身份识别系统，仍然被IRC服务器用来认证它的用户</td></tr><tr><td>123 &#x2F;UDP</td><td>NTP</td><td>NTP（Network Time Protocol） - 用于网络时间同步</td></tr><tr><td>137 &#x2F;TCP,UDP</td><td>NetBIOS Name Service</td><td>NetBIOS（网上基本输入输出系统）， NetBIOS 名称服务</td></tr><tr><td>138 &#x2F;TCP,UDP</td><td>NetBIOS Datagram Service</td><td>NetBIOS NetBIOS 数据报文服务</td></tr><tr><td>139 &#x2F;TCP,UDP</td><td>NetBIOS Session Service</td><td>NetBIOS NetBIOS 会话服务</td></tr><tr><td>143 &#x2F;TCP,UDP</td><td>IMAP</td><td>因特网信息访问协议（Internet Message Access Protocol） - 用于检索 电子邮件</td></tr><tr><td>161 &#x2F;TCP,UDP</td><td>SNMP</td><td>简单网络管理协议</td></tr><tr><td>179 &#x2F;TCP</td><td>Bgp</td><td>边界网关协议 (Border Gateway Protocol)</td></tr><tr><td>194 &#x2F;TCP</td><td>IRC</td><td>互联网中继聊天（Internet Relay Chat）</td></tr><tr><td>220 &#x2F;TCP,UDP</td><td>IMAP3</td><td>因特网信息访问协议，交互邮件访问协议第3版</td></tr><tr><td>389 &#x2F;TCP,UDP</td><td>LDAP</td><td>轻型目录访问协议（Lightweight Directory Access Protocol）</td></tr><tr><td>443 &#x2F;TCP</td><td>Https</td><td>超文本传输安全协议 - 超文本传输协议 over TLS&#x2F;SSL（加密传输）</td></tr><tr><td>546 &#x2F;TCP,UDP</td><td>DHCPv6 client</td><td>DHCPv6客户端（动态主机配置协议，Dynamic Host Configuration Protocol）</td></tr><tr><td>547 &#x2F;TCP,UDP</td><td>DHCPv6 server</td><td>DHCPv6服务器</td></tr><tr><td>631 &#x2F;TCP,UDP</td><td>CUPS</td><td>通用Unix打印系统</td></tr><tr><td>636 &#x2F;TCP,UDP</td><td>LDAPS</td><td>LDAP over SSL（加密传输，也被称为LDAPS）</td></tr><tr><td>991 &#x2F;TCP,UDP</td><td>NAS</td><td>NAS (Netnews Admin System， 网络新闻管理系统 )</td></tr><tr><td>1080 &#x2F;tcp</td><td>SOCKS</td><td>SOCKS代理</td></tr><tr><td>1194 &#x2F;udp</td><td>OpenVPN</td><td>OpenVPN</td></tr><tr><td>1433 &#x2F;tcp,udp</td><td>SQL Server</td><td>Microsoft SQL 数据库系统</td></tr><tr><td>1434 &#x2F;tcp,udp</td><td>SQL Server monitor</td><td>Microsoft SQL 活动监视器</td></tr><tr><td>1521 &#x2F;tcp</td><td>Oracle</td><td>Oracle数据库 default listener, in future releases official port 2483</td></tr><tr><td>3306 &#x2F;tcp,udp</td><td>MySQL</td><td>MySQL数据库系统</td></tr><tr><td>3389 &#x2F;tcp</td><td>RDP</td><td>远程桌面协议（RDP）</td></tr><tr><td>5432 &#x2F;tcp</td><td>PostgreSQL</td><td>PostgreSQL database system</td></tr></tbody></table></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层负责 实际的数据传输功能；</p><blockquote><p>⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，所以这些功能交由网络层实现。</p></blockquote><p>主要协议： IP</p><p>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装 成 IP 报文，如果 IP 报文大小超过 MTU（最大传输但与，以太网中⼀般为 1500 字节）就会再次进行分片，得到⼀个即将发送到网络的 IP 报文。</p><p>IP地址分为两种意义 ：</p><ul><li>网络号：负责标识该 IP 地址是属于哪个子网的</li><li>主机号：负责标识同⼀子网下的不同主机</li></ul><p>通过子网掩码算出，先匹配到相同的网络号，再去找对应的主机。</p><p>路由：通过算法决定下一步走哪一条路径。</p><blockquote><p>IP 协议的寻址作用是告诉我们去往下⼀个目的地该朝哪个⽅向走，路由则是根据「下⼀个目的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘。</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层 标识网络中的设备，为网络层提供链路级别传输的服务。</p><blockquote><p>每⼀台设备的网卡都会有⼀个 MAC 地址，它就是用来唯⼀标识设备的。路由器计算出了下⼀个目的地 IP 地址，再通过 ARP 协议找到该目的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p></blockquote><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层 （Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>HTTP，是超文本传输协议，HyperText Transfer Protocol</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>HTTP五大类状态码：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1**</td><td>提示信息，表示目前是协议处理的中间状态，还需要后续操作</td></tr><tr><td>2**</td><td>成功，报文已经收到并正确处理</td></tr><tr><td>3**</td><td>重定向，资源位置发生变动，需要客户端重新发送请求</td></tr><tr><td>4**</td><td>客户端错误，请求报文有误，服务器无法处理</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求时内部发生错误</td></tr></tbody></table><p>1xx —— 属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。 </p><p>2xx —— 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 </p><ul><li>「200 OK」：是最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 </li><li>「204 No Content」：也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「206 Partial Content」：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的⼀部分，也是服务器处理成功的状态。</li></ul><p>3xx —— 表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 </p><ul><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。 </p></li><li><p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。 </p><blockquote><p>301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 </p></blockquote></li><li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，᯿定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓 存控制。</p></li></ul><p>4xx —— 表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 </p><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 </li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 </li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p>5xx —— 表示客户端请求报文正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。 </p><ul><li>「500 Internal Server Error」与 400 类型一样，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 </li><li>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。 </li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器 发生了错误。 </li><li>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“网络服务正忙，请稍后再试”的意思。</li></ul><h3 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h3><ul><li><p>Host 字段 —— 客户端发送请求时，用来指定服务器的域名。</p><blockquote><p>例： Host: www. baidu.com ，有了Host字段，就可以将请求发往「同⼀台」服务器上的不同网站。</p></blockquote></li><li><p>Content-Length 字段 —— 服务器本次回应返回的数据长度。</p></li><li><p>Connection 字段 —— 用于客户端要求服务器使用TCP 持久连接，以便其他请求复用。</p><blockquote><p>Connection：Keep-Alive</p><p>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive.</p><p>⼀个可以复用的 TCP 连接会持续到 客户端或服务器主动关闭连接。</p></blockquote></li><li><p>Content-Type —— 用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Accept —— 客户端声明自己可以接收哪些数据格式</p><blockquote><p>客户端    Accept:  *&#x2F;*    （表示能接收所有数据格式</p><p>服务器   Content-Type:  text&#x2F;html; charset&#x3D;utf-8</p></blockquote></li><li><p>Content-Encoding  ——  说明数据的压缩方法，即服务器返回的数据用了什么压缩格式</p><p>Accept-Encoding  —— 客户端能接受的压缩方式。</p></li></ul><h2 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h2><p>GET —— 请求从服务器获取资源；</p><p>POST —— 向 url 指定的资源提交数据，数据就放在报文的 body 里；</p><blockquote><p>安全：在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。</p><p>幂等：是指多次执⾏相同的操作，结果都是「相同」的。</p><p>对此 —— </p><ul><li>GET方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全 的，且每次的结果都是相同的；</li><li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的。</li></ul></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>优点：简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li><p>简单： HTTP 基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式，易于理解。</p></li><li><p>灵活和易于扩展：：HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许自定义和扩充。</p><p>同时HTTP是工作再应用层的，它的下层可以随意变化，比如：HTTPS就是在HTTP和TCP之间增加了SSL&#x2F;TLS安全传输层，HTTP3还把TCP换成了基于UDP的QUIC。</p></li></ul><p>缺点：无状态，明文传输，不安全</p><ul><li><p>无状态</p><p>好处在于服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的 负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>坏处是在完成有关联性的操作时会非常麻烦，需要每次都询问身份信息。</p><blockquote><p>最简单的解决方式：使用 Cookie 技术</p></blockquote></li><li><p>明文传输</p><p>好处在于方便阅读，通过浏览器控制台或抓包都可以直接查看，便于调试。</p><p>坏处是 信息裸奔了，很容易被窃取信息。</p></li><li><p>不安全</p><ul><li>窃听风险：通信使用明文；</li><li>冒充风险：不验证通信方的身份，可能遭遇伪装；</li><li>篡改风险：无法证明报文的完整性，可能数据遭到篡改</li></ul><blockquote><p>解决：可以用HTTPS，也就是引入 SSL&#x2F;TLS 层</p></blockquote></li></ul><p>HTTP&#x2F;1.1性能</p><ul><li><p>长连接</p><p>HTTP&#x2F;1.0每次发起请求，都要新建一次TCP连接，而且是串行请求，做了无所谓的TCP建立连接和断开。</p><p>HTTP&#x2F;1.1提出了 长连接，也就是持久连接，只要任意一端没有明确提出断开连接，则会保持TCP连接状态。</p><blockquote><p>长连接使得 管道网络传输 成为可能，即在同⼀个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>但是服务器还是得按顺序处理请求，可能发生 队头阻塞。</p></blockquote></li><li><p>队头阻塞</p><p>「请求 - 应答」的模式会发送队头阻塞，影响性能；</p><p>因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了上述的风险： </p><ul><li><p>信息加密：交互信息无法被窃取；</p><p>使用<strong>混合加密</strong>的方式实现信息的机密性。</p><blockquote><p>混合加密： 对称加密 + 非对称加密 </p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 </li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul><p>之所以使用混合加密是因为：</p><ul><li>对称加密 只使用⼀个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密 使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></blockquote></li><li><p>校验机制：无法篡改通信内容，篡改了就不能正常显示； </p><p>使用 <strong>摘要算法</strong> 来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决 了篡改的风险。</p><blockquote><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」⼀同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出 的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p></blockquote></li><li><p>身份证书：证明网站合法性；</p><p>将服务器<strong>公钥放入到数字证书</strong>中，解决了冒充的风险。</p><blockquote><p>公钥的可信度：将公钥放在CA（数字证书认证机构）颁发的数字证书中，只要证书可信，公钥就可信；</p><ol><li>服务器把自己的公钥注册到CA;</li><li>CA用自己的私钥将服务器的公钥 数字签名，并颁发数字证书；</li><li>客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性；</li><li>从数字证书获取服务器的公钥后，使用公钥对报文加密后发送；</li><li>服务器使用是要对报文解密；</li></ol></blockquote></li></ul><h3 id="HTTPS建立连接"><a href="#HTTPS建立连接" class="headerlink" title="HTTPS建立连接"></a>HTTPS建立连接</h3><p>SSL&#x2F;TLS 协议基本流程： </p><ol><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。 </li><li>双方采用「会话秘钥」进行加密通信。</li></ol><p>前两步是SSL&#x2F;TLS的建立过程，即握手阶段，设计四次通信：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091837504.png" alt="HTTPS 连接建立过程"></p><p>流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><blockquote><p>关于SSL和TLS：</p><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p><p>因此，SSL 和 TLS 可以视作同一东西的不同阶段。</p></blockquote><blockquote><p>SSL1.2 需要4次握手，2个RTT时延；而SSL&#x2F;TLS1.3 只需3次握手，1个RTT时延。</p></blockquote><h2 id="HTTP-x2F-1-1-2-3的演变"><a href="#HTTP-x2F-1-1-2-3的演变" class="headerlink" title="HTTP&#x2F;1.1~2~3的演变"></a>HTTP&#x2F;1.1~2~3的演变</h2><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p><ul><li>使用 TCP <strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持<strong>管道（pipeline）网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的<strong>顺序响应</strong>的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091847917.png" alt="HTT/1 ~ HTTP/2"></p><p><em>1. 头部压缩</em></p><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><em>2. 二进制格式</em></p><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p>在收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p><em>3. 数据流</em></p><p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>在 HTTP&#x2F;2 中每个请求或相应的所有数据包，称为一个数据流（<code>Stream</code>）。每个数据流都标记着一个独一无二的编号（Stream ID），<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><p><em>4. 多路复用</em></p><p>HTTP&#x2F;2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p><blockquote><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p></blockquote><p><em>5. 服务器推送</em></p><p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p><blockquote><p>比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，而在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p></blockquote><p>HTTP&#x2F;2缺陷：</p><p>在TCP层仍存在队头阻塞问题：</p><p>TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><blockquote><p>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，</p><p>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p></blockquote><p>对此，HTTP&#x2F;3 把 HTTP 下层的 TCP 协议<strong>改成了 UDP</strong>！</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091857744.png" alt="HTTP/1 ~ HTTP/3"></p><p>并且，基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC有以下特点：</p><ul><li><p><em>无队头阻塞</em></p><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。（Stream之间没有依赖，都是独立的）</p></li><li><p>更快的连接建立</p><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”</strong>，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 <strong>1 个 RTT 就可以「同时」完成建立连接与密钥协商</strong>，如图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091901785.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p><blockquote><p>在第二次连接的时候，应用数据包还可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p></blockquote></li><li><p>连接迁移</p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p></li></ul><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>不过，QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><p>所以，HTTP&#x2F;3 现在普及的进度非常的缓慢。</p><h2 id="HTTP-x2F-1-1如何优化"><a href="#HTTP-x2F-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h2><p>思路：</p><ul><li><p><strong>尽量避免发送 HTTP 请求</strong>；</p><p>—— <strong>缓存</strong>：将请求的url作为key，响应作为value； 并估算一个过期时间，过期后发请求，会带上上一次请求的摘要，服务器比对后，如果一样，仅返回不含包体的 <code>304 Not Modified</code> 响应，不一样就带上最新的资源。</p></li><li><p><strong>在需要发送 HTTP 请求时，考虑如何减少请求次数</strong>；</p><p>—— <strong>减少重定向请求次数</strong>： 将重定向工作交给代理服务器。</p><p>—— <strong>合并请求</strong>： 比如将多个小图片放在一起发送，将css、js一起打包发送，但缺点是：如果其中一个资源发送变化，客户端必须重新下载整个大资源文件。</p><p>—— <strong>延迟发送请求</strong>：一般页面中有很多url，没必要全部获取，只获取当前用户所看到的页面资源。</p></li><li><p><strong>减少服务器的 HTTP 响应的数据大小</strong>；</p><p>—— <strong>无损压缩</strong>： 如Brotli，gzip等算法</p><p>—— <strong>有损压缩</strong>：WebP格式（图片压缩）</p></li></ul><h2 id="HTTPS-TLS握手解析"><a href="#HTTPS-TLS握手解析" class="headerlink" title="HTTPS TLS握手解析"></a>HTTPS TLS握手解析</h2><p>HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><blockquote><p><strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><ul><li>客户端：ClientHello</li><li>服务端：ServerHello，Certificate，ServerHelloDone</li><li>客户端：ClientKeyExchange，ChangeCipherSpec，Finished</li><li>服务端：ChangeCiipherSpec，Finished</li></ul></blockquote><p>早先的密钥交换算法是RSA算法，但<strong>不支持前向保密</strong>（一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解）。现在大多数网站使用的正是 ECDHE 密钥协商算法，</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>RSA算法中，TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，需要确保私钥不被窃取。</p><h4 id="TLS第一次握手"><a href="#TLS第一次握手" class="headerlink" title="TLS第一次握手"></a>TLS第一次握手</h4><p>客户端发出一个「<strong>Client Hello</strong>」，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111346948.png" alt="img"></p><h4 id="TLS第二次握手"><a href="#TLS第二次握手" class="headerlink" title="TLS第二次握手"></a>TLS第二次握手</h4><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111517197.png" alt="img"></p><blockquote><p>上图选择的密码套件： “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256” ，其基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」。</p><ul><li><p>其中 “TLS”后 “WITH” 前 一般有两个单词，为密钥交换算法 和 约定证书的验证算法。图中只有RSA，说明这个算法用的都是RSA；</p></li><li><p>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</p></li><li><p>摘要算法 SHA256 用于消息认证和产生随机数；</p></li></ul><p>此时，两个 HELLO 就确认了TLS 版本和使用的密码套件，并且各自发了一个随机数给对方，这是生成 「会话密钥」的条件。</p></blockquote><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111532597.png" alt="img"></p><p>随后，服务端发送「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111532847.png" alt="img"></p><h4 id="TLS第三次握手"><a href="#TLS第三次握手" class="headerlink" title="TLS第三次握手"></a>TLS第三次握手</h4><p>客户端验证完证书后，认为可信则继续往下走。</p><p>接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</p><blockquote><p>服务端会用RSA私钥解密，得到 pre-master。</p><p>此时，双方都有了三个随机数：<strong>Client Random、Server Random、pre-master</strong>，根据这三个随机数，就可以生成 <strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p></blockquote><p>客户端生成会话密钥后，发送一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111553333.png" alt="img"></p><p>然后再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111554344.png" alt="img"></p><blockquote><p>可以发现，在「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p></blockquote><h4 id="TLS第四次握手"><a href="#TLS第四次握手" class="headerlink" title="TLS第四次握手"></a>TLS第四次握手</h4><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>之后就可以用 会话密钥加解密 HTTP 请求和响应了。</p><h3 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h3><blockquote><p>ECDHE 密钥协商算法是 DH 算法演进过来，DH算法的核心数学思想是 离散对数。</p></blockquote><h4 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h4><p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，即 % 或 mod 。</p><p>式子： a^i^ % p &#x3D; b ， 底数a和模板p是公共参数，是公开的，b是真数，i 是对数。 </p><p>一般 对数 作为密钥，知道了对数，能算出真数，但只知道 真数，且<strong>模板p是很大的质数</strong>时，极难算出 对数。</p><h4 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h4><p>DH算法的密钥交换过程：</p><ul><li><p>首先双方会先确定<strong>模板</strong>和<strong>底数</strong>，两个数是公开的，设模板为P，底数为G；</p></li><li><p>然后各自生成一个随机整数为私钥，假设双方的密钥为a和b。</p></li><li><p>于是有：</p><p>公钥A &#x3D; G ^a^ % P</p><p>公钥B &#x3D; G ^b^ % P</p></li><li><p>之后将公钥发给对方， 双方都可以算出一个相同的<strong>对称加密密钥k</strong>， k &#x3D; B ^a^ % P &#x3D; A ^b^ % p。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111612199.png" alt="img"></p><p>DH算法的实现：</p><p>DHE算法，E 是指 ephemeral（临时性的），即双方的私钥在每次密钥交换通信时，都是随机生成的、临时的。</p><blockquote><p>DH算法的另一个实现是 static DH，即有一方的私钥是静态的，一般是服务器方固定私钥，但这样通过大量密钥协商过程的数据 可能可以暴力破解出服务器的私钥。</p><p>所以 static DH 算法不具备前向安全性，并不被采用。</p></blockquote><h4 id="ECDHE算法-1"><a href="#ECDHE算法-1" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h4><p>现在广泛应用的密钥交换算法 —— ECDHE算法。</p><p>ECDHE算法在 DHE算法的基础上，利用了ECC椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种<strong>椭圆曲线</strong>，和曲线上的<strong>基点 G</strong>，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在TLS第二次握手中，客户端拿到服务端的数字证书后，要校验该数字证书的有效性。</p><p>数字证书 通常包含：</p><ul><li>公钥；</li><li>持有者信息；</li><li>证书认证机构（CA）的信息；</li><li>CA 对这份文件的数字签名及使用的算法；</li><li>证书有效期；</li><li>还有一些其他额外信息；</li></ul><p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名。</p><p>签名的作用：可以避免中间人在获取证书时对证书内容的篡改。</p><h4 id="数字证书签发和验证"><a href="#数字证书签发和验证" class="headerlink" title="数字证书签发和验证"></a>数字证书签发和验证</h4><p>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111541262.png" alt="img"></p><p>证书链：</p><p>一般申请的证书由中间证书签发，而不是由根证书签发。 客户端发现签发者不是根证书时，会逐步向上验证，确保中间证书是可信的。</p><p>之所以要弄证书链，是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>项目结构</p><p>轮播图</p><p>swiper</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 轮播图 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">&quot;banners&quot;</span> <span class="attr">indicator-active-color</span>=<span class="string">&quot;#d43c33&quot;</span> <span class="attr">indicator-color</span>=<span class="string">&quot;ivory&quot;</span> <span class="attr">indicator-dots</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon5.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon2.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon3.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可滚动的视图区</p><p>scroll-view</p><p>接口数据：在代码&#x2F;硅谷音乐_server 目录下cmd进入输入： npm start</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/"/>
      <url>/Notes/2022/04/14/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="X-amp-X"><a href="#X-amp-X" class="headerlink" title="X &amp; -X"></a>X &amp; -X</h2><p><strong>X &amp; -X 得到 二进制数的LowBit</strong>（其二进制最低位的1，其余位均为0）：</p><p>-X的值，是在X的基础上进行按位取反之后再加1得到的，</p><ul><li>当X为偶数时，~X为奇数，奇数加上1会发生进位，最低位的连续的1都会变为0，所以X和 ~X的低位都为0，高位都相反，只有得到进位的那个位置都为1，即X的最右边的1相等，所以，<strong>当一个偶数与它的负值相与时， 结果是能整除这个偶数的最大的2的幂, 即： m &#x3D; n &amp; -n , 则 n % m &#x3D; 0, 且 m &#x3D; 2^k^</strong></li><li><strong>当X为奇数时</strong>，因为奇数取反后为偶数，偶数加1并不会影响进位，所以<strong>此时 X &amp; -X 结果一定为1</strong>（奇数最低位的1就在二进制数的末尾）</li></ul><h1 id="双指针-Two-Pointers"><a href="#双指针-Two-Pointers" class="headerlink" title="双指针   Two Pointers"></a><strong>双指针   Two Pointer</strong>s</h1><h2 id="141：判断链表中是否有环："><a href="#141：判断链表中是否有环：" class="headerlink" title="141：判断链表中是否有环："></a><strong>141：</strong>判断链表中是否有环<strong>：</strong></h2><p>(快慢指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> listNode *head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="344：反转字符串"><a href="#344：反转字符串" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = sSize - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        swap(s + left, s + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="881：救生艇"><a href="#881：救生艇" class="headerlink" title="881：救生艇"></a>881：救生艇</h2><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果最重的人可以与最轻的人共用一艘船，那么就这样安排。否则，最重的人无法与任何人配对，那么他们将自己独自乘一艘船。</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>* people, <span class="type">int</span> peopleSize, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(peopleSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    qsort(people,peopleSize,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = peopleSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; left &lt; right; right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找法-Binary-Search"><a href="#二分查找法-Binary-Search" class="headerlink" title="二分查找法   Binary Search"></a><strong>二分查找法   Binary Search</strong></h1><p>二分査找也称折半査找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p><p>该算法的基本思想是将所要査找的序列的中间位置的数据与所要査找的元素进行比较，如果相等，则表示査找成功，否则将以该位置为基准将所要査找的序列分为<strong>左右两部分</strong>。接下来根据所要査找序列的升降序规律及中间元素与所查找元素的大小关系，对其采用同样的方法进行査找，直至能够确定所要查找的元素是否存在。</p><blockquote><p>使用二分法的条件：有序，无重复元素</p></blockquote><h2 id="二分法的边界条件"><a href="#二分法的边界条件" class="headerlink" title="二分法的边界条件"></a>二分法的边界条件</h2><p>二分法的区间一般分为两种，</p><ul><li>左闭右闭，即 [left, right]<ul><li>定义了target 在 [left, right] 区间，所以有：<ul><li>用 while (left &lt;&#x3D; right) ，因为left &#x3D;&#x3D; right是有意义的</li><li>当 if (nums[middle] &gt; target) ，right &#x3D; middle - 1，因为当前这个nums[middle]一定不是target，所以左区间的结束下标就是middle - 1。</li></ul></li></ul></li><li>左闭右开，即 [left, right) <ul><li>用 while (left &lt; right) ，因为left &#x3D;&#x3D; right是无意义的</li><li>当 if (nums[middle] &gt; target) ，right &#x3D; middle，因为当前这个nums[middle]不是target，去左区间寻找，而区间又是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul></li></ul><h2 id="704：二分查找"><a href="#704：二分查找" class="headerlink" title="704：二分查找"></a>704：二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 1: mid = (left + right) / 2</span></span><br><span class="line"><span class="comment">         * 2: mid = left + (right - left) / 2</span></span><br><span class="line"><span class="comment">         * 第2种可以防止(left + right)直接相加数值过大越界的问题</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35：搜索插入的位置"><a href="#35：搜索插入的位置" class="headerlink" title="35：搜索插入的位置"></a>35：搜索插入的位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="162：寻找峰值"><a href="#162：寻找峰值" class="headerlink" title="162：寻找峰值"></a>162：寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>解：（巧用二分法）</p><p>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 numsnums 中找到中间的元素 midmid。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 midmid 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 midmid 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Left &lt; Right)</span><br><span class="line">    &#123;</span><br><span class="line">        iMid = (Left + Right) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(nums[Mid] &gt; nums[Mid + <span class="number">1</span>])&#123;</span><br><span class="line">            Right = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Left = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="74：搜索二维矩阵"><a href="#74：搜索二维矩阵" class="headerlink" title="74：搜索二维矩阵"></a>74：搜索二维矩阵</h2><p>在m * n矩阵中，搜索是否存在一个目标值。</p><p>该矩阵有如下特点：</p><ul><li><p>每行中的整数从左到右按升序排列；</p></li><li><p>每行的第一个整数大于前一行的最后一个整数；</p><p>示例：</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>两次二分查找：</p><p>我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">-1</span>, high = matrixSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>* row, <span class="type">int</span> rowSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = rowSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rowIndex = binarySearchFirstColumn(matrix, matrixSize, target);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一次二分查找：</p><p>若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。</p><p>代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrixSize, n = matrixColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> a = matrix[mid / n][mid % n];</span><br><span class="line">        <span class="keyword">if</span>(a == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口  Sliding Window"></a><strong>滑动窗口  Sliding Window</strong></h1><h2 id="209：长度最小的子数组"><a href="#209：长度最小的子数组" class="headerlink" title="209：长度最小的子数组"></a>209：长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>,minSize = <span class="number">0</span>, sum = <span class="number">0</span>,ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;right &lt; numsSize; right++)&#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            minSize = right - left + <span class="number">1</span>;</span><br><span class="line">            ans = minSize &lt; ans ? minSize : ans;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1456：定长子串中元音的最大数目"><a href="#1456：定长子串中元音的最大数目" class="headerlink" title="1456：定长子串中元音的最大数目"></a>1456：定长子串中元音的最大数目</h2><p>给你字符串 s 和整数 k 。</p><p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 元音字母 为（a, e, i, o, u）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abciiidef&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[right] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[right] == <span class="string">&#x27;a&#x27;</span> || s[right] == <span class="string">&#x27;e&#x27;</span> || s[right] == <span class="string">&#x27;i&#x27;</span> || s[right] == <span class="string">&#x27;o&#x27;</span> || s[right] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            ans = sum &gt; ans ? sum : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">&#x27;a&#x27;</span> || s[left] == <span class="string">&#x27;e&#x27;</span> || s[left] == <span class="string">&#x27;i&#x27;</span> || s[left] == <span class="string">&#x27;o&#x27;</span> || s[left] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归  Recursion"></a><strong>递归  Recursion</strong></h1><h2 id="344：反转字符串-1"><a href="#344：反转字符串-1" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursion(s,left + <span class="number">1</span>,right - <span class="number">1</span>);</span><br><span class="line">    swap(&amp;s[left],&amp;s[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    recursion(s,<span class="number">0</span>,sSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="206：反转一个单链表。"><a href="#206：反转一个单链表。" class="headerlink" title="206：反转一个单链表。"></a>206：反转一个单链表。</h2><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708769.png" alt="image-20210402193739408"></p><h2 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687:最长同值路径"></a>687:最长同值路径</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p>示例 1:</p><p>输入:</p><pre><code>          5         / \        4   5       / \   \      1   1   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>输入：</p><pre><code>          1         / \        4   5       / \   \      4   4   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrowLeft</span> <span class="operator">=</span> <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowRight += right +  <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *maxDep, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入最底层的节点，从下往上计算 */</span></span><br><span class="line">    <span class="type">int</span> leftDep = Dfs(root-&gt;left, maxDep, root-&gt;val);</span><br><span class="line">    <span class="type">int</span> rightDep = Dfs(root-&gt;right, maxDep, root-&gt;val);</span><br><span class="line"></span><br><span class="line">    *maxDep = MAX(*maxDep, leftDep + rightDep); </span><br><span class="line">    <span class="comment">// 从下往上遍历需要时刻更新最大值</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX(leftDep, rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxDep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Dfs(root, &amp;maxDep, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> maxDep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分治法-Divide-amp-Conquer"><a href="#分治法-Divide-amp-Conquer" class="headerlink" title="分治法   Divide &amp; Conquer"></a><strong>分治法   Divide &amp; Conquer</strong></h1><p>分治法所能解决的问题一般具有以下几个特征：</p><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。(前提)</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；（分治的关键，如果不具备，可以考虑贪心算法和动态规划）</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（关系分治的效率，如果要反复求解公共子问题，用动态规划较好）</p></li></ol><p><strong>分治法在每一层递归上都有三个步骤：</strong></p><p><strong>step1 分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p><strong>step2 解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p><strong>step3 合并</strong>：将各个子问题的解合并为原问题的解。</p><p><strong>分治法的复杂性分析</strong></p><p>一个分治法将<strong>规模为n</strong>的问题分成<strong>k个规模为n／m</strong>的子问题去解。设分解阀值n0&#x3D;1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解**合并为原问题的解需用f(n)**个单位时间。用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p><p><strong>T（n）&#x3D; k T(n&#x2F;m)+f(n)</strong></p><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>思路：</strong></p><p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p><p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p><p><strong>算法：</strong></p><p>我们使用分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countInRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) </span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">majorityElementRec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//大小为1的数组中唯一的元素是多数</span></span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这个切片的左右两半上递归。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> majorityElementRec(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> majorityElementRec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">//如果两半在多数元素上达成一致，则返回它。</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，计算每个元素并返回“赢家”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> countInRange(nums, left, lo, hi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> countInRange(nums, right, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法-Backtracking"><a href="#回溯法-Backtracking" class="headerlink" title="回溯法   Backtracking"></a><strong>回溯法   Backtracking</strong></h1><p>常见问题：</p><ul><li>排列问题，讲究顺序，因此已经选过的元素还有可能再次被选中放置在不同的位置上，构成不同的排列；</li><li>组合问题与子集问题，因为不计算元素顺序，一个元素选还是没有选过很重要，因此需要设置搜索起点，搜索起点之前的元素不再考虑，这样才能做到不重不漏；</li><li>切割问题：如 给一字符串返回符合条件的子串</li><li>棋盘问题：如 N皇后，解数独</li></ul><blockquote><p>编码之前先根据具体的用例画出<code>树形图</code>，图和代码是一 一对应的关系，先画图再编码是不错的方式；</p></blockquote><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            getParenthesis(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParenthesis</span><span class="params">(String str,<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> )&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                <span class="comment">//剩余左右括号数相等，下一个只能用左括号</span></span><br><span class="line">                getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="comment">//剩余左括号小于右括号，下一个可以用左括号也可以用右括号</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">                &#125;</span><br><span class="line">                getParenthesis(str+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k1判断a中添加元素的个数，n1用于表示加入的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span> n, <span class="type">int</span> n1, <span class="type">int</span> k, <span class="type">int</span> k1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n1 &lt;= n; n1++) &#123;</span><br><span class="line">            a.add(n1);</span><br><span class="line">            backtrack(a, n, n1 + <span class="number">1</span>, k, k1 + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//栈方便后进先出</span></span><br><span class="line">        backtrack(stack, n, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n为nums长度，m为指示下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; m &lt;= n; m++) &#123;</span><br><span class="line">            a.add(nums[m]);</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            backtrack(a, nums, n, m + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">        backtrack(a, nums, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a存储每一组答案， ind只放0和1，用来判断nums中的值是否被取过， n为nums长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span>[] ind, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            a.add(nums[i]);</span><br><span class="line">            ind[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(a, nums, ind, n);</span><br><span class="line">            ind[i] = <span class="number">0</span>;</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ind = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        backtrack(a, nums, ind, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a><strong>深度优先搜索</strong>（DFS）</h1><p><strong>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，再返回至最近的分支进行搜索，而且每个节点只能访问一次。</strong></p><p><strong>常用栈 或 递归 实现</strong></p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> width, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; length - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; width - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j, width, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length, width = grid.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j, width, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">searchLand_DFS</span><span class="params">(<span class="type">char</span> **grid, <span class="type">int</span> rowSize, <span class="type">int</span> colSize,<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="comment">//将搜索过的位置变为0</span></span><br><span class="line">    grid[row][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//向右搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col + <span class="number">1</span> &lt; colSize) &amp;&amp; (grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid,rowSize,colSize,row,col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row + <span class="number">1</span> &lt; rowSize) &amp;&amp; (grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row + <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize,colSize, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;gridColSize[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                searchLand_DFS(grid,gridSize, gridColSize[<span class="number">0</span>],i,j);</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.二叉搜索树的范围和</h2><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p>代码：(这里利用了递归实现深度优先搜索，下面两种代码一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; low )&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  root-&gt;val + </span><br><span class="line">       rangeSumBST(root-&gt;left,low,high) +</span><br><span class="line">        rangeSumBST(root-&gt;right,low,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = rangeSumBST(root -&gt;left,L,R) + rangeSumBST (root -&gt; right,L,R);</span><br><span class="line">    <span class="keyword">if</span>(root -&gt;val &lt;= R &amp;&amp; root -&gt;val &gt;= L)</span><br><span class="line">        sum += root -&gt;val;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i] [j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(isConnected, visited, n, i);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] isConnected, <span class="type">boolean</span>[] visited, <span class="type">int</span> n, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(isConnected, visited, n, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方格分割"><a href="#方格分割" class="headerlink" title="方格分割"></a>方格分割</h2><p>有一个6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如：</p><img src="https://img-blog.csdn.net/20180203161615277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTkVVUTUwZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:50%;" /><p>注意：旋转对称的属于同一种分割法。</p><p>题解：<br>如果把样例图案剪开，发现有且只有两个点在边界上，且一定经过 （3,3）点<br>那么以（3,3）为起点进行深搜，深搜到一个点那么他的中心对称点相当于也搜过了，如果发现搜到了边界，那么它的中心对称点也到了边界 ，沿着已经搜过的点剪开，那么，剪开的两个图形为中心对称图形，但要注意最终的结果要除以4<br>例如 我们从（3,3）点出发一直向右到边界 ， 或一直向左，或一直向上，或一直向下，剪出来的图形是同一个。</p><p>我们从中心点开始搜索，每次可以走四个方向。搜索的过程要将中心对称点顺便标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">7</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">6</span> || y == <span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span>- xx][<span class="number">6</span> - yy] = <span class="number">1</span>;</span><br><span class="line">            DFS(xx,yy);</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span> - xx][<span class="number">6</span> - yy] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a><strong>广度优先搜索</strong>（BFS）</h1><h2 id="107-二叉树的层序遍历"><a href="#107-二叉树的层序遍历" class="headerlink" title="107.二叉树的层序遍历"></a>107.二叉树的层序遍历</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line">返回结果：</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tempNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tempNums.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tempNums);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = list.remove();</span><br><span class="line">            i = cur[<span class="number">0</span>]; j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量-1"><a href="#547-省份数量-1" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] visits = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                    visits[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isConnected[j][k] == <span class="number">1</span> &amp;&amp; visits[k] == <span class="number">0</span>)</span><br><span class="line">                            q.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集  Union Find"></a><strong>并查集  Union Find</strong></h1><h2 id="200-岛屿数量-2"><a href="#200-岛屿数量-2" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (cols == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rows * cols;</span><br><span class="line">        <span class="comment">// 多开一个结点，把 &#x27;0&#x27; 都与最后这个结点连在一起</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + direction[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> j + direction[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (inArea(newX, newY, rows, cols) &amp;&amp; grid[newX][newY] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            unionFind.union(getIndex(i, j, cols), getIndex(newX, newY, cols));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unionFind.union(getIndex(i, j, cols), size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.getCount() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="comment">//连通分量个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            count = n;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="comment">// 只实现了路径压缩，并且是隔代压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * cols + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量-2"><a href="#547-省份数量-2" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] == i)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        parent[find(parent, i)] = find(parent, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index] != index)</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721.账户合并"></a>721.账户合并</h2><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：accounts = [</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john00@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john_newyork@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：[</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&#x27;john00@mail.com&#x27;</span>, <span class="string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="string">&#x27;johnsmith@mail.com&#x27;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 <span class="string">&quot;johnsmith@mail.com&quot;</span>。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">（可以以任何顺序返回这些列表）</span><br></pre></td></tr></table></figure><p>根据题意可知：</p><ul><li>存在相同邮箱的账号一定属于同一个人</li><li>名称相同的账户不一定属于同一个人</li></ul><p><strong>思路：</strong><br>由于名称相同无法判断为同1人，所以只能<strong>使用邮箱是否相同来判断是否为同一人。</strong></p><p>这样建立并查集就比较简单了：</p><ul><li>先初始化每个账户为1个连通分量</li><li>遍历每个账户下的邮箱，判断该邮箱是否在其他账户下出现</li><li>如果未出现，继续</li><li>如果账户A、B下出现了相同的邮箱email，那么将账户A和账户B两个连通分量进行合并</li><li>最后遍历并查集中每个连通分量，将所有连通分量内部账户的邮箱全部合并(相同的去重，不同的合并)</li><li>结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">myUnion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的邮箱对应到同一个id【也就是第一次出现的id，比如4、5在同一个连通域，那么这个连通域对应的id就是4】</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法   Greedy"></a><strong>贪心算法</strong>   Greedy</h1><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实时维护 最远可以到达的位置。</span></span><br><span class="line"><span class="comment">// 对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，</span></span><br><span class="line"><span class="comment">// 因此我们可以用 i + nums[i] 更新最远可以到达的位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">far</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//最远可到达距离必须大于当前位置，否则说明无法到达当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= far) &#123;</span><br><span class="line">                far = Math.max(far, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (far &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="记忆化搜索-Menory-Search"><a href="#记忆化搜索-Menory-Search" class="headerlink" title="记忆化搜索   Menory Search"></a><strong>记忆化搜索   Menory Search</strong></h1><h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划   Dynamic Programming"></a><strong>动态规划   Dynamic Programming</strong></h1><p><strong>动态规划</strong>：先将问题分解为子问题，并且对于这些分解的子问题自身是最优的才能在这个基础上得出我们要解决的问题的最优方案.<br><strong>与贪心算法不同之处</strong>在于，贪心算法是从局部最优来解决问题，而动态规划则是从全局最优来解决问题，当对情况及条件加以限制时，贪心算法会因目光短浅而得到错误答案。<br><strong>记忆化搜索</strong>&#x3D;搜索的形式+动态规划的思想<br>搜索过程中会有很多重复计算，通过记录一些状态的答案减少重复搜索量.<br>搜索过程中一个搜索结果必须可以建立在同类型问题的结果上</p><p><strong>联系</strong><br>记忆化搜索与递归一样，都是自顶向下的思路，而动态规划则是自底向上的思路。<br>在平常练习中，我们一般是只考虑一个问题，一般习惯于自顶向下正向思考，这也比较符合人类的逻辑习惯嘛，这便是记忆化搜索（ms）。如果逆向思考，自底向上递推求解，这便是动态规划（dp）了。</p><hr><p>dp和ms 原理都是相同的，只是实现方法不同<br>可以明显的发现有以下几点不同：</p><p>1、DP是从下向上，而记忆化搜索是从上向下的</p><p>2、DP是从下向上，为了求到最终结果需要把过程中所有的值都保存下来，以便下一步可能会使用，而因为记忆化搜索是从上向下的，所以求解过程求的都是需要的；也就是说不需要的值并没有求</p><p>3、记忆化搜索使用递归实现的；</p><p>如果一个dp[i] [j]的值已经求过，使用DP直接调用即可；而使用记忆化搜索则要进入递归</p><p>如果一个dp[i] [j]的值还未求过，使用DP直接求得，而使用记忆化搜索则要进入递归中去求，而这个递归很有可能是多重的</p><p>这样一来DP在时间上几乎总是优于记忆化搜索的</p><hr><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>解答：</p><p>我们采用自下而上的方式进行思考。定义 F(i) 为组成金额 i 所需最少的硬币数量，假设在计算 F(i)之前，我们已经计算出 F(0) - F(i-1) 的答案。 则 F(i) 对应的转移方程应为</p><p>F(i) &#x3D; min [  F( i - cj )  ]  +  1</p><p>{cj 表示第 j 枚硬币的面值，即我们枚举最后一枚硬币时，需要从  i - cj  这个金额状态 F( i - cj ) 转移过来，也就是求出 F( i - cj )  所需的硬币数量，再加1}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span> *coins, <span class="type">int</span> coinsSize, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、确定base case */</span></span><br><span class="line">    <span class="type">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 2、从面值为1开始，计算其dp值 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 2.1、确定状态：当前面值的 dp 值为 amount + 1 */</span></span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 2.2、确定选择：即为硬币的面值</span></span><br><span class="line"><span class="comment">         * 依次计算当前dp值是否可以再分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++) &#123;</span><br><span class="line">            <span class="comment">/* 判断条件是 i &gt; coins[j](1、2、5) */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                <span class="comment">/* dp(amount) = min(dp(amount - coins[1、2、5])) + 1 */</span></span><br><span class="line">                dp[i] = (dp[i - coins[j]] + <span class="number">1</span>) &lt; dp[i] ? (dp[i - coins[j]] + <span class="number">1</span>) : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3、若当前硬币不能被再分，则返回-1 */</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount] &lt; amount + <span class="number">1</span> ? dp[amount] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>假如计划在第 i 天卖出股票，那么最大利润的差值一定是在[0, i-1] 之间选最低点买入；所以遍历数组，依次求每个卖出时机的的最大差值，再从中取最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice=<span class="number">0xFFFFFF</span>;</span><br><span class="line">    <span class="type">int</span> maxret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxret = (prices[i]-minprice)&gt;maxret ? prices[i]-minprice:maxret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>解题思路与斐波那契一致；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最少爬一阶</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>,c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>动态规划转移方程：</p><p><strong>f(i, j) &#x3D; f(i-1, j) + f(i, j-1)</strong></p><p>注：网格的边界，它们的值均为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> nums[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h2><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>用<em>dp</em>( i , j ) 表示以 ( i, j ) 为右下角，且只包含 1 的正方形的边长最大值。</p><ul><li><p>如果该位置的值是 0，则dp( i , j )&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p></li><li><p>如果该位置的值是 1，则 dp( i , j ) 的值由其上方、左方和左上方的三个相邻位置的dp( i , j ) 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p><strong>dp(i, j)&#x3D;min( dp(i−1, j), dp(i−1, j−1), dp(i, j−1) )+1</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b,c) ((a)&lt;(b)?( (a)&lt;(c)?(a):(c) ):( (b)&lt;(c)?(b):(c) ))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrixSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j,k,ms = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;matrixSize;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;matrixColSize[j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; j&gt;<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>) matrix[j][k] = MIN(matrix[j<span class="number">-1</span>][k],matrix[j][k<span class="number">-1</span>],matrix[j<span class="number">-1</span>][k<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k] &gt; ms) ms = matrix[j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ms-<span class="string">&#x27;0&#x27;</span>)*(ms-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p>（完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p>这是完全背包问题的简单变形：</p><ul><li>背包大小即传入的参数<code>n</code></li><li>物品的重量是平方数的值<code>sqr</code></li><li>物品的价值是<code>1</code>，因为我们要求的是数字个数</li></ul><p>题目转换为，能用 [1,n]  里的共<code>m</code>个平方数（物品）刚好装满空间为<code>n</code>的背包的所有方法中，产生价值最少的装法。<br>完全背包问题模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记 dp[<span class="number">0.</span>.capa + <span class="number">1</span>] 是备忘录数组</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j = weight[i] to capa</span><br><span class="line">        dp[j] = max( dp[j] , dp[j - weight[i]] + val[i] )</span><br><span class="line">输出 dp[capa]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        dp[i] = INT_MAX - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">            dp[i] = min(dp[i],dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>（十一届蓝桥C++-B组）</p><p>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。</p><p>要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？</p><p>答案很大，你只需要给出方案数除以 2020 的余数即可。</p><p>题解：（动态规划）</p><p>用DP[i] [j]表示第一层有i个数，第二层有j个数有多少种方案</p><p>题目要求同一行中右边比左边大， 同一列中下边比上边的大，所以 j &lt;&#x3D; i</p><p>1.当j &lt; i 时， DP[i] [j]可以用此时少一个数的方案来表示，少一个数可以是DP[i - 1] [j]，也可以是DP[i] [j - 1]，所以：</p><p>DP[i] [j] &#x3D; DP[i - 1] [j] + DP[i] [j - 1]</p><p>2.当j &#x3D; i时， 因为要求，所以</p><p>DP[i] [j] &#x3D; DP[i] [j - 1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1011</span>][<span class="number">1011</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">DP[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) DP[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> DP[i][j] = (DP[i - <span class="number">1</span>][j] + DP[i][j - <span class="number">1</span>]) % <span class="number">2020</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, DP[<span class="number">1010</span>][<span class="number">1010</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)    <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h2><p>背包问题可以描述为：给定一组物品，每种物品都有自己的<strong>重量</strong>和<strong>价值</strong>，在<strong>限定的总重量</strong>内，如何选择才能使得物品的<strong>总价值</strong>最高。<br>背包问题是典型的动态规划问题。</p><p>而背包问题还存在需要<strong>恰好装满</strong>背包和<strong>不需要恰好装满</strong>两种情况</p><ol><li>01背包问题（每种物品只有一件，放或者不放）</li><li>完全背包问题（每件物品有无限件可用）</li><li>多重背包问题（每件物品有n[i]件可用）</li></ol><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。求将哪些物品装入背包可使价值总和最大。</p><p>”01”的意思是：每种物品仅有一件，放为“1”，不放为“0”。<br>我们假定 f [i] [v] 为将前 i 件物品恰好放入一个容量为V的背包中可获得的最大价值。<br>则其状态转移方程是：</p><p><strong>f [i] [V]&#x3D;max{ f [i-1] [V] ,f [i-1] [V-weight[i] ]+value[i] }</strong></p><ul><li>公式中，即将前 i 件物品放入容量为V 的背包中：<ul><li>不放第 i 件：前 i - 1 件物品放入容量为V的背包中，价值为f [i - 1] [V] ;</li><li>放第 i 件：前 i - 1 件物品放入剩余容量为 V - weight[i] 的背包中，价值为f [i-1] [V-weight[i] ]+value[i]</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &lt;= j) &#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>还可以将二维数组转化为一维数组，减少空间复杂度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= weight[i]; --j)</span><br><span class="line">            f[j] = max(f[j], f[j - weight[i]] + value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><p>（在输出的时候，只能输出最后的价值，不能知道选择的物品是哪个。为此，在这里我们定义一个数组x[i]，对于每一个物品，如果被选择置为“1”，否则为“0”。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V  100  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> N,M; </span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//动态规划分析</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=M; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (weight[i]&lt;=j)  </span><br><span class="line">            &#123;  </span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-weight[i]]+value[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//输出选择的物品</span></span><br><span class="line">    <span class="type">int</span> j = M;</span><br><span class="line">    <span class="type">int</span> x[V];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=N; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] &gt; f[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            x[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            j = j - weight[i<span class="number">-1</span>];<span class="comment">//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; ++i)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[i]);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。每件物品可以无限选用，求将哪些物品装入背包可使价值总和最大。</p><p>完全背包问题不设定物品取用上限</p><p>对于算法的优化我们可以这样想：<br>在01背包问题中，我们要保证第i次循环中的f [i] [v]是由f [i-1] [ V-weight[i] ] 递推而来，每一次都是“加选出<strong>一个（即一种）</strong>物品”而这种方式同时也保证了每件物品只选一次。<br>而完全背包问题的特点刚好是每种物品可选无限件，所以在考虑“加选出<strong>一个（即一种）</strong>物品”时就是单纯的考虑“加选出<strong>一个（可能为同一种）</strong>物品”，这样我们就需要考虑选入的物品是已经选入的情况。相比来说，反而简化了代码。</p><p>同样，我们假定f [i] [v]为将前i件物品前恰好放入一个容量为V的背包中可获得的<strong>最大价值</strong><br>则其状态转移方程是：</p><p>*<em>f [i] [V]&#x3D;max{ f [i-1] [V]  ,  f [i-1] [ V-k</em>weight[i] ] + k <em>value[i] }</em>*</p><p>( 0&lt;&#x3D;k*weight[i]&lt;&#x3D;v，其中0&lt;&#x3D;k&lt;&#x3D;V&#x2F;weight[i+1]  )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">           f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] = max(f[j], f[j - weight[i]] + value[i]); </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[N][M]);<span class="comment">//输出最优解  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品最多有n[i]个，每个的费用是weight[i]，价值是value[i]。每件物品最多可以选用相应的最大个数，求将哪些物品装入背包可使价值总和最大。<br>多重背包问题设定物品选择上限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">               f[j] = max(f[j], f[j - k * weight[i]] + k * value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];   </span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M,cur;  </span><br><span class="line">    freopen(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;weight[i],&amp;value[i],&amp;num[i]); </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>LCS ：longest common sequence</p><p>子序列与子串不同，子序列：将给定序列中零个或多个元素去掉之后得到的结果；子串：给定串中任意个连续的字符组成的子序列称为该串的子串</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708770.png"></p><p>此问题有最优子结构性质：</p><p>设序列S<del>1</del>&#x3D;{x<del>1</del>,x<del>2</del>,……x<del>n</del>}和S<del>2</del>&#x3D; {y<del>1</del>,y<del>2</del>,……y<del>m</del>}的最长公共子序列为S&#x3D;{z<del>1</del>,z<del>2</del>,……z<del>k</del>}，则：</p><p>1）若x<del>n</del>&#x3D;y<del>m</del>，那么zk&#x3D;xn&#x3D;ym 且S[k-1]是S1[n-1]和S2[m-1]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del> !&#x3D; x<del>n</del>，则S[k]是S1[n-1]和S2[m]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del>!&#x3D;y<del>m</del>，则S[k]是S1[n]和S2[m-1]的最长公共子序列</p><p>可见：两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列具有最优子结构性质，可以用动态规划求解。 </p><p><strong>递推公式：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708771.png" alt="image-20210409174359997"></p><p>为了求出LCS中具体的字符，再用一个表格b[i] [j] 表示dp[i] [j]与周边表格的关系（也可以使用dp[i] [j]来推，不必再建一个表格）。</p><p>即 S1[i] 和 S2[j] 值相等时dp[i] [j] 的值与右上的dp[i-1] [j-1]有关 ，用1表示 ，以此类推；</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232206589.png" alt="202203191708772"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232206196.png" alt="202203191708773"></p><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。</p><p>一维数组的前缀和 : sum[i] &#x3D; sum[i-1] + a[i] </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) y[i]=x[i];</span><br><span class="line">    <span class="keyword">else</span> y[i]=y[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组前缀和：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/webp" alt="img"></p><p>二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：</p><p><img src="https://www.zhihu.com/equation?tex=b_%7Bx,y%7D=b_%7Bx-1,y%7D+b_%7Bx,y-1%7D-b_%7Bx-1,y-1%7D+a_%7Bx,y%7D" alt="[公式]"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++)<span class="comment">//n行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)<span class="comment">//m列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) b[y][x]=a[y][x];<span class="comment">//左上角的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) b[y][x]=b[y<span class="number">-1</span>][x]+a[y][x];<span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>) b[y][x]=b[y][x<span class="number">-1</span>]+a[y][x];<span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">else</span> b[y][x]=b[y<span class="number">-1</span>][x]+b[y][x<span class="number">-1</span>]-b[y<span class="number">-1</span>][x<span class="number">-1</span>]+a[y][x];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树   Trie"></a><strong>前缀树   Trie</strong></h1><p>Trie 是一颗非典型的多叉树模型，</p><p>多叉：即每个结点的分支数量可能为多个。</p><p>非典型：因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，</p><p>比如一般的多叉树的结点是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    VALUETYPE value;    <span class="comment">//结点值</span></span><br><span class="line">    TreeNode* children[NUM];    <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TrieNode结点中并没有直接保存字符值的数据成员，而是用 字母映射表 next ，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">if</span> (parentNode-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        说明父结点的后一个字母不可为 ch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        说明父结点的后一个字母可以是 ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720.词典中最长的单词"></a>720.词典中最长的单词</h2><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p><p>若无答案，则返回空字符串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： </span><br><span class="line">单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：</span><br><span class="line">&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>将所有单词插入 <code>trie</code>，然后从 <code>trie</code> 进行深度优先搜索，每找到一个单词表示该单词的全部前缀均存在，我们选取长度最长的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    String word; <span class="comment">// 用来保存当前遍历的 word</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        getMaxLengthWord(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 insert()insert() 方法时：</span></span><br><span class="line"><span class="comment">若遍历的当前字符串 word 中的某个字符所在字母表中的位置上在对应 children[26] 数组中没有节点，即 **node.children[c - &#x27;a&#x27;] == null**，则在该位置上定义一个新的 Trie 节点并且 node 指向新定义的节点，即 **node = node.children[c - &#x27;a&#x27;]**。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当 word 全部遍历完成时，此时 node 为 word 中的最后一个位置上的节点，此时将 isEnd 设置为 true 表示该 word 已经遍历完并全部插入到 Trie 树中并将该 word 保存到最后一个节点上，即 **node.word = word**。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">        node.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 当调用 **getMaxLengthWord()** 方法时：</span></span><br><span class="line"><span class="comment">若当前传入的节点不是最后一个位置上节点而是中间某位置的节点，此时直接结束。</span></span><br><span class="line"><span class="comment">若当前传入的节点的深度 deep &gt; maxLength，此时应该更新 maxLength的值并且将该节点对应的 word保存下来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 通过递归遍历 node 的 children 数组并且每遍历一次深度 deep 增加 1：DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMaxLengthWord</span><span class="params">(Trie node, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">0</span> &amp;&amp; !node.isEnd) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxLength) &#123;</span><br><span class="line">            res = node.word;</span><br><span class="line">            maxLength = deep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前传入节点的 children[26]children[26] 对每一个不为空的节点都进行深度搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                getMaxLengthWord(node.children[i], deep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目顺序"><a href="#题目顺序" class="headerlink" title="题目顺序"></a>题目顺序</h1><p><strong>leetcode</strong></p><ul><li>数组Arrary：485，283，27</li><li>链表Linked List: 203,206</li><li>队列Queue：933，225（用队列实现<strong>栈</strong>），622，64</li><li>栈Atack：20，496，232（用栈实现队列）</li><li>哈希表Hash Table：217，389，496</li><li>集合Set：217，705（设计哈希集合）</li><li>堆Heap：215，692</li><li>树&#x2F;图：各种算法</li><li>双指针算法Two Pointers：141，344，881</li><li>二分查找法Binary Search(模板）：704，35，162，74</li><li>滑动窗口Sliding Window：209，1456</li><li>递归算法Recursion（开始练习时用笔画）：509，206，344，687</li><li>分治算法Divide &amp; Conquer：169，53</li><li>回溯算法Backtracking：22，78，77，46（全部非常经典）</li><li>深度优先搜索DFS：200，547，721</li><li>宽度优先搜索BFS：102，107，200</li><li>并查集Union Find（模板）：200，547，<strong>721</strong></li><li>贪心算法Greedy：<strong>322</strong>，1217，55</li><li>记忆化搜索Memoization：509，322</li><li><strong>动态规划</strong>Bynamic Bogramming：509，62，121，70，279，221</li><li>拓扑排序Topologic Sort：207，210</li><li>前缀Trie：208（模板），<strong>720</strong>，692</li></ul><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>判断闰年：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//是闰年，m[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转数组：</p><p>Collections.reverse(ret);</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h2><p>数组：广义表</p><p>树：<del>层次遍历算法</del>，线索二叉树，<del>二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋）</del>，<del>B树（多路平衡查找树）</del>，<del>B+树</del>，——红黑树</p><p>并查集：</p><p>图：</p><h2 id="数组-Arrarry"><a href="#数组-Arrarry" class="headerlink" title="数组  Arrarry"></a><strong>数组  Arrarry</strong></h2><p><a href="#java%E6%95%B0%E7%BB%84">java</a></p><p>C</p><ul><li>使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）</li></ul><p>C 语言不允许返回一个完整的数组作为函数的参数。</p><p>想要从函数返回一个数组，需先声明一个返回指针的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">myFunction</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p><p>示例（生成随机数，并用数组返回）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java数组"><p> <strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数组创建</span></span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;b: &quot;</span> + Arrays.toString(b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 3</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;c: &quot;</span> + Arrays.toString(c));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 4</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr.add(i + <span class="number">1</span>);<span class="comment">//add方法：括号内为(数组索引值,元素），索引值可以不加，则将元素插入到末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr: &quot;</span> + arr.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        arr.add(<span class="number">99</span>);        <span class="comment">//O(1)</span></span><br><span class="line">        arr.add(<span class="number">3</span>, <span class="number">88</span>);     <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> arr.get(<span class="number">1</span>);      <span class="comment">//()里为索引值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新元素 ：O(1)</span></span><br><span class="line">        c[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        arr.set(<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.删除元素 ： O(N)</span></span><br><span class="line">        arr.remove(<span class="number">1</span>);      <span class="comment">//删除下标为1处的元素</span></span><br><span class="line">        arr.remove(Integer.valueOf(<span class="number">4</span>));     <span class="comment">//删除第一个值为4的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;      <span class="comment">//删除所有值为3的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">                arr.remove(i--);        <span class="comment">//每删除一个元素后当前下标应-1，否则会漏掉下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.数组长度 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSize</span> <span class="operator">=</span> arr.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历数组 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> c[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.查找元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">99</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;we found 99 at int c!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is99</span> <span class="operator">=</span> arr.contains(<span class="number">99</span>);    <span class="comment">//找到目标值则返回True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9. 数组排序 : O(N logN)</span></span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        Collections.sort(arr);  <span class="comment">//升序排列</span></span><br><span class="line">        Collections.sort(arr, Collections.reverseOrder());  <span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（N）</p><p>删除（Delete）：O（N）</p><h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表  Linked List"></a><strong>链表  Linked List</strong></h2><p><a href="#java%E9%93%BE%E8%A1%A8">java</a></p><p> <strong>C</strong></p><p>创建链表：</p><p>创建结构变量指针，使用前要先分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">LinkList *<span class="title function_">CreatList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList *temp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LinkList *a = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a-&gt;data);</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改链表结点的值</span></span><br><span class="line">LinkList  <span class="title function_">changeList</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;结点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表的第n个位置插入数据</span></span><br><span class="line">LinkList *<span class="title function_">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;   <span class="comment">//temp用于表示插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =  temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList  *in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;in-&gt;data);</span><br><span class="line">    in-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表中第n个节点</span></span><br><span class="line">LinkList *<span class="title function_">delete</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;    <span class="comment">//temp用于表示删除位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList *del = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkList *<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头插法和尾插法："><a href="#头插法和尾插法：" class="headerlink" title="头插法和尾插法："></a>头插法和尾插法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">p=head;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">q=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_1</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">p=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">p-&gt;next=head-&gt;next;</span><br><span class="line">head-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>=</span>head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">head</span>;</span></span><br><span class="line">head=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">creat(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line"></span><br><span class="line">creat_1(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java链表"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        list.add(<span class="number">1</span>);    <span class="comment">//O(1)</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">99</span>); <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.搜索元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">99</span>);   <span class="comment">//搜索元素值，然后返回索引值(下标)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.更新元素 : O(N)</span></span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">88</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.删除元素 : O(N)</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除头节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除链表头部节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//sentinel：哨兵</span></span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> ans, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的时间复杂度"><a href="#链表的时间复杂度" class="headerlink" title="链表的时间复杂度"></a>链表的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列  Queue"></a><strong>队列  Queue</strong></h2><p><a href="#java%E9%98%9F%E5%88%97">java</a></p><p><strong>C</strong></p><p>判断队列是否为空：</p><ol><li>设置一个标志变量；</li><li>当队列满时，保留一个元素空间；设队列最大尺寸为QueueSize，则<strong>队列满的条件是：（rear+1）%QueueSize &#x3D;&#x3D; front</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QuDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span> *_<span class="title">next</span>;</span></span><br><span class="line">    QuDataType _data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QueueNode *_front;</span><br><span class="line">    QueueNode *_rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue *q)</span>;<span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue *q,QuDataType data)</span>;<span class="comment">//队尾入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue *q)</span>;<span class="comment">//队头出队列</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列头部元素</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列中有效元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;<span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;<span class="comment">// 销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数据入队列必须要先创建节点</span></span><br><span class="line">QueueNode * <span class="title function_">BuyQueueNode</span><span class="params">(QuDataType x)</span>&#123;    <span class="comment">//创建节点并初始化此节点</span></span><br><span class="line">    QueueNode * cur = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    cur-&gt;_data = x;</span><br><span class="line">    cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>&#123; <span class="comment">//初始化队列结构</span></span><br><span class="line">    q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QuDataType x)</span> &#123; <span class="comment">//队列尾部入数据</span></span><br><span class="line">    QueueNode * cur = BuyQueueNode(x);  <span class="comment">//先把创建好的节点传过来</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;             <span class="comment">//若是队列本身为空，队列里就只有这一个节点，又为队列头又为队列尾</span></span><br><span class="line">        q-&gt;_front = q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;_rear-&gt;_next = cur; <span class="comment">//否则，链表尾插操作</span></span><br><span class="line">        q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span> &#123;    <span class="comment">//队列头部出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;    <span class="comment">//本身队列为空，不做操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* tmp = q-&gt;_front-&gt;_next;   <span class="comment">//先保留下一个节点，防止断链</span></span><br><span class="line">    <span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">    q-&gt;_front = tmp;   <span class="comment">//更新对列头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//获取队列首部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>&#123;<span class="comment">//获取队列尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front == <span class="literal">NULL</span>;   <span class="comment">//为空，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>&#123;  <span class="comment">//获取队列中的元素个数</span></span><br><span class="line">    QueueNode * cur;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur = q-&gt;_front; cur; cur = cur-&gt;_next)<span class="comment">//循环遍历，计数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* q)</span>  <span class="comment">//销毁队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;_front)&#123;</span><br><span class="line">        QueuePop(q);<span class="comment">//对每一个元素迭代出队即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q)); <span class="comment">//1</span></span><br><span class="line">    QueuePop(&amp;q);<span class="comment">//出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q));<span class="comment">//2   此时队首为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueBack(&amp;q));<span class="comment">//4  队尾为4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java队列"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建队列</span></span><br><span class="line">        <span class="comment">//用LinkedList(链表)作为对象,插入和删除操作时间复杂度只有O(1)</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素 :O(1)</span></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(temp1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.删除即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();   <span class="comment">//返回值，并将其删除 </span></span><br><span class="line">        System.out.println(temp2);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断队列是否为空 ：O(1)</span></span><br><span class="line">        System.out.println(queue.isEmpty());    <span class="comment">//队列空则返回True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.队列长度 ：O(1)</span></span><br><span class="line">        <span class="comment">//创建链表时会有一个变量，当加入一个元素时变量加1，获取长度时会直接返回这个变量值</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历队列 :O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933.最近的请求次数"></a>933.最近的请求次数</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h4><p>利用两个队列 来实现栈的基本操作：进栈，显示栈顶元素，删除栈顶元素，判空f</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a>622.设计循环队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[(rear + capacity - <span class="number">1</span>) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a>Deque（双端队列）</h4><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p><ul><li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li></ul><p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure><p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p><p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p><p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure><p>创建 ArrayDeque实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure><p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure><p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p><p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()</p><p>方法具体说明：</p><p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p><p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure><p><strong>获取元素：</strong></p><p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p><p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement的值是: “first element”。</p><p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p><p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure><p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p><p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure><p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure><p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure><p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p><p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure><p>执行完代码后size大小是2，因为Deque中包含两个元素。</p><p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p><p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p><p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的时间复杂度"><a href="#队列的时间复杂度" class="headerlink" title="队列的时间复杂度"></a>队列的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈   Stack"></a><strong>栈   Stack</strong></h2><p><strong>java：</strong></p><p>（Java堆栈Stack已经过时，推荐使用Deque替代Stack。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取栈顶元素 : O(1)</span></span><br><span class="line">        stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//pop方法会删除元素并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的大小 : O(1)</span></span><br><span class="line">        stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈是否为空 : O(1)</span></span><br><span class="line">        stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的遍历 : O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p><ul><li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li><li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li></ul><p>假设：</p><p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 </p><p>10入栈时，栈为空，直接入栈，栈内元素为10。</p><p>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</p><p>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</p><p>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</p><p>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</p><p><strong>伪代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(遍历这个数组)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        hash.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != hash.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素1"><a href="#496-下一个更大元素1" class="headerlink" title="496.下一个更大元素1"></a>496.下一个更大元素1</h3><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>只使用两个栈，实现一个先入先出的队列（push,pop,peek,empty)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack1中的数据依次出栈并入栈stack2</span></span><br><span class="line">    <span class="comment">//数据进栈stack2</span></span><br><span class="line">    <span class="comment">//stack2中数据依次出栈并入栈stack1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的时间复杂度"><a href="#栈的时间复杂度" class="headerlink" title="栈的时间复杂度"></a>栈的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串   String"></a><strong>字符串   String</strong></h2><p>字符串输入：</p><ol><li><p>数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">6</span>] = <span class="string">&quot;array&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;array&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %c %c&quot;</span>,p,*p,*(p + <span class="number">2</span>));   <span class="comment">//第一个输出字符串；第二个输出指针指向，即字符串的第一个字符；第三个输出字符串中 第三个字符</span></span><br></pre></td></tr></table></figure></li><li><p>数组&#x2F;指针 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">6</span>];</span><br><span class="line">scang(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line">gets(arr1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>( <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>) );  <span class="comment">//记得为指针数组分配内存，否则会报错之类的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>,arr2);</span><br><span class="line">gets(arr2);</span><br></pre></td></tr></table></figure><p>（scanf只能输入一个单词，当遇到空格时会认为字符串结束；gets函数只知道数组的开始，并不知道数组的大小，如果输入过长容易溢出，并可能擦掉程序中的其他数据）</p></li><li><p>使用while完成多组测试，而不是在输入完一组数据后退出控制台</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">100</span>],arr2[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a;   </span><br><span class="line"><span class="keyword">while</span>((a = <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,arr1,arr2)) != EOF)&#123;     <span class="comment">//也可用while((a = getchar(arr1)) != &#x27;\n&#x27;)</span></span><br><span class="line">    pritnf(<span class="string">&quot;scanf返回l %d,s1是%s，s2是%s&quot;</span>，a,arr1,arr2);   <span class="comment">//这行输出后可以继续进行输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>KMP算法实现过程接近人为模式匹配</p><ul><li>匹配失败后，模式串移动的距离和主串无关，只与模式串本身有关，模式串后移等价于指针j前移。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2-1Q212223I41Z.gif" alt="模式串后移等价于 j 前移"></p><p>因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j&#x3D;3，则该字符匹配失败后指针 j 指向模式串中第 3 个字符。</p><p>模式串中各字符对应 <strong>next 值</strong>的计算方式是，取该字符前面的字符串（不包含自己），其<strong>前缀字符串和后缀字符串相同字符的最大个数再 +1</strong> 就是该字符对应的 next 值。</p><p>（模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。）</p><h4 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h4><p>一般的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样可能会有多余的操作，如：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2-1Q212224002945.gif" alt="Next函数的缺陷"></p><p>当匹配失败时，Next 函数会由图 10b) 开始继续进行模式匹配，但是从图中可以看到，这样做是没有必要的。</p><p>如此，问题在当 T[i-1]&#x3D;&#x3D;T[j-1] 成立时，没有继续对 i++ 和 j++ 后的 T[i-1] 和 T[j-1] 的值做判断。</p><p>因此改进后的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123; </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i<span class="number">-1</span>]!=T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               next[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i]=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a><strong>散列表（Hash）</strong></h2><ul><li><p><strong>哈希表</strong>（hashtable），又叫散列表，是根据关键码（key）来进行访问的数据结构，通过哈希函数把key转成哈希值来定位数据存储的位置。通常是键-值对（即key-value）的结构，即用key算出的哈希值来定位存储位置，在该位置上存储内容为value。</p></li><li><p><strong>哈希集合</strong>（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。<br>简单来说就是，哈希集合是不能存储重复元素的数据结构（集合），而哈希表是存储键-值对（key-value），其中键key不能重复。</p></li><li><p><strong>哈希映射</strong>（hashmap）是和哈希表（hashtable）相似的数据结构，也是键-值对存储，只是哈希映射是线程安全的，而哈希表是非线程安全的。所谓线程安全，就是多线程同时操作数据的时候，能确保在同一时刻只能有一个线程能访问同一个数据（也就是会给数据操作加锁）；如果不能确保这个，就是非线程安全。</p></li></ul><p>哈希表 可能存在特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。</p><p>目前，这个哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p><p>下面简单<strong>介绍几种哈希函数</strong>。</p><ul><li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li><li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li><li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取<strong>素数</strong>或者直接用 n。</li></ul><p><strong>对散列表函数产生冲突的解决办法</strong>：</p><p>​有时不同的 Key 通过哈希函数可能会得到相同的地址，这在我们操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 Key 计算之后获得了相同的地址。</p><p>冲突的处理方式也有很多，下面介绍几种。</p><ul><li><strong>开放地址法</strong>（也叫<strong>线性探测</strong>）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。(如  f（key) &#x3D; {  f(key + d)  } % m）</li><li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li><li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</li><li><strong>建立一个公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li></ul><h3 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h3><p><a href="java%E6%95%A3%E5%88%97%E8%A1%A8">java</a></p><p><strong>C：</strong></p><h5 id="实现简单的哈希表"><a href="#实现简单的哈希表" class="headerlink" title="实现简单的哈希表"></a>实现简单的哈希表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12   <span class="comment">//定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;    <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;    <span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;   <span class="comment">//散列表表长，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line">Status <span class="title function_">InterHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;     <span class="comment">//除留余数法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入关键字进散列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);   <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;      <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">    H-&gt;elem[addr] = key;        <span class="comment">//直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表查找关键字</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">    *addr = Hash(key);                 <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key) &#123;        <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;            <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;     <span class="comment">//如果循环回到原点</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       <span class="comment">//则说明关键字不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>] = &#123;<span class="number">12</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    InterHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        IntertHash(&amp;H, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入之后的哈希表为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, H.elem[i]);</span><br><span class="line">    <span class="type">int</span> addr, j;</span><br><span class="line">    j = SearchHash(H, a[<span class="number">5</span>], &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;搜索到a[5]的地址是：%d&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希集合"><a href="#实现哈希集合" class="headerlink" title="实现哈希集合"></a>实现哈希集合</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">listContains</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List *head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line">MyHashSet *<span class="title function_">myHashSetCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashSet *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetAdd</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetRemove</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">myHashSetContains</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetFree</span><span class="params">(MyHashSet *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希映射"><a href="#实现哈希映射" class="headerlink" title="实现哈希映射"></a>实现哈希映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">listFind</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line">MyHashMap* <span class="title function_">myHashMapCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a neme = "java散列表"><p><strong>java：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        String[] hashTable = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>]; <span class="comment">//用数组创建</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//用HashMap方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//将其改为不会用到的值</span></span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取元素 : O(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> hashTable[<span class="number">1</span>];</span><br><span class="line">        map.get(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查key是否存在 : O(1)</span></span><br><span class="line">        map.containsKey(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长度，是否为空 : O(1)</span></span><br><span class="line">        map.size();</span><br><span class="line">        </span><br><span class="line">        map.isEmpty();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key对应的value，如果找不到key，则返回设置的默认值。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p><p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p><ol><li><strong>访问速度很快</strong></li></ol><p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p><ol start="2"><li><strong>需要额外的空间</strong></li></ol><p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p><p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p><p><strong>3) 无序</strong></p><p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p><p><strong>4) 可能会产生碰撞</strong></p><p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p><h3 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h3><p>根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p><p><strong>缓存</strong></p><p>通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p><p>在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p><p>有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p><p><strong>快速查找</strong></p><p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p><p>这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p><p>还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p><p>当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢，而散列表则不会。</p><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (hash.containsKey(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">hash.put(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h3><p>给定两个字符串 <strong>s</strong> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p><p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表的时间复杂度"><a href="#哈希表的时间复杂度" class="headerlink" title="哈希表的时间复杂度"></a>哈希表的时间复杂度</h3><p>访问（Access）：</p><p>搜索（Search）：O（1)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合   Set"></a><strong>集合   Set</strong></h2><ul><li><strong>无序，不重复</strong></li></ul><ol><li>检查元素是否存在</li><li>检查元素是否重复（原数据长度与集合长度是否相同）</li></ol><h3 id="java（哈希集合HashSet）"><a href="#java（哈希集合HashSet）" class="headerlink" title="java（哈希集合HashSet）"></a>java（哈希集合HashSet）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//[10,2]</span></span><br><span class="line">        System.out.println(set.add(<span class="number">2</span>));<span class="comment">//添加的元素已存在，会返回false，不存在则返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索元素 : O(1)0</span></span><br><span class="line">        set.contains(<span class="number">2</span>);<span class="comment">//存在则返回true</span></span><br><span class="line">        System.out.println(set.contains(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素-1"><a href="#217-存在重复元素-1" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树   Tree"></a><strong>树   Tree</strong></h2><ul><li><p>树中有一个根结点，其余节点可以分成若干个互不相交的“子树”。</p></li><li><p>除了根节点，每个结点有且只有一个父节点；</p></li><li><p>一棵N个结点的树有N - 1条边；</p></li></ul><p>结点的度：结点的子树个数；</p><p>树的度：树中所有结点中最大的度；</p><p>叶结点：度为0的结点；</p><p>兄弟结点：具有同一父结点的各个结点；</p><p>路径和路径结点：从结点N到结点Nk的路径，其路径结点为路径中结点个数 - 1，即路径中所包含的边的个数；</p><p>祖先结点：从某一结点，到根结点的所有节点，都是这个结点的祖先节点；</p><p>子孙结点：某一结点的子树中的所有节点，都是这个结点的子孙；</p><p>层次：规定根结点  在0&#x2F;1层，其他结点的层数是其父结点的层数+1；</p><p>深度：从上往下数，等于层；高度：从下往上数</p><h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p><strong>普通二叉树</strong>：每个结点最多两个子结点</p><p><strong>满二叉树</strong>：除了叶结点，每个结点都有两个子结点，并且所有叶结点都在同一层上；</p><blockquote><p>满二叉树的深度为k，则该树一共有 2^k^ - 1 个节点。</p></blockquote><p><strong>完全二叉树</strong>：从树的根结点出发，从上到下，从左到右，依次填满结点形成的二叉树</p><p>（满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）</p><p><strong>二叉树的遍历：</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>前</strong>序遍历</td><td><strong>根节点</strong>-&gt;左子树-&gt;右子树</td></tr><tr><td><strong>中</strong>序遍历</td><td>左子树-&gt;<strong>根节点</strong>-&gt;右子树</td></tr><tr><td><strong>后</strong>序遍历</td><td>左子树-&gt;右子树-&gt;<strong>根子树</strong></td></tr><tr><td>层次遍历</td><td>从上到下，从左到右</td></tr></tbody></table><p>（层次遍历需要用到 队列 ）</p><h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">//创建树的结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//创建树根</span></span><br><span class="line">    Node *root;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Tree *tree, <span class="type">int</span> value)</span> &#123;     <span class="comment">//创建树</span></span><br><span class="line">    Node *node = (Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个结点</span></span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) tree-&gt;root = node;  <span class="comment">//判断树是不是空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">//不是空树</span></span><br><span class="line">        Node *temp = tree-&gt;root;    <span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123;    <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Deleteer</span><span class="params">(Node *node, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L,*LL;    <span class="comment">//在删除左右子树都有的结点时使用；</span></span><br><span class="line">    Node *p=node;</span><br><span class="line">    Node *parent=node;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;  <span class="comment">//0表示左子树，1表示右子树；</span></span><br><span class="line">    <span class="keyword">if</span>(!node)    <span class="comment">//如果排序树为空，则退出；</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p)  <span class="comment">//二叉排序树有效；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)  <span class="comment">//叶结点(左右子树都为空)；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == node)  <span class="comment">//被删除的结点只有根结点；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">NULL</span>;  <span class="comment">//设置父结点左子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);   <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//父结点为右子树；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;right=<span class="literal">NULL</span>;  <span class="comment">//设置父结点右子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);  <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;left)  <span class="comment">//左子树为空，右子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)    <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;right)  <span class="comment">//右子树为空，左子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)  <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LL=p;  <span class="comment">//保存左子树的结点；</span></span><br><span class="line">                L=p-&gt;right;  <span class="comment">//从当前结点的右子树进行查找；</span></span><br><span class="line">                <span class="keyword">if</span>(L-&gt;left)  <span class="comment">//左子树不为空；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LL=L;</span><br><span class="line">                    L=L-&gt;left;   <span class="comment">//查找左子树；</span></span><br><span class="line">                    p-&gt;data=L-&gt;data;  <span class="comment">//将左子树的数据保存到被删除结点；</span></span><br><span class="line">                    LL-&gt;left=L-&gt;left;  <span class="comment">//设置父结点的左子树指针为空；</span></span><br><span class="line">                    <span class="keyword">for</span>(; L-&gt;left; L=L-&gt;left);</span><br><span class="line">                    L-&gt;left=p-&gt;left;</span><br><span class="line">                    p-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;data=L-&gt;data;</span><br><span class="line">                    LL-&gt;right=L-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; p-&gt;data)  <span class="comment">//需删除记录的关键字小于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的左子树；</span></span><br><span class="line">            child=<span class="number">0</span>;  <span class="comment">//标记在当前结点左子树；</span></span><br><span class="line">            parent=p;<span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;left;  <span class="comment">//查找左子树；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//需删除记录的关键字大于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的右子树；</span></span><br><span class="line">            child=<span class="number">1</span>;  <span class="comment">//标记在当前结点右子树查找；</span></span><br><span class="line">            parent=p;  <span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;right;  <span class="comment">//查找右子树；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;  <span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;     <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(tree.root);</span><br><span class="line">    Deleteer(tree.root,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>二又排序树、二叉查找树（BST, Binary Search Tree）<br>是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又各是一棵二又排序树。</li></ul><blockquote><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值；</p><p>进行中序遍历，可以得到一个递增的有序序列。</p></blockquote><p><strong>查找：</strong>时间复杂度 O(h)，若排序树很平衡，则h接近log<del>2</del>n，若非常不平衡，则h会接近n。</p><p><strong>插入：</strong>时间复杂度 O(h)</p><p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于 根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p><p><strong>删除：</strong></p><p>先搜索找到目标结点：</p><ul><li>①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质。</li><li>②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ul><h3 id="自平衡二叉树AVL"><a href="#自平衡二叉树AVL" class="headerlink" title="自平衡二叉树AVL"></a>自平衡二叉树AVL</h3><p>平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)ー一树上任一结点的左子树和右子树的<strong>高度之差不超过1</strong>。</p><p>结点的平衡因子 &#x3D; 左子树高 - 右子树高。</p><ul><li>平衡二叉树结点的平衡因子的值只可能是-1、0或1。否则就不是平衡二叉树了。</li></ul><p>查找：时间复杂度不超过O(h) 、O(log<del>2</del>n)</p><p><strong>插入</strong>：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201805281.png" alt="image-20211228111813606"></p><p><strong>调整</strong>最小不平衡子树A（从插入点找到的第一个不平衡点为根的子树）：</p><ul><li><p><strong>LL</strong>：在A的左孩子的左子树中插入导致不平衡；<br>调整：A的左孩子结点<strong>右上旋</strong>；</p></li><li><p><strong>RR</strong> ：在A的右孩子的右子树中插入导致不平衡；</p><p>调整：A的右孩子结点<strong>左上旋</strong>；</p></li><li><p><strong>LR</strong> ：在A的左孩子的右子树中插入导致不平衡；<br>调整：A的左孩子的右孩子<strong>先左上旋再右上旋</strong>；</p></li><li><p><strong>RL</strong> ：在A的右孩子的左子树中插入导致不平衡；<br>调整：A的右孩子的左孩子<strong>先右上旋后左上旋</strong>；</p></li></ul><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>结点的带权路径长度：</strong></p><blockquote><p>树的每一个结点，都可以拥有自己的“权重”（Weight），权重在不同的算法当中可以起到不同的作用。结点的带权路径长度，是指树的根结点到该结点的路径长度，和该结点权重的乘积。</p></blockquote><p><strong>树的带权路径长度</strong></p><blockquote><p>在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p></blockquote><p><strong>而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</strong></p><p><strong>一颗有n个叶子结点的的哈夫曼树共有2n-1个结点</strong></p><p>原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p><p>思路：</p><blockquote><p>借助辅助队列，将权值最小的两个叶子节点挑出来，并根据这两个结点生成一个新的父结点，父节点的权值是这两个结点权值之和；从队列中移除已选择的节点，把新的父结点加入队列；</p><p>重复这一步骤，直到所有结点组成一颗完整二叉树</p><p>（如果是构造<strong>k叉哈夫曼树</strong>，且节点数无法严格构成k叉树，则需要补充几个<strong>权值为0的 “假节点”</strong>）</p></blockquote><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207127.png" alt="202204201806626" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207452.png" alt="202204201806756" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207097.png" alt="202204201807079" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 结点权值?</span></span><br><span class="line">    <span class="type">int</span> parent, lc, rc; <span class="comment">// 双亲结点和左 右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minum;      <span class="comment">// 定义一个临时变量保存最小值?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;     <span class="comment">// 以下是找到第一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = minum;</span><br><span class="line">    <span class="comment">// 以下是找到第二个最小值，且与第一个不同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = minum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuff</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s1, s2;</span><br><span class="line">    m = n * <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>]; <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 1 - n 存放叶子结点，初始化</span></span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 非叶子结点的初始化</span></span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe HuffmanTree is: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)     <span class="comment">// 创建非叶子节点，建哈夫曼树</span></span><br><span class="line">    &#123;   <span class="comment">// 在HT[1]~HT[i-1]的范围内选择两个parent为0且weight最小的两个结点，其序号分别赋值给 s1 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;  <span class="comment">// 删除这两个结点</span></span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lc = s1;      <span class="comment">// 生成新的树，左右子节点是 s1和s2</span></span><br><span class="line">        HT[i].rc = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;   <span class="comment">// 新树的权�?</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d (%d, %d)\n&quot;</span>, HT[i].weight, HT[s1].weight, HT[s2].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *w, n, wei;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the number of node\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ninput the %dth node of value\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei);</span><br><span class="line">        w[i] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreatHuff</span>(HT, w, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋0，右分支赋1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的基本思想是：为出现次数较多的字符编以较短的编码，在压缩原理中有重要作用。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称<strong>多路平衡查找树</strong>。</p><p>B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的<strong>m叉树</strong>：</p><ol><li>树中每个结点<strong>至多有m棵子树</strong>，即<strong>至多含有m-1个关键字</strong></li><li>若<strong>根结点不是终端结点，则至少有两棵子树</strong>。</li><li>除根结点外的所有<strong>非叶结点至少有 m&#x2F;2 棵子树</strong>，即至少含有 (m&#x2F;2) -1 个关键字。</li><li><strong>所有的叶结点都出现在同一层次上，并且不帯信息</strong>（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807887.png" alt="image-20211227205412747"></p><p><strong>m阶B树的核心特性</strong></p><ol><li>根节点的子树数∈[2,m], 关键字数∈[1, m-1]<br>其他结点的子树数∈ [(m&#x2F;2), m] ;关键字数∈[(m&#x2F;2)-1, m-1]</li><li>对任一结点，其所有子树高度都相同</li><li>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt;关键字2 &lt; 子树2 &lt;. (类比二叉査找树左&lt;中&lt;右)</li></ol><blockquote><p>注：算B树高度时，不用包括叶子节点&#x2F;失败节点；</p><p>n个关键字的B树必有n+1个叶子节点。（相当于在n个关键字中插入木板，两边也插，则插了n+1个木板）</p></blockquote><p><strong>B树的插入</strong></p><p><strong>新元素一定是插入到最底层“终端节点”</strong>，用“查找”来确定插入位置。</p><p>在插入key后，若导致原结点关键字数超过上限，则从中间位置( [m&#x2F;2] )将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置( [m&#x2F;2] )的结点插入原结点的父结点。 </p><p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807992.png" alt="image-20211227210741287"></p><hr><p><strong>B树的删除</strong></p><ul><li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除</strong>该关键字（要注意节点关键字个数是否低于下限 [m&#x2F;2] - 1 )</p></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来<strong>替代</strong>被删除的关键字（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素）——对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807165.png" alt="image-20211227211302810"></p><ul><li><p>若删除关键字所在节点删除后，<strong>关键字低于下限</strong>：</p><ul><li><p>如果<strong>兄弟节点关键字充足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>借关键字</strong>“的目的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807275.png" alt="image-20211227211924677"></p></li><li><p>如果<strong>兄弟节点关键字不足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>合并</strong>“的目的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808905.png" alt="image-20211227212543467"></p></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树 可以类比分块查找。</p><p>分块查找：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808668.png" alt="image-20211227212836480"></p><p>B+树：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808635.png" alt="image-20211227212949012"></p><p>一棵<strong>m阶的B+树</strong>需满足下列条件：</p><ol><li>每个分支结点最多有m棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 m&#x2F;2 棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。（区别于B树，因为B+树的关键字和子树是一一对应的）</li><li>所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（支持顺序查找）</li><li>所有<strong>分支结点</strong>中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的指针。</li></ol><p><strong>B+的查找：</strong></p><p><strong>无论查找成功与否，最终一定要走到最下面一层节点。</strong>因为只有叶子节点存放了所需记录。</p><hr><p><strong>B树和B+树的对比：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808265.png" alt="image-20211227213649466"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="概念性质"><a href="#概念性质" class="headerlink" title="概念性质"></a>概念性质</h4><p>红黑树的概念模型是<strong>2-3-4树</strong>，以<strong>二叉树为基础</strong>，在二叉树属性中加入<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p><p>红黑树的<strong>五大定义</strong>：</p><ol><li><strong>节点颜色只能为红或黑；</strong></li><li><strong>根节点是黑色；</strong></li><li><strong>每个叶子节点是黑色的（这里的叶子节点其实是空节点）</strong></li><li><strong>不能出现连续的红色节点；</strong></li><li><strong>从任意节点到它的每个子节点的所有路径都包含相同的黑色节点；</strong></li></ol><p>这5条定义确保了红黑树的关键特性：</p><ul><li><strong>从根到叶子节点的最长路径，不会超过最短路径的两倍</strong>；</li><li>这棵树<strong>基本是平衡</strong>的；</li><li>虽然不是绝对平衡，但可以保证<strong>最坏情况下，红黑树依然是高效的</strong>；</li></ul><p>为什么能做到最长路径不超过最短路径的两倍？</p><blockquote><p>性质4规定了路径上不能有两个相连的红节点，因此，最长路径一定是红色节点和黑节点交替而成；</p><p>性质2和3规定了根节点和叶子节点都是黑色，所以最短路径的黑节点一定多于红节点（可能全部为黑）；</p><p>性质5规定每条路径黑节点的数目相同；</p><p>因此，没有路径的长能多于其他任何路径两倍。</p></blockquote><p>红黑树的<strong>三种变换：变色，左旋转，右旋转</strong></p><p>红黑树<strong>插入的新节点为红色</strong>的：</p><blockquote><p>因为插入红节点，不会违反红黑树的规则，虽然可能会红红相连，不过可以通过变色和旋转来调整；而插入黑色节点，必然会导致一条路径上多一个黑节点（难以调整）。</p></blockquote><hr><p><strong>左旋转</strong>：以当前节点X为根，逆时针旋转二叉树，使得<strong>父节点原来的位置被右子节点替代，左子节点的位置被父节点替代</strong>。同时，节点Y的<strong>左子树</strong> b 向<strong>左平移</strong>成为了节点X的<strong>右子树</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2.png" alt="image-20200303132706061"></p><p>旋转之后仍然是二叉搜索树：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/3.png" alt="image-20200303132617108"></p><p><strong>右旋转</strong>：以节点X为根，<strong>顺时针</strong>旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/4.png" alt="image-20200303132529476"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h4 id="2-3树-到-红黑树"><a href="#2-3树-到-红黑树" class="headerlink" title="2-3树 到 红黑树"></a>2-3树 到 红黑树</h4><p>2-3-4树中的2节点对应红黑树中的黑色节点，而非2节点以红节点+黑节点的方式表示，黑色父节点+一个红色子节点表示3节点，黑色父节点+左右两个红色子节点表示4节点；</p><blockquote><p>2-3-4树 ：是一颗阶数为4的B树，它可能会存在2节点，3节点，4节点（2节点就是普通的二叉树节点；3节点：由2个属性X和Y，3个子节点，分别是小于X的，大于X小于Y的，大于Y的；4节点跟3节点类似）</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/9f7961f77546c8f13448372625282335.png" alt="B树到红黑树的转化"></p><p>下面是以较为简单的 2-3树和左倾红黑树 为例，理解两者的转化关系</p><blockquote><p>2-3树不用考虑2-3-4树中复杂的4节点分裂；</p><p>左倾红黑树规定了红色节点只能在左子树，这个限制减少了原本红黑树的调平难度，更容易理解；</p></blockquote><hr><p>2-3树 和 左倾红黑树 ：把左倾红黑树中的红色节点<strong>顺时针方向旋转45°</strong>使其与黑父平行，然后再将它们看作一个整体，可以近似得到一颗2-3树。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/5a84b9872980c9a8761d3b84315d5931.png" alt="B树到红黑树的转化"></p><p>从2-3树来看，红黑树的红节点和黑节点是绑定的，因为在2-3树中它们本来就在同一层，所有只有黑节点在2-3树中体现树的高度</p><hr><p><strong>对于2-3树的插入：</strong></p><p>我们的插入操作需要遵循一个<strong>原则</strong>：先将这个元素尝试性地放在<strong>已经存在的节点中</strong>（即插入一个红色节点），如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（<strong>临时</strong>）。然后，我们对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p><p>如图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/02050b1461f4b891a92052f41139c567.png" alt="2-3树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/706a4ae059ebd3b6cfd8dfef6a3f05e4.png" alt="2-3-4树的插入"></p><p>在2-3树中如果待插入节点是个2节点，而2节点对应着红黑树中的黑色父节点；所以向2节点插入元素，即在黑色父节点下面增加一个红色儿子，</p><p>3节点插入元素，即已经有一个黑色父节点和一个红色子节点，则再给黑色父节点一个红色子节点</p><hr><p><strong>对于2-3树的删除：</strong></p><p>2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p><p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己<strong>唯一的元素</strong>，引发2节点自身的删除，会使得树中某条路径的<strong>高度发生变化</strong>，树变得<strong>不平衡</strong>。</p><p>对此有两种方案：</p><ol><li>先删除这个2节点，再对树进行平衡调整；</li><li>想办法让被删除元素不可能出现在2节点中；</li></ol><p>这里看第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点。</p><p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/9f2f0ebec960203ecafac6bf91462be2.png" alt="2-3树的删除"></p><p>插入和删除操作的父子节点上下浮动和删除里借元素的做法，就是红黑树的调整（变色，旋转）；</p><p>看左倾红黑树的 插入和删除（图示）：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/4947b64375651e3b2072ecd09d3fad7b.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/03f56fa81ffaee6bfe4fd68d25b6bc63.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/162498f17b4122405b0ef04cefe55368.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/28d7b36542a54750935418950da5d8eb.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/cd622250cc9453c634658ae934defc88.png" alt="左倾红黑树的删除"></p><p>删除之后需要一些调整（左倾红黑树不允许出现右倾）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/711d441a7e05c4843237ac5e6f424f26.png" alt="左倾红黑树的删除"></p><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆   Heap"></a><strong>堆   Heap</strong></h2><p>性质：</p><ol><li>结构性：用<strong>数组表示</strong>的<strong>完全二叉树</strong>。</li><li>有序性：任意结点的关键字（权值）是其子树所有结点的最小值&#x2F;最大值<br>1. 父结点大于子结点：最大堆&#x2F;大根堆（MaxHeap）<br>            2. 父结点小于子结点：最小堆&#x2F;小根堆（MinHeap）</li></ol><p>应用：</p><ol><li>优先队列：是一种特殊的“队列”，从队列中取出元素的顺序是依照元素的关键字（权值&#x2F;数值）大小，而不是元素进入队列的先后顺序。</li><li>堆排序</li></ol><h3 id="最小堆操作与实现："><a href="#最小堆操作与实现：" class="headerlink" title="最小堆操作与实现："></a>最小堆操作与实现：</h3><p>对于任意最多有MaxSize个元素的最小堆H ∈ MinHeap 元素，item ∈</p><p> ElementType主要操作有：</p><ul><li>MinHeap Create(int Maxsize): 创建一个空的最小堆。</li><li>void Destroy(MinHeap)：释放堆的空间。</li><li>Boolean IsFull(MinHeap H): 判断最小堆是否已满。</li><li>Boolean IsEmpty(MinHeap H): 判断最小堆是否为空。</li><li>void Insert(MinHeap H,ElementType item): 将元素item插入最小堆H。</li><li>ElementType DeleteMin(MinHeap H): 返回最小堆H中最小元素（高优先级）。</li><li>MinHeap BuildMinHeap(ElementType *Element,int Size,int MaxSize)：创建一个非空的最小堆</li></ul><p><strong>数组下标为0</strong>的位置放一个比所有堆中元素都要小的元素（可以是ElementType的最小值），称为“<strong>哨兵</strong>”。从下标为1的位置开始存放堆中元素。因为是完全二叉树，所以父亲节点与其左右子节点下标满足一些关系。</p><p><strong>由子节点找父节点：父节点下标&#x3D;子节点下标 &#x2F; 2</strong><br><strong>由父节点找左子节点：左子节点下标&#x3D;父节点下标 * 2</strong><br><strong>由父节点找右子节点：右子节点下标&#x3D;父节点下标 * 2 + 1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elenment;      <span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;       <span class="comment">//堆的当前元素个数（最后一个元素的下标）</span></span><br><span class="line">    <span class="type">int</span> MaxSize;        <span class="comment">//堆存储空间的大小</span></span><br><span class="line">&#125; HeapStruct, *MinHeap;</span><br><span class="line"></span><br><span class="line">MinHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span> &#123;</span><br><span class="line">    MinHeap H = (MinHeap) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));     <span class="comment">//分配堆结构空间</span></span><br><span class="line">    H-&gt;Elenment = (ElementType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType) * (MaxSize + <span class="number">1</span>));    <span class="comment">//分配储存堆元素的数组的空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;MaxSize = MaxSize;</span><br><span class="line">    H-&gt;Elenment[<span class="number">0</span>] = <span class="number">-2020</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆申请的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Elenment);     <span class="comment">//先释放堆节点的数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(H);        <span class="comment">//再释放堆节点的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;MaxSize); <span class="comment">//判断最小堆中元素个数size是否等于最大容量MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);  <span class="comment">//判断堆中元素个数是否等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素item插入最小堆H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inset</span><span class="params">(MinHeap H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断堆H是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果H未满，将item放入堆最后一个元素，查看它的父节点，如果它的父节点比它大，将它和它的父节点互换位置循环此过程，直至它的父节点小于它。可能它比所有它的父节点都要小，但是一定会比哨兵大（数组中下标为0的位置），所以一定最后它的下标一定大于哨兵的下标0。这就是哨兵的意义。</span></span><br><span class="line">    H-&gt;Size++;</span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;Size; H-&gt;Elenment[i / <span class="number">2</span>] &gt; item; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        H-&gt;Elenment[i] = H-&gt;Elenment[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最小堆H中最小元素（高优先级）</span></span><br><span class="line"><span class="comment">//将堆根结点元素取出，并将堆元素重新排序</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MinHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = <span class="number">0</span>,child = <span class="number">0</span>;</span><br><span class="line">    ElementType item, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否已经空了</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> H-&gt;Elenment[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆没有空，将根节点返回，最后一个叶子节点放到根节点位置，然后比较它与它的左右子节点中最小节点的大小，如果它比较大，则将它和它的较小的子节点互换位置，重复此过程，直至他比两个子节点都小或者它不在有子节点</span></span><br><span class="line">    item = H-&gt;Elenment[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elenment[H-&gt;Size];</span><br><span class="line">    H-&gt;Size--;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找出左右子结点最小的那个</span></span><br><span class="line">        <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child +<span class="number">1</span>]))&#123;</span><br><span class="line">            child ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">            H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非空的堆</span></span><br><span class="line"><span class="comment">//可以先建一个空堆，再用Insert函数将元素一个一个插入；另一种方法是：将数组复制到堆结点的Element，再进行排序第二种方法时间复杂度更低</span></span><br><span class="line"><span class="comment">//已知一个数组，创建一个由数组元素组成的最小堆</span></span><br><span class="line">MinHeap <span class="title function_">BuildMinHeap</span><span class="params">(ElementType *Element,<span class="type">int</span> Size,<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">    MinHeap H = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, parent = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">    ElementType Temp;</span><br><span class="line"></span><br><span class="line">    H = Create(MaxSize);    <span class="comment">//创建一个空最小堆</span></span><br><span class="line">    <span class="keyword">if</span> (Size &gt; H-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆储存空间不足\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;Size; i++)&#123;</span><br><span class="line">        H-&gt;Elenment[i + <span class="number">1</span>] = Element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Size = Size;</span><br><span class="line">    <span class="comment">//给最小堆排序</span></span><br><span class="line">    <span class="comment">//最后一个节点的父节点的左右指针都指向一个堆，将最后一个节点的父节点和它的两个子节点排序（方法类似与删除节点的操作），使得最后一个节点、其父节点和其兄弟节点形成一个堆。循环操作，从最后一个节点的父节点往上依次执行这个操作，最后使得整个树都是一个堆。</span></span><br><span class="line">    <span class="keyword">for</span> (parent = H-&gt;Size/<span class="number">2</span>; parent &gt;= <span class="number">1</span>; parent--)&#123;</span><br><span class="line">        Temp = H-&gt;Elenment[parent];</span><br><span class="line">        <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果左右子树都存在，将child作为两者较小者的下标</span></span><br><span class="line">            <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child + <span class="number">1</span>]))&#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较parent和child分别指向的结点的大小，parent较大则互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(Temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">                H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H-&gt;Elenment[parent] = Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heapsort是利用堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值总小于（或大于）它的父结点。它有两种方法来排序：</p><ol><li>大顶堆：每个结点的值都大于或等于其他子结点的值，在堆排序中可用于升序排序。（因为其中每一次排序都会先将堆顶的元素交换到后面）</li><li>小顶堆：每个结点的值都小于或等于其他子结点的值，在堆排序中可用于降序排序。</li></ol><p>堆排序的平均时间复杂度是O（nlogn）</p><h4 id="堆排序操作与实现"><a href="#堆排序操作与实现" class="headerlink" title="堆排序操作与实现"></a>堆排序操作与实现</h4><ol><li>创建一个堆；</li><li>把堆首与堆尾互换；</li><li>把堆的尺寸缩小1，并调用heapify（堆化）将堆重新调整好；</li><li>重复步骤2、3，直到堆的尺寸为1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="comment">//建立父结点指标和子结点指标</span></span><br><span class="line">    <span class="type">int</span> parent = start;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;    <span class="comment">//子结点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])     <span class="comment">//选择两个子结点中较大的</span></span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &gt; arr[child])     <span class="comment">//如果父结点较大，则表示调整完毕，直接跳出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则交换父子结点内容，再继续子结点和孙结点比较</span></span><br><span class="line">            swap(&amp;arr[parent],&amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_dort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        max_heapify(arr, i ,len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位交换，再重新调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//因为除了交换的两个元素，其他已经堆化好了，所以从上往下只经过一条路径即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>（可以自行构造最大堆或最小堆，加深对堆的认识）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            maxheap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxheap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆实现（只需k个元素在堆里）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            swim(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                sink(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    bool <span class="title function_">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; priorityThan(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; priorityThan(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (priorityThan(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="692-前k个高频单词"><a href="#692-前k个高频单词" class="headerlink" title="692.前k个高频单词"></a>692.前k个高频单词</h3><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小根优先队列。</span></span><br><span class="line"><span class="comment">//将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 kk 个元素就是前 kk 个出现次数最多的单词。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用哈希表存储字符串和出现次数</span></span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个PriorityQueue对象：将key-value转为entry对象，放入优先队列（堆）中，（自定义）排序（构造最小堆）</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; entry1, Map.Entry&lt;String, Integer&gt; entry2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();<span class="comment">//注意这里 entry2.compareTo(entry1) 中entry1与entry2在数组中的位置，entry2表示后加进来的元素，entry1表示原来的元素.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将哈希表中的key-value依次放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;    <span class="comment">//大小超过k后，去掉堆顶元素（去掉最小值，因为题目要求最大的k个）</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ret.add(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 + 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            hash.put(s, hash.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一组value变为一个entry对象存入list数组</span></span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hash.get(word1).equals(hash.get(word2)) ? word1.compareTo(word2) : hash.get(word2) - hash.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>G（ V , E ）：图由顶点集合V（G）和边集合E（G）构成；</p><p><strong>端点：</strong></p><p>无向图：一条边（i，j） ，它的顶点 i 和 j 叫<strong>端点</strong>，它们互为<strong>邻接点</strong>；</p><p>有向图：一条边&lt; i , j &gt;  ，它的顶点 i 为 起始端点 （起点），j 为终止端点 （终点），它们互为邻接点；</p><p><strong>度</strong>：</p><p>以某点为端点的 边的数量 叫该顶点的<strong>度</strong></p><p>入度：进入该点的边数；</p><p>出度：从该点出发的边数</p><p><strong>完全图：</strong></p><p>完全无向图：n( n - 1 ) &#x2F; 2 条边</p><p>完全有向图：n( n - 1) 条边</p><p>当一个图接近完全图时，称为<strong>稠密图</strong>，反之，则为<strong>稀疏图</strong>；</p><p><strong>路径：</strong></p><p>路径长度：一条路径上经过的边的数目；</p><p>简单路径：除开始点和结束点可以相同，其它顶点均不同；</p><p>环&#x2F;回路：一条路径上开始点和结束点为同一顶点；</p><p><strong>连通：</strong>指从 i 到 j 有路径，则 i 和 j 连通；</p><p>连通图：无向图中任意两点连通；</p><p>强连通图：有向图中任意两点连通；</p><p>连通分量：指无向图G中的极大连通子图；</p><p>强连通分量：指有向图G中的极大连通子图；</p><p>（强连通图的连通分量只有一个，非连通图有多个连通分量）（强连通图也一样）</p><p><strong>权：</strong>边上附加的一个数值，可以表示从一个顶点到另一个顶点的距离或代价；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问：</span><br><span class="line">设有一个图G=（V，E），取V的子集V&#x27;，E的子集E&#x27;。那么，（V&#x27;，E）一定是G的子图吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果对顶点的子集和边的子集不加限定的话，(V&#x27;,E&#x27;)不一定构成一个图。</span><br><span class="line">假如边集对应的顶点包含在所取的顶点集中，则(V&#x27;,E&#x27;)构成G的子图</span><br><span class="line">如果所取的顶点集不能包含s取的边集所对应的所有顶点，则(V&#x27;,E&#x27;)不构成G的子图。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 存储类型：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809164.png" alt="image-20211227214212034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define MAXV &lt;最大顶点个数&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 顶点 类型    </span></span><br><span class="line">typedef struct&#123;</span><br><span class="line"><span class="type">int</span> no;<span class="comment">//顶点编号</span></span><br><span class="line">InfoType info;<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接矩阵 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接表 存储类型：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809277.png" alt="image-20211227214032490"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 边节点 类型</span></span><br><span class="line">typedef struct ANode&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边的终点编号</span></span><br><span class="line">    struct ANode *next;<span class="comment">//指向下一条边</span></span><br><span class="line">    InfoType info;<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接表头节点 类型</span></span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    vertex data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstArc;<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 邻接表 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VNode adjList[MAXV];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 和 邻接表 对比：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809762.png" alt="image-20211227214112779"></p><p><strong>十字链表（有向图）</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809325.png" alt="image-20211227214400091"></p><p>找顶点出边： 顺着绿色线找</p><p>找顶点入边：顺着橙色线找</p><hr><p><strong>邻接多重表（无向图）</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809819.png" alt="image-20211227214717843"></p><hr><p><strong>四种存储方式 对比</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809656.png" alt="image-20211227214851706"></p><h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createAdj</span><span class="params">(AdjGraph *G, <span class="type">int</span> a[MAXV][MAXV], <span class="type">int</span> n, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;      <span class="comment">//所有头节点的指针域赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; a[i][j] != INF) &#123;        <span class="comment">//这条边存在</span></span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;                  <span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = a[i][j];            <span class="comment">//存放 权</span></span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;   <span class="comment">//头插法插入节点</span></span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">displayAdj</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;</span><br><span class="line">        printf(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        pre = G-&gt;adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//释放第i个单链表的所有节点</span></span><br><span class="line">                free(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(G);    <span class="comment">//释放头节点数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵g 转化成 邻接表G （时间复杂度：O(n^2)）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;</span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将邻接表G转换成邻接矩阵g</span></span><br><span class="line"><span class="comment">//时间复杂度：无向图为O(n+2e)，有向图为O(n+e)，e为边数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)<span class="comment">//扫描所有的单链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;<span class="comment">//p指向第i个单链表的首结点while(p！=NULL)//扫描第i个单链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        g.n = G-&gt;n;</span><br><span class="line">        g.e = G-&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索: O(n+e)</span></span><br><span class="line"><span class="comment">//用栈 或 递归</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXV; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    p = G-&gt;adjList[v].firstArc;</span><br><span class="line">    <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">        w = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索: O(n+e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">//定义环形队列指针</span></span><br><span class="line">    IntiQueue(qu);      <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visit[MAXV];    <span class="comment">//顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%2d&quot;</span>, v); <span class="comment">//输出被访问的顶点 编号</span></span><br><span class="line">    visit[v] = <span class="number">1</span>;   <span class="comment">//此点 已访问</span></span><br><span class="line">    EnQueue(qu, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(qu))&#123;</span><br><span class="line">        DeQuenu(qu, w);     <span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjList[w].firstArc; <span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//查找w的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(qu, p-&gt;adjvex);<span class="comment">//该点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;<span class="comment">//找下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个<strong>连通图的生成树</strong>是一个<strong>极小连通子图</strong>，它含有图中<strong>全部n个顶点</strong>和构成一棵树的（<strong>n - 1</strong> ）条边。</p><p>遍历方法得到生成树：深度优先生成树，广度~~树</p><p>（所以一个连通图的生成树不一定唯一）</p><p><strong>最小生成树</strong></p><p>对 带权连通图G （权 均为大于0的实数），其权值之和最小的生成树 即 图的最小生成树。</p><h4 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a><strong>普里姆(prim)算法</strong></h4><p>（从顶点 考虑）</p><ol><li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li><li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li><li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li><li>重复步骤2，3，知道V-S为空集</li></ol><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232209206.png" alt="202204201810815" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232209658.png" alt="202204201810813" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MAXV];<span class="comment">//lowcost存储到未标顶点的最小权值</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> closest[MAXV], i, j, k;<span class="comment">//closest存储最小权值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;         <span class="comment">//赋初值</span></span><br><span class="line">        lowcost[i] = g.edges[v][i];</span><br><span class="line">        closest[i] = v;<span class="comment">//此时生成树只有一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g.n; i++) &#123;     <span class="comment">//输出（n - 1）条边</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//在( V - U )中找出离U最近的顶点k</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;      <span class="comment">//k记录最近的顶点编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;     <span class="comment">//标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)        <span class="comment">//修改数组lowcost和cloest</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];<span class="comment">//更新S和V-S之间最小权值</span></span><br><span class="line">                closest[j] = k;<span class="comment">//最小权值对应的 在Sz</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="克鲁斯卡尔（kruskal-算法"><a href="#克鲁斯卡尔（kruskal-算法" class="headerlink" title="克鲁斯卡尔（kruskal)算法"></a><strong>克鲁斯卡尔（kruskal)算法</strong></h4><p>（从边 考虑）</p><ol><li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li><li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li><li>直到图中所有的顶点都在同一个顶点集为止</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232210576.png" alt="202204201810581"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232210733.png" alt="202204201810936"></p><p>思路：连通图的边按照权值从小到大进行排列；依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201811175.png" alt="image-20211227204922551"></p><h4 id="狄克斯特拉-Dijkstra-算法"><a href="#狄克斯特拉-Dijkstra-算法" class="headerlink" title="狄克斯特拉(Dijkstra)算法"></a><strong>狄克斯特拉(Dijkstra)算法</strong></h4><p>只适用 有向无环图，图中存在负权重、环 时，无法使用狄克斯特拉算法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232208359.png" alt="202204201811792"></p><p>过程如下:</p><p>从起点开始，起点到其所有邻居的距离2和6是初始值，其他不相邻的节点的距离为无穷大，</p><p>然后从{2,6,无穷大}中找到最小值2,2对应的节点是B，然后从B开始遍历B的所有邻居{A,终点}，计算起点-&gt;B-&gt;A的距离为2+3&#x3D;5，比之前的距离6要小，所以更新A的记录为5，继续计算起点-&gt;B-&gt;终点的距离为2+5&#x3D;7，比之前的距离无穷大要小，所以更新终点的记录为7，至此B的所有相邻节点遍历完毕，故划去B，</p><p>之后继续从{2,5,7}中寻找最小值，由于2对应的B节点已经被划去，所以只要从{5,7}中找最小值，最小值为5，5对应于节点A，然后从A开始遍历A的所有邻居{终点}，计算起点-&gt;A-&gt;终点的距离6，比之前的距离7要小，故更新终点的记录为6，至此A的所有邻居遍历完毕，故划去A，</p><p>最后只剩下终点这个节点，由于终点没有邻居，故图中的所有邻居遍历完毕。至此得出从起点到终点的最短距离是6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//狄克斯特拉(Dijkstra)算法：O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;  <span class="comment">//v为源点</span></span><br><span class="line">    <span class="type">int</span> dist[MAXV], path[MAXV]; <span class="comment">//dist[]存放到某点的最短路径长度，path[]存放最短路径</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];    <span class="comment">//标记顶点是否访问过</span></span><br><span class="line">    <span class="type">int</span> mindis, u;      <span class="comment">//mindis为最短距离，u为新考虑的中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123; <span class="comment">//初始化dist和path</span></span><br><span class="line">        dist[i] = g.edges[v][i];    <span class="comment">//距离初始化，即v点到其余点的距离</span></span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        mindis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)       <span class="comment">//找最小路径长度的顶点u</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//修改未考虑的顶点的距离</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist, path, s, g.n, v); <span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弗洛伊德-Floyd）算法"><a href="#弗洛伊德-Floyd）算法" class="headerlink" title="弗洛伊德(Floyd）算法"></a><strong>弗洛伊德(Floyd）算法</strong></h4><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p><p>矩阵D记录顶点间的最小路径<br>例如D[0q0] [3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；</p><p>矩阵P记录顶点间最小路径中的中转点<br>例如P[0] [3]&#x3D; 1 说明，0 到 3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</p><p>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathmatirx[MAXV][MAXV];<span class="comment">//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2</span></span><br><span class="line"><span class="type">int</span> shortPath[MAXV][MAXV];<span class="comment">//记录顶点间的最小路径值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">short_path_floyd</span><span class="params">(MatGraph G, <span class="type">int</span> P[MAXV][MAXV], <span class="type">int</span> D[MAXV][MAXV])</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, k;</span><br><span class="line">    <span class="comment">//初始化floyd算法的两个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            D[v][w] = G.edges[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是弗洛伊德算法的核心部分</span></span><br><span class="line">    <span class="comment">//k为中间点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.n; k++) &#123;</span><br><span class="line">        <span class="comment">//v为起点</span></span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">            <span class="comment">//w为终点</span></span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; (D[v][k] + D[k][w])) &#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径</span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的D矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的P矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//求 0 到 3的最小路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;path: %d&quot;</span>, v);<span class="comment">//打印起点</span></span><br><span class="line">    <span class="keyword">while</span> (k != w) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>, k);<span class="comment">//打印中间点</span></span><br><span class="line">        k = P[k][w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p><blockquote><p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p></blockquote><p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现<code>一次</code>。</li><li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p><p><strong>代码思想为：</strong></p><p>新建node类，包含节点数值和它的指向；</p><p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p><p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p><p>重复上述操作，直到栈为空。</p><h3 id="210-课程表"><a href="#210-课程表" class="headerlink" title="210.课程表"></a>210.课程表</h3><p>现在你总共有 <strong>numCourses</strong> 门课需要选，记为 0 到 numCourses - 1。给你一个数组 <strong>prerequisites</strong> ，其中 <strong>prerequisites[i] &#x3D; [ai, bi]</strong> ，表示在选修课程 ai 前 必须 先选修 bi 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示：[<span class="number">0</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组。</p><p><strong>题解：</strong></p><p>本题是一道经典的「拓扑排序」问题。</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A 的前面。</p></li></ul><p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。</p><p><strong>方法一，深度优先搜索</strong></p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)(u,v) 之前的拓扑关系，所以不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: **O(n+m)**，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: **O(n+m)**。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n)的空间存储节点状态、最终答案等。</p></li></ul><p><strong>方法二：广度优先搜索</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/sort.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称为缩小增量（递减增量）算法，是<strong>插入排序的改进</strong>。</p><p>希尔排序需要一个增量序列（增量会递减）,一般用len&#x2F;2，如：len为11，则增量分别为5，2，1，进行三次循环。</p><p>每次循环排序只排 间隔 为增量值的数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;      <span class="comment">//i为增量,初始化为len/2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;       <span class="comment">//j用于每次更改增量后遍历一次数组</span></span><br><span class="line">                <span class="type">int</span> k;          <span class="comment">//k用于对第j个元素进行插入排序，比较的是前面间隔为i的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                <span class="keyword">for</span> (k = j; k &gt;= i &amp;&amp; temp &lt; nums[k - i]; k -= i) &#123;</span><br><span class="line">                    nums[k] = nums[k - i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ShellSort</span>().shellSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数据不断分半，直到只剩下一个元素，然后从以分半的两段数据，逐个选出最小的元素移入临时数组的末尾。（归并排序需要用到临时数组）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Merge-sort-example-300px.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[],<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> l_pos = left;</span><br><span class="line">    <span class="comment">//标记右半曲第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//临时变量元素的下标</span></span><br><span class="line">    <span class="type">int</span> pos = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp;r_pos &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos])     <span class="comment">//左半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[l_pos++];</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//右半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l_pos &lt;= mid)&#123;       <span class="comment">//合并左半区剩余元素（右半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[l_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r_pos &lt;= right)&#123;      <span class="comment">//合并右半区剩余元素（左半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将临时数组中合并后的元素复制到原来的数组</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        arr[left] = tempArr[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//如果只有一个元素，那么不需要继续划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归划分左右半区</span></span><br><span class="line">        msort(arr,tempArr, left, mid);</span><br><span class="line">        msort(arr, tempArr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tempArr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//分配一个辅助数组</span></span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tempArr)&#123;    <span class="comment">//辅助数组分配成功</span></span><br><span class="line">        msort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tempArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: failed to allocate memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在区间中挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行同样操作。直到各个分区只有一个数时为止。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/quickSort.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以第一个元素作为基准</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> i = start, j = end, x = s[start];     <span class="comment">//以第一个元素作为基准，后面用了类似挖坑的写法，临时存储这个元素，遇到第一个需要交换的元素，直接赋值给基准处。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;     <span class="comment">//一边交换后，换另一边比较</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quicksort(s, start, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(s, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> i = start, j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= mid &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        quick_sort_recursive(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>（堆积是一个近似完全二叉树的结构，并同时满足堆积的性质）</p><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>算法步骤：</p><ol><li>创建一个堆</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸减少1，并调用上浮&#x2F;下沉操作，把新的最大值调整到堆首；</li><li>重复步骤2，3，直到堆的尺寸为1；</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/heapSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</p><p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。</p><p>由于<strong>用来计数的数组C的长度取决于待排序数组中数据的范围</strong>（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>算法的步骤如下：</p><ol><li><p>找出待排序的数组中最大和最小的元素</p></li><li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p></li><li><p>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/countingSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，<strong>尽量增大桶的数量</strong></li><li>使用的映射函数能够将输入的 <strong>N 个数据均匀的分配到 K 个桶中</strong></li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</p><p>最慢的情况：当输入的数据被分配到了同一个桶中。</p><p>示例：</p><p>元素分布在桶中：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);  <span class="comment">//桶大小是5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选出最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里的XxxSort根据情况而定</span></span><br><span class="line">            bucket = XxxSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（自动扩容）将元素加入到桶中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>下面三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/radixSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最高位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取位数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> (arr[j] % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>)     <span class="comment">//考虑正负数</span></span><br><span class="line">                    bucket += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bucket = -bucket;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容，并保存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>对磁盘中的数据进行排序。</p><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>最少只需要在内存中开辟2个输入缓冲区和一个输出缓冲区，每次将磁盘的数据块 输入到输入缓冲区，然后按 归并排序的规则，从2个输入缓冲区 每次跳出最小的数 放到输出缓冲区，当有输入缓冲区为空了，应该立刻将和它排好序的下一个数据块放到输入缓冲区中。当输出缓冲区满时，写出外存。</p><p>减少时间开销：进行<strong>K路归并排序</strong>，需要在内存中分配k个输入缓冲区和一个输出缓冲区。</p><blockquote><p>因为读写磁盘时间开销大，所以多几路可以提高效率，但也不能太多，因为需要在内存中开多个缓冲区，且每次比较都要比较这k个缓冲区的最小值</p></blockquote><p>时间开销：读写外存时间+内部排序时间+内部归并时间</p><p>优化：</p><ul><li><strong>增加归并路数k</strong><ul><li>代价1：需要增加相应的输入缓冲区</li><li>代价2：每次从k个归并段总选一个最小值需要（k-1）次比较。——<strong>可用败者树减少关键字比较次数</strong></li></ul></li><li><strong>减少初始归并段数量r</strong><ul><li>若有N个记录，内存工作区可放L个记录，则初始归并段数量 r &#x3D; N &#x2F; L ——<strong>可用 置换-选择排序 减少初始归并段</strong></li></ul></li></ul><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树解决的问题：使用多路平衡归并可減少归并趟数，但是用老土方法从k个归并段选出一个最小&#x2F;最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到 log<del>2</del>k。</p><p>败者树可视为一棵<strong>完全二又树（多了一个在根节点之上的头节点</strong>）。<strong>k个叶结点</strong>分别对应<strong>k个归并段</strong>中当前参加比较的元素，<strong>非叶子结点</strong>用来记忆<strong>左右子树中的“失败者”</strong>，而让胜者往上继续进行比较，一直到根结点。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812994.png" alt="image-20211227202553354"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812382.png" alt="image-20211227202243956"></p><h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>设初始待排文件为FI,初始归并段输出文件为FO,内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置換-选择算法的步骤如下：</p><ol><li>从FI输入w个记录到工作区WA</li><li>从WA中选出其中关键字取最小值的记录，记为 MIINIMAX记录。(MIINIMAX指不断选出的最小指中的最大值)</li><li>将 MINIMAX记录输出到FO中去。</li><li>若FI不空，则从FI输入下一个记录到WA中。</li><li>从WA中所有关键字比 MIINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li><li>重复(3)~(5),直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li><li>重复(2)~(6),直至WA为空。由此得到全部初始归并段。</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812678.png" alt="image-20211227203606666"></p><p>r</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol><li><p>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ ）。<br>(A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</p><blockquote><p>答案：A</p><p>先用指针变量q指向结点A的后继结点B，然后将结点B的值复制到结点A中，最后删除结点B。</p></blockquote></li><li><p>设有n个待排序的记录关键字，则在堆排序中需要（ ）个辅助记录单元。</p><blockquote><p>答案：1个。</p><p>堆排序只需一个辅助空间，用来记录当前操作的二叉树上的根节点的数字，来与其左右孩子节点比较。</p></blockquote></li><li><p>设某二叉树中度数为0的结点数为N0，度数为1的结点数为Nl，度数为2的结点数为N2，则下列等式成立的（ ）。</p><blockquote><p>答案：N<del>0</del> &#x3D; N<del>2</del> + 1</p></blockquote></li><li><p>设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（ ）。</p><blockquote><p>答案：log<del>2</del>n + 1</p></blockquote></li><li><p>1、数据的最小单位是（ A ）。<br>(A) 数据项<br>(B) 数据类型<br>(C) 数据元素<br>(D) 数据变量</p></li><li><p>设一棵m叉树中度数为0的结点数为N0，度数为1的结点数为N1，……，度数为m的结点数为Nm，则N0 &#x3D;（ B ）。<br>(A) Nl+N2+……+Nm<br>(B) <strong>1+N2+2N3+3N4+……+(m-1)Nm</strong><br>(C) N2+2N3+3N4+……+(m-1)Nm<br>(D) 2Nl+3N2+……+(m+1)Nm</p></li><li><p>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个。 </p><blockquote><p>解：6个</p><p>除了根节点外，其他节点均为孩子节点，而孩子节点等于总的分支数，即 孩子节点 &#x3D;  1 * n<del>1</del> + 2 * n<del>2</del>+3 * n<del>3</del> &#x3D; 10；</p><p>所以总节点数 &#x3D; 10 + 1 &#x3D; 11（1是指根节点），度数为0的节点数 &#x3D; 11 - n<del>1</del> - n<del>2</del> - n<del>3</del> &#x3D; 6;</p></blockquote></li><li><p>设顺序表的长度为n，则顺序查找的平均比较次数为（）。</p><blockquote><p>解：（n+1）&#x2F; 2</p><p>若第一个为查找元素，则查找次数为1，。。。。。所以 平均查找次数为 (1+2+3 + ….+ n) &#x2F; n&#x3D; (1+n) &#x2F; 2； </p></blockquote></li><li></li></ol><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol><li><p>通常从四个方面评价算法的质量：<u>正确性、易读性、强壮性、高效性</u>。</p></li><li><p>数据结构从逻辑上划分为三种基本类型：线性结构，树型结构，图型结构。</p></li><li><p>用链表存储二叉树，则有n个节点的二叉树共有 2n 个指针域，其中 n-1 个存放了地址，剩下的是空指针（n+1个）。</p></li><li><p>AOV网是一种 <u>有向无回路</u> 的图。</p></li><li><p>对于具有n个顶点和e条边的有向图和无向图，其对应的邻接表中，所含边节点分别有 e 和 2e 个。</p></li><li><p>在一个具有n个顶点的无向完全图中，包含有 n(n-1)&#x2F;2 条边，有n个顶点的有向完全图中，包含有 n(n-1) 条边。</p></li><li><p>设某二叉树中度数为0的节点数为 N，度数为1的节点数为 M，可得该二叉树中度数为2的节点数为 <u>N - 1</u> ，。</p></li><li><p>数据的物理结构主要包括 顺序存储结构 和 链式存储结构。</p></li><li><p>设满二叉树的深度为k， 则该树的节点数为 2^k^ - 1； 若用二叉链表作为二叉树的存储结构，设该树有 n 个节点，则一共有 n + 1个空指针域。</p></li><li><p>一个序列，经过栈的作用可以得到 C^n^<del>2n</del>&#x2F; (n+1) 中不同的输出序列。（卡特兰数）</p></li></ol><blockquote><p>如：序列有3个数，则有5中不同的输出序列。</p></blockquote><ol start="11"><li><p>设哈夫曼树有n个节点，则该树有 0 个度数为1的节点。</p></li><li><p>设有n个结点的完全二叉树，如果按照从自上到下、从左到右从1开始顺序编号，则第 i 个结点的双亲结点编号为 i &#x2F; 2 ;  右孩子结点的编号为 2i + 1。</p></li><li><p>设一组初始记录关键字为(72，73，71，23，94，16，5)，则以记录关键字72为基准的一趟快速排序结果为 </p><blockquote><p>答案：(5，16，71，23，72，94，73)</p><p>两个指针，从左开始，和从右开始，先从右开始选第一个遇到的小于基准的数，和基准数换位；换 从左开始，遇到的第一个大于基准的数，和基准换位；再从右继续……循环，直至小于基准的在左边，大于基准的在右边。</p></blockquote></li><li><p>在二叉排序树中插入一个结点的时间复杂度为 O(n)，如果该排序树即不平衡，需要遍历n个节点，如果该树很平衡，则只需log<del>2</del>n。</p></li><li><p>设初始记录关键字序列为(K1，K2，…，Kn)，则用筛选法思想建堆必须从第 <em><strong>n&#x2F;2</strong></em> 个元素开始进行筛选。</p></li><li><p>设哈夫曼树中共有99个结点，则该树中有<u>50</u> 个叶子结点；若采用二叉链表作为存储结构，则该树中有_<u>100</u>_个空指针。</p></li><li><p>设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储______m-1个队列元素；当前实际存储_____(R - F + M) % M_个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。</p></li><li><p>设顺序线性表中有n个数据元素，则第i个位置上插入一个数据元素需要移动表中 <em><strong><u>n-i+1</u></strong></em> 个数据元素；删除第i个位置上的数据元素需要移动表中 <u>n-i</u> 个元素。</p></li><li><p>根据二叉树的<u>先序和中序</u>遍历、或<u>中序和后序</u>遍历，可以唯一确定二叉树的形状。</p></li><li><p>筛选法建初始堆必须从第 n &#x2F; 2 个元素开始进行筛选。</p></li><li><p>快速排序在序列基本有序时为 O(n^2^)，在序列基本无序时为 O(nlog<del>2</del>n)。</p></li><li><p>设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有 <u>n(m-1)+1</u> 个空指针域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(others)</title>
      <link href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/"/>
      <url>/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络已由一种<strong>通信基础设施</strong>发展为一种重要的<strong>信息服务基础设施</strong>。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>网络、互联网 和 因特网：</strong></p><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><p>互连网（互联网）：多个网络通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092055783.png" alt="image-20220609205526560"></p><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><blockquote><p><strong>internet与Internet的区别</strong></p><ul><li><strong>internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是因特网(Internet)。</strong></p></blockquote><p><strong>因特网发展的三个阶段：</strong></p><p>一，从单个网络AEPANET向互联网发展</p><blockquote><p>1969年，第一个分组交换网AEPANET；</p><p>70年代中期，研究多种网络之间的互联；</p><p>1983年，TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生)</p></blockquote><p>二，逐步建成三级结构的因特网</p><blockquote><p>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网，地区网，校园网）；</p><p>1990年，ARPANET任务完成，正式关闭；</p><p>1991年，美国政府将因特网主干网交给私人公式经营，并开始对接入因特网的单位收费；</p></blockquote><p>三，逐步形成了多层次的ISP结构的因特网</p><blockquote><p>1993年，NSFNET逐渐被若干个商用因特网主干网替代，政府不再负责因特网运营，让各种<strong>因特网服务提供者ISP</strong>来运营；</p><p>1994年，万维网WWW技术促使因特网迅速发展；</p><p>1995年，NSFNET停止运作，因特网彻底商业化</p></blockquote><p><strong>因特网服务提供者ISP(Internet Service Provider)</strong></p><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过ISP接入因特网</strong></p><p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p><p><strong>因为因特网上的主机都必须有IP地址才能进行通信，所以要通过该ISP接入到因特网</strong></p><p>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</p><p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><p><strong>因特网的标准化工作：</strong></p><ul><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在指定其标准上的一个很大的特点是</p><p>面向公众。</p><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><p>因特网协会ISOC</p><p>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ul><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li><li><p>制订因特网的正式标准要经过以下<strong>4个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是RFC文档）</p><p>2、建议标准（从这个阶段开始就成为RFC文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li></ol></blockquote><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><strong>客户-服务器方式（C&#x2F;S方式）：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><hr><p>三种交换方式：</p><h4 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h4><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li><p>缓存分组</p></li><li><p>转发分组</p><p>简称为“分组转发”</p></li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><p><strong>报文交换（Message Switching）</strong></p><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><p><strong>电路交换（Circuit Switching）</strong></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h4 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h4><blockquote><p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p></blockquote><p>分析：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092111714.png" alt="image-20220609211127245"></p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><h2 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h2><p><strong>定义</strong></p><ul><li><p>计算机网络的精确定义并未统一</p></li><li><p>计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合</p><ul><li><strong>互连</strong>：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li><strong>自治</strong>：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li><strong>集合</strong>：是指至少需要两台计算机；</li></ul></li><li><p>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件</strong>（一定包含有中央处理机CPU）<strong>互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li></ul></li><li><p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</p></li></ul><p><strong>分类：</strong></p><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li><p>公用网</p></li><li><p>专用网</p></li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li><p>总线型网络</p></li><li><p>星型网络</p></li><li><p>环形网络</p></li><li><p>网状型网络</p></li></ul><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092123906.png" alt="image-20220609212320739" style="zoom:33%;" /><hr><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><blockquote><p>速率 ，带宽，吞吐量，时延<br>时延带宽积，往返时间RTT，利用率，丢包率</p></blockquote><p><strong>速率</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092129034.png" alt="image-20220609212901840"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092129544.png" alt="image-20220609212954392"></p><p><strong>带宽</strong></p><p>带宽在计算机网络中的意义：</p><p>用来表示网络的<strong>通信线路所能传送数据的能力</strong>，因此网络带宽表示在<strong>单位时间</strong>内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”；<br>单位：b&#x2F;s (kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s,Tb&#x2F;s)</p><blockquote><p>平时说的出口网速 200兆之类，就是指带宽200Mb&#x2F;s</p></blockquote><blockquote><p>带宽在模拟信号系统中的意义：</p><p>信号所包含的各种不同频率成分所占据的频率范围；<br>单位：Hz （kHz，MHz，GHz）</p></blockquote><p><strong>吞吐量</strong></p><p>吞吐量表示在<strong>单位时间内通过某个网络 (或信道、接口) 的数据量</strong>。吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量受网络的带宽或额定速率的限制。</p><blockquote><p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><p><strong>时延</strong></p><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li><strong>发送时延  &#x3D; 分组长度(b) &#x2F; 发送速率 (b&#x2F;s)</strong></li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </p><ul><li><strong>传播时延 &#x3D; 信道长度(m) &#x2F; 电磁波传播速率(m&#x2F;s)</strong></li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><blockquote><p>常见的电磁波传播速率：</p><p>自由空间： 3 * 10^8^ m&#x2F;s</p><p>铜线：2.3 * 10^8^ m&#x2F;s</p><p>光纤：2.0 * 10^8^ m&#x2F;s</p></blockquote><ul><li><strong>处理时延</strong></li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li><strong>排队时延</strong></li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><p><strong>时延带宽积</strong></p><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><blockquote><p>可以把时延带宽积看作一个圆柱体管道，传播时延是长度，带宽的圆柱面积，则时延带宽积就是圆柱的体积。</p></blockquote><p><strong>往返时间RTT</strong></p><p>互联网上的信息很多时候是双向交互的。往返时间RTT(route-trip-time)就是<strong>双向交互一次所需的时间</strong>。</p><p><strong>利用率</strong></p><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的。（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均。</li></ul><p>根据排队论，当某信道的利用率增大时，该信道的时延也会迅速增加。对此，信道利用率不是越多越好。</p><p>令U为利用率，D<del>0</del>表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用简单公司来表示： D &#x3D; D<del>0</del> &#x2F; (1-U )  或 U &#x3D; 1 - D<del>0</del>&#x2F;D</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092157958.png" alt="image-20220609215754798" style="zoom:50%;" /><p>一般ISP会控制他们的信道利用率不超过50%，否则就要准备扩容增大线路带宽。</p><p><strong>丢包率</strong></p><p>即分组丢失率，指在一定的时间范围内，传输过程中丢失的分组数量于总分组数量的比率。</p><p>分组丢失主要分为：</p><ul><li>分组在传输过程中出现误码，被节点丢弃；</li><li>分组到达一台队列已满的分组交换机时会被丢弃，在通信量较大时可能造成网络拥塞。</li></ul><hr><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>常见体系结构：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101158602.png" alt="image-20220610115806247"></p><p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092212994.png" alt="image-20220609221218825"></p><p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。只不过路由器一般只包含网络接口层和网际层。</p><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><blockquote><p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><p><strong>结构分层的必要性：</strong></p><blockquote><p>物理层：解决使用何种信号来传输比特的问题</p><p>数据链路层：解决分组在一个网络或一段链路上传输的问题</p><p>网络层：解决分组在多个网络上传输（路由）的问题</p><p>传输层：解决进程间基于网络的通信问题</p><p>应用层：解决通过应用进程的交互来实现特定网络应用的问题</p></blockquote><p><strong>物理层问题</strong>  </p><ul><li>采用怎样的传输媒体（介质）</li><li>采用在怎样的物理接口</li><li>使用怎样的信号表示比特1和0</li></ul><blockquote><p>严格来说，传输媒体并不属于物理层</p></blockquote><p><strong>数据链路层问题</strong></p><ul><li>如何标识网络中的各主机（主机编制问题，如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据</li><li>如何协调各主机争用总线（总线已被淘汰），以太网交换机如何实现</li></ul><p><strong>网络层问题</strong></p><ul><li>如何标识各网络，以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</li><li>路由器如何转发分组，如何进行路由选择</li></ul><p><strong>运输层问题</strong></p><ul><li>如何解决进程间基于网络的通信问题</li><li>出现传输错误时，如何处理</li></ul><p><strong>应用层问题</strong></p><ul><li>通过应用进程间的交互来完成特定的网络应用</li></ul><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><h3 id="结构分层思想举例"><a href="#结构分层思想举例" class="headerlink" title="结构分层思想举例"></a>结构分层思想举例</h3><p>例子：主机的浏览器如何与Web服务器进行通信</p><p><strong>解析：</strong></p><p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101216697.png" alt="image-20220610121600426"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p>第一步：</p><ul><li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li><li>应用层将HTTP请求报文交付给<strong><strong>运输层</strong></strong>处理</li></ul><p>第二步：</p><ul><li><strong>运输层</strong>给HTTP请求报文添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li><li>TCP报文段的首部格式作用是区分应用进程以及实现可靠传输</li><li>运输层将TCP报文段交付给网络层处理</li></ul><p>第三步：</p><ul><li><strong>网络层</strong>给TCP报文段添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li><li>IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发</li><li>网络层将IP数据报交付给数据链路层处理</li></ul><p>第四步：</p><ul><li><strong>数据链路层</strong>给IP数据报添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> </li><li>该<strong>首部的作用</strong>主要是为了让帧能够在一段链路上或一个网络上<strong>传输</strong>，能够被相应的目的主机<strong>接收</strong></li><li>该<strong>尾部的作用</strong>是让目的主机检查所接收到的<strong>帧是否有误码</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，并在该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li>物理层将装有前导码的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul><p><strong>2、路由器转发</strong></p><p>在路由器中</p><ul><li><p><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></p></li><li><p><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></p></li><li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p></li><li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p></li><li><p><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></p></li><li><p><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p></li><li><p>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></p></li></ul><p><strong>3、接收方接收</strong></p><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><blockquote><p>发回响应报文的步骤和之前过程类似</p></blockquote><h3 id="结构中的专用术语"><a href="#结构中的专用术语" class="headerlink" title="结构中的专用术语"></a>结构中的专用术语</h3><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p>实体：任何可发送或接受信息的硬件或软件进程；</p><p>对等实体：收发双方相同层次中的实体。</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101225613.png" alt="image-20220610122556298" style="zoom:50%;" /><p><strong>协议</strong></p><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101226924.png" alt="image-20220610122641613" style="zoom: 50%;" /><p><strong>服务</strong></p><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务；要实现本层协议，还需要实现下面一层所提供的服务。</p><blockquote><p>协议是水平的，服务的垂直的。</p><p>实体看的见相邻下层所提供的服务，但并不知道实现该服务的具体协议。</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101425791.png" alt="image-20220610142535580"></p><p>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</p><ul><li>数据链路层的服务访问点为 帧的“类型”字段；</li><li>网络层的服务访问点为 IP数据报首部的“协议字段”</li><li>运输层的服务访问点为 “端口号”</li></ul><p>服务原语：上层使用下层所提供的服务必须通过与下层交换的 一些命令。</p><p>协议数据单元PDU：对等层次之间传送的数据包。</p><p>服务数据单元SDU：同一系统内，层与层之间交换的数据报。</p><blockquote><p>多个SDU可以合成为一个PDU，一个SDU也可以划分为几个PDU</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101435104.png" alt="image-20220610143542921"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="体系结构题目"><a href="#体系结构题目" class="headerlink" title="体系结构题目"></a>体系结构题目</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816036.png" alt="image-20201007230219248"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816006.png" alt="image-20201007230242426"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816577.png" alt="image-20201007230300194"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816509.png" alt="image-20201007230345580"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816604.png" alt="image-20201007230404271"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816327.png" alt="image-20201007230432453"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816796.png" alt="image-20201007230450993"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816958.png" alt="image-20201007230511370"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817497.png" alt="image-20201007230548012"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817672.png" alt="image-20201007230616796"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817303.png" alt="image-20201007230635007"></p><h3 id="时延相关题目"><a href="#时延相关题目" class="headerlink" title="时延相关题目"></a>时延相关题目</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817503.png" alt="image-20201007230747143"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817860.png" alt="image-20201007231024960"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817068.png" alt="image-20201007230843470"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817264.png" alt="image-20201007231125552"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817817.png" alt="image-20201007231159268"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817500.png" alt="image-20201007231234486"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817962.png" alt="image-20201007231318549"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817733.png" alt="image-20201007231338817"></p><hr><hr><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</p><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</p><p>物理层协议的主要任务：</p><ul><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li><li><strong>电器特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li></ul><hr><p><strong>物理层下面的传输媒体</strong></p><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。可分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><p><strong>导引型传输媒体——</strong> 同轴电缆，双绞线，光纤，电力线</p><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820064.png" alt="image-20201008132050917"></p><p><strong>双绞线</strong></p><p>绞合的作用：抵御外部的电磁波干扰，减少相邻导线的电磁干扰</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820943.png" alt="image-20201008132225715"></p><p><strong>光纤</strong></p><p>光纤的优点：</p><ul><li>通信容量大(25000~30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820250.png" alt="image-20201008132403903"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820991.png" alt="image-20201011001240573"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><strong>电力线</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820364.png" alt="image-20201008132709015"></p><p>**非导引型传输媒体—— ** 无线电波，微波，红外线，可见光</p><p>非导引型传输媒体是指自由空间。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820859.png" alt="image-20201008132857833"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820579.png" alt="image-20201008132943176"></p><p><strong>无线电波</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821443.png" alt="image-20201008133135659"></p><p><strong>微波</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821980.png" alt="image-20201008133317293"></p><p><strong>红外线</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821480.png" alt="image-20201008133421986"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821992.png" alt="image-20201008133718810"></p><hr><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h3><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h3 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h3><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p><ul><li>外同步：在收发双方之间添加一个单独的时钟信号线；</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（如曼切斯特编码）</li></ul><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><blockquote><p>字节间异步（字节间的时间间隔不固定）</p><p>但字节中的每个比特仍是同步的（各比特的持续时间相同）</p></blockquote><h3 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即<strong>只能有一个方向的通信而没有反方向的交互</strong>。无线电广播或有线电以及电视广播就属于这种类型</p></li><li><p><strong>双向交替通信</strong>：</p></li></ul><p>  又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但<strong>不能双方同时发送</strong>（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来。</p><ul><li><strong>双向同时通信</strong>：</li></ul><p>  又称为<strong>全双工通信</strong>，即通信的双发<strong>可以同时发送和接收信息</strong>。</p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201822780.png" alt="image-20201008144616896"></p><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><p>简单的说，码元就是构成信号的一段波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p></li></ul><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输。</p><ul><li><strong>编码</strong>：不改变信号性质，仅对数字基带信号的波形进行变换。编码后产生的信号仍为数字信号。</li><li><strong>调制</strong>：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号。</li></ul><h3 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h3><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li></ul><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p><strong>不归零编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823868.png" alt="image-20201008150058039"></p><ul><li><p>正电平表示比特1&#x2F;0</p></li><li><p>负电平表示比特0&#x2F;1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p>实际比特1和比特0的表示要看现实怎么规定。</p><blockquote><p>接收端如何判断连续的高或低电平是多少个码元？</p><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li>但是对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823665.png" alt="image-20201008195033189"></p><p>每个码元传输结束后信号都要“归零”。</p><blockquote><p>归零编码虽然自同步，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823274.png" alt="image-20201008195148727"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1&#x2F;0</li><li>正跳变表示比特0&#x2F;1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823543.png" alt="image-20201008195235561"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1&#x2F;0</li><li>不变化表示比特0&#x2F;1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824797.png" alt="image-20201008155429044"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p>对于频率，相位，振幅：</p><p>因为频率和相位是相关的，即频率是随时间的变化率，所以一次只能调制频率和相位两个中的一个。</p><p>而<strong>相位和振幅是可以一起调制</strong>的，称为<strong>正交振幅调制QAM</strong>。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824483.png" alt="image-20201008155955169"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824648.png" alt="image-20201008160133748"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828876.png" alt="image-20201008160208060"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828564.png" alt="image-20201010204336400"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p>奈氏准则和香农公式</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828574.png" alt="image-20201010204818976"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828860.png" alt="image-20201010204928756"></p><p>奈氏准则和香农公式对比：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829903.png" alt="image-20201010205029346"></p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829130.png" alt="image-20201011001949479"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829906.png" alt="image-20201011002236208"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829227.png" alt="image-20201011002540041"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829160.png" alt="image-20201011002842704"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829046.png" alt="image-20201011002953703"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830773.png" alt="image-20201011003214653"></p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p>物理层的基本概念：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830239.png" alt="image-20201010213213489"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830843.png" alt="image-20201010213423319"></p><p>信道的极限容量习题：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831374.png" alt="image-20201010205425612"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831817.png" alt="image-20201010205914234"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831990.png" alt="image-20201010210031254"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831754.png" alt="image-20201010210217898"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832708.png" alt="image-20201010210350902"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>概述：</p><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832281.png" alt="image-20201011102531462"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832208.png" alt="image-20201014004326549"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832305.png" alt="image-20201011102618878"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832076.png" alt="image-20201011102653161"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832730.png" alt="image-20201011102733584"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832446.png" alt="image-20201014004459744"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><p>三个重要问题：封装成帧，差错控制，可靠传输</p><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201833689.png" alt="image-20201011103650253"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834092.png" alt="image-20201011103917512"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834059.png" alt="image-20201011105314053"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834929.png" alt="image-20201011105824466"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835050.png" alt="image-20201011110017415"></p><p>还有数据碰撞问题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835279.png" alt="image-20201011110129994"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p><p>在无线局域网中仍然使用的是共享信道技术</p></blockquote><hr><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><strong>帧头和帧尾中包含有重要的控制信息</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835745.png" alt="image-20201011110851301"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835483.png" alt="image-20201011111334052"></p><p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835950.png" alt="image-20201011111729324"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835266.png" alt="image-20201011112450187"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835838.png" alt="image-20201011113207944"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835258.png" alt="image-20201011113804721"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul><p><strong>帧的数据部分长度</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835162.png" alt="image-20201011115008209"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835744.png" alt="image-20201011115049672"></p><hr><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836377.png" alt="image-20201011133757804"></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836792.png" alt="image-20201011234428217"></p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836931.png" alt="image-20201011234605045"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836456.png" alt="image-20201011234701845"></p><p><strong>例题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836330.png" alt="image-20201011235128869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836299.png" alt="image-20201011235325022"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836992.png" alt="image-20201011235726437"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>下面是比特差错</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837668.png" alt="image-20201012153605893"></p><p><strong>其他传输差错</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837902.png" alt="image-20201012153811724"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837434.png" alt="image-20201012154910921"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837981.png" alt="image-20201012155300937"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837448.png" alt="image-20201012160026362"></p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><h5 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h5><p><strong>确认与否认</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837618.png" alt="image-20201012162009780" style="zoom:67%;" /><p><strong>超时重传</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838548.png" alt="image-20201012162112151" style="zoom:67%;" /><p><strong>确认丢失</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838886.png" alt="image-20201012162318298" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838138.png" alt="image-20201012162348428" style="zoom:67%;" /><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838714.png" alt="image-20201012162815885" style="zoom:67%;" /><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838787.png" alt="image-20201012164008780"></p><h5 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838614.png" alt="image-20201012164924635"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838894.png" alt="image-20201012181005719"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839189.png" alt="image-20201012181047665"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h5><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839407.png" alt="image-20201012190027828"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839877.png" alt="image-20201012190632086"></p><h5 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h5><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839295.png" alt="image-20201012191936466"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840102.png" alt="image-20201012192932035"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840642.png" alt="image-20201012193212419"></p><h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840820.png" alt="image-20201012194304696"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h5><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840684.png" alt="image-20201012195440780"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840224.png" alt="image-20201012195629368"></p><p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840568.png" alt="image-20201012195836902"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840802.png" alt="image-20201012200120166"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840452.png" alt="image-20201012200454557"></p><p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840611.png" alt="image-20201012201109774"></p><p>习题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841879.png" alt="image-20201012202419107"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841136.png" alt="image-20201012202222138"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841235.png" alt="image-20201012203638722"></p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p><p><strong>习题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841142.png" alt="image-20201012205250996"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841680.png" alt="image-20201012204742870"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841365.png" alt="image-20201012205133924"></p><hr><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841059.png" alt="image-20201012210844629"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841191.png" alt="image-20201012211423528"></p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>必须规定特殊的字符作为帧定界符</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842227.png" alt="image-20201012211826281"></p><h3 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h3><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842132.png" alt="image-20201012212148803"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842896.png" alt="image-20201012212255550"></p><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842191.png" alt="image-20201012212558654"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842702.png" alt="image-20201012213021860"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h2 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h2><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842052.png" alt="image-20201013201521915"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842967.png" alt="image-20201013201533445"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843155.png" alt="image-20201013201133903"></p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843066.png" alt="image-20201013152007335"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843815.png" alt="image-20201013152453425"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p><strong>信道复用</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843541.png" alt="image-20201013153642544"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843603.png" alt="image-20201013153947668"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843265.png" alt="image-20201013154142540"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843757.png" alt="image-20201013202218132"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843093.png" alt="image-20201013203126625"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844662.png" alt="image-20201013203324709"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102991.png" alt="image-20201013203459640"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844943.png" alt="image-20201013203819578"></p><h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844121.png" alt="image-20201013211620687"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844069.png" alt="image-20201013213102777"></p><h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844417.png" alt="image-20201013215400688"></p><h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844253.png" alt="image-20201013215530979"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845220.png" alt="image-20201013221240514"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845573.png" alt="image-20201013221834942"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h4 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845196.png" alt="image-20201013221705893"></p><h4 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845009.png" alt="image-20201013223235305"></p><h4 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845970.png" alt="image-20201013224051932"></p><h4 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845234.png" alt="image-20201013225400777"></p><h4 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846259.png" alt="image-20201013230717856"></p><h4 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846454.png" alt="image-20201013231430295"></p><h4 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846704.png" alt="image-20201013231703302"></p><h4 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p><h4 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846916.png" alt="image-20201014192811760"></p><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846204.png" alt="image-20201014200149717"></p><h4 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846513.png" alt="image-20201014200833233"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847394.png" alt="image-20201014201511741"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847865.png" alt="image-20201014201927680"></p><h4 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847251.png" alt="image-20201014202213766"></p><p><strong>退避算法的示例</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847562.png" alt="image-20201014202819851"></p><h4 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847732.png" alt="image-20201014203119710"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847138.png" alt="image-20201014203506878"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847909.png" alt="image-20201014203859033"></p><hr><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848054.png" alt="image-20201014222831663"></p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848361.png" alt="image-20201014223659993"></p><h4 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848447.png" alt="image-20201014224732019"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848580.png" alt="image-20201014225358570"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong>网络接口标识符</strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849458.png" alt="image-20201014230248959"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849957.png" alt="image-20201014230625182"></p><h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849376.png" alt="image-20201014230822305"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849241.png" alt="image-20201014231244655"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849435.png" alt="image-20201014231754669"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849979.png" alt="image-20201014232132424"></p><blockquote><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850865.png" alt="image-20201014232714791"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850050.png" alt="image-20201015001243584"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850804.png" alt="image-20201015001535528"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850938.png" alt="image-20201015002054876"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址属于网 络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136208.png" alt="image-20201015104441580"></p><h4 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136442.png" alt="image-20201015104913755"></p><h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136019.png" alt="image-20201015105455043"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136695.png" alt="image-20210103212224961"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137675.png" alt="image-20201015113826197"></p><p>ARP高速缓存表</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137411.png" alt="image-20201015114052206"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137758.png" alt="image-20201015114444263"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137663.png" alt="image-20201015114811501"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137915.png" alt="image-20201015115212170"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137213.png" alt="image-20201015115236673"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137862.png" alt="image-20201015115252972"></p><p>动态与静态的区别</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137135.png" alt="image-20201015115831543"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137959.png" alt="image-20201015120108028"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137362.png" alt="image-20201015120707150"></p><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><hr><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138058.png" alt="image-20201015144628691"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h4 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h4><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138728.png" alt="image-20201015145732275"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138344.png" alt="image-20201015150620067"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h4 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138342.png" alt="image-20201015152232158"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138603.png" alt="image-20201015152858146"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138172.png" alt="image-20201015153907268"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138132.png" alt="image-20201015154523036"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138199.png" alt="image-20201015155408692"></p><p><strong>广播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138404.png" alt="image-20201015155440402"></p><p><strong>多个单播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138655.png" alt="image-20201015155526386"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138589.png" alt="image-20201015155706698"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138900.png" alt="image-20201015160146482"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138739.png" alt="image-20201015160526999"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138019.png" alt="image-20201015161015165"></p><h3 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h3><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139714.png" alt="image-20201015161458528"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138052.png" alt="image-20201015162310922"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139151.png" alt="image-20201015162622462"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139175.png" alt="image-20201015163157140"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139956.png" alt="image-20201015164210543"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139732.png" alt="image-20201015170656500"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139056.png" alt="image-20201015170739679"></p><hr><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><h3 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139171.png" alt="image-20201015171453001"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139047.png" alt="image-20201015171515481"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139916.png" alt="image-20201015171900775"></p><h3 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139764.png" alt="image-20201015172204419"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140370.png" alt="image-20201015202257756"></p><hr><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140175.png" alt="image-20201015202859124"></p><p><strong>分割广播域的方法</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140409.png" alt="image-20201015203113654"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140285.png" alt="image-20201015203559548"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140278.png" alt="image-20201015204639599"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140318.png" alt="image-20201015204749141"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140563.png" alt="image-20201015205311757"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140910.png" alt="image-20201015205947636"></p><p><strong>小例题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140498.png" alt="image-20201015210417695"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140897.png" alt="image-20201015211031361"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140495.png" alt="image-20201015211349531"></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140189.png" alt="image-20201015211512622"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol></blockquote><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><h3 id="封装成帧习题"><a href="#封装成帧习题" class="headerlink" title="封装成帧习题"></a>封装成帧习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141621.png" alt="image-20201011114856991"></p><h3 id="差错检测习题"><a href="#差错检测习题" class="headerlink" title="差错检测习题"></a>差错检测习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141534.png" alt="image-20201011235128869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141798.png" alt="image-20201011235325022"></p><h3 id="可靠传输习题"><a href="#可靠传输习题" class="headerlink" title="可靠传输习题"></a>可靠传输习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102392.png" alt="image-20201012181005719"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141698.png" alt="image-20201012182002090"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141804.png" alt="image-20201012202419107"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141578.png" alt="image-20201012205250996"></p><h3 id="媒体接入控制习题"><a href="#媒体接入控制习题" class="headerlink" title="媒体接入控制习题"></a>媒体接入控制习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141212.png" alt="image-20201013203459640"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141265.png" alt="image-20201013204352725"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141599.png" alt="image-20201013205054730"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141363.png" alt="image-20201013232656202"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141094.png" alt="image-20201013232840109"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141269.png" alt="image-20201013233632636"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141947.png" alt="image-20201014204557440"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141898.png" alt="image-20201014204839055"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141187.png" alt="image-20201014204939865"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102983.png" alt="image-20201014224410943"></p><h3 id="MAC地址、IP地址以及ARP协议习题"><a href="#MAC地址、IP地址以及ARP协议习题" class="headerlink" title="MAC地址、IP地址以及ARP协议习题"></a>MAC地址、IP地址以及ARP协议习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142430.png" alt="image-20201015110420372"></p><h3 id="以太网交换机自学习和转发帧的流程-1"><a href="#以太网交换机自学习和转发帧的流程-1" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142915.png" alt="image-20201015164846227"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142603.png" alt="image-20201015165218663"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142639.png" alt="image-20201015170131492"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142421.png" alt="image-20201017134630948"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142155.png" alt="image-20201017135644630"></p><ul><li>路由选择问题</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142899.png" alt="image-20201017135710478"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142162.png" alt="image-20201017135914985"></p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142418.png" alt="image-20201017142545630"></p><blockquote><p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142125.png" alt="image-20201017140623851"></p><hr><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li></ul><h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142954.png" alt="image-20201017141425892"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142664.png" alt="image-20201017141851030"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h3 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h3><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142076.png" alt="image-20201017143206060"></p><h3 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143571.png" alt="image-20201017144317166"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143355.png" alt="image-20201017145210533"></p><p><strong>B类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102164.png" alt="image-20201017145508001"></p><p><strong>C类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143066.png" alt="image-20201017150204774"></p><p><strong>练习</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143152.png" alt="image-20201017150543386"></p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>IP 地址的指派范围</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143626.png" alt="image-20201017152911541"></p><p><strong>一般不使用的特殊的 IP 地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143431.png" alt="image-20201017152959586"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><h4 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143914.png" alt="image-20201017154645198"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143642.png" alt="image-20201017154852896"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143283.png" alt="image-20201017155026814"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。</li></ul></blockquote><h4 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h4><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143325.png" alt="image-20201017155930011"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143933.png" alt="image-20201017160116239"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143413.png" alt="image-20201017160252066"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143377.png" alt="image-20201017161651058"></p><p>例子2</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143929.png" alt="image-20201017161719339"></p><p><strong>默认子网掩码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144827.png" alt="image-20201017162807076"></p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144957.png" alt="image-20201017162938612"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h4><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144773.png" alt="image-20201017164031532"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li></ul></blockquote><h4 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144818.png" alt="image-20201017165037268"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144385.png" alt="image-20201017165113442"></p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144984.png" alt="image-20201017165615915"></p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144727.png" alt="image-20201017170552495"></p><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><h4 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144640.png" alt="image-20201018143550103"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144885.png" alt="image-20201018140809079"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144054.png" alt="image-20201018140916631"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144749.png" alt="image-20201018141132446"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p></blockquote><h4 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144829.png" alt="image-20201018143632352"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144019.png" alt="image-20201018142333145"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144315.png" alt="image-20201018143344440"></p><hr><h2 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144538.png" alt="image-20201018144335297"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144393.png" alt="image-20201018151314019"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144091.png" alt="image-20201018150151171"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145423.png" alt="image-20201018150223497"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102692.png" alt="image-20201018145501063"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145850.png" alt="image-20201018150029179"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145151.png" alt="image-20201018151108989"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145272.png" alt="image-20201018151528027"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145885.png" alt="image-20201018151956275"></p><p>路由器是隔离广播域的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145075.png" alt="image-20201018152040610"></p><hr><h2 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145422.png" alt="image-20201018155702081"></p><h3 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h3><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145136.png" alt="image-20201018160349375"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145293.png" alt="image-20201018160906284"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145925.png" alt="image-20201018161440257"></p><blockquote><p>多条路由可选，匹配路由最具体的</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145060.png" alt="image-20201018161542579"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145063.png" alt="image-20201018162041966"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103223.png" alt="image-20201018162333671"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145038.png" alt="image-20201018162759562"></p><p>错误情况</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145591.png" alt="image-20201018163323343"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145392.png" alt="image-20201018163933715"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145058.png" alt="image-20201018164453398"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145273.png" alt="image-20201018164811811"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146199.png" alt="image-20201018164913684"></p><p>解决方法</p><p>添加故障的网络为黑洞路由</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146545.png" alt="image-20201018165122023"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146380.png" alt="image-20201018165153517"></p><p>假设。一段时间后故障网络恢复了</p><p>R1又自动地得出了其接口0的直连网络的路由条目</p><p>针对该网络的黑洞网络会自动失效</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146323.png" alt="image-20201018165328319"></p><p>如果又故障</p><p>则生效该网络的黑洞网络</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146375.png" alt="image-20201018165521938"></p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146543.png" alt="image-20201018165709294"></p><hr><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146916.png" alt="image-20201019134827343"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146505.png" alt="image-20201019134946971"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146310.png" alt="image-20201019135122326"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146733.png" alt="image-20201019135328925"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146209.png" alt="image-20201019140009740"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146950.png" alt="image-20201019140234652"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146852.png" alt="image-20201019141149194" style="zoom:50%;" /><p>物理层将信号转换成比特流，送交数据链路层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146584.png" alt="image-20201019141210774" style="zoom: 50%;" /><p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146443.png" alt="image-20201019141242246" style="zoom:50%;" /><p>  如果送交网络层的分组是普通待转发的数据分组</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146012.png" alt="image-20201019141305650" style="zoom:50%;" /><p>   则根据分组首部中的目的地址进行查表转发</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146996.png" alt="image-20201019141327380" style="zoom:50%;" /><p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p></li><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146712.png" alt="image-20201019141745375" style="zoom:50%;" /><p>数据链路层将数据分组封装成帧，交给物理层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147738.png" alt="image-20201019141838032" style="zoom:50%;" /><p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p></li></ul><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147346.png" alt="image-20201019143040253"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147888.png" alt="image-20201019142228360" style="zoom:50%;" /><p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147781.png" alt="image-20201019142415055"></p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147895.png" alt="image-20201019142924889"></p></li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147697.png" alt="image-20201019144915687"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159586.png" alt="image-20201019145247606"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159219.png" alt="image-20201019145510947"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159339.png" alt="image-20201019145627339"></p><blockquote><p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200780.png" alt="image-20201019150120900"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200091.png" alt="image-20201019150412666"></p><p>举例2</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200777.png" alt="image-20201019150525711"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200128.png" alt="image-20201019151041492"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200717.png" alt="image-20201019151135255"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200320.png" alt="image-20201019151332767"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200545.png" alt="image-20201019151639181"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200548.png" alt="image-20201019152526098"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200244.png" alt="image-20201019161841695"></p><p><strong>问候（Hello）分组</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200585.png" alt="image-20201019161653875"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200277.png" alt="image-20201019162341151"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200131.png" alt="image-20201019162933483"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200046.png" alt="image-20201019163148068"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103702.png" alt="image-20201019163250129"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200953.png" alt="image-20201019163746254"></p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200826.png" alt="image-20201019164657606"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200436.png" alt="image-20201019170100568"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201556.png" alt="image-20201019170217622"></p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201816.png" alt="image-20201019191438399"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201342.png" alt="image-20201019191718506"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201443.png" alt="image-20201019191836397"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201643.png" alt="image-20201019192031087"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201648.png" alt="image-20201019192059962"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201534.png" alt="image-20201019192840368"></p><h3 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201784.png" alt="image-20201019192800829"></p><hr><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><h3 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201646.png" alt="image-20201019205931748"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201149.png" alt="image-20201019211719880"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201065.png" alt="image-20201019212617006"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201308.png" alt="image-20201019220435415"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201665.png" alt="image-20201019221021157"></p><p>​        现在假定分片2的IP数据报经过某个网络时还需要进行分片</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201471.png" alt="image-20201019221246870"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201363.png" alt="image-20201019222512112"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201290.png" alt="image-20201019222552444"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202265.png" alt="image-20201019222729797"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202402.png" alt="image-20201019223101434"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202510.png" alt="image-20201019225141559"></p><hr><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202306.png" alt="image-20201019232539898"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202517.png" alt="image-20201020001035813"></p><h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202270.png" alt="image-20201019230838587"></p><h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202289.png" alt="image-20201019231022291"></p><h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202565.png" alt="image-20201019231230798"></p><h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202256.png" alt="image-20201019231355471"></p><h4 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202910.png" alt="image-20201019231553990"></p><h4 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202227.png" alt="image-20201019231733673"></p><h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202208.png" alt="image-20201019233817921"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202658.png" alt="image-20201019234123026"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202439.png" alt="image-20201019234718107"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203184.png" alt="image-20201019234741268"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203507.png" alt="image-20201019234758693"></p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203373.png" alt="image-20201019234909146"></p><hr><h2 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h3><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203221.png" alt="image-20201019235534728"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203199.png" alt="image-20201019235631474"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203051.png" alt="image-20201019235718010"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203532.png" alt="image-20201020000136443"></p><blockquote><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203609.png" alt="image-20201020000618797"></p><p>部门A向部门B发送数据流程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203083.png" alt="image-20201020001107425"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203813.png" alt="image-20201020001528569"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203256.png" alt="image-20201020001935801"></p><h3 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203331.png" alt="image-20201020002020607"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203215.png" alt="image-20201020002439942"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203339.png" alt="image-20201020002734192"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203296.png" alt="image-20201020003238729"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203259.png" alt="image-20201020003411024"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203895.png" alt="image-20201020003658349"></p><p>这种基本转换存在一个问题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203017.png" alt="image-20201020003733863"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203526.png" alt="image-20201020003840584"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204315.png" alt="image-20201020004159360"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204805.png" alt="image-20201020004312942"></p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204532.png" alt="image-20201020004447021"></p><h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><h3 id="IPv4习题"><a href="#IPv4习题" class="headerlink" title="IPv4习题"></a>IPv4习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204392.png" alt="image-20201017151024579"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204149.png" alt="image-20201017151500372"></p><blockquote><p>题目的注意点</p><p><strong>本题按照节约原则</strong></p><p>路由器的接口也要分配一个IP地址</p><p>所以橙色网络的IP地址数量是 65534 + 1 &#x3D; 65535，同理 蓝色网络的是 255 个，绿色网络（交换式以太网）的是 16 + 24 + 1 &#x3D; 41 个，红色网络（两台路由器通过一段链路直连，它们的直连接口也属于一个网络）是 2 个</p><p>分配IP地址不能相同</p><p>不能出现两个一样的网络号</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204613.png" alt="image-20201017161733295"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204915.png" alt="image-20201017162644758"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204956.png" alt="image-20201017165224804"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204998.png" alt="image-20201017170339534"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204982.png" alt="image-20201017170516701"></p><h3 id="IP数据报的发送和转发过程-1"><a href="#IP数据报的发送和转发过程-1" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204474.png" alt="image-20201018152326777"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204995.png" alt="image-20201018152504951"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103142.png" alt="image-20201018152811812"></p><h3 id="路由选择协议-1"><a href="#路由选择协议-1" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204524.png" alt="image-20201019150738458"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204229.png" alt="image-20201019152221295"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204574.png" alt="image-20201019192349770"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204352.png" alt="image-20201019192546327"></p><h3 id="IPv4数据报的首部格式-1"><a href="#IPv4数据报的首部格式-1" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204163.png" alt="image-20201019223719168"></p><blockquote><p>780&#x2F;8向下取整等于97</p><p>97*8 &#x3D; 776</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205086.png" alt="image-20201019224949922"></p><h3 id="网际控制报文协议ICMP-1"><a href="#网际控制报文协议ICMP-1" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205294.png" alt="image-20201019232300815"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><p><strong>进程之间的通信</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205838.png" alt="image-20201020211725185" style="zoom:67%;" /><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205927.png" alt="image-20201020211339131"></p><p><strong>进程之间通信流程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205734.png" alt="image-20201020213721054"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205206.png" alt="image-20201020220439303"></p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205023.png" alt="image-20201020220545411"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205119.png" alt="image-20201020222828878"></p><hr><h2 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h2><h3 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205780.png" alt="image-20201020223242364"></p><h3 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205662.png" alt="image-20201020223920225"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h3 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205858.png" alt="image-20201020224521744"></p><h3 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h3><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205262.png" alt="image-20201020224658524"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205805.png" alt="image-20201020225830336"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205637.png" alt="image-20201020230059196"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205063.png" alt="image-20201020231032812"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205474.png" alt="image-20201020231308120"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205335.png" alt="image-20201020231935656"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205940.png" alt="image-20201020232517383"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205718.png" alt="image-20201020232132890"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206490.png" alt="image-20201020232548833"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206268.png" alt="image-20201020232337332"></p><hr><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li></ul><p>可靠信道与不可靠信道</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206322.png" alt="image-20201021192221061"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206996.png" alt="image-20201021193640130"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h3 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h3><p>可以发送广播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206740.png" alt="image-20201021194104694" style="zoom: 50%;" /><p>可以向某个多播组发送多播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206379.png" alt="image-20201021194225567" style="zoom:50%;" /><p>还可以发送单播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206513.png" alt="image-20201021194341256" style="zoom:50%;" /><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206431.png" alt="image-20201021195034383"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206471.png" alt="image-20201021204152175"></p><p>UDP结构</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206342.png" alt="image-20201021205214512"></p><h3 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h3><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206928.png" alt="image-20201021194557102" style="zoom:50%;" /><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206359.png" alt="image-20201021194749562" style="zoom:50%;" /><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206050.png" alt="image-20201021195435677"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206491.png" alt="image-20201021204508839"></p><p>TCP结构</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206112.png" alt="image-20201021205307406"></p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207577.png" alt="image-20201023004653315"></p><hr><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207073.png" alt="image-20201021223432091"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207882.png" alt="image-20201021231801076"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207604.png" alt="image-20201021231904707"></p><p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103829.png" alt="image-20201021231945653"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103375.png" alt="image-20201021232027721"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103814.png" alt="image-20201021232600497"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103574.png" alt="image-20201021232645300"></p><blockquote><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></blockquote><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103652.png" alt="image-20201021234004254"></p><hr><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103929.png" alt="image-20201022141057083"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103604.png" alt="image-20201022142108309"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104447.png" alt="image-20201022141423443"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104250.png" alt="image-20201022141556134"></p><blockquote><p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><h5 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h5><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109242.png" alt="image-20201022145631052"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104406.png" alt="image-20201022144725100"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104418.png" alt="image-20201022150143886"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104769.png" alt="image-20201022145749592"></p><p>这个时候又回到了慢开始</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104855.png" alt="image-20201022145544163"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104111.png" alt="image-20201022145824004"></p><h5 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104118.png" alt="image-20201022150236926"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104896.png" alt="image-20201022150902709"></p><h5 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109112.png" alt="image-20201022151250183"></p><h5 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104801.png" alt="image-20201022151819265"></p><h5 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104335.png" alt="image-20201022152041751"></p><hr><h2 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104854.png" alt="image-20201022152651184"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104075.png" alt="image-20201022152708875"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104379.png" alt="image-20201022153244047"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104395.png" alt="image-20201022153518218"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104356.png" alt="image-20201022153758413"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104634.png" alt="image-20201022154045440"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104875.png" alt="image-20201022154137911"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104017.png" alt="image-20201022154350745"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104292.png" alt="image-20201022154418863"></p><hr><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105424.png" alt="image-20201022161436801"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105231.png" alt="image-20201022161734997"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105357.png" alt="image-20201022164339902"></p><hr><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105494.png" alt="image-20201022193215183"></p><h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h4 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109760.png" alt="image-20201022193418673"></p><h4 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105786.png" alt="image-20201022194219693"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105116.png" alt="image-20201022194350899"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105666.png" alt="image-20201022194926877"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105383.png" alt="image-20201022195108616"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105987.png" alt="image-20201022195847144"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105453.png" alt="image-20201022202010182"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105501.png" alt="image-20201022202932905"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105669.png" alt="image-20201022203744174"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105664.png" alt="image-20201022204422775"></p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h4 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105712.png" alt="image-20201022205124204"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105153.png" alt="image-20201022210030419"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105425.png" alt="image-20201022232158631"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105761.png" alt="image-20201022233050922"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105795.png" alt="image-20201022233941557"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105899.png" alt="image-20201022234741310"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105753.png" alt="image-20201022234942562"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h4 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h4><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105118.png" alt="image-20201022235800155"></p><hr><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105209.png" alt="image-20201023000859363"></p><h3 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><p>源端口和目的端口</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105005.png" alt="image-20201023005210010"></p><p>序号、确认号和确认标志位</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105887.png" alt="image-20201023003826059"></p><p>数据偏移、保留、窗口和校验和</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106212.png" alt="image-20201023004227265"></p><p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106148.png" alt="image-20201023005001450"></p><p>选项和填充</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106152.png" alt="image-20201023005132426"></p><h2 id="TCP的流量控制-1"><a href="#TCP的流量控制-1" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106867.png" alt="image-20201021233918057"></p><h2 id="TCP的拥塞控制-1"><a href="#TCP的拥塞控制-1" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109288.png" alt="image-20201022152255103"></p><h2 id="TCP可靠传输的实现-1"><a href="#TCP可靠传输的实现-1" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106986.png" alt="image-20201022163045361"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106939.png" alt="image-20201022164057627"></p><h2 id="TCP的运输连接管理-1"><a href="#TCP的运输连接管理-1" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106225.png" alt="image-20201022204336098"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106569.png" alt="image-20201023195112701"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106908.png" alt="image-20201023200511781"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106981.png" alt="image-20201023200819770"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106076.png" alt="image-20201023201028141"></p><p>常见的应用</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106165.png" alt="image-20201023201101024"></p><p>总结</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106303.png" alt="image-20201023201137047"></p><hr><h2 id="客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h2><h3 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106479.png" alt="image-20201023201308269"></p><h3 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106472.png" alt="image-20201023201610088"></p><h3 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106650.png" alt="image-20201023202017683"></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106641.png" alt="image-20201023202049202"></p><hr><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h3 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h3><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106291.png" alt="image-20201023205719672"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106375.png" alt="image-20201023210345650"></p><h3 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h3><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110903.png" alt="image-20201023211525686"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106009.png" alt="image-20201023213058543"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110726.png" alt="image-20201023214542329"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107981.png" alt="image-20201023215341522"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107820.png" alt="image-20201023215652859"></p></blockquote><p>剩下流程图示</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107359.png" alt="image-20201023220114952"></p><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107631.png" alt="image-20201023221111923"></p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107088.png" alt="image-20201023221251022"></p><hr><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>域名相比IP地址更容易记忆</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107866.png" alt="image-20201023234832678"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107594.png" alt="image-20201023235123151"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107384.png" alt="image-20201023235231869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107412.png" alt="image-20201023235457857"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110026.png" alt="image-20201023235617575"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107303.png" alt="image-20201023235910545"></p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107162.png" alt="image-20201024000255580"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107018.png" alt="image-20201024000335147"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107997.png" alt="image-20201024000408396"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107763.png" alt="image-20201024002135210"></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107450.png" alt="image-20201024002224354"></p><hr><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><h3 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107047.png" alt="image-20201024132745558"></p><h3 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h3><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107714.png" alt="image-20201024133155327" style="zoom:50%;" /><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107071.png" alt="image-20201024133247537" style="zoom:50%;" /><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107982.png" alt="image-20201024133400777"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107875.png" alt="image-20201024133601943"></p><h3 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h3><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107109.png" alt="image-20201024134319922"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110318.png" alt="image-20201024134624114"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107237.png" alt="image-20201024135018620" style="zoom:67%;" /><p>两种模式对比</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107529.png" alt="image-20201024135050743"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108898.png" alt="image-20201024135848563"></p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108116.png" alt="image-20201024151757221"></p><h3 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108781.png" alt="image-20201024152052056"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108941.png" alt="image-20201024152628966"></p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108716.png" alt="image-20201024153425016"></p><h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108381.png" alt="image-20201024153736033"></p><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108265.png" alt="image-20201024154039565"></p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108299.png" alt="image-20201024154744175"></p><hr><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="概念-16"><a href="#概念-16" class="headerlink" title="概念"></a>概念</h3><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108341.png" alt="image-20201024170819303"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108866.png" alt="image-20201024171432743"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108120.png" alt="image-20201024170923530"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108679.png" alt="image-20201024171058583"></p><p><strong>万维网的文档</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108199.png" alt="image-20201024171724030"></p><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h3><h4 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h4><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108275.png" alt="image-20201024222457800"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108924.png" alt="image-20201024222825888"></p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><strong>HTTP请求报文格式</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108707.png" alt="image-20201024224828528"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108837.png" alt="image-20201024224920638"></p><h4 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108083.png" alt="image-20201024224945200"></p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108970.png" alt="image-20201024224632514"></p><p>如果该请求有缓存</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108019.png" alt="image-20201024224720124"></p><p>如果该请求没有缓存</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108709.png" alt="image-20201024225013288"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108683.png" alt="image-20201024225504869"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109037.png" alt="image-20201024225846863"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109122.png" alt="image-20201024230242550"></p><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109946.png" alt="image-20201024231143505"></p><h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><h3 id="域名系统DNS-1"><a href="#域名系统DNS-1" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109103.png" alt="image-20201024000627823"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109876.png" alt="image-20201024002135210"></p><h3 id="文件传送协议FTP-1"><a href="#文件传送协议FTP-1" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109711.png" alt="image-20201024135242632"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109336.png" alt="image-20201024135740064"></p><h3 id="电子邮件-1"><a href="#电子邮件-1" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109425.png" alt="image-20201024154357384"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109231.png" alt="image-20201024154637025"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109217.png" alt="image-20201024154704101"></p><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109301.png" alt="image-20201024230522020"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109729.png" alt="image-20201024230846111"></p><h1 id="网络是怎么连接的"><a href="#网络是怎么连接的" class="headerlink" title="网络是怎么连接的"></a>网络是怎么连接的</h1><h2 id="0、大致流程"><a href="#0、大致流程" class="headerlink" title="0、大致流程"></a>0、大致流程</h2><ul><li>首先，用户输入网址</li><li><strong>浏览器</strong>解析网址，生成HTTP消息并转交给Socket库</li><li><strong>Socket库</strong>将收到 的HTTP消息作为数据转交给协议栈</li><li><strong>TCP</strong>按照网络包的长度对数据进行拆分，在每个包前面加上TCP头部并转交给IP——【TCP-HTTP数据块】</li><li><strong>IP</strong>在TCP包前加上IP头部，然后查询MAC地址并加上MAC头部，然后将包转交给网卡驱动——【MAC-IP-TCP-HTTP数据块】</li><li><strong>网卡驱动</strong>收到IP发来的包，将其转交给网卡并发出发送指令</li><li><strong>网卡</strong>检查以太网的可发送状态，将包转换成电信号，通过双绞线发送出去</li><li>信号通过<strong>双绞线</strong>到达集线器</li><li><strong>集线器</strong>将信号广播到所有端口，信号会到达交换机</li><li><strong>交换机</strong>根据收到的包的接收方MAC地址查询自身的地址表，找到输出端口，并将包转发到输出端口——【IP-TCP-HTTP数据块】</li><li><strong>互联网接入路由器</strong>根据收到的包的接收方IP地址查询自身的路由表，找到输出端口，并将包转发到输出端口（互联网接入路由器输出到互联网的包带有PPPoE头部和PPP头部）——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li><strong>ADSL Modem</strong>将收到的包拆分成ATM信元，然后转换成电信号通过电话线发送到电话局的DSLAM</li><li><strong>DSLAM</strong>（局端多路Modem）将收到的电信号还原成ATM信号并发送给BAS</li><li><strong>BAS</strong>将ATM信元还原成网络包，根据接收方IP地址进行转发——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li>BAS转发的包加上L2TP头部并通过<strong>隧道</strong>——【L2TP-PPP-IP-TCP-HTTP数据块】</li><li>网络包到达位于隧道出口的隧道路由器，L2TP头部和PPP头部被丢弃，通过互联网流向Web服务器【MAC-IP-TCP-HTTP数据块】</li><li>服务器端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过。Web服务器前面如果有缓存服务器，会拦截通过防火墙的包。如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据。如果请求的页面没有被缓存，缓存服务器会将请求转发给Web服务器</li><li>Web服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈</li><li>协议栈依次检查IP头部和TCP头部，如果没有问题则取出HTTP消息的数据进行组装</li><li>HTTP消息被恢复成原始状态，然后通过Socket库转交给Web服务器，Web服务器分析HTTP信息的内容，并根据请求内容将读取的数据返回给客户端</li></ul><h2 id="一、浏览器生成消息"><a href="#一、浏览器生成消息" class="headerlink" title="一、浏览器生成消息"></a><strong>一、浏览器生成消息</strong></h2><h3 id="1-生成HTTP-1-请求消息"><a href="#1-生成HTTP-1-请求消息" class="headerlink" title="1.生成HTTP[^1]请求消息"></a>1.生成HTTP[^1]请求消息</h3><p>当使用浏览器输入网址时，浏览器首先会对URL[^2]进行解析，（URL有多种格式<a href="%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%B1%E4%BA%8E%E5%BC%80%E5%A4%B4%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%EF%BC%8CFTP%E5%8D%8F%E8%AE%AE%EF%BC%8Cfile%EF%BC%88%E8%AF%BB%E5%8F%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8Cmallto%EF%BC%88%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%89%E7%AD%89%EF%BC%8C%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82%E5%85%B6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%90%8E%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9C%81%E7%95%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%8B%E5%85%88%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%B3%E4%B8%BB%E9%A1%B5%E3%80%82">^3</a>）浏览器由此可确定服务器的域名和文件名，接下来便根据这些信息生成HTTP请求消息，</p><p>[^2]: URL:Uniforn Resource Locator,统一资源定位符，即网址。<br>[^1]: HTTP:Hypertext Transfer Protocol,超文本传送协议</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109442.jpg" alt="网络连接大致流程1"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109530.jpg" alt="网络连接大致流程2"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
