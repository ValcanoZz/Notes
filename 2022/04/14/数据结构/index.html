<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>数据结构 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="[TOC] 欠缺数组：广义表 树：层次遍历算法，线索二叉树，二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋），B树（多路平衡查找树），B+树，——红黑树 并查集： 图： 数组  Arrarryjava C  使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）  C 语言不允许返回一个完整的数组作为函数的参数。 想要">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构">
<meta property="og:url" content="http://example.com/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="[TOC] 欠缺数组：广义表 树：层次遍历算法，线索二叉树，二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋），B树（多路平衡查找树），B+树，——红黑树 并查集： 图： 数组  Arrarryjava C  使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）  C 语言不允许返回一个完整的数组作为函数的参数。 想要">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/181212/2-1Q212223I41Z.gif">
<meta property="og:image" content="http://data.biancheng.net/uploads/allimg/181212/2-1Q212224002945.gif">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211228111813606.png">
<meta property="og:image" content="d:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png">
<meta property="og:image" content="d:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%912.png">
<meta property="og:image" content="d:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%913.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227205412747.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227210741287.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227211302810.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227211924677.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227212543467.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227212836480.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227212949012.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227213649466.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/2.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/3.png">
<meta property="og:image" content="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9f7961f77546c8f13448372625282335.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/5a84b9872980c9a8761d3b84315d5931.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/02050b1461f4b891a92052f41139c567.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/706a4ae059ebd3b6cfd8dfef6a3f05e4.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/9f2f0ebec960203ecafac6bf91462be2.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/4947b64375651e3b2072ecd09d3fad7b.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/03f56fa81ffaee6bfe4fd68d25b6bc63.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/162498f17b4122405b0ef04cefe55368.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/28d7b36542a54750935418950da5d8eb.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/cd622250cc9453c634658ae934defc88.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/711d441a7e05c4843237ac5e6f424f26.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214212034.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214032490.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214112779.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214400091.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214717843.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227214851706.png">
<meta property="og:image" content="d:/Note/Typora_picture/prim%E7%AE%97%E6%B3%951.png">
<meta property="og:image" content="d:/Note/Typora_picture/prim2.png">
<meta property="og:image" content="d:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%951.png">
<meta property="og:image" content="d:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%952.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227204922551.png">
<meta property="og:image" content="d:/Note/Typora_picture/Dijkstra%E7%AE%97%E6%B3%95.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/sort.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2018/09/Merge-sort-example-300px.gif">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png">
<meta property="og:image" content="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227202553354.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227202243956.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227203606666.png">
<meta property="og:image" content="d:/Note/Typora_picture/image-20211227203540414.png">
<meta property="article:published_time" content="2022-04-14T06:55:35.306Z">
<meta property="article:modified_time" content="2022-04-14T01:30:45.281Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://data.biancheng.net/uploads/allimg/181212/2-1Q212223I41Z.gif">
  
    <link rel="alternate" href="/Notes/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Notes/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/Notes/css/style.css">

  
    
<link rel="stylesheet" href="/Notes/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Notes/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/Notes/">Home</a>
        
          <a class="main-nav-link" href="/Notes/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/Notes/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-数据结构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.306Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      数据结构
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>[TOC]</p>
<h2 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h2><p>数组：广义表</p>
<p>树：<del>层次遍历算法</del>，线索二叉树，<del>二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋）</del>，<del>B树（多路平衡查找树）</del>，<del>B+树</del>，——红黑树</p>
<p>并查集：</p>
<p>图：</p>
<h2 id="数组-Arrarry"><a href="#数组-Arrarry" class="headerlink" title="数组  Arrarry"></a><strong>数组  Arrarry</strong></h2><p><a href="#java%E6%95%B0%E7%BB%84">java</a></p>
<p>C</p>
<ul>
<li>使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）</li>
</ul>
<p>C 语言不允许返回一个完整的数组作为函数的参数。</p>
<p>想要从函数返回一个数组，需先声明一个返回指针的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">myFunction</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p>
<p>示例（生成随机数，并用数组返回）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java数组">

<p> <strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数组创建</span></span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;b: &quot;</span> + Arrays.toString(b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 3</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;c: &quot;</span> + Arrays.toString(c));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 4</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr.add(i + <span class="number">1</span>);<span class="comment">//add方法：括号内为(数组索引值,元素），索引值可以不加，则将元素插入到末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr: &quot;</span> + arr.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        arr.add(<span class="number">99</span>);        <span class="comment">//O(1)</span></span><br><span class="line">        arr.add(<span class="number">3</span>, <span class="number">88</span>);     <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> arr.get(<span class="number">1</span>);      <span class="comment">//()里为索引值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新元素 ：O(1)</span></span><br><span class="line">        c[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        arr.set(<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.删除元素 ： O(N)</span></span><br><span class="line">        arr.remove(<span class="number">1</span>);      <span class="comment">//删除下标为1处的元素</span></span><br><span class="line">        arr.remove(Integer.valueOf(<span class="number">4</span>));     <span class="comment">//删除第一个值为4的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;      <span class="comment">//删除所有值为3的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">                arr.remove(i--);        <span class="comment">//每删除一个元素后当前下标应-1，否则会漏掉下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.数组长度 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSize</span> <span class="operator">=</span> arr.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历数组 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> c[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.查找元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">99</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;we found 99 at int c!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is99</span> <span class="operator">=</span> arr.contains(<span class="number">99</span>);    <span class="comment">//找到目标值则返回True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9. 数组排序 : O(N logN)</span></span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        Collections.sort(arr);  <span class="comment">//升序排列</span></span><br><span class="line">        Collections.sort(arr, Collections.reverseOrder());  <span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h3><p>访问（Access）：O（1）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（N）</p>
<p>删除（Delete）：O（N）</p>
<h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表  Linked List"></a><strong>链表  Linked List</strong></h2><p><a href="#java%E9%93%BE%E8%A1%A8">java</a></p>
<p> <strong>C</strong></p>
<p>创建链表：</p>
<p>创建结构变量指针，使用前要先分配内存空间</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">LinkList *<span class="title function_">CreatList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList *temp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LinkList *a = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a-&gt;data);</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改链表结点的值</span></span><br><span class="line">LinkList  <span class="title function_">changeList</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;结点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表的第n个位置插入数据</span></span><br><span class="line">LinkList *<span class="title function_">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;   <span class="comment">//temp用于表示插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =  temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList  *in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;in-&gt;data);</span><br><span class="line">    in-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表中第n个节点</span></span><br><span class="line">LinkList *<span class="title function_">delete</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;    <span class="comment">//temp用于表示删除位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList *del = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkList *<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="头插法和尾插法："><a href="#头插法和尾插法：" class="headerlink" title="头插法和尾插法："></a>头插法和尾插法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">	p=head;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		q=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">		q-&gt;next = p-&gt;next;</span><br><span class="line">		p-&gt;next=q;</span><br><span class="line">		p=q;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_1</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>;</span></span><br><span class="line">	head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">		p=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">		p-&gt;next=head-&gt;next;</span><br><span class="line">		head-&gt;next=p;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>=</span>head-&gt;next;</span><br><span class="line">	<span class="keyword">while</span>(p)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">		p=p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">puts</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">head</span>;</span></span><br><span class="line">	head=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">	creat(head, <span class="number">5</span>);</span><br><span class="line">	output(head);</span><br><span class="line"></span><br><span class="line">	creat_1(head, <span class="number">5</span>);</span><br><span class="line">	output(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java链表">

<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        list.add(<span class="number">1</span>);    <span class="comment">//O(1)</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">99</span>); <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.搜索元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">99</span>);   <span class="comment">//搜索元素值，然后返回索引值(下标)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.更新元素 : O(N)</span></span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">88</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.删除元素 : O(N)</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除头节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除链表头部节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);	<span class="comment">//sentinel：哨兵</span></span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> ans, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="链表的时间复杂度"><a href="#链表的时间复杂度" class="headerlink" title="链表的时间复杂度"></a>链表的时间复杂度</h3><p>访问（Access）：O（N）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列  Queue"></a><strong>队列  Queue</strong></h2><p><a href="#java%E9%98%9F%E5%88%97">java</a></p>
<p><strong>C</strong></p>
<p>判断队列是否为空：</p>
<ol>
<li>设置一个标志变量；</li>
<li>当队列满时，保留一个元素空间；设队列最大尺寸为QueueSize，则<strong>队列满的条件是：（rear+1）%QueueSize &#x3D;&#x3D; front</strong>。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QuDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span> *_<span class="title">next</span>;</span></span><br><span class="line">    QuDataType _data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QueueNode *_front;</span><br><span class="line">    QueueNode *_rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue *q)</span>;<span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue *q,QuDataType data)</span>;<span class="comment">//队尾入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue *q)</span>;<span class="comment">//队头出队列</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列头部元素</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列中有效元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;<span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;<span class="comment">// 销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数据入队列必须要先创建节点</span></span><br><span class="line">QueueNode * <span class="title function_">BuyQueueNode</span><span class="params">(QuDataType x)</span>&#123;    <span class="comment">//创建节点并初始化此节点</span></span><br><span class="line">    QueueNode * cur = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    cur-&gt;_data = x;</span><br><span class="line">    cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>&#123; <span class="comment">//初始化队列结构</span></span><br><span class="line">    q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QuDataType x)</span> &#123; <span class="comment">//队列尾部入数据</span></span><br><span class="line">    QueueNode * cur = BuyQueueNode(x);  <span class="comment">//先把创建好的节点传过来</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;             <span class="comment">//若是队列本身为空，队列里就只有这一个节点，又为队列头又为队列尾</span></span><br><span class="line">        q-&gt;_front = q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;_rear-&gt;_next = cur; <span class="comment">//否则，链表尾插操作</span></span><br><span class="line">        q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span> &#123;    <span class="comment">//队列头部出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;    <span class="comment">//本身队列为空，不做操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* tmp = q-&gt;_front-&gt;_next;   <span class="comment">//先保留下一个节点，防止断链</span></span><br><span class="line">    <span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">    q-&gt;_front = tmp;   <span class="comment">//更新对列头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//获取队列首部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>&#123;<span class="comment">//获取队列尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front == <span class="literal">NULL</span>;   <span class="comment">//为空，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>&#123;  <span class="comment">//获取队列中的元素个数</span></span><br><span class="line">    QueueNode * cur;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur = q-&gt;_front; cur; cur = cur-&gt;_next)<span class="comment">//循环遍历，计数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* q)</span>  <span class="comment">//销毁队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;_front)&#123;</span><br><span class="line">        QueuePop(q);<span class="comment">//对每一个元素迭代出队即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q)); <span class="comment">//1</span></span><br><span class="line">    QueuePop(&amp;q);<span class="comment">//出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q));<span class="comment">//2   此时队首为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueBack(&amp;q));<span class="comment">//4  队尾为4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a name = "java队列">

<p><strong>java</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建队列</span></span><br><span class="line">        <span class="comment">//用LinkedList(链表)作为对象,插入和删除操作时间复杂度只有O(1)</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素 :O(1)</span></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(temp1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.删除即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();   <span class="comment">//返回值，并将其删除 </span></span><br><span class="line">        System.out.println(temp2);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断队列是否为空 ：O(1)</span></span><br><span class="line">        System.out.println(queue.isEmpty());    <span class="comment">//队列空则返回True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.队列长度 ：O(1)</span></span><br><span class="line">        <span class="comment">//创建链表时会有一个变量，当加入一个元素时变量加1，获取长度时会直接返回这个变量值</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历队列 :O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933.最近的请求次数"></a>933.最近的请求次数</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p>
<p>请你实现 RecentCounter 类：</p>
<p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h4><p>利用两个队列 来实现栈的基本操作：进栈，显示栈顶元素，删除栈顶元素，判空f</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a>622.设计循环队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[(rear + capacity - <span class="number">1</span>) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h4 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a>Deque（双端队列）</h4><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p>
<ul>
<li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li>
</ul>
<p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure>


<p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p>
<p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p>
<p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure>


<p>创建 ArrayDeque实例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure>

<p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure>


<p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p>
<p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()<br>这些方法下面会一一讲解。</p>
<p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>


<p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p>
<p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>

<p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>获取元素：</strong></p>
<p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p>
<p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement的值是: “first element”。</p>
<p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p>
<p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure>


<p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p>
<p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure>




<p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure>

<p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure>


<p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p>
<p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure>


<p>执行完代码后size大小是2，因为Deque中包含两个元素。</p>
<p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p>
<p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p>
<p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="队列的时间复杂度"><a href="#队列的时间复杂度" class="headerlink" title="队列的时间复杂度"></a>队列的时间复杂度</h3><p>访问（Access）：O（N）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈   Stack"></a><strong>栈   Stack</strong></h2><p><strong>java：</strong></p>
<p>（Java堆栈Stack已经过时，推荐使用Deque替代Stack。）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取栈顶元素 : O(1)</span></span><br><span class="line">        stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//pop方法会删除元素并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的大小 : O(1)</span></span><br><span class="line">        stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈是否为空 : O(1)</span></span><br><span class="line">        stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的遍历 : O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p>
<ul>
<li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li>
<li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li>
</ul>
<p>假设：</p>
<p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 </p>
<p>10入栈时，栈为空，直接入栈，栈内元素为10。</p>
<p>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</p>
<p>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</p>
<p>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</p>
<p>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(遍历这个数组)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">	&#123;</span><br><span class="line">		入栈;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">		&#123;</span><br><span class="line">			栈顶元素出栈;</span><br><span class="line">			更新结果;</span><br><span class="line">		&#125;</span><br><span class="line">		当前数据入栈;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p>
<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        hash.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != hash.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="496-下一个更大元素1"><a href="#496-下一个更大元素1" class="headerlink" title="496.下一个更大元素1"></a>496.下一个更大元素1</h3><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p>
<p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p>
<p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p>
<p>示例 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>只使用两个栈，实现一个先入先出的队列（push,pop,peek,empty)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//stack1中的数据依次出栈并入栈stack2</span></span><br><span class="line">    <span class="comment">//数据进栈stack2</span></span><br><span class="line">    <span class="comment">//stack2中数据依次出栈并入栈stack1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="栈的时间复杂度"><a href="#栈的时间复杂度" class="headerlink" title="栈的时间复杂度"></a>栈的时间复杂度</h3><p>访问（Access）：O（1）</p>
<p>搜索（Search）：O（N)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串   String"></a><strong>字符串   String</strong></h2><p>字符串输入：</p>
<ol>
<li><p>数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">6</span>] = <span class="string">&quot;array&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;array&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %c %c&quot;</span>,p,*p,*(p + <span class="number">2</span>));   <span class="comment">//第一个输出字符串；第二个输出指针指向，即字符串的第一个字符；第三个输出字符串中 第三个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>数组&#x2F;指针 </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">6</span>];</span><br><span class="line">scang(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line">gets(arr1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>( <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>) );  <span class="comment">//记得为指针数组分配内存，否则会报错之类的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>,arr2);</span><br><span class="line">gets(arr2);</span><br></pre></td></tr></table></figure>

<p>（scanf只能输入一个单词，当遇到空格时会认为字符串结束；gets函数只知道数组的开始，并不知道数组的大小，如果输入过长容易溢出，并可能擦掉程序中的其他数据）</p>
</li>
<li><p>使用while完成多组测试，而不是在输入完一组数据后退出控制台</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">100</span>],arr2[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a;   </span><br><span class="line"><span class="keyword">while</span>((a = <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,arr1,arr2)) != EOF)&#123;     <span class="comment">//也可用while((a = getchar(arr1)) != &#x27;\n&#x27;)</span></span><br><span class="line">    pritnf(<span class="string">&quot;scanf返回l %d,s1是%s，s2是%s&quot;</span>，a,arr1,arr2);   <span class="comment">//这行输出后可以继续进行输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>KMP算法实现过程接近人为模式匹配</p>
<ul>
<li>匹配失败后，模式串移动的距离和主串无关，只与模式串本身有关，模式串后移等价于指针j前移。</li>
</ul>
<p><img src="http://data.biancheng.net/uploads/allimg/181212/2-1Q212223I41Z.gif" alt="模式串后移等价于 j 前移"></p>
<p>因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j&#x3D;3，则该字符匹配失败后指针 j 指向模式串中第 3 个字符。</p>
<p>模式串中各字符对应 <strong>next 值</strong>的计算方式是，取该字符前面的字符串（不包含自己），其<strong>前缀字符串和后缀字符串相同字符的最大个数再 +1</strong> 就是该字符对应的 next 值。</p>
<p>（模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。）</p>
<h4 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h4><p>一般的Next函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但这样可能会有多余的操作，如：</p>
<p><img src="http://data.biancheng.net/uploads/allimg/181212/2-1Q212224002945.gif" alt="Next函数的缺陷"></p>
<p>当匹配失败时，Next 函数会由图 10b) 开始继续进行模式匹配，但是从图中可以看到，这样做是没有必要的。</p>
<p>如此，问题在当 T[i-1]&#x3D;&#x3D;T[j-1] 成立时，没有继续对 i++ 和 j++ 后的 T[i-1] 和 T[j-1] 的值做判断。</p>
<p>因此改进后的Next函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123; </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i<span class="number">-1</span>]!=T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               next[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i]=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a><strong>散列表（Hash）</strong></h2><ul>
<li><p><strong>哈希表</strong>（hashtable），又叫散列表，是根据关键码（key）来进行访问的数据结构，通过哈希函数把key转成哈希值来定位数据存储的位置。通常是键-值对（即key-value）的结构，即用key算出的哈希值来定位存储位置，在该位置上存储内容为value。</p>
</li>
<li><p><strong>哈希集合</strong>（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。<br>简单来说就是，哈希集合是不能存储重复元素的数据结构（集合），而哈希表是存储键-值对（key-value），其中键key不能重复。</p>
</li>
<li><p><strong>哈希映射</strong>（hashmap）是和哈希表（hashtable）相似的数据结构，也是键-值对存储，只是哈希映射是线程安全的，而哈希表是非线程安全的。所谓线程安全，就是多线程同时操作数据的时候，能确保在同一时刻只能有一个线程能访问同一个数据（也就是会给数据操作加锁）；如果不能确保这个，就是非线程安全。</p>
</li>
</ul>
<p>哈希表 可能存在特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。</p>
<p>目前，这个哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p>
<p>下面简单<strong>介绍几种哈希函数</strong>。</p>
<ul>
<li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li>
<li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li>
<li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li>
<li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li>
<li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取<strong>素数</strong>或者直接用 n。</li>
</ul>
<p><strong>对散列表函数产生冲突的解决办法</strong>：</p>
<p>​	有时不同的 Key 通过哈希函数可能会得到相同的地址，这在我们操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 Key 计算之后获得了相同的地址。</p>
<p>冲突的处理方式也有很多，下面介绍几种。</p>
<ul>
<li><strong>开放地址法</strong>（也叫<strong>线性探测</strong>）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。(如  f（key) &#x3D; {  f(key + d)  } % m）</li>
<li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li>
<li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</li>
<li><strong>建立一个公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li>
</ul>
<h3 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h3><p><a href="java%E6%95%A3%E5%88%97%E8%A1%A8">java</a></p>
<p><strong>C：</strong></p>
<h5 id="实现简单的哈希表"><a href="#实现简单的哈希表" class="headerlink" title="实现简单的哈希表"></a>实现简单的哈希表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12   <span class="comment">//定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;    <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;    <span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;   <span class="comment">//散列表表长，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line">Status <span class="title function_">InterHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;     <span class="comment">//除留余数法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入关键字进散列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);   <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;      <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">    H-&gt;elem[addr] = key;        <span class="comment">//直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表查找关键字</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">    *addr = Hash(key);                 <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key) &#123;        <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;            <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;     <span class="comment">//如果循环回到原点</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       <span class="comment">//则说明关键字不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>] = &#123;<span class="number">12</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    InterHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        IntertHash(&amp;H, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入之后的哈希表为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, H.elem[i]);</span><br><span class="line">    <span class="type">int</span> addr, j;</span><br><span class="line">    j = SearchHash(H, a[<span class="number">5</span>], &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;搜索到a[5]的地址是：%d&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="实现哈希集合"><a href="#实现哈希集合" class="headerlink" title="实现哈希集合"></a>实现哈希集合</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">listContains</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List *head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line">MyHashSet *<span class="title function_">myHashSetCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashSet *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetAdd</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetRemove</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">myHashSetContains</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetFree</span><span class="params">(MyHashSet *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="实现哈希映射"><a href="#实现哈希映射" class="headerlink" title="实现哈希映射"></a>实现哈希映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">listFind</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line">MyHashMap* <span class="title function_">myHashMapCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a neme = "java散列表">

<p><strong>java：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        String[] hashTable = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>]; <span class="comment">//用数组创建</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//用HashMap方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//将其改为不会用到的值</span></span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取元素 : O(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> hashTable[<span class="number">1</span>];</span><br><span class="line">        map.get(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查key是否存在 : O(1)</span></span><br><span class="line">        map.containsKey(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长度，是否为空 : O(1)</span></span><br><span class="line">        map.size();</span><br><span class="line">        </span><br><span class="line">        map.isEmpty();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key对应的value，如果找不到key，则返回设置的默认值。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p>
<p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p>
<ol>
<li><strong>访问速度很快</strong></li>
</ol>
<p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p>
<ol start="2">
<li><strong>需要额外的空间</strong></li>
</ol>
<p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p>
<p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p>
<p><strong>3) 无序</strong></p>
<p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p>
<p><strong>4) 可能会产生碰撞</strong></p>
<p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p>
<h3 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h3><p>根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p>
<p><strong>缓存</strong></p>
<p>通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p>
<p>在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p>
<p>有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p>
<p><strong>快速查找</strong></p>
<p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p>
<p>这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p>
<p>还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p>
<p>当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢，而散列表则不会。</p>
<h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">	HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">	<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line">		<span class="keyword">if</span> (hash.containsKey(i)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span></span><br><span class="line">			hash.put(i, <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h3><p>给定两个字符串 <strong>s</strong> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p>
<p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p>
<p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

















<h3 id="哈希表的时间复杂度"><a href="#哈希表的时间复杂度" class="headerlink" title="哈希表的时间复杂度"></a>哈希表的时间复杂度</h3><p>访问（Access）：</p>
<p>搜索（Search）：O（1)</p>
<p>插入（Insert）：O（1）</p>
<p>删除（Delete）：O（1）</p>
<h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合   Set"></a><strong>集合   Set</strong></h2><ul>
<li><strong>无序，不重复</strong></li>
</ul>
<ol>
<li>检查元素是否存在</li>
<li>检查元素是否重复（原数据长度与集合长度是否相同）</li>
</ol>
<h3 id="java（哈希集合HashSet）"><a href="#java（哈希集合HashSet）" class="headerlink" title="java（哈希集合HashSet）"></a>java（哈希集合HashSet）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//[10,2]</span></span><br><span class="line">        System.out.println(set.add(<span class="number">2</span>));	<span class="comment">//添加的元素已存在，会返回false，不存在则返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索元素 : O(1)0</span></span><br><span class="line">        set.contains(<span class="number">2</span>);	<span class="comment">//存在则返回true</span></span><br><span class="line">        System.out.println(set.contains(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="217-存在重复元素-1"><a href="#217-存在重复元素-1" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>









<h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树   Tree"></a><strong>树   Tree</strong></h2><ul>
<li><p>树中有一个根结点，其余节点可以分成若干个互不相交的“子树”。</p>
</li>
<li><p>除了根节点，每个结点有且只有一个父节点；</p>
</li>
<li><p>一棵N个结点的树有N - 1条边；</p>
</li>
</ul>
<p>结点的度：结点的子树个数；</p>
<p>树的度：树中所有结点中最大的度；</p>
<p>叶结点：度为0的结点；</p>
<p>兄弟结点：具有同一父结点的各个结点；</p>
<p>路径和路径结点：从结点N到结点Nk的路径，其路径结点为路径中结点个数 - 1，即路径中所包含的边的个数；</p>
<p>祖先结点：从某一结点，到根结点的所有节点，都是这个结点的祖先节点；</p>
<p>子孙结点：某一结点的子树中的所有节点，都是这个结点的子孙；</p>
<p>层次：规定根结点  在0&#x2F;1层，其他结点的层数是其父结点的层数+1；</p>
<p>深度：从上往下数，等于层；高度：从下往上数</p>
<h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p><strong>普通二叉树</strong>：每个结点最多两个子结点</p>
<p><strong>满二叉树</strong>：除了叶结点，每个结点都有两个子结点，并且所有叶结点都在同一层上；</p>
<blockquote>
<p>满二叉树的深度为k，则该树一共有 2^k^ - 1 个节点。</p>
</blockquote>
<p><strong>完全二叉树</strong>：从树的根结点出发，从上到下，从左到右，依次填满结点形成的二叉树</p>
<p>（满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）</p>
<p><strong>二叉树的遍历：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><strong>前</strong>序遍历</td>
<td><strong>根节点</strong>-&gt;左子树-&gt;右子树</td>
</tr>
<tr>
<td><strong>中</strong>序遍历</td>
<td>左子树-&gt;<strong>根节点</strong>-&gt;右子树</td>
</tr>
<tr>
<td><strong>后</strong>序遍历</td>
<td>左子树-&gt;右子树-&gt;<strong>根子树</strong></td>
</tr>
<tr>
<td>层次遍历</td>
<td>从上到下，从左到右</td>
</tr>
</tbody></table>
<p>（层次遍历需要用到 队列 ）</p>
<h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">//创建树的结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//创建树根</span></span><br><span class="line">    Node *root;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Tree *tree, <span class="type">int</span> value)</span> &#123;     <span class="comment">//创建树</span></span><br><span class="line">    Node *node = (Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个结点</span></span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) tree-&gt;root = node;  <span class="comment">//判断树是不是空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">//不是空树</span></span><br><span class="line">        Node *temp = tree-&gt;root;    <span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123;    <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Deleteer</span><span class="params">(Node *node, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L,*LL;    <span class="comment">//在删除左右子树都有的结点时使用；</span></span><br><span class="line">    Node *p=node;</span><br><span class="line">    Node *parent=node;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;  <span class="comment">//0表示左子树，1表示右子树；</span></span><br><span class="line">    <span class="keyword">if</span>(!node)    <span class="comment">//如果排序树为空，则退出；</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p)  <span class="comment">//二叉排序树有效；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)  <span class="comment">//叶结点(左右子树都为空)；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == node)  <span class="comment">//被删除的结点只有根结点；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">NULL</span>;  <span class="comment">//设置父结点左子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);   <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//父结点为右子树；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;right=<span class="literal">NULL</span>;  <span class="comment">//设置父结点右子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);  <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;left)  <span class="comment">//左子树为空，右子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)    <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;right)  <span class="comment">//右子树为空，左子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)  <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LL=p;  <span class="comment">//保存左子树的结点；</span></span><br><span class="line">                L=p-&gt;right;  <span class="comment">//从当前结点的右子树进行查找；</span></span><br><span class="line">                <span class="keyword">if</span>(L-&gt;left)  <span class="comment">//左子树不为空；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LL=L;</span><br><span class="line">                    L=L-&gt;left;   <span class="comment">//查找左子树；</span></span><br><span class="line">                    p-&gt;data=L-&gt;data;  <span class="comment">//将左子树的数据保存到被删除结点；</span></span><br><span class="line">                    LL-&gt;left=L-&gt;left;  <span class="comment">//设置父结点的左子树指针为空；</span></span><br><span class="line">                    <span class="keyword">for</span>(; L-&gt;left; L=L-&gt;left);</span><br><span class="line">                    L-&gt;left=p-&gt;left;</span><br><span class="line">                    p-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;data=L-&gt;data;</span><br><span class="line">                    LL-&gt;right=L-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; p-&gt;data)  <span class="comment">//需删除记录的关键字小于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的左子树；</span></span><br><span class="line">            child=<span class="number">0</span>;  <span class="comment">//标记在当前结点左子树；</span></span><br><span class="line">            parent=p;<span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;left;  <span class="comment">//查找左子树；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//需删除记录的关键字大于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的右子树；</span></span><br><span class="line">            child=<span class="number">1</span>;  <span class="comment">//标记在当前结点右子树查找；</span></span><br><span class="line">            parent=p;  <span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;right;  <span class="comment">//查找右子树；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;  <span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;     <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(tree.root);</span><br><span class="line">    Deleteer(tree.root,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>二又排序树、二叉查找树（BST, Binary Search Tree）<br>是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p>
<ul>
<li>左子树上所有结点的关键字均小于根结点的关键字</li>
<li>右子树上所有结点的关键字均大于根结点的关键字</li>
<li>左子树和右子树又各是一棵二又排序树。</li>
</ul>
<blockquote>
<p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值；</p>
<p>进行中序遍历，可以得到一个递增的有序序列。</p>
</blockquote>
<p><strong>查找：</strong>时间复杂度 O(h)，若排序树很平衡，则h接近log<del>2</del>n，若非常不平衡，则h会接近n。</p>
<p><strong>插入：</strong>时间复杂度 O(h)</p>
<p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于 根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p>
<p><strong>删除：</strong></p>
<p>先搜索找到目标结点：</p>
<ul>
<li>①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质。</li>
<li>②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li>
<li>③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li>
</ul>
<h3 id="自平衡二叉树AVL"><a href="#自平衡二叉树AVL" class="headerlink" title="自平衡二叉树AVL"></a>自平衡二叉树AVL</h3><p>平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)ー一树上任一结点的左子树和右子树的<strong>高度之差不超过1</strong>。</p>
<p>结点的平衡因子 &#x3D; 左子树高 - 右子树高。</p>
<ul>
<li>平衡二叉树结点的平衡因子的值只可能是-1、0或1。否则就不是平衡二叉树了。</li>
</ul>
<p>查找：时间复杂度不超过O(h) 、O(log<del>2</del>n)</p>
<p><strong>插入</strong>：</p>
<p><img src="D:/Note/Typora_picture/image-20211228111813606.png" alt="image-20211228111813606"></p>
<p><strong>调整</strong>最小不平衡子树A（从插入点找到的第一个不平衡点为根的子树）：</p>
<ul>
<li><p><strong>LL</strong>：在A的左孩子的左子树中插入导致不平衡；<br>调整：A的左孩子结点<strong>右上旋</strong>；</p>
</li>
<li><p><strong>RR</strong> ：在A的右孩子的右子树中插入导致不平衡；</p>
<p>调整：A的右孩子结点<strong>左上旋</strong>；</p>
</li>
<li><p><strong>LR</strong> ：在A的左孩子的右子树中插入导致不平衡；<br>调整：A的左孩子的右孩子<strong>先左上旋再右上旋</strong>；</p>
</li>
<li><p><strong>RL</strong> ：在A的右孩子的左子树中插入导致不平衡；<br>调整：A的右孩子的左孩子<strong>先右上旋后左上旋</strong>；</p>
</li>
</ul>
<h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>结点的带权路径长度：</strong></p>
<blockquote>
<p>树的每一个结点，都可以拥有自己的“权重”（Weight），权重在不同的算法当中可以起到不同的作用。结点的带权路径长度，是指树的根结点到该结点的路径长度，和该结点权重的乘积。</p>
</blockquote>
<p><strong>树的带权路径长度</strong></p>
<blockquote>
<p>在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p>
</blockquote>
<p><strong>而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</strong></p>
<p><strong>一颗有n个叶子结点的的哈夫曼树共有2n-1个结点</strong></p>
<p>原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p>
<p>思路：</p>
<blockquote>
<p>借助辅助队列，将权值最小的两个叶子节点挑出来，并根据这两个结点生成一个新的父结点，父节点的权值是这两个结点权值之和；从队列中移除已选择的节点，把新的父结点加入队列；</p>
<p>重复这一步骤，直到所有结点组成一颗完整二叉树</p>
<p>（如果是构造<strong>k叉哈夫曼树</strong>，且节点数无法严格构成k叉树，则需要补充几个<strong>权值为0的 “假节点”</strong>）</p>
</blockquote>
<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91.png" style="zoom: 33%;" />

<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%912.png" style="zoom:33%;" />

<img src="D:/Note/Typora_picture/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%913.png" style="zoom:33%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 结点权值?</span></span><br><span class="line">    <span class="type">int</span> parent, lc, rc; <span class="comment">// 双亲结点和左 右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minum;      <span class="comment">// 定义一个临时变量保存最小值?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;     <span class="comment">// 以下是找到第一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = minum;</span><br><span class="line">    <span class="comment">// 以下是找到第二个最小值，且与第一个不同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = minum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuff</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s1, s2;</span><br><span class="line">    m = n * <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>]; <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 1 - n 存放叶子结点，初始化</span></span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 非叶子结点的初始化</span></span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe HuffmanTree is: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)     <span class="comment">// 创建非叶子节点，建哈夫曼树</span></span><br><span class="line">    &#123;   <span class="comment">// 在HT[1]~HT[i-1]的范围内选择两个parent为0且weight最小的两个结点，其序号分别赋值给 s1 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;  <span class="comment">// 删除这两个结点</span></span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lc = s1;      <span class="comment">// 生成新的树，左右子节点是 s1和s2</span></span><br><span class="line">        HT[i].rc = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;   <span class="comment">// 新树的权�?</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d (%d, %d)\n&quot;</span>, HT[i].weight, HT[s1].weight, HT[s2].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *w, n, wei;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the number of node\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ninput the %dth node of value\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei);</span><br><span class="line">        w[i] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreatHuff</span>(HT, w, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋0，右分支赋1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p>
<p>哈夫曼编码的基本思想是：为出现次数较多的字符编以较短的编码，在压缩原理中有重要作用。</p>
<h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称<strong>多路平衡查找树</strong>。</p>
<p>B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的<strong>m叉树</strong>：</p>
<ol>
<li>树中每个结点<strong>至多有m棵子树</strong>，即<strong>至多含有m-1个关键字</strong></li>
<li>若<strong>根结点不是终端结点，则至少有两棵子树</strong>。</li>
<li>除根结点外的所有<strong>非叶结点至少有 m&#x2F;2 棵子树</strong>，即至少含有 (m&#x2F;2) -1 个关键字。</li>
<li><strong>所有的叶结点都出现在同一层次上，并且不帯信息</strong>（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20211227205412747.png" alt="image-20211227205412747"></p>
<p><strong>m阶B树的核心特性</strong></p>
<ol>
<li>根节点的子树数∈[2,m], 关键字数∈[1, m-1]<br>其他结点的子树数∈ [(m&#x2F;2), m] ;关键字数∈[(m&#x2F;2)-1, m-1]</li>
<li>对任一结点，其所有子树高度都相同</li>
<li>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt;关键字2 &lt; 子树2 &lt;. (类比二叉査找树左&lt;中&lt;右)</li>
</ol>
<blockquote>
<p>注：算B树高度时，不用包括叶子节点&#x2F;失败节点；</p>
<p>n个关键字的B树必有n+1个叶子节点。（相当于在n个关键字中插入木板，两边也插，则插了n+1个木板）</p>
</blockquote>
<p><strong>B树的插入</strong></p>
<p><strong>新元素一定是插入到最底层“终端节点”</strong>，用“查找”来确定插入位置。</p>
<p>在插入key后，若导致原结点关键字数超过上限，则从中间位置( [m&#x2F;2] )将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置( [m&#x2F;2] )的结点插入原结点的父结点。 </p>
<p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增。</p>
<p><img src="D:/Note/Typora_picture/image-20211227210741287.png" alt="image-20211227210741287"></p>
<hr>
<p><strong>B树的删除</strong></p>
<ul>
<li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除</strong>该关键字（要注意节点关键字个数是否低于下限 [m&#x2F;2] - 1 )</p>
</li>
<li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来<strong>替代</strong>被删除的关键字（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素）——对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</p>
</li>
</ul>
<p><img src="D:/Note/Typora_picture/image-20211227211302810.png" alt="image-20211227211302810"></p>
<ul>
<li><p>若删除关键字所在节点删除后，<strong>关键字低于下限</strong>：</p>
<ul>
<li><p>如果<strong>兄弟节点关键字充足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>借关键字</strong>“的目的。</p>
<p><img src="D:/Note/Typora_picture/image-20211227211924677.png" alt="image-20211227211924677"></p>
</li>
<li><p>如果<strong>兄弟节点关键字不足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>合并</strong>“的目的。</p>
<p><img src="D:/Note/Typora_picture/image-20211227212543467.png" alt="image-20211227212543467"></p>
</li>
</ul>
</li>
</ul>
<h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树 可以类比分块查找。</p>
<p>分块查找：</p>
<p><img src="D:/Note/Typora_picture/image-20211227212836480.png" alt="image-20211227212836480"></p>
<p>B+树：</p>
<p><img src="D:/Note/Typora_picture/image-20211227212949012.png" alt="image-20211227212949012"></p>
<p>一棵<strong>m阶的B+树</strong>需满足下列条件：</p>
<ol>
<li>每个分支结点最多有m棵子树（孩子结点）。</li>
<li>非叶根结点至少有两棵子树，其他每个分支结点至少有 m&#x2F;2 棵子树。</li>
<li><strong>结点的子树个数与关键字个数相等</strong>。（区别于B树，因为B+树的关键字和子树是一一对应的）</li>
<li>所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（支持顺序查找）</li>
<li>所有<strong>分支结点</strong>中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的指针。</li>
</ol>
<p><strong>B+的查找：</strong></p>
<p><strong>无论查找成功与否，最终一定要走到最下面一层节点。</strong>因为只有叶子节点存放了所需记录。</p>
<hr>
<p><strong>B树和B+树的对比：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227213649466.png" alt="image-20211227213649466"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="概念性质"><a href="#概念性质" class="headerlink" title="概念性质"></a>概念性质</h4><p>红黑树的概念模型是<strong>2-3-4树</strong>，以<strong>二叉树为基础</strong>，在二叉树属性中加入<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p>
<p>红黑树的<strong>五大定义</strong>：</p>
<ol>
<li><strong>节点颜色只能为红或黑；</strong></li>
<li><strong>根节点是黑色；</strong></li>
<li><strong>每个叶子节点是黑色的（这里的叶子节点其实是空节点）</strong></li>
<li><strong>不能出现连续的红色节点；</strong></li>
<li><strong>从任意节点到它的每个子节点的所有路径都包含相同的黑色节点；</strong></li>
</ol>
<p>这5条定义确保了红黑树的关键特性：</p>
<ul>
<li><strong>从根到叶子节点的最长路径，不会超过最短路径的两倍</strong>；</li>
<li>这棵树<strong>基本是平衡</strong>的；</li>
<li>虽然不是绝对平衡，但可以保证<strong>最坏情况下，红黑树依然是高效的</strong>；</li>
</ul>
<p>为什么能做到最长路径不超过最短路径的两倍？</p>
<blockquote>
<p>性质4规定了路径上不能有两个相连的红节点，因此，最长路径一定是红色节点和黑节点交替而成；</p>
<p>性质2和3规定了根节点和叶子节点都是黑色，所以最短路径的黑节点一定多于红节点（可能全部为黑）；</p>
<p>性质5规定每条路径黑节点的数目相同；</p>
<p>因此，没有路径的长能多于其他任何路径两倍。</p>
</blockquote>
<p>红黑树的<strong>三种变换：变色，左旋转，右旋转</strong></p>
<p>红黑树<strong>插入的新节点为红色</strong>的：</p>
<blockquote>
<p>因为插入红节点，不会违反红黑树的规则，虽然可能会红红相连，不过可以通过变色和旋转来调整；而插入黑色节点，必然会导致一条路径上多一个黑节点（难以调整）。</p>
</blockquote>
<hr>
<p><strong>左旋转</strong>：以当前节点X为根，逆时针旋转二叉树，使得<strong>父节点原来的位置被右子节点替代，左子节点的位置被父节点替代</strong>。同时，节点Y的<strong>左子树</strong> b 向<strong>左平移</strong>成为了节点X的<strong>右子树</strong></p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/2.png" alt="image-20200303132706061"></p>
<p>旋转之后仍然是二叉搜索树：</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/3.png" alt="image-20200303132617108"></p>
<p><strong>右旋转</strong>：以节点X为根，<strong>顺时针</strong>旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；</p>
<p><img src="https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/4.png" alt="image-20200303132529476"></p>
<h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h4 id="2-3树-到-红黑树"><a href="#2-3树-到-红黑树" class="headerlink" title="2-3树 到 红黑树"></a>2-3树 到 红黑树</h4><p>2-3-4树中的2节点对应红黑树中的黑色节点，而非2节点以红节点+黑节点的方式表示，黑色父节点+一个红色子节点表示3节点，黑色父节点+左右两个红色子节点表示4节点；</p>
<blockquote>
<p>2-3-4树 ：是一颗阶数为4的B树，它可能会存在2节点，3节点，4节点（2节点就是普通的二叉树节点；3节点：由2个属性X和Y，3个子节点，分别是小于X的，大于X小于Y的，大于Y的；4节点跟3节点类似）</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9f7961f77546c8f13448372625282335.png" alt="B树到红黑树的转化"></p>
<p>下面是以较为简单的 2-3树和左倾红黑树 为例，理解两者的转化关系</p>
<blockquote>
<p>2-3树不用考虑2-3-4树中复杂的4节点分裂；</p>
<p>左倾红黑树规定了红色节点只能在左子树，这个限制减少了原本红黑树的调平难度，更容易理解；</p>
</blockquote>
<hr>
<p>2-3树 和 左倾红黑树 ：把左倾红黑树中的红色节点<strong>顺时针方向旋转45°</strong>使其与黑父平行，然后再将它们看作一个整体，可以近似得到一颗2-3树。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5a84b9872980c9a8761d3b84315d5931.png" alt="B树到红黑树的转化"></p>
<p>从2-3树来看，红黑树的红节点和黑节点是绑定的，因为在2-3树中它们本来就在同一层，所有只有黑节点在2-3树中体现树的高度</p>
<hr>
<p><strong>对于2-3树的插入：</strong></p>
<p>我们的插入操作需要遵循一个<strong>原则</strong>：先将这个元素尝试性地放在<strong>已经存在的节点中</strong>（即插入一个红色节点），如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（<strong>临时</strong>）。然后，我们对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p>
<p>如图：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/02050b1461f4b891a92052f41139c567.png" alt="2-3树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/706a4ae059ebd3b6cfd8dfef6a3f05e4.png" alt="2-3-4树的插入"></p>
<p>在2-3树中如果待插入节点是个2节点，而2节点对应着红黑树中的黑色父节点；所以向2节点插入元素，即在黑色父节点下面增加一个红色儿子，</p>
<p>3节点插入元素，即已经有一个黑色父节点和一个红色子节点，则再给黑色父节点一个红色子节点</p>
<hr>
<p><strong>对于2-3树的删除：</strong></p>
<p>2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p>
<p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己<strong>唯一的元素</strong>，引发2节点自身的删除，会使得树中某条路径的<strong>高度发生变化</strong>，树变得<strong>不平衡</strong>。</p>
<p>对此有两种方案：</p>
<ol>
<li>先删除这个2节点，再对树进行平衡调整；</li>
<li>想办法让被删除元素不可能出现在2节点中；</li>
</ol>
<p>这里看第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点。</p>
<p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素<br><img src="https://img-blog.csdnimg.cn/img_convert/9f2f0ebec960203ecafac6bf91462be2.png" alt="2-3树的删除"></p>
<p>插入和删除操作的父子节点上下浮动和删除里借元素的做法，就是红黑树的调整（变色，旋转）；</p>
<p>看左倾红黑树的 插入和删除（图示）：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4947b64375651e3b2072ecd09d3fad7b.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/03f56fa81ffaee6bfe4fd68d25b6bc63.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/162498f17b4122405b0ef04cefe55368.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/28d7b36542a54750935418950da5d8eb.png" alt="左倾红黑树的插入"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cd622250cc9453c634658ae934defc88.png" alt="左倾红黑树的删除"></p>
<p>删除之后需要一些调整（左倾红黑树不允许出现右倾）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/711d441a7e05c4843237ac5e6f424f26.png" alt="左倾红黑树的删除"></p>
<h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆   Heap"></a><strong>堆   Heap</strong></h2><p>性质：</p>
<ol>
<li>结构性：用<strong>数组表示</strong>的<strong>完全二叉树</strong>。</li>
<li>有序性：任意结点的关键字（权值）是其子树所有结点的最小值&#x2F;最大值<br>1. 父结点大于子结点：最大堆&#x2F;大根堆（MaxHeap）<br>            2. 父结点小于子结点：最小堆&#x2F;小根堆（MinHeap）</li>
</ol>
<p>应用：</p>
<ol>
<li>优先队列：是一种特殊的“队列”，从队列中取出元素的顺序是依照元素的关键字（权值&#x2F;数值）大小，而不是元素进入队列的先后顺序。</li>
<li>堆排序</li>
</ol>
<h3 id="最小堆操作与实现："><a href="#最小堆操作与实现：" class="headerlink" title="最小堆操作与实现："></a>最小堆操作与实现：</h3><p>对于任意最多有MaxSize个元素的最小堆H ∈ MinHeap 元素，item ∈</p>
<p> ElementType主要操作有：</p>
<ul>
<li>MinHeap Create(int Maxsize): 创建一个空的最小堆。</li>
<li>void Destroy(MinHeap)：释放堆的空间。</li>
<li>Boolean IsFull(MinHeap H): 判断最小堆是否已满。</li>
<li>Boolean IsEmpty(MinHeap H): 判断最小堆是否为空。</li>
<li>void Insert(MinHeap H,ElementType item): 将元素item插入最小堆H。</li>
<li>ElementType DeleteMin(MinHeap H): 返回最小堆H中最小元素（高优先级）。</li>
<li>MinHeap BuildMinHeap(ElementType *Element,int Size,int MaxSize)：创建一个非空的最小堆</li>
</ul>
<p><strong>数组下标为0</strong>的位置放一个比所有堆中元素都要小的元素（可以是ElementType的最小值），称为“<strong>哨兵</strong>”。从下标为1的位置开始存放堆中元素。因为是完全二叉树，所以父亲节点与其左右子节点下标满足一些关系。</p>
<p><strong>由子节点找父节点：父节点下标&#x3D;子节点下标 &#x2F; 2</strong><br><strong>由父节点找左子节点：左子节点下标&#x3D;父节点下标 * 2</strong><br><strong>由父节点找右子节点：右子节点下标&#x3D;父节点下标 * 2 + 1</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elenment;      <span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;       <span class="comment">//堆的当前元素个数（最后一个元素的下标）</span></span><br><span class="line">    <span class="type">int</span> MaxSize;        <span class="comment">//堆存储空间的大小</span></span><br><span class="line">&#125; HeapStruct, *MinHeap;</span><br><span class="line"></span><br><span class="line">MinHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span> &#123;</span><br><span class="line">    MinHeap H = (MinHeap) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));     <span class="comment">//分配堆结构空间</span></span><br><span class="line">    H-&gt;Elenment = (ElementType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType) * (MaxSize + <span class="number">1</span>));    <span class="comment">//分配储存堆元素的数组的空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;MaxSize = MaxSize;</span><br><span class="line">    H-&gt;Elenment[<span class="number">0</span>] = <span class="number">-2020</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆申请的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Elenment);     <span class="comment">//先释放堆节点的数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(H);        <span class="comment">//再释放堆节点的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;MaxSize); <span class="comment">//判断最小堆中元素个数size是否等于最大容量MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);  <span class="comment">//判断堆中元素个数是否等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素item插入最小堆H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inset</span><span class="params">(MinHeap H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断堆H是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果H未满，将item放入堆最后一个元素，查看它的父节点，如果它的父节点比它大，将它和它的父节点互换位置循环此过程，直至它的父节点小于它。可能它比所有它的父节点都要小，但是一定会比哨兵大（数组中下标为0的位置），所以一定最后它的下标一定大于哨兵的下标0。这就是哨兵的意义。</span></span><br><span class="line">    H-&gt;Size++;</span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;Size; H-&gt;Elenment[i / <span class="number">2</span>] &gt; item; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        H-&gt;Elenment[i] = H-&gt;Elenment[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最小堆H中最小元素（高优先级）</span></span><br><span class="line"><span class="comment">//将堆根结点元素取出，并将堆元素重新排序</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MinHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = <span class="number">0</span>,child = <span class="number">0</span>;</span><br><span class="line">    ElementType item, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否已经空了</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> H-&gt;Elenment[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆没有空，将根节点返回，最后一个叶子节点放到根节点位置，然后比较它与它的左右子节点中最小节点的大小，如果它比较大，则将它和它的较小的子节点互换位置，重复此过程，直至他比两个子节点都小或者它不在有子节点</span></span><br><span class="line">    item = H-&gt;Elenment[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elenment[H-&gt;Size];</span><br><span class="line">    H-&gt;Size--;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找出左右子结点最小的那个</span></span><br><span class="line">        <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child +<span class="number">1</span>]))&#123;</span><br><span class="line">            child ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">            H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非空的堆</span></span><br><span class="line"><span class="comment">//可以先建一个空堆，再用Insert函数将元素一个一个插入；另一种方法是：将数组复制到堆结点的Element，再进行排序第二种方法时间复杂度更低</span></span><br><span class="line"><span class="comment">//已知一个数组，创建一个由数组元素组成的最小堆</span></span><br><span class="line">MinHeap <span class="title function_">BuildMinHeap</span><span class="params">(ElementType *Element,<span class="type">int</span> Size,<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">    MinHeap H = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, parent = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">    ElementType Temp;</span><br><span class="line"></span><br><span class="line">    H = Create(MaxSize);    <span class="comment">//创建一个空最小堆</span></span><br><span class="line">    <span class="keyword">if</span> (Size &gt; H-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆储存空间不足\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;Size; i++)&#123;</span><br><span class="line">        H-&gt;Elenment[i + <span class="number">1</span>] = Element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Size = Size;</span><br><span class="line">    <span class="comment">//给最小堆排序</span></span><br><span class="line">    <span class="comment">//最后一个节点的父节点的左右指针都指向一个堆，将最后一个节点的父节点和它的两个子节点排序（方法类似与删除节点的操作），使得最后一个节点、其父节点和其兄弟节点形成一个堆。循环操作，从最后一个节点的父节点往上依次执行这个操作，最后使得整个树都是一个堆。</span></span><br><span class="line">    <span class="keyword">for</span> (parent = H-&gt;Size/<span class="number">2</span>; parent &gt;= <span class="number">1</span>; parent--)&#123;</span><br><span class="line">        Temp = H-&gt;Elenment[parent];</span><br><span class="line">        <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果左右子树都存在，将child作为两者较小者的下标</span></span><br><span class="line">            <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child + <span class="number">1</span>]))&#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较parent和child分别指向的结点的大小，parent较大则互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(Temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">                H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H-&gt;Elenment[parent] = Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heapsort是利用堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值总小于（或大于）它的父结点。它有两种方法来排序：</p>
<ol>
<li>大顶堆：每个结点的值都大于或等于其他子结点的值，在堆排序中可用于升序排序。（因为其中每一次排序都会先将堆顶的元素交换到后面）</li>
<li>小顶堆：每个结点的值都小于或等于其他子结点的值，在堆排序中可用于降序排序。</li>
</ol>
<p>堆排序的平均时间复杂度是O（nlogn）</p>
<h4 id="堆排序操作与实现"><a href="#堆排序操作与实现" class="headerlink" title="堆排序操作与实现"></a>堆排序操作与实现</h4><ol>
<li>创建一个堆；</li>
<li>把堆首与堆尾互换；</li>
<li>把堆的尺寸缩小1，并调用heapify（堆化）将堆重新调整好；</li>
<li>重复步骤2、3，直到堆的尺寸为1。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="comment">//建立父结点指标和子结点指标</span></span><br><span class="line">    <span class="type">int</span> parent = start;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;    <span class="comment">//子结点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])     <span class="comment">//选择两个子结点中较大的</span></span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &gt; arr[child])     <span class="comment">//如果父结点较大，则表示调整完毕，直接跳出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则交换父子结点内容，再继续子结点和孙结点比较</span></span><br><span class="line">            swap(&amp;arr[parent],&amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_dort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        max_heapify(arr, i ,len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位交换，再重新调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//因为除了交换的两个元素，其他已经堆化好了，所以从上往下只经过一条路径即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p>
<p><strong>示例 :</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure>

<p>（可以自行构造最大堆或最小堆，加深对堆的认识）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            maxheap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxheap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆实现（只需k个元素在堆里）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            swim(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                sink(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    bool <span class="title function_">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; priorityThan(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; priorityThan(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (priorityThan(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="692-前k个高频单词"><a href="#692-前k个高频单词" class="headerlink" title="692.前k个高频单词"></a>692.前k个高频单词</h3><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p>
<p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p>
<p>示例 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小根优先队列。</span></span><br><span class="line"><span class="comment">//将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 kk 个元素就是前 kk 个出现次数最多的单词。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用哈希表存储字符串和出现次数</span></span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个PriorityQueue对象：将key-value转为entry对象，放入优先队列（堆）中，（自定义）排序（构造最小堆）</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; entry1, Map.Entry&lt;String, Integer&gt; entry2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();	<span class="comment">//注意这里 entry2.compareTo(entry1) 中entry1与entry2在数组中的位置，entry2表示后加进来的元素，entry1表示原来的元素.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将哈希表中的key-value依次放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;    <span class="comment">//大小超过k后，去掉堆顶元素（去掉最小值，因为题目要求最大的k个）</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ret.add(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 + 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            hash.put(s, hash.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一组value变为一个entry对象存入list数组</span></span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hash.get(word1).equals(hash.get(word2)) ? word1.compareTo(word2) : hash.get(word2) - hash.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>G（ V , E ）：图由顶点集合V（G）和边集合E（G）构成；</p>
<p><strong>端点：</strong></p>
<p>无向图：一条边（i，j） ，它的顶点 i 和 j 叫<strong>端点</strong>，它们互为<strong>邻接点</strong>；</p>
<p>有向图：一条边&lt; i , j &gt;  ，它的顶点 i 为 起始端点 （起点），j 为终止端点 （终点），它们互为邻接点；</p>
<p><strong>度</strong>：</p>
<p>以某点为端点的 边的数量 叫该顶点的<strong>度</strong></p>
<p>入度：进入该点的边数；</p>
<p>出度：从该点出发的边数</p>
<p><strong>完全图：</strong></p>
<p>完全无向图：n( n - 1 ) &#x2F; 2 条边</p>
<p>完全有向图：n( n - 1) 条边</p>
<p>当一个图接近完全图时，称为<strong>稠密图</strong>，反之，则为<strong>稀疏图</strong>；</p>
<p><strong>路径：</strong></p>
<p>路径长度：一条路径上经过的边的数目；</p>
<p>简单路径：除开始点和结束点可以相同，其它顶点均不同；</p>
<p>环&#x2F;回路：一条路径上开始点和结束点为同一顶点；</p>
<p><strong>连通：</strong>指从 i 到 j 有路径，则 i 和 j 连通；</p>
<p>连通图：无向图中任意两点连通；</p>
<p>强连通图：有向图中任意两点连通；</p>
<p>连通分量：指无向图G中的极大连通子图；</p>
<p>强连通分量：指有向图G中的极大连通子图；</p>
<p>（强连通图的连通分量只有一个，非连通图有多个连通分量）（强连通图也一样）</p>
<p><strong>权：</strong>边上附加的一个数值，可以表示从一个顶点到另一个顶点的距离或代价；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问：</span><br><span class="line">设有一个图G=（V，E），取V的子集V&#x27;，E的子集E&#x27;。那么，（V&#x27;，E）一定是G的子图吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果对顶点的子集和边的子集不加限定的话，(V&#x27;,E&#x27;)不一定构成一个图。</span><br><span class="line">假如边集对应的顶点包含在所取的顶点集中，则(V&#x27;,E&#x27;)构成G的子图</span><br><span class="line">如果所取的顶点集不能包含s取的边集所对应的所有顶点，则(V&#x27;,E&#x27;)不构成G的子图。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>邻接矩阵 存储类型：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214212034.png" alt="image-20211227214212034"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define MAXV &lt;最大顶点个数&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 顶点 类型    </span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	<span class="type">int</span> no;		<span class="comment">//顶点编号</span></span><br><span class="line">	InfoType info;	<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接矩阵 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>邻接表 存储类型：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214032490.png" alt="image-20211227214032490"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 边节点 类型</span></span><br><span class="line">typedef struct ANode&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;		<span class="comment">//该边的终点编号</span></span><br><span class="line">    struct ANode *next;	<span class="comment">//指向下一条边</span></span><br><span class="line">    InfoType info;	<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接表头节点 类型</span></span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    vertex data;	<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstArc;<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 邻接表 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VNode adjList[MAXV];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;	<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure>

<p><strong>邻接矩阵 和 邻接表 对比：</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214112779.png" alt="image-20211227214112779"></p>
<p><strong>十字链表（有向图）</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214400091.png" alt="image-20211227214400091"></p>
<p>找顶点出边： 顺着绿色线找</p>
<p>找顶点入边：顺着橙色线找</p>
<hr>
<p><strong>邻接多重表（无向图）</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214717843.png" alt="image-20211227214717843"></p>
<hr>
<p><strong>四种存储方式 对比</strong></p>
<p><img src="D:/Note/Typora_picture/image-20211227214851706.png" alt="image-20211227214851706"></p>
<h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createAdj</span><span class="params">(AdjGraph *G, <span class="type">int</span> a[MAXV][MAXV], <span class="type">int</span> n, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;      <span class="comment">//所有头节点的指针域赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; a[i][j] != INF) &#123;        <span class="comment">//这条边存在</span></span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;                  <span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = a[i][j];            <span class="comment">//存放 权</span></span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;   <span class="comment">//头插法插入节点</span></span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">displayAdj</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;</span><br><span class="line">        printf(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        pre = G-&gt;adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//释放第i个单链表的所有节点</span></span><br><span class="line">                free(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(G);    <span class="comment">//释放头节点数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵g 转化成 邻接表G （时间复杂度：O(n^2)）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;</span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将邻接表G转换成邻接矩阵g</span></span><br><span class="line"><span class="comment">//时间复杂度：无向图为O(n+2e)，有向图为O(n+e)，e为边数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)<span class="comment">//扫描所有的单链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;<span class="comment">//p指向第i个单链表的首结点while(p！=NULL)//扫描第i个单链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        g.n = G-&gt;n;</span><br><span class="line">        g.e = G-&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索: O(n+e)</span></span><br><span class="line"><span class="comment">//用栈 或 递归</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXV; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    p = G-&gt;adjList[v].firstArc;</span><br><span class="line">    <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">        w = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索: O(n+e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">//定义环形队列指针</span></span><br><span class="line">    IntiQueue(qu);      <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visit[MAXV];    <span class="comment">//顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%2d&quot;</span>, v); <span class="comment">//输出被访问的顶点 编号</span></span><br><span class="line">    visit[v] = <span class="number">1</span>;   <span class="comment">//此点 已访问</span></span><br><span class="line">    EnQueue(qu, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(qu))&#123;</span><br><span class="line">        DeQuenu(qu, w);     <span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjList[w].firstArc; <span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//查找w的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(qu, p-&gt;adjvex);<span class="comment">//该点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;<span class="comment">//找下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个<strong>连通图的生成树</strong>是一个<strong>极小连通子图</strong>，它含有图中<strong>全部n个顶点</strong>和构成一棵树的（<strong>n - 1</strong> ）条边。</p>
<p>遍历方法得到生成树：深度优先生成树，广度~~树</p>
<p>（所以一个连通图的生成树不一定唯一）</p>
<p><strong>最小生成树</strong></p>
<p>对 带权连通图G （权 均为大于0的实数），其权值之和最小的生成树 即 图的最小生成树。</p>
<h4 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a><strong>普里姆(prim)算法</strong></h4><p>（从顶点 考虑）</p>
<ol>
<li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li>
<li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li>
<li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li>
<li>重复步骤2，3，知道V-S为空集</li>
</ol>
<img src="D:/Note/Typora_picture/prim%E7%AE%97%E6%B3%951.png" style="zoom: 50%;" />

<img src="D:/Note/Typora_picture/prim2.png" style="zoom:50%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MAXV];				<span class="comment">//lowcost存储到未标顶点的最小权值</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> closest[MAXV], i, j, k;		<span class="comment">//closest存储最小权值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;         <span class="comment">//赋初值</span></span><br><span class="line">        lowcost[i] = g.edges[v][i];		</span><br><span class="line">        closest[i] = v;				<span class="comment">//此时生成树只有一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g.n; i++) &#123;     <span class="comment">//输出（n - 1）条边</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//在( V - U )中找出离U最近的顶点k</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;      <span class="comment">//k记录最近的顶点编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;     <span class="comment">//标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)        <span class="comment">//修改数组lowcost和cloest</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];		<span class="comment">//更新S和V-S之间最小权值</span></span><br><span class="line">                closest[j] = k;					<span class="comment">//最小权值对应的 在Sz</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="克鲁斯卡尔（kruskal-算法"><a href="#克鲁斯卡尔（kruskal-算法" class="headerlink" title="克鲁斯卡尔（kruskal)算法"></a><strong>克鲁斯卡尔（kruskal)算法</strong></h4><p>（从边 考虑）</p>
<ol>
<li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li>
<li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li>
<li>直到图中所有的顶点都在同一个顶点集为止</li>
</ol>
<img src="D:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%951.png" style="zoom: 80%;" />

<img src="D:/Note/Typora_picture/kruskal%E7%AE%97%E6%B3%952.png" style="zoom: 67%;" />

<p>思路：连通图的边按照权值从小到大进行排列；依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><img src="D:/Note/Typora_picture/image-20211227204922551.png" alt="image-20211227204922551"></p>
<h4 id="狄克斯特拉-Dijkstra-算法"><a href="#狄克斯特拉-Dijkstra-算法" class="headerlink" title="狄克斯特拉(Dijkstra)算法"></a><strong>狄克斯特拉(Dijkstra)算法</strong></h4><p>只适用 有向无环图，图中存在负权重、环 时，无法使用狄克斯特拉算法</p>
<img src="D:/Note/Typora_picture/Dijkstra%E7%AE%97%E6%B3%95.png" style="zoom:67%;" />

<p>过程如下:</p>
<p>从起点开始，起点到其所有邻居的距离2和6是初始值，其他不相邻的节点的距离为无穷大，</p>
<p>然后从{2,6,无穷大}中找到最小值2,2对应的节点是B，然后从B开始遍历B的所有邻居{A,终点}，计算起点-&gt;B-&gt;A的距离为2+3&#x3D;5，比之前的距离6要小，所以更新A的记录为5，继续计算起点-&gt;B-&gt;终点的距离为2+5&#x3D;7，比之前的距离无穷大要小，所以更新终点的记录为7，至此B的所有相邻节点遍历完毕，故划去B，</p>
<p>之后继续从{2,5,7}中寻找最小值，由于2对应的B节点已经被划去，所以只要从{5,7}中找最小值，最小值为5，5对应于节点A，然后从A开始遍历A的所有邻居{终点}，计算起点-&gt;A-&gt;终点的距离6，比之前的距离7要小，故更新终点的记录为6，至此A的所有邻居遍历完毕，故划去A，</p>
<p>最后只剩下终点这个节点，由于终点没有邻居，故图中的所有邻居遍历完毕。至此得出从起点到终点的最短距离是6。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//狄克斯特拉(Dijkstra)算法：O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;  <span class="comment">//v为源点</span></span><br><span class="line">    <span class="type">int</span> dist[MAXV], path[MAXV]; <span class="comment">//dist[]存放到某点的最短路径长度，path[]存放最短路径</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];    <span class="comment">//标记顶点是否访问过</span></span><br><span class="line">    <span class="type">int</span> mindis, u;      <span class="comment">//mindis为最短距离，u为新考虑的中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123; <span class="comment">//初始化dist和path</span></span><br><span class="line">        dist[i] = g.edges[v][i];    <span class="comment">//距离初始化，即v点到其余点的距离</span></span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        mindis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)       <span class="comment">//找最小路径长度的顶点u</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//修改未考虑的顶点的距离</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist, path, s, g.n, v); <span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h4 id="弗洛伊德-Floyd）算法"><a href="#弗洛伊德-Floyd）算法" class="headerlink" title="弗洛伊德(Floyd）算法"></a><strong>弗洛伊德(Floyd）算法</strong></h4><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p>
<p>矩阵D记录顶点间的最小路径<br>例如D[0q0] [3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；</p>
<p>矩阵P记录顶点间最小路径中的中转点<br>例如P[0] [3]&#x3D; 1 说明，0 到 3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</p>
<p>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathmatirx[MAXV][MAXV];<span class="comment">//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2</span></span><br><span class="line"><span class="type">int</span> shortPath[MAXV][MAXV];<span class="comment">//记录顶点间的最小路径值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">short_path_floyd</span><span class="params">(MatGraph G, <span class="type">int</span> P[MAXV][MAXV], <span class="type">int</span> D[MAXV][MAXV])</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, k;</span><br><span class="line">    <span class="comment">//初始化floyd算法的两个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            D[v][w] = G.edges[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是弗洛伊德算法的核心部分</span></span><br><span class="line">    <span class="comment">//k为中间点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.n; k++) &#123;</span><br><span class="line">        <span class="comment">//v为起点</span></span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">            <span class="comment">//w为终点</span></span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; (D[v][k] + D[k][w])) &#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径</span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的D矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的P矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//求 0 到 3的最小路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;path: %d&quot;</span>, v);<span class="comment">//打印起点</span></span><br><span class="line">    <span class="keyword">while</span> (k != w) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>, k);<span class="comment">//打印中间点</span></span><br><span class="line">        k = P[k][w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p>
<blockquote>
<p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p>
</blockquote>
<p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p>
<p><strong>规则</strong>：</p>
<ul>
<li>图中每个顶点只出现<code>一次</code>。</li>
<li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li>
<li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li>
</ul>
<p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p>
<p><strong>代码思想为：</strong></p>
<p>新建node类，包含节点数值和它的指向；</p>
<p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p>
<p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p>
<p>重复上述操作，直到栈为空。</p>
<h3 id="210-课程表"><a href="#210-课程表" class="headerlink" title="210.课程表"></a>210.课程表</h3><p>现在你总共有 <strong>numCourses</strong> 门课需要选，记为 0 到 numCourses - 1。给你一个数组 <strong>prerequisites</strong> ，其中 <strong>prerequisites[i] &#x3D; [ai, bi]</strong> ，表示在选修课程 ai 前 必须 先选修 bi 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示：[<span class="number">0</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure>

<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组。</p>
<p><strong>题解：</strong></p>
<p>本题是一道经典的「拓扑排序」问题。</p>
<ul>
<li><p>我们将每一门课看成一个节点；</p>
</li>
<li><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A 的前面。</p>
</li>
</ul>
<p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。</p>
<p><strong>方法一，深度优先搜索</strong></p>
<p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p>
<p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p>
<ul>
<li><p>「未搜索」：我们还没有搜索到这个节点；</p>
</li>
<li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p>
</li>
<li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p>
</li>
</ul>
<p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p>
<ul>
<li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p>
</li>
<li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p>
</li>
<li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p>
</li>
<li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)(u,v) 之前的拓扑关系，所以不用进行任何操作。</p>
</li>
<li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p>
</li>
</ul>
<p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li><p>时间复杂度: **O(n+m)**，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p>
</li>
<li><p>空间复杂度: **O(n+m)**。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n)的空间存储节点状态、最终答案等。</p>
</li>
</ul>
<p><strong>方法二：广度优先搜索</strong></p>
<p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p>
<p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p>
<p>我们将 u 放入答案中；</p>
<p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p>
<p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/sort.png" alt="img"></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称为缩小增量（递减增量）算法，是<strong>插入排序的改进</strong>。</p>
<p>希尔排序需要一个增量序列（增量会递减）,一般用len&#x2F;2，如：len为11，则增量分别为5，2，1，进行三次循环。</p>
<p>每次循环排序只排 间隔 为增量值的数，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;      <span class="comment">//i为增量,初始化为len/2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;       <span class="comment">//j用于每次更改增量后遍历一次数组</span></span><br><span class="line">                <span class="type">int</span> k;          <span class="comment">//k用于对第j个元素进行插入排序，比较的是前面间隔为i的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                <span class="keyword">for</span> (k = j; k &gt;= i &amp;&amp; temp &lt; nums[k - i]; k -= i) &#123;</span><br><span class="line">                    nums[k] = nums[k - i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ShellSort</span>().shellSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数据不断分半，直到只剩下一个元素，然后从以分半的两段数据，逐个选出最小的元素移入临时数组的末尾。（归并排序需要用到临时数组）</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Merge-sort-example-300px.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[],<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> l_pos = left;</span><br><span class="line">    <span class="comment">//标记右半曲第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//临时变量元素的下标</span></span><br><span class="line">    <span class="type">int</span> pos = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp;r_pos &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos])     <span class="comment">//左半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[l_pos++];</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//右半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l_pos &lt;= mid)&#123;       <span class="comment">//合并左半区剩余元素（右半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[l_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r_pos &lt;= right)&#123;      <span class="comment">//合并右半区剩余元素（左半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将临时数组中合并后的元素复制到原来的数组</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        arr[left] = tempArr[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//如果只有一个元素，那么不需要继续划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归划分左右半区</span></span><br><span class="line">        msort(arr,tempArr, left, mid);</span><br><span class="line">        msort(arr, tempArr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tempArr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//分配一个辅助数组</span></span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tempArr)&#123;    <span class="comment">//辅助数组分配成功</span></span><br><span class="line">        msort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tempArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: failed to allocate memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在区间中挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行同样操作。直到各个分区只有一个数时为止。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/quickSort.gif" alt="img"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以第一个元素作为基准</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> i = start, j = end, x = s[start];     <span class="comment">//以第一个元素作为基准，后面用了类似挖坑的写法，临时存储这个元素，遇到第一个需要交换的元素，直接赋值给基准处。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;     <span class="comment">//一边交换后，换另一边比较</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quicksort(s, start, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(s, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> i = start, j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= mid &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        quick_sort_recursive(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>（堆积是一个近似完全二叉树的结构，并同时满足堆积的性质）</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p>
<ul>
<li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p>
</li>
<li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p>
</li>
</ul>
<p>算法步骤：</p>
<ol>
<li>创建一个堆</li>
<li>把堆首（最大值）和堆尾互换；</li>
<li>把堆的尺寸减少1，并调用上浮&#x2F;下沉操作，把新的最大值调整到堆首；</li>
<li>重复步骤2，3，直到堆的尺寸为1；</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/heapSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</p>
<p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。</p>
<p>由于<strong>用来计数的数组C的长度取决于待排序数组中数据的范围</strong>（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p>
<p>算法的步骤如下：</p>
<ol>
<li><p>找出待排序的数组中最大和最小的元素</p>
</li>
<li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p>
</li>
<li><p>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p>
</li>
</ol>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/countingSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，<strong>尽量增大桶的数量</strong></li>
<li>使用的映射函数能够将输入的 <strong>N 个数据均匀的分配到 K 个桶中</strong></li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</p>
<p>最慢的情况：当输入的数据被分配到了同一个桶中。</p>
<p>示例：</p>
<p>元素分布在桶中：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="img"></p>
<p>然后，元素在每个桶中排序：</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);  <span class="comment">//桶大小是5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选出最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里的XxxSort根据情况而定</span></span><br><span class="line">            bucket = XxxSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（自动扩容）将元素加入到桶中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<p>下面三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<p><img src="https://www.runoob.com/wp-content/uploads/2019/03/radixSort.gif" alt="img"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最高位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取位数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> (arr[j] % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>)     <span class="comment">//考虑正负数</span></span><br><span class="line">                    bucket += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bucket = -bucket;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容，并保存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>对磁盘中的数据进行排序。</p>
<h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>最少只需要在内存中开辟2个输入缓冲区和一个输出缓冲区，每次将磁盘的数据块 输入到输入缓冲区，然后按 归并排序的规则，从2个输入缓冲区 每次跳出最小的数 放到输出缓冲区，当有输入缓冲区为空了，应该立刻将和它排好序的下一个数据块放到输入缓冲区中。当输出缓冲区满时，写出外存。</p>
<p>减少时间开销：进行<strong>K路归并排序</strong>，需要在内存中分配k个输入缓冲区和一个输出缓冲区。</p>
<blockquote>
<p>因为读写磁盘时间开销大，所以多几路可以提高效率，但也不能太多，因为需要在内存中开多个缓冲区，且每次比较都要比较这k个缓冲区的最小值</p>
</blockquote>
<p>时间开销：读写外存时间+内部排序时间+内部归并时间</p>
<p>优化：</p>
<ul>
<li><strong>增加归并路数k</strong><ul>
<li>代价1：需要增加相应的输入缓冲区</li>
<li>代价2：每次从k个归并段总选一个最小值需要（k-1）次比较。——<strong>可用败者树减少关键字比较次数</strong></li>
</ul>
</li>
<li><strong>减少初始归并段数量r</strong><ul>
<li>若有N个记录，内存工作区可放L个记录，则初始归并段数量 r &#x3D; N &#x2F; L ——<strong>可用 置换-选择排序 减少初始归并段</strong></li>
</ul>
</li>
</ul>
<h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树解决的问题：使用多路平衡归并可減少归并趟数，但是用老土方法从k个归并段选出一个最小&#x2F;最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到 log<del>2</del>k。</p>
<p>败者树可视为一棵<strong>完全二又树（多了一个在根节点之上的头节点</strong>）。<strong>k个叶结点</strong>分别对应<strong>k个归并段</strong>中当前参加比较的元素，<strong>非叶子结点</strong>用来记忆<strong>左右子树中的“失败者”</strong>，而让胜者往上继续进行比较，一直到根结点。</p>
<p><img src="D:/Note/Typora_picture/image-20211227202553354.png" alt="image-20211227202553354"></p>
<p><img src="D:/Note/Typora_picture/image-20211227202243956.png" alt="image-20211227202243956"></p>
<h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>设初始待排文件为FI,初始归并段输出文件为FO,内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置換-选择算法的步骤如下：</p>
<ol>
<li>从FI输入w个记录到工作区WA</li>
<li>从WA中选出其中关键字取最小值的记录，记为 MIINIMAX记录。(MIINIMAX指不断选出的最小指中的最大值)</li>
<li>将 MINIMAX记录输出到FO中去。</li>
<li>若FI不空，则从FI输入下一个记录到WA中。</li>
<li>从WA中所有关键字比 MIINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li>
<li>重复(3)~(5),直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li>
<li>重复(2)~(6),直至WA为空。由此得到全部初始归并段。</li>
</ol>
<p><img src="D:/Note/Typora_picture/image-20211227203606666.png" alt="image-20211227203606666"></p>
<p><img src="D:/Note/Typora_picture/image-20211227203540414.png" alt="image-20211227203540414"></p>
<h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li><p>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ ）。<br>(A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</p>
<blockquote>
<p>答案：A</p>
<p>先用指针变量q指向结点A的后继结点B，然后将结点B的值复制到结点A中，最后删除结点B。</p>
</blockquote>
</li>
<li><p>设有n个待排序的记录关键字，则在堆排序中需要（ ）个辅助记录单元。</p>
<blockquote>
<p>答案：1个。</p>
<p>堆排序只需一个辅助空间，用来记录当前操作的二叉树上的根节点的数字，来与其左右孩子节点比较。</p>
</blockquote>
</li>
<li><p>设某二叉树中度数为0的结点数为N0，度数为1的结点数为Nl，度数为2的结点数为N2，则下列等式成立的（ ）。</p>
<blockquote>
<p>答案：N<del>0</del> &#x3D; N<del>2</del> + 1</p>
</blockquote>
</li>
<li><p>设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（ ）。</p>
<blockquote>
<p>答案：log<del>2</del>n + 1</p>
</blockquote>
</li>
<li><p>1、数据的最小单位是（ A ）。<br>(A) 数据项<br>(B) 数据类型<br>(C) 数据元素<br>(D) 数据变量</p>
</li>
<li><p>设一棵m叉树中度数为0的结点数为N0，度数为1的结点数为N1，……，度数为m的结点数为Nm，则N0 &#x3D;（ B ）。<br>(A) Nl+N2+……+Nm<br>(B) <strong>1+N2+2N3+3N4+……+(m-1)Nm</strong><br>(C) N2+2N3+3N4+……+(m-1)Nm<br>(D) 2Nl+3N2+……+(m+1)Nm</p>
</li>
<li><p>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个。 </p>
<blockquote>
<p>解：6个</p>
<p>除了根节点外，其他节点均为孩子节点，而孩子节点等于总的分支数，即 孩子节点 &#x3D;  1 * n<del>1</del> + 2 * n<del>2</del>+3 * n<del>3</del> &#x3D; 10；</p>
<p>所以总节点数 &#x3D; 10 + 1 &#x3D; 11（1是指根节点），度数为0的节点数 &#x3D; 11 - n<del>1</del> - n<del>2</del> - n<del>3</del> &#x3D; 6;</p>
</blockquote>
</li>
<li><p>设顺序表的长度为n，则顺序查找的平均比较次数为（）。</p>
<blockquote>
<p>解：（n+1）&#x2F; 2</p>
<p>若第一个为查找元素，则查找次数为1，。。。。。所以 平均查找次数为 (1+2+3 + ….+ n) &#x2F; n&#x3D; (1+n) &#x2F; 2； </p>
</blockquote>
</li>
<li></li>
</ol>
<h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol>
<li><p>通常从四个方面评价算法的质量：<u>正确性、易读性、强壮性、高效性</u>。</p>
</li>
<li><p>数据结构从逻辑上划分为三种基本类型：线性结构，树型结构，图型结构。</p>
</li>
<li><p>用链表存储二叉树，则有n个节点的二叉树共有 2n 个指针域，其中 n-1 个存放了地址，剩下的是空指针（n+1个）。</p>
</li>
<li><p>AOV网是一种 <u>有向无回路</u> 的图。</p>
</li>
<li><p>对于具有n个顶点和e条边的有向图和无向图，其对应的邻接表中，所含边节点分别有 e 和 2e 个。</p>
</li>
<li><p>在一个具有n个顶点的无向完全图中，包含有 n(n-1)&#x2F;2 条边，有n个顶点的有向完全图中，包含有 n(n-1) 条边。</p>
</li>
<li><p>设某二叉树中度数为0的节点数为 N，度数为1的节点数为 M，可得该二叉树中度数为2的节点数为 <u>N - 1</u> ，。</p>
</li>
<li><p>数据的物理结构主要包括 顺序存储结构 和 链式存储结构。</p>
</li>
<li><p>设满二叉树的深度为k， 则该树的节点数为 2^k^ - 1； 若用二叉链表作为二叉树的存储结构，设该树有 n 个节点，则一共有 n + 1个空指针域。</p>
</li>
<li><p>一个序列，经过栈的作用可以得到 C^n^<del>2n</del>&#x2F; (n+1) 中不同的输出序列。（卡特兰数）</p>
</li>
</ol>
<blockquote>
<p>如：序列有3个数，则有5中不同的输出序列。</p>
</blockquote>
<ol start="11">
<li><p>设哈夫曼树有n个节点，则该树有 0 个度数为1的节点。</p>
</li>
<li><p>设有n个结点的完全二叉树，如果按照从自上到下、从左到右从1开始顺序编号，则第 i 个结点的双亲结点编号为 i &#x2F; 2 ;  右孩子结点的编号为 2i + 1。</p>
</li>
<li><p>设一组初始记录关键字为(72，73，71，23，94，16，5)，则以记录关键字72为基准的一趟快速排序结果为 </p>
<blockquote>
<p>答案：(5，16，71，23，72，94，73)</p>
<p>两个指针，从左开始，和从右开始，先从右开始选第一个遇到的小于基准的数，和基准数换位；换 从左开始，遇到的第一个大于基准的数，和基准换位；再从右继续……循环，直至小于基准的在左边，大于基准的在右边。</p>
</blockquote>
</li>
<li><p>在二叉排序树中插入一个结点的时间复杂度为 O(n)，如果该排序树即不平衡，需要遍历n个节点，如果该树很平衡，则只需log<del>2</del>n。</p>
</li>
<li><p>设初始记录关键字序列为(K1，K2，…，Kn)，则用筛选法思想建堆必须从第 <em><strong>n&#x2F;2</strong></em> 个元素开始进行筛选。</p>
</li>
<li><p>设哈夫曼树中共有99个结点，则该树中有<u>50</u> 个叶子结点；若采用二叉链表作为存储结构，则该树中有_<u>100</u>_个空指针。</p>
</li>
<li><p>设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储______m-1个队列元素；当前实际存储_____(R - F + M) % M_个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。</p>
</li>
<li><p>设顺序线性表中有n个数据元素，则第i个位置上插入一个数据元素需要移动表中 <em><strong><u>n-i+1</u></strong></em> 个数据元素；删除第i个位置上的数据元素需要移动表中 <u>n-i</u> 个元素。</p>
</li>
<li><p>根据二叉树的<u>先序和中序</u>遍历、或<u>中序和后序</u>遍历，可以唯一确定二叉树的形状。</p>
</li>
<li><p>筛选法建初始堆必须从第 n &#x2F; 2 个元素开始进行筛选。</p>
</li>
<li><p>快速排序在序列基本有序时为 O(n^2^)，在序列基本无序时为 O(nlog<del>2</del>n)。</p>
</li>
<li><p>设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有 <u>n(m-1)+1</u> 个空指针域。</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" data-id="cl1ynefm6000aswtu2r4o0557" data-title="数据结构" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          算法
        
      </div>
    </a>
  
  
    <a href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">设计模式</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Notes/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/">快捷键</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Notes/" class="mobile-nav-link">Home</a>
  
    <a href="/Notes/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Notes/js/jquery-3.4.1.min.js"></script>



  
<script src="/Notes/fancybox/jquery.fancybox.min.js"></script>




<script src="/Notes/js/script.js"></script>





  </div>
</body>
</html>