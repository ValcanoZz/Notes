<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/Notes/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/Notes/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/Notes/css/style.css">

  
    
<link rel="stylesheet" href="/Notes/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/Notes/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/Notes/">Home</a>
        
          <a class="main-nav-link" href="/Notes/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/Notes/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-linux" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/linux/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.236Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/linux/">Linux</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>linux是一个开源、兔费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目(c&#x2F;c++&#x2F;php&#x2F;python&#x2F;java&#x2F;go) 都会部署到Linux&#x2F;unix系统上。</p>
<blockquote>
<p>常见的操作系统(windows、IOS、Android、MacOS、Linux、Unix)</p>
<p>linux之父：Linus Torvalds，他开发了linux0.01版源码，也是Git创作者。</p>
</blockquote>
<hr>
<p><strong>Linux主要发行版本</strong></p>
<p><strong>Ubuntu</strong>（乌班图），<strong>RedHat</strong>（红帽子），<strong>CentOS</strong>，Debain，Fedora，SuSE，OpenSUSE</p>
<hr>
<h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul>
<li><p>linux在&#x3D;&#x3D;服务器领域&#x3D;&#x3D;的应用是最好的，有免费，稳定，高效的特点。</p>
</li>
<li><p>在嵌入式领域，linux运行稳定，对网络有良好支持，且低成本，能根据需求进行软件裁剪，内核最小可到几百kb。</p>
<p>如：机顶盒、数字电视、网络电话、远程交换机、手机、PDA、智能家居等 物联网应用。</p>
</li>
</ul>
<hr>
<h3 id="Linux和Unix的关系"><a href="#Linux和Unix的关系" class="headerlink" title="Linux和Unix的关系"></a>Linux和Unix的关系</h3><p>Unix只针对大型主机或服务器，后来在GNU计划（自由软件 集体协作计划）倡导下，Linus Torvalds基于Unix的轻量版Minix上开发出了Linux内核。</p>
<hr>
<h3 id="linux网络连接的三种模式"><a href="#linux网络连接的三种模式" class="headerlink" title="linux网络连接的三种模式"></a>linux网络连接的三种模式</h3><ul>
<li>桥接模式，虚拟系统可以和外部系统通讯，但是容易造成IP冲突；</li>
<li>NAT模式，网络地址转换模式虚拟系统可以和外部系统通讯，不造成IP冲突；</li>
<li>主机模式：独立的系统；</li>
</ul>
<hr>
<h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>VMware提供了快照管理，它能使虚拟机系统回到原先某个正常运行的状态。</p>
<p>在选项“虚拟机”下的“快照”处使用快照。</p>
<p>调分辨率：xrandr -s 1</p>
<hr>
<h3 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h3><p>在vmWare的“虚拟机”选项中设置共享的文件夹在主机中的路径，设置好后，可以在centos的主文件夹——其他位置——计算机——mnt——hgfs下找到共享的文件。</p>
<h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>因为linux服务器是开发小组共享，正式上线的项目是运行在公网的。因此程序员需要远程登录到Liux进行项目管理或者开发。</p>
<blockquote>
<p>远程登录客户端：可以用Xshell</p>
<p>远程传输文件：可以用Xftp</p>
<p>其他工具大同小异。</p>
</blockquote>
<h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>linux的文件系统是采用<strong>级层式</strong>的&#x3D;&#x3D;树状目录结构&#x3D;&#x3D;，在此结构中的最上层是根目录 “ &#x3D;&#x3D;&#x2F;&#x3D;&#x3D; ”，然后在此目录下再创建其他的目录。</p>
<blockquote>
<p>在linux中，一切皆文件。</p>
</blockquote>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204081725703.png" alt="image-20220408172505611"></p>
<hr>
<p><strong>具体目录结构：</strong></p>
<ul>
<li><p>&#x2F;bin【常用】 (&#x2F;usr&#x2F;bin &#x2F;usr&#x2F;local&#x2F;bin)<br>是Binary [ˈbaɪnəri] (二进制) 的缩写，这个目录存放着最经常使用的命令。</p>
</li>
<li><p>&#x2F;sbin               (&#x2F;usr&#x2F;sbin &#x2F;usr&#x2F;local&#x2F;sbin)<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p>home【常用】<br>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</p>
</li>
<li><p>&#x2F;root【常用】<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p>&#x2F;Iib</p>
<p>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p>
</li>
<li><p>&#x2F;Iost+found</p>
<p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p>&#x2F;etc【常用】<br>所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库 my.conf。</p>
</li>
<li><p>&#x2F;usr【常用】<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p>
</li>
<li><p>&#x2F;boot【常用】</p>
<p>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p>&#x2F;proc【不能动】 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p>
</li>
<li><p>&#x2F;srv【不能动】service缩写，该目录存放一些服务启动之后需要提取的数据。</p>
</li>
<li><p>&#x2F;sys【不能动】这是liux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs&#x3D;》【别动】</p>
</li>
<li><p>&#x2F;tmp      这个目录是用来存放一些临时文件的。</p>
</li>
<li><p>&#x2F;dev<br>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</p>
</li>
<li><p>&#x2F;media【常用】</p>
<p>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p>
</li>
<li><p>&#x2F;mnt 【常用】系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。 如：和主机的共享文件夹。</p>
</li>
<li><p>&#x2F;opt<br>这是给主机额外安装软件所存放的目录。如安装 oracle数据库就可放到该目录下。默认为空。</p>
</li>
<li><p>&#x2F;usr&#x2F;local【常用】<br>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p>
</li>
<li><p>&#x2F;var 【常用】<br>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p>
</li>
<li><p>selinux [security-enhanced linux]<br>SELinux 是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p>
</li>
</ul>
<h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>linux内置 vim文本编辑器，具有程序编辑能力。</p>
<p><strong>三种模式：</strong></p>
<ul>
<li><strong>一般模式</strong>：用vim打开文档时直接进入的是一般模式，可以使用 [上下左右]键来移动光标，用 [删除字符]或 [删除整行] 来处理文档，也可以使用复制粘贴。</li>
<li><strong>编辑模式</strong>：按下 i，o，a，r任意字母之后可以进入编辑模式。一般都是按 i 键。</li>
<li><strong>命令行模式</strong>：在一般模式下输入 ：或 &#x2F; 后可进入，在此模式下，可以使用相关指令：读取、存盘、替换、离开vim、显示行号等。</li>
</ul>
<p><strong>模式间的切换：</strong></p>
<blockquote>
<p>命令行下： # &#x3D;&#x3D;vim&#x3D;&#x3D; xxx 进入一般模式</p>
<p>一般模式下： &#x3D;&#x3D;i&#x3D;&#x3D; 进入编辑模式， &#x3D;&#x3D;:&#x3D;&#x3D; 或 &#x3D;&#x3D;&#x2F;&#x3D;&#x3D; 进入命令行模式</p>
<p>编辑模式和命令行模式下： 按&#x3D;&#x3D;esc&#x3D;&#x3D;退出到一般模式</p>
<p>命令行模式下： &#x3D;&#x3D;wq&#x3D;&#x3D; 保存退出，q 退出 ，q！强制退出，不保存</p>
</blockquote>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204082035048.png" alt="image-20220408203535866"></p>
<hr>
<h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><p>在一般模式下：</p>
<p>拷贝当前行：<strong>yy</strong>， 如果要拷贝当前向下的5行，则 5yy，然后粘贴（输入p）；</p>
<p>删除当前行：<strong>dd</strong>，如果要删除当前向下的5行，则 5dd；</p>
<p>撤销： <strong>u</strong></p>
<p>定位到文档的末行和首行： <strong>G</strong> 到末行， <strong>gg</strong> 到首行；</p>
<p>定位到文档的某一行：先输入 <strong>行号</strong>，再按 <strong>shift + g</strong></p>
<hr>
<p>在命令行模式下：</p>
<p>查找： <strong>&#x2F;关键字</strong> ，然后按回车查找，按n查找下一个</p>
<p>设置文件的行号： <strong>:set nu</strong></p>
<p>取消文件的行号： <strong>:set nonu</strong></p>
<hr>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204082049378.png" alt="image-20220408204927118"></p>
<h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h1><blockquote>
<p>在命令末尾或sql语句末尾加上  &#x3D;&#x3D;&#x2F;G&#x3D;&#x3D;，表示将显示结果按行打印，提高显示效果。</p>
<p>运行文件时，末尾加“&amp;”，表示后台运行，如：.&#x2F;hello.java &amp;</p>
</blockquote>
<h3 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机&amp;重启"></a>关机&amp;重启</h3><p>立即关机： shutdown -h now  或  halt</p>
<p>立即重启：shutdown -r now  或  reboot</p>
<p>一分钟后关机： shutdown -h 1  </p>
<p>将内存的数据同步到磁盘：sync</p>
<blockquote>
<p>关机和重启的命令执行前，默认会执行一次同步命令sync。</p>
</blockquote>
<hr>
<h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>切换用户(可以切换到管理员身份)： su - 用户名</p>
<p>注销用户&#x2F;退出登录&#x2F;返回原来用户：logout </p>
<blockquote>
<p>由于系统管理员有最大权限，为避免误操作，平时登录时尽量少用root账号登录。可以先登录普通用户，再用“su - 用户名”切换管理员身份；</p>
<p>logout 只能在提示符下使用，在图形运行终端处 和 运行级别3以下 使用无效。</p>
</blockquote>
<hr>
<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>添加用户： useradd 用户名</p>
<blockquote>
<p>当创建用户成功后，会自动在home目录下创建和用户同名的家目录，也可以通过 “ useradd -d 指定目录 新用户名” 在创建新用户时指定 家目录。</p>
</blockquote>
<p>修改密码：passwd 用户名</p>
<blockquote>
<p>注意：如果用户名中有大写字母的话，在输入命令，要换成小写。</p>
</blockquote>
<p>删除用户： userdel 用户名</p>
<blockquote>
<p>” userdel 用户名“会保留家目录，如果要删除用户及其用户主目录，用 ”userdel -r 用户名“</p>
</blockquote>
<p>查询用户信息： id 用户名</p>
<p>查看当前用户：whoami </p>
<p>查看登录用户：who am i</p>
<blockquote>
<p>用户组：系统可以将 拥有共性&#x2F;权限的多个用户进行分组，以方便进行管理。</p>
</blockquote>
<p>新增组：groupadd 组名</p>
<p>删除组：groupdel 组名</p>
<p>新增用户时直接加入组：useradd -g 用户组 用户名</p>
<p>修改用户的组别：usermod -g 用户组 用户名</p>
<blockquote>
<p>用户 和 组 的相关文件：</p>
<ul>
<li><p>&#x2F;etc&#x2F;passwd  ——  用户user的配置文件，记录用户的各种信息；</p>
<p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p>
<p>如：valcanozz : x:1000:1000:ValcanoZz:&#x2F;home&#x2F;valcanozz:&#x2F;bin&#x2F;bash</p>
</li>
<li><p>&#x2F;etc&#x2F;shadow  —— 口令的配置文件</p>
<p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p>
</li>
<li><p>&#x2F;etc&#x2F;group  —— 组group的配置文件，记录Linux包含的组的信息；</p>
<p>每行的含义：组名：口令：组标识号：组内用户列表</p>
</li>
</ul>
</blockquote>
<hr>
<h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>切换运行级别： init  [0123456]</p>
<p>显示默认运行级别：systemctl  get-default</p>
<blockquote>
<p>运行级别：</p>
<p>0: 关机<br>1: 单用户【找回丢失密码】，root权限，用于系统维护，禁止远程登录<br>2: 多用户状态，没有网络服务<br>3: 完全的多用户状态，有网络服务，无界面<br>4: 系统未使用，保留给用户<br>5: 图形界面<br>6: 系统重启<br>常用运行级别是3和5，也可以指定默认运行级别。</p>
<p>设置默认运行级别：systemctl set-default 运行级别；  如：systemctl  set-default  multi-user.target 切换默认级别为3；</p>
<table>
<thead>
<tr>
<th>init级别</th>
<th>systemctl target</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>shutdown.target</td>
</tr>
<tr>
<td>1</td>
<td>emergency.target</td>
</tr>
<tr>
<td>2</td>
<td>rescure.target</td>
</tr>
<tr>
<td>3</td>
<td>multi-user.target</td>
</tr>
<tr>
<td>4</td>
<td>无</td>
</tr>
<tr>
<td>5</td>
<td>graphical.target</td>
</tr>
<tr>
<td>6</td>
<td>无</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<p><strong>开机流程：</strong></p>
<p>开机 —— BIOS —— &#x2F;boot —— systemd进程1 —— 运行级别 —— 运行级对应的服务</p>
<hr>
<h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>获取帮助信息： man 命令或配置文件，如：man ls 查看ls命令的帮助信息；</p>
<blockquote>
<p>man可以获取 命令的使用说明，是中文文档，在man下，按空格显示下一页，按q退出</p>
</blockquote>
<p>获取shell内置命令的帮助信息：help 命令</p>
<blockquote>
<p>显示出的是英文文档。</p>
</blockquote>
<hr>
<h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>显示当前工作目录的绝对路径：pwd</p>
<p>显示当前目录下的文件： ls</p>
<p>显示指定目录下的文件： ls  目录路径</p>
<ul>
<li>ls的常用选项： -a 显示所有文件包括隐藏文件，-l 以列表形式显示信息</li>
</ul>
<p>切换目录： cd  路径</p>
<ul>
<li>cd 的常用法：<ul>
<li>cd~ 或cd： —— 回到自己的家目录，比如你是root, 则cd~ 就是到 &#x2F;root</li>
<li>cd..   —— 回到上一级目录</li>
</ul>
</li>
</ul>
<blockquote>
<p>在linux下，隐藏文件是以 . 开头；</p>
<p>命令的选项可以组合使用，比如 ls -a 和 ls -l 可以组合：ls -al 或 ls -la</p>
</blockquote>
<p>创建目录： mkdir  新目录名</p>
<ul>
<li>mkdir常用选项： -p  创建多级目录（没加-p就只能创建一级目录）<ul>
<li>如：mkdir  &#x2F;home&#x2F;dog<br>    mkdir  -p   &#x2F;home&#x2F;animal&#x2F;tiger</li>
</ul>
</li>
</ul>
<p>删除空目录：rmdir  空目录</p>
<p>删除非空目录： rmdir  -rf  目录</p>
<p>创建空文件：touch 文件名</p>
<p>拷贝文件： cp  源文件  目标文件(夹)</p>
<p>拷贝整个文件夹： cp  -r  源文件夹  目标文件夹</p>
<blockquote>
<p>如果想强制覆盖不提示，可以在cp命令前加”\“ ，如：\cp  -r  &#x2F;home&#x2F;hello.txt  &#x2F;opt</p>
</blockquote>
<p>删除文件或目录：rm  文件或目录名</p>
<ul>
<li>常用选项： -r   递归删除整个文件夹 ； -f  强制删除不提示</li>
</ul>
<p>文件重命名：mv  旧文件名  新文件名</p>
<p>文件移动：mv  旧文件路径  新文件路径</p>
<p>查看文件：cat  文件名</p>
<ul>
<li>常用选项： -n  显示行号</li>
</ul>
<blockquote>
<p>cat 命令只能浏览文件，不能修改文件；</p>
<p>一般为了浏览方便，会带上管道命令： |  ，管道命令就是将上一个命令的结果交给下一个命令处理，如： car -n &#x2F;etc&#x2F;profile | more，就是将查看文件的内容 用more命令查看</p>
</blockquote>
<p>more指令：是一个基于VI编辑器的文本过滤器，它以按页方式显示文本内容；</p>
<ul>
<li><p>语法：more  文件名</p>
</li>
<li><p>more模式下的按键：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空格</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>回车</td>
<td>向下翻一行</td>
</tr>
<tr>
<td>q</td>
<td>离开more</td>
</tr>
<tr>
<td>Ctrl + F</td>
<td>向下滚动一个屏幕</td>
</tr>
<tr>
<td>Ctrl + B</td>
<td>返回上一屏幕</td>
</tr>
<tr>
<td>&#x3D;</td>
<td>输出当前行的行号</td>
</tr>
<tr>
<td>:f</td>
<td>输出文件名和当前行号</td>
</tr>
</tbody></table>
</li>
</ul>
<p>less指令：采用分屏方式查看文件内容，功能与more类似，但比more更强大，支持各种终端。</p>
<ul>
<li><p>语法：less  文件名</p>
</li>
<li><p>less模式下的按键：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>空格 或 [pagedown]</td>
<td>向下翻一页</td>
</tr>
<tr>
<td>[pageup]</td>
<td>向上翻一页</td>
</tr>
<tr>
<td>&#x2F;字串</td>
<td>向下搜索 字串，n：向下找，N：向上找</td>
</tr>
<tr>
<td>?字串</td>
<td>向上搜索 字串，n：向下找，N：向上找</td>
</tr>
<tr>
<td>q</td>
<td>离开less</td>
</tr>
</tbody></table>
</li>
</ul>
<p>输出内容到控制台： echo  内容   （内容可以是环境变量，如 $PATH，$HOSTNAME）</p>
<p>显示文件开头内容： head 文件名</p>
<ul>
<li>默认显示头10行，使用 head -n  5 文件名 ，可以显示头5行。</li>
</ul>
<p>显示文件末尾内容：tail  文件</p>
<ul>
<li>默认显示末10行，使用 tail -n 5 文件名，可以显示末5行，  </li>
<li>tail -f  文件名，可以实时监控文件。</li>
</ul>
<p>.   &gt;指令 和 &gt;&gt; 指令</p>
<ul>
<li><p>前者是覆盖，后者是追加</p>
<p>如：</p>
<p>ls  -l  &gt;  文件		(将列表的内容写入文件a.txt中（覆盖写））<br>ls  -al  &gt;&gt;  文件		(将列表的内容追加到文件aa.txt的末尾)<br>cat  文件1  &gt;  文件2		(将文件1的内容覆盖到文件2)<br>echo  “内容”  &gt;&gt;  文件（追加）</p>
</li>
</ul>
<p>软链接： ln  -s  原文件或目录  软链接名  ，如： ln  -s  &#x2F;root  &#x2F;home&#x2F;myroot   在&#x2F;home下创建一个软链接，指向&#x2F;root；</p>
<p>查看历史命令： history</p>
<ul>
<li>查看最近的10条命令：history  10； 执行历史编号为5的命令： !5</li>
</ul>
<hr>
<h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><p>显示日期：</p>
<p>date		显示当前时间<br>date +%Y		显示当前年份<br>date +%m		显示当前月份<br>date +%d		显示当前是哪一大<br>date “+%Y-%m-%d%H:%M:%S”		显示年月日时分秒</p>
<p>设置日期： date  -s  字符串时间  ，如：date  -s  “2022-04-09 18:54:10”</p>
<p>查看当月日历：cal         查看2020年日历：cal  2020</p>
<hr>
<h3 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h3><p>查看ip ： ifconfig </p>
<p>查找指定文件： find   目录范围  选项</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-name  …</td>
<td>查找指定文件名</td>
</tr>
<tr>
<td>-user  …</td>
<td>查找属于某用户的所有文件</td>
</tr>
<tr>
<td>-size  …</td>
<td>按照指定文件大小查找</td>
</tr>
</tbody></table>
<blockquote>
<p>如：</p>
<p>按文件名：根据名称查找&#x2F;home目录下的hello.txt文件	——  find  &#x2F;home  -name  hello.txt<br>按拥有者：查找&#x2F;opt目录下，用户名称为nobody的文件	—— find  &#x2F;opt  -user  nobody<br>查找整个liux系统下大于200M的文件(+n大于n小于n等于，单位有k,M,G)	—— find  &#x2F;-size  +200M</p>
</blockquote>
<p>基于数据库查询文件： locate  文件</p>
<p>由于locate指令基于数据库进行查询，所以第一次运行前，需 使用 updatedb 指令创建 locate数据库。</p>
<blockquote>
<p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。</p>
<p>Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻</p>
</blockquote>
<p>查看指令在哪个目录下： which  指令</p>
<p>过滤查找：grep  [选项]  查找内容  源文件</p>
<ul>
<li>-n   显示匹配行及行号</li>
<li>-i   忽略字母大小写</li>
</ul>
<blockquote>
<p>如：在hello.txt文件中，查找”yes”所在行，并且显示行号<br>写法1: 	cat  &#x2F;home&#x2F;hello.txt  |  grep  -n  “yes”<br>写法2: 	grep  -n  “yes”  home&#x2F;hello.txt</p>
</blockquote>
<p>注：grep后的查找内容 支持正则表达式，如 ls -l &#x2F;opt | grep “^d”   表示查看&#x2F;opt文件夹下 的目录，”^d”表示以d开头。</p>
<hr>
<h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><p>将文件压缩为 .gz文件： gzip  文件</p>
<p>解压缩 .gz文件： gunzip  文件.gz</p>
<p>压缩文件或目录： zip  [选项]   xxx.zip   文件或目录</p>
<ul>
<li>-r   递归压缩，即压缩目录</li>
</ul>
<p>解压缩文件： unzip  [选项]  压缩文件</p>
<ul>
<li>-d  目录      —— 指定解压后文件的存放目录</li>
</ul>
<p>打包文件： tar  [选项]   xxx.tar.gz  打包的内容</p>
<ul>
<li>-c	产生.tar打包文件</li>
<li>-v    显示详细信息</li>
<li>-f    指定压缩后的文件名</li>
<li>-z    打包同时压缩</li>
<li>-x    解包 .tar文件</li>
</ul>
<blockquote>
<p>如：</p>
<p>压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz<br>    tar  -zcvf   pc.tar.gz  &#x2F;home&#x2F;pig.txt   &#x2F;home&#x2F;cat.txt</p>
<p>将home的文件夹压缩成myhome.tar.gz<br>    tar  -zcvf   myhome.tar.gz   &#x2F;home&#x2F;</p>
<p>将pc.tar.gz 解压到当前目录<br>    tar  -zxvf   pc.tar.gz</p>
<p>将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2目录下<br>    tar  -zxvf   &#x2F;home&#x2F;myhome.tar.gz-C   &#x2F;opt&#x2F;tmp2</p>
</blockquote>
<h1 id="组管理-和-权限管理"><a href="#组管理-和-权限管理" class="headerlink" title="组管理 和 权限管理"></a>组管理 和 权限管理</h1><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有 所有者、所在组、其它组的概念。</p>
<ul>
<li><p>所有者</p>
<p>一般是指 文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。</p>
<ul>
<li><p>查看所有文件的所有者： ls  -ahl</p>
</li>
<li><p>修改文件所有者： chown  用户名[:所在组]  文件名  （-r  如果是目录，则使其下的子文件和目录递归生效）</p>
</li>
</ul>
</li>
<li><p>所在组</p>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组（默认）。</p>
<ul>
<li><p>修改文件&#x2F;目录 所在的组： chgrp  组名  文件名</p>
</li>
<li><p>新增组：groupadd 组名</p>
</li>
<li><p>删除组：groupdel 组名</p>
</li>
<li><p>新增用户时直接加入组：useradd -g 用户组 用户名</p>
</li>
<li><p>修改用户的组别：usermod -g 用户组 用户名</p>
</li>
</ul>
</li>
<li><p>其他组</p>
<p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p>
</li>
</ul>
<blockquote>
<p>在root用户下，可以改变用户的组别：	</p>
<p>usermod  -g  新组名  用户名<br>usermod  -d  目录名  用户名   ——  改变该用户登陆的初始目录。说明：用户需要有进入到新目录的权限。</p>
</blockquote>
<p><strong>权限：</strong></p>
<p>使用 ls -l 显示出的信息首部，有  -rwxrw-r–.  类似的列表，它代表不同不同用户对该文件的 权限。</p>
<ul>
<li><ul>
<li>r  代表可读（read），</li>
<li>w 代表可写 (修改文件，或该目录内创建删除重命名目录)， </li>
<li>x 代表可执行 (执行文件，或进入目录）；</li>
</ul>
</li>
<li>权限列表 0~9位：<ul>
<li>第0位：确定文件类型—— l 是链接，d 是目录 ， c 是 字符设备文件, 如鼠标,键盘，b 是块设备, 如硬盘，- 是普通文件，</li>
<li>第1~3位： 所有者的权限</li>
<li>第4~6位：所属组的权限（和所有者同一组的其他用户）</li>
<li>第7~9位：其他组的用户的权限</li>
</ul>
</li>
</ul>
<blockquote>
<p>-rw-r–r–.  1  root  root  143  4月  8  21:22  hello.java</p>
<p>分别代表的含义： 权限  (文件)硬链接数&#x2F;(目录)子目录数  用户名  组名  文件&#x2F;目录大小   最后修改日期   文件名</p>
</blockquote>
<ul>
<li><p><strong>修改权限</strong>： chmod</p>
<ul>
<li><p>通过 + - &#x3D; 变更权限：</p>
<p>chmod   u&#x3D;rwx,g&#x3D;rw,o&#x3D;x	文件目录名</p>
<p>chmod   o+w	文件目录名</p>
<p>chmod   a-x	文件目录名</p>
<blockquote>
<p>u: 所有者	g：所有组	o：其他人	a：所有人（u，g，o的总和）</p>
</blockquote>
</li>
<li><p>通过 数字变更权限：</p>
<p>chmod   751   文件目录名</p>
<p>相当于  chmod   u&#x3D;rwx,g&#x3D;rw,o&#x3D;x	文件目录名</p>
<blockquote>
<p>r &#x3D; 4，w &#x3D; 2， x &#x3D; 1， 所以rwx &#x3D; 4+2+1 &#x3D; 7，rx &#x3D; 4 + 1 &#x3D; 5</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p>
<p>任务调度分类：</p>
<ul>
<li>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等；</li>
<li>个别用户工作：个别用户可能希望执行某些程序，比如对 mysql数据库的备份；</li>
</ul>
<p>指令：&#x3D;&#x3D;crontab  [选项]&#x3D;&#x3D;</p>
<ul>
<li>-e	编辑定时任务</li>
<li>-l     查询crontab任务</li>
<li>-r     删除当前用户所有的crontab任务（终止任务调度）</li>
<li>service crond restart   重启任务调度</li>
</ul>
<blockquote>
<p>执行  crontab -e  ，进入任务编辑界面；</p>
<p>输入任务，如： *&#x2F;2 * * * *  ls -l  &#x2F;etc&#x2F;  &#x2F;tmp&#x2F;to.txt<br>意思是：每2分钟执行一次 ls -l  &#x2F;etc&#x2F;  &#x2F;tmp&#x2F;to.txt</p>
</blockquote>
<p>定时用的 五个 * 占位符：</p>
<table>
<thead>
<tr>
<th></th>
<th>含义</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td>第一个 *</td>
<td>一小时中的第几分钟</td>
<td>0~59</td>
</tr>
<tr>
<td>第二个 *</td>
<td>一天中的第几小时</td>
<td>0~23</td>
</tr>
<tr>
<td>第三个 *</td>
<td>一月中的第几天</td>
<td>1~31</td>
</tr>
<tr>
<td>第四个 *</td>
<td>一年中的第几月</td>
<td>1~12</td>
</tr>
<tr>
<td>第五个 *</td>
<td>一周中的星期几</td>
<td>0~7 (0和7都是周日)</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>代表每个单位时间，如第一个*指一小时的每分钟都执行一次</td>
</tr>
<tr>
<td>，</td>
<td>代表不连续时间，如“0 8,12,16 * * * 命令” 指每天的8点，12点，16点都执行一次命令</td>
</tr>
<tr>
<td>-</td>
<td>代表连续时间，如“0 5 * * 1-6 命令” 指周一到周六的5点0分执行都执行一次命令</td>
</tr>
<tr>
<td>*&#x2F;n</td>
<td>代表间隔多久执行一次</td>
</tr>
</tbody></table>
<hr>
<p>指令：&#x3D;&#x3D;at [选项] [时间]&#x3D;&#x3D;    一次性定时计划任务</p>
<blockquote>
<p>at的守护进程std会在后台运行，检查作业队列来运行；</p>
<p>默认情况下，atd守护进程每60秒检查作业队列。</p>
<p>在使用at命令时，一定要保证atd进程的启动，使用 ps -ef | grep atd  检测atd是否在运行。</p>
<p>按下Crel + D 结束at命令的输入</p>
<p>atrm  4   将编号为4的任务删除</p>
<p>atq   查看at任务</p>
</blockquote>
<p>选项：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-m</td>
<td>当指定任务完成，将给用户发送邮件</td>
</tr>
<tr>
<td>-I  （是大写i )</td>
<td>atq的别名</td>
</tr>
<tr>
<td>-d</td>
<td>atrm的别名</td>
</tr>
<tr>
<td>-v</td>
<td>显示任务将被执行的时间</td>
</tr>
<tr>
<td>-c</td>
<td>打印任务的内容到标准输出</td>
</tr>
<tr>
<td>-V</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>-q 队列</td>
<td>使用指定的队列</td>
</tr>
<tr>
<td>-f  文件</td>
<td>从指定文件读入任务，而不是从标准输入读入</td>
</tr>
<tr>
<td>-t  时间参数</td>
<td>以时间参数的形式提交要运行的任务</td>
</tr>
</tbody></table>
<blockquote>
<p>at 的时间定义：</p>
<ul>
<li>当天的时间：  hh:mm，如果时间过去了，就放到第二天执行；</li>
<li>12小时计时，后加am或pm，如11pm；</li>
<li>具体日期： yy-mm-dd  或 mm&#x2F;dd&#x2F;yy  或  dd.mm,yy，如：04:00 2022-03-1；</li>
<li>相对计时法，格式为： now + 时间单位；</li>
<li>直接用 today ，tomorrow 来指定时间；</li>
</ul>
<p>例：</p>
<ul>
<li><p>2天后的下午5点执行&#x2F;bin&#x2F;1 s &#x2F;home<br>#at  5pm  + 2 days<br>at&gt; &#x2F;bin&#x2F;ls  &#x2F;home</p>
</li>
<li><p>明天17点钟，输出时间到指定文件内  比如root&#x2F;datel100.log<br>#at  5pm  tomorrow<br>at&gt; data &gt; &#x2F;root&#x2F;date100.log</p>
</li>
<li><p>2分钟后，输出时间到指定文件内比如root&#x2F;date200.log<br>#at  now  + 2  minutes<br>at&gt; data &gt; &#x2F;root&#x2F;date200.log</p>
</li>
</ul>
</blockquote>
<h1 id="磁盘分区、挂载"><a href="#磁盘分区、挂载" class="headerlink" title="磁盘分区、挂载"></a>磁盘分区、挂载</h1><p>linux中，硬盘的分区需要挂载到 目录才能使用，这种处理方式叫“载入”，使一个分区和一个目录联系起来。</p>
<p>Linux硬盘分为 IDE 和 SCSI 两种，目前基本都用SCSI硬盘；</p>
<ul>
<li><p>IDE硬盘：</p>
<p>驱动器标识符为“hdx~”</p>
<ul>
<li>“hd” 表示分区所在的设备为IDE硬盘；</li>
<li>“x”为盘号：a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘；</li>
<li>“~” 代表分区，用数字表示，前4个分区为主分区或拓展分区，从5开始是逻辑分区；</li>
</ul>
</li>
<li><p>SCSI硬盘：</p>
<p>驱动器标识符为“sdx~”</p>
<ul>
<li>“sd” 表示分区所在的设备为IDE硬盘；</li>
<li>“x”为盘号：a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘；</li>
<li>“~” 代表分区，用数字表示，前4个分区为主分区或拓展分区，从5开始是逻辑分区；</li>
</ul>
</li>
</ul>
<p>相关指令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看设备挂载情况</span><br><span class="line">lsblk</span><br><span class="line">lsblk -f</span><br><span class="line">// 查看系统整体磁盘使用情况</span><br><span class="line">df -h</span><br><span class="line">//查看指定目录的磁盘使用情况</span><br><span class="line">du -h 目录</span><br><span class="line">选项: </span><br><span class="line">-s	指定目录占用大小汇总</span><br><span class="line">-h	带计量单位</span><br><span class="line">-a	含文件</span><br><span class="line">-max-depth=l	子目录深度</span><br><span class="line">-c	列出明细的同时，增加汇总值</span><br><span class="line">如: du -hac --max-depth=1 /opt</span><br></pre></td></tr></table></figure>



<h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>windows中查看网络配置：ipconfig</p>
<p>linux中查看网络配置：ifconfig</p>
<p>测试主机间网络连通性： ping  目的主机</p>
<hr>
<p>将主机的ip修改为静态ip：</p>
<ul>
<li><p>进入配置文件：vi  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p>
</li>
<li><p>修改文件：</p>
<p>BOOTPROTO&#x3D;static		#[none|static |bootp|dhcp] (引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议)<br>IPADDR&#x3D;192.168.205.129	#指定ip地址<br>GATEWAY&#x3D;192.168.205.2	#网关<br>DNS1&#x3D;192.168.205.2	#域名解析器</p>
</li>
<li><p>修改VMware的虚拟网络编辑器</p>
</li>
<li><p>重启网络服务：service network restart</p>
</li>
</ul>
<hr>
<p>查看主机名：hostname</p>
<p>修改主机名文件： vim  &#x2F;etc&#x2F;hostname	修改后重启生效</p>
<p>设置hosts映射（可以通过别名代替ip地址）：</p>
<ul>
<li>windows：在 C:\Windows\System32\drivers\etc\hosts 指定即可；</li>
<li>linux：在 &#x2F;etc&#x2F;hosts  文件指定</li>
</ul>
<blockquote>
<p>主机名解析机制：</p>
<ul>
<li>浏览器先检查浏览器缓存中有没有该域名解析P地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存，如果有直接返回P完成解析。这两个缓存，可以理解为本地解析器缓存。<ul>
<li>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址（DNS解析记<br>录）。如在cmd窗口中输入<br>ipconfig &#x2F;displaydns 	&#x2F;&#x2F;DNS域名解析缓存<br>ipconfig &#x2F;flushdns		&#x2F;&#x2F;手动清理dns缓存</li>
</ul>
</li>
<li>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</li>
<li>如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP,则到域名服务DNS进行解析域</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204120936007.png" alt="image-20220412093654757"></p>
</blockquote>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>在LINUX中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号 (pid,进程号)。</p>
<blockquote>
<p>程序是可运行的代码，是静态的，进程是已经运行在内存中，是动态的；</p>
<p>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p>
<p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p>
</blockquote>
<p><strong>查看进程：  ps  [选项]</strong></p>
<ul>
<li>ps -a		显示当前终端的所有进程信息</li>
<li>ps -u        以用户的格式显示进程信息</li>
<li>ps -x        显示后台进程运行的参数</li>
<li>如：ps  -aux  |  grep  xxx</li>
</ul>
<blockquote>
<p>ps显示字段说明：</p>
<ul>
<li>System V	展示风格</li>
<li>USER：用户名称</li>
<li>PID：进程号</li>
<li>%CPU：进程占用CPU的百分比</li>
<li>%MEM：进程占用物理内存的百分比</li>
<li>VSZ：进程占用的虚拟内存大小(单位：KB)</li>
<li>RSS：进程占用的物理内存大小(单位：KB)</li>
<li>TT：终端名称，缩写</li>
<li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li>
<li>START：进程的启动时间</li>
<li>TIME：CPU时间，即进程使用CPU的总时间</li>
<li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li>
</ul>
</blockquote>
<p><strong>终止进程：</strong></p>
<ul>
<li><strong>kill  [选项]  进程号</strong>			通过进程号杀死&#x2F;终止进程<ul>
<li>-9       表示强迫进程立即停止</li>
</ul>
</li>
<li><strong>killall    进程名称</strong>           通过进程名称杀死进程，也支持通配符(这在系统因负载过大而变得很慢时很有用)</li>
</ul>
<blockquote>
<p>如：</p>
<p>终止远程登录服务sshd： kill  sshd对应的进程号；</p>
<p>再次启动sshd服务：&#x2F;bin&#x2F;systemctl  start  sshd.service</p>
</blockquote>
<p><strong>查看进程树：pstree   [选项]</strong>       （-p：显示pid， -u：显示所属用户）</p>
<hr>
<h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务(service)<strong>本质就是进程</strong>，但是服务是运行在<strong>后台</strong>的，通常都会监听某个端口，等待其它程序的请求，比如（mysqld,sshd,防火墙等），因此又被称为<strong>守护进程</strong>。</p>
<p><strong>service管理指令： servicce  服务名   [start|stop|restart|reload|status]</strong></p>
<blockquote>
<p>在CentOS7.0之后，很多服务不再使用service，而是改为systemctl；</p>
<p>现在还在使用service指令的服务，可以在 &#x2F;etc&#x2F;init.d 查看，有：functions，netconsole，network，README，vmware-tools</p>
<p>例：  service  network  status   查看网络服务状态</p>
</blockquote>
<p><strong>查看服务名：</strong> 输入 setup ，然后选择“系统服务” 即可查看全部服务。</p>
<p>服务的运行级别</p>
<p><strong>给不同运行级别设置自启动的服务：</strong> chkconfig</p>
<ul>
<li><strong>查看服务：chkconfig  –list</strong> </li>
<li><strong>修改自启动&#x2F;关闭：chkconfig  –level  5  服务名  on&#x2F;off</strong></li>
</ul>
<blockquote>
<p>chkconfig重新设置后，要重启才生效。</p>
<p>在CentOS7.0之后，很多服务改为systemctl进行管理，chkconfig管理的范围和service一样[?]；</p>
</blockquote>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204121119405.png" alt="image-20220412111942205"></p>
<hr>
<p><strong>systemctl 管理指令：</strong></p>
<p>语法： <strong>systemctl  [start|stop|restart|status]  服务名</strong></p>
<p>查看ysytemctl管理的范围：在 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system中查看 </p>
<ul>
<li>查看服务的自启动状态： systemctl list-unit-files </li>
<li>设置服务开机启动&#x2F;关闭：systemctl enable&#x2F;disable 服务名</li>
<li>查看服务是否是自启动：systemctl  is-enabled 服务名</li>
</ul>
<blockquote>
<p>systemctl  start&#x2F;stop  服务名   只是当前生效，重启后仍按设置来；</p>
<p>想要自启动 永久生效，要更改设置，即systemctl enable&#x2F;disable 服务名</p>
</blockquote>
<hr>
<p><strong>设置防火墙：firewall指令</strong></p>
<ul>
<li><p>打开端口：firewall-cmd  –permanent  –add-port&#x3D;端口号&#x2F;协议</p>
</li>
<li><p>关闭端口：firewall-cmd  –permanent  –remove-port&#x3D;端口号&#x2F;协议</p>
</li>
<li><p>重新载入防火墙，使设置生效：firewall-cmd  –reload</p>
</li>
<li><p>查询端口是否生效：firewall-cmd  -query-port&#x3D;端口&#x2F;协议</p>
</li>
</ul>
<p>**动态监控进程： top [选项] **</p>
<ul>
<li>-d  秒数      指定top命令每隔几秒更新，默认是3秒；</li>
<li>-i                 使top不显示闲置和僵死的进程；</li>
<li>-p                通过指定ID来监控某个进程的状态；</li>
</ul>
<p>top界面交互：</p>
<ul>
<li>P    以CPU使用率排序，默认；</li>
<li>M    以内存使用率排序；</li>
<li>N    以PID排序；</li>
<li>u     再输入用户名，监控指定用户的进程；</li>
<li>k     再输入进程ID号，结束进程；</li>
<li>q    退出top</li>
</ul>
<p><strong>监控网络状态： netstat  [选项]</strong></p>
<ul>
<li>-an     按一定顺序排列输出；</li>
<li>-p     显示哪个进程在调用；</li>
</ul>
<p><strong>检测主机连接命令： ping  对方ip</strong></p>
<h1 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h1><p>RPM</p>
<p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有 .RPM扩展名的文件。RPM是RedHat Package Manager (RedHat软件包管理工具) 的缩写，类似windows的setup.exe,这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。<br>Linux的分发版本都有采用(suse,redhat,.centos等等)，可以算是公认的行业标准。</p>
<blockquote>
<p>rpm包名格式：</p>
<p>firefox-60.2.2-1.el7.centos.x86 64</p>
<ul>
<li>名称：firefox</li>
<li>版本号：60.2.2-1</li>
<li>使用操作系统：el7.centos.x86 64</li>
</ul>
</blockquote>
<p>指令：</p>
<ul>
<li>查询已安装的rpm列表： rpm  -qa | grep  xxx</li>
<li>查询软件包是否安装：rpm   -q   软件名</li>
<li>查询软件包信息： rpm   -qi   软件名</li>
<li>查询软件包中的文件：rpm  -ql   软件名</li>
<li>查询文件所属的软件包：rpm  -qf   目录&#x2F;文件</li>
<li>卸载软件包：rpm  -e   软件名<ul>
<li>如果其他软件依赖于将要删除的软件包，则卸载时会产生错误信息，可以加上参数 –nodeps  来强制删除，一般不推荐这么做。</li>
</ul>
</li>
<li>安装rpm包： rpm  -ivh   rpm包全路径名<ul>
<li>i    install 安装</li>
<li>v    verbose 提示</li>
<li>h    hash 进度条</li>
</ul>
</li>
</ul>
<hr>
<p>yum</p>
<p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动<br>下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p>
<p>指令：</p>
<ul>
<li><p>查询yum服务器是否有需要安装的软件：yum list | grep  软件名</p>
</li>
<li><p>安装yum包： yum install  xxxx</p>
</li>
</ul>
<h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><blockquote>
<p>需求：</p>
<p>Linuxi运维工程师在进行服务器集群管理时，需要编写Shell程序来进行服务器管理。<br>对于JavaEE和Python程序员来说，工作的需要，可能需要编写一些Shell脚本进行程序或者服务器的维护，比如编写一个定时备份数据库的脚本。<br>对于大数据程序员来说，需要编写Shell程序来管理集群。</p>
</blockquote>
<p>Shel是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Sheel来启动、挂起、停止甚至是编写一些程序。</p>
<p>脚本格式要求:</p>
<ul>
<li>脚本以  &#x3D;&#x3D;#!&#x2F;bin&#x2F;bash&#x3D;&#x3D;  开头</li>
</ul>
<p>执行：</p>
<p>方式1 不用权限，直接用sh命令执行文件： sh  xxx.sh</p>
<p>方式2  需要权限，使用绝对或相对路径执行： .&#x2F;xxx.sh</p>
<blockquote>
<p>权限不够，可用 chmod u+x  xxx.sh 赋予执行权限；</p>
</blockquote>
<hr>
<h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><p>显示shell中所有变量：set</p>
<ul>
<li><p>系统变量：</p>
</li>
<li><p>用户自定义变量：</p>
<ul>
<li><p>定义方式：变量名&#x3D;值     如：A&#x3D;100</p>
</li>
<li><p>撤销变量： unset  变量</p>
</li>
<li><p>声明静态变量：readonly  变量       ——注：静态变量不能unset</p>
</li>
</ul>
<blockquote>
<p>注：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=100</span><br><span class="line">echo A=$A        #输出变量时，前面要带$，以作区分</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">unset A</span><br><span class="line"></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将指令返回的结果赋值给变量,使用 `` 或 $()</span> </span><br><span class="line">C=`date`</span><br><span class="line">D=`$(date)`</span><br></pre></td></tr></table></figure></blockquote>
</li>
</ul>
<p>变量定义的规范：</p>
<ul>
<li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如：5A&#x3D;200  是错的；</li>
<li>等号两侧不能有空格；</li>
<li>变量名称一般习惯为大写；</li>
</ul>
<blockquote>
<p>输出变量时，前面要带&#x3D;&#x3D;$&#x3D;&#x3D;，不然会被识别为字符；</p>
<p>将指令返回的结果赋值给变量，使用 &#x3D;&#x3D;&#96;&#96;&#x3D;&#x3D; 或 &#x3D;&#x3D;$()&#x3D;&#x3D;   ；</p>
</blockquote>
<p>设置环境变量：</p>
<ul>
<li>在环境变量的配置文件中，用 “export 变量名&#x3D;变量值”   设置环境变量&#x2F;全局变量</li>
<li>刷新配置文件  ：source 配置文件</li>
<li>查询环境变量的值： echo $ 变量名</li>
</ul>
<blockquote>
<p>环境变量的配置文件在：&#x2F;etc&#x2F;profile</p>
</blockquote>
<hr>
<p>shell脚本的多行注释：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">	内容</span><br><span class="line">!</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>位置参数变量：</strong></p>
<p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。</p>
<p>语法：</p>
<ul>
<li>$n   ——   n为数字，$0代表命令本身，$1 ~ $9代表第1到第9个参数，10以上的参数，10以上的参数需要用大括号包含，如 ${10}   </li>
<li>$*   ——   这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体</li>
<li>$@  ——   这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区分对待</li>
<li>$#  ——   这个变量代表命令行中所有参数的个数</li>
</ul>
<p>如：在 hello.sh文件中，写入</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;执行命令为$0   第一个参数为$1  第一个参数为$2&quot;</span><br><span class="line">echo &quot;所有的参数为 $*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;参数个数为 $#&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如执行指令:  ./hello.sh 100 200, 会输出:</span></span><br><span class="line">执行命令为./hello.sh   第一个参数为100  第一个参数为200</span><br><span class="line">所有的参数为 100 200</span><br><span class="line">100 200</span><br><span class="line">参数个数为 2</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>预定义变量：</strong></p>
<p>$$   ——   当前进程的进程号（PID)<br>$!   ——   后台运行的最后一个进程的进程号（PID)<br>$？——  最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0  (具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前执行的进程id=$$&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以后台的方式运行一个脚本，并获取他的进程号</span></span><br><span class="line">root/shcode/myshell.sh &amp;</span><br><span class="line">echo &quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="line">echo &quot;执行的结果是=$?&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>三种使用格式：</p>
<ul>
<li>$((运算式)) </li>
<li>$[运算式]</li>
<li>expr m + n  &#x2F;&#x2F;expression表达式<ul>
<li>注意expr运算符间要有空格，如果希望将expr的结果赋给某个变量，要加反引号 &#96;&#96;</li>
</ul>
</li>
</ul>
<p>运算符：和其他的一样，但乘号要加 “ \ “，如   \ *</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：计算(2+3)X4的值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第一种方式</span></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line">echo &quot;res1=SRES1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第二种方式，推荐使用</span></span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line">echo &quot;res2=SRES2&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第三种方式<span class="built_in">expr</span></span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES4=`expr $STEMP \* 4`</span><br><span class="line">echo &quot;res4=SRES4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：请求出命令行的两个参数[整数]的和 20 50</span></span><br><span class="line">SUM=$S[$1+$2]</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>判断符号：</p>
<ul>
<li>字符串比较： &#x3D;</li>
<li>两个整数比较：<ul>
<li>-lt   小于</li>
<li>-le   小于等于 little equal</li>
<li>-eq   等于   equal</li>
<li>-gt    大于</li>
<li>-ge    大于等于  greater  equal</li>
<li>-ne    不等于</li>
</ul>
</li>
<li>按照文件权限进行判断：<ul>
<li>-r    有读的权限</li>
<li>-w   有写的权限</li>
<li>-x    有执行的权限</li>
</ul>
</li>
<li>按照文件类型进行判断：<ul>
<li>-f    文件存在，且是一个常规文件</li>
<li>-e    文件存在</li>
<li>-d    文件存在并是一个目录</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用 =</span></span><br><span class="line">1f [ &quot;ok&quot;=&quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2:23是否大于等于22</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用~ge</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">	echo &quot;大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3:/root/shcode,/aaa.txt目录中的文件是否存在</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用-f</span></span><br><span class="line">if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">	echo&quot;存在&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看几个案例</span></span><br><span class="line">if hspedu</span><br><span class="line">then</span><br><span class="line">	echo &quot;hello,hspedu&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>

<p><strong>流程控制：</strong></p>
<p><strong>if 判断</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>if…else if…else 判断</strong></p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line"><span class="keyword">elif</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">	...</span><br><span class="line">	</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p><strong>for循环</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">do </span><br><span class="line">	...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="keyword">for</span> 变量名 int 参数列表</span></span><br><span class="line">do </span><br><span class="line">	...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：反复输出 命令行输入的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里 <span class="variable">$@</span> 会分多次输出， $* 会一次性输出</span></span><br><span class="line">for loop int $@</span><br><span class="line">do </span><br><span class="line">	echo &quot;the value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：<span class="built_in">sum</span> 从1累加到100</span></span><br><span class="line">SUM=0</span><br><span class="line">for(( i=1; i&lt;=100; i++))</span><br><span class="line">do</span><br><span class="line">	SUM=$[$SUM+$i]</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>while语句</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断 ]</span><br><span class="line">do</span><br><span class="line">	...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="keyword">while</span> ((条件判断))</span></span><br><span class="line">do</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>无限循环：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure>

<p><strong>until循环</strong></p>
<p>until 会一直循环到 条件为ture 为止，与while正好相反；</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断 ]</span><br><span class="line">do</span><br><span class="line">	...</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p><strong>case….esac 多选择语句</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">值1)</span><br><span class="line">	...</span><br><span class="line">;;</span><br><span class="line">值2)</span><br><span class="line">	...</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure>

<p>跳出循环：  break   和   continue</p>
<hr>
<h3 id="read输入"><a href="#read输入" class="headerlink" title="read输入"></a>read输入</h3><p>read  选项  参数</p>
<ul>
<li>选项： -p   输出读取时的提示符     -t   指定读取时等待的时间（秒），超时则继续往下执行代码。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -t 10 -p &quot;请输入一个数NUM1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的NUM1=$NUM1&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>系统函数：</p>
<ul>
<li><p><strong>basename  文件路径名  [文件后缀]</strong></p>
<p>取出前缀路径，获取文件名；</p>
<p>如果指定了文件后缀，也可以同时去掉文件后缀；</p>
</li>
<li><p><strong>dirname  文件路径名</strong></p>
<p>去掉文件名，获取路径部分</p>
</li>
</ul>
<p>自定义函数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[function] 函数名()&#123;</span><br><span class="line">	....</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/</span></span><br><span class="line">function getSum()&#123;</span><br><span class="line">	SUM=$[$n1+$n2]</span><br><span class="line">	echo &quot;和是$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入n1=&quot; n1</span><br><span class="line">read -p &quot;请输入n2=&quot; n2</span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure>







<p>CentOS8.1的使用</p>
<p>日志管理</p>
<p>内核源码&amp;内核升级</p>
<p>备份与恢复</p>
<p>可视化管理 webmin 和 bt 运维工具</p>
<h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>找回root密码：</p>
<ul>
<li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。</li>
<li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以“fi” “Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。</li>
<li>输入完成后，直接按快捷键：Ctrl+x 进入 单用户模式。</li>
<li>进入后，在光标闪烁的位置中输入：mount -o remount,rw &#x2F;</li>
<li>在新的一行最后面输入：passwd   按回车键。之后就可以输入新密码，以及确认密码。</li>
<li>密码修改后，会显示passwd…..的样式，即修改成功；</li>
<li>接着输入：touch  &#x2F;.autorelabel 回车，再输入：exec &#x2F;sbin&#x2F;init  回车，然后等待系统修改密码（过程时间可能有点长），并自动重启即可。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/linux/" data-id="cl1ynefm20007swtu7bphae0a" data-title="Linux" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Leetcode刷题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.225Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/">算法题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="2-两数相加-M"><a href="#2-两数相加-M" class="headerlink" title="2.两数相加(M)"></a>2.两数相加(M)</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>
<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>
<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure>

<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>要注意的点：</p>
<p>节点和大于9，要注意进位；</p>
<p>最后一个节点进位要额外新加一个节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            list.val %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> list;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1 != <span class="literal">null</span> ? l1.val : l2.val);</span><br><span class="line">                l1 = l1 != <span class="literal">null</span> ? l1.next : l1;</span><br><span class="line">                l2 = l2 != <span class="literal">null</span> ? l2.next : l2;</span><br><span class="line">            &#125;</span><br><span class="line">            list = list.next;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                list.val++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                list.val %= <span class="number">10</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="3-无重复字符的最长子串-M"><a href="#3-无重复字符的最长子串-M" class="headerlink" title="3.无重复字符的最长子串(M)"></a>3.无重复字符的最长子串(M)</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>思路：</p>
<p>使用滑动窗口：每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p>
<p>使用哈希集合判断是否有字符重复</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashSet&lt;Character&gt; set= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                set.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r + <span class="number">1</span>&lt; n &amp;&amp; !set.contains(s.charAt(r + <span class="number">1</span>)))&#123;</span><br><span class="line">                set.add(s.charAt(r + <span class="number">1</span>));</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, r - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="4-寻找两个正序数组的中位数-D"><a href="#4-寻找两个正序数组的中位数-D" class="headerlink" title="4.寻找两个正序数组的中位数(D)"></a>4.寻找两个正序数组的中位数(<strong>D</strong>)</h1><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，中位数 <span class="number">2</span></span><br></pre></td></tr></table></figure>



<p>方法一：</p>
<p>暴力法：直接将两个数组加入到一个新数组，排序，再求中位数</p>
<p>时间复杂度：O（(m+n)*log(m+n) )；空间：O（m+n）</p>
<p>将两个数组的值从小到大 合并到新数组，再求中位数</p>
<p>时间复杂度：O（m+n )；空间：O（m+n）</p>
<p>方法二：</p>
<p>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。</p>
<p>时间复杂度：O（m+n )；空间：O（1）</p>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><p>这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)&#x2F;2 或 (m+n)&#x2F;2+1。</p>
<p>找到第 k 个元素，我们可以比较 A[k&#x2F;2-1] 和B[k&#x2F;2-1]，</p>
<p>可以归纳出三种情况：</p>
<ul>
<li><p>如果 A[k&#x2F;2-1] &lt; B[k&#x2F;2-1]，则比 A[k&#x2F;2−1] 小的数最多只有 A 的前 k&#x2F;2−1 个数和 B 的前 k&#x2F;2−1 个数，即比 A[k&#x2F;2−1] 小的数最多只有 k-2 个，因此 A[k&#x2F;2−1] 不可能是第 k 个数，A[0] 到 A[k&#x2F;2−1] 也都不可能是第 k 个数，可以全部排除。</p>
</li>
<li><p>如果 A[k&#x2F;2−1]&gt;B[k&#x2F;2−1]，则可以排除 B[0] 到 B[k&#x2F;2−1]。</p>
</li>
<li><p>如果 A[k&#x2F;2−1]&#x3D;B[k&#x2F;2−1]，则可以归入第一种情况处理。</p>
</li>
</ul>
<p>可以看到，比较 A[k&#x2F;2−1] 和 B[k&#x2F;2−1] 之后，可以排除 k&#x2F;2k&#x2F;2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p>
<p>有以下三种情况需要特殊处理：</p>
<ul>
<li><p>如果 A[k&#x2F;2−1] 或者B[k&#x2F;2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k&#x2F;2。</p>
</li>
<li><p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</p>
</li>
<li><p>如果 k&#x3D;1，我们只要返回两个数组首元素的最小值即可。</p>
</li>
</ul>
<p>用一个例子说明：</p>
<p>A: 1 3 <strong>4</strong> 9<br>B: 1 2 <strong>3</strong> 4 5 6 7 8 9</p>
<blockquote>
<p>k &#x3D; (4 + 9 ) &#x2F; 2 + 1 &#x3D; 7;</p>
<p>比较两个数组下标为k &#x2F; 2 - 1 &#x3D; 2的数，即A[2] 和B[2]</p>
<p>由于A[2] &gt; B[2] ，所以排除B[0] 到B[2]，数组B的下标偏移变为3，同时更新k的值：K &#x3D; K - K &#x2F; 2 &#x3D; 4;</p>
<p>下一步寻找，比较下标为 K &#x2F; 2 - 1 &#x3D; 1的数，即A[1] 和B[4] </p>
</blockquote>
<p>A: 1 <strong>3</strong> 4 9<br>B: <del>1 2 3</del> 4 <strong>5</strong> 6 7 8 9</p>
<blockquote>
<p>由于 A[1] &lt; B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k &#x3D; k - k&#x2F;2&#x3D;2。</p>
<p>下一步寻找，比较两个有序数组中下标为 k&#x2F;2-1&#x3D;0 的数，即比较 A[2] 和 B[3]</p>
</blockquote>
<p>A: <del>1 3</del> <strong>4</strong> 9<br>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p>
<blockquote>
<p>由于A[2]&#x3D;B[3]，根据之前的规则，排除A 中的元素，因此排除 A[2]，即数组 A 的下标偏移变为 3，同时更新 k 的值： k&#x3D;k-k&#x2F;2&#x3D;1。</p>
<p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3] &gt; B[3]，因此第 k 个数是 B[3]&#x3D;4。</p>
</blockquote>
<p>A: <del>1 3 4</del> <strong>9</strong> </p>
<p>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（log(m+n) )；空间：O（1）</p>
<h3 id="划分数组"><a href="#划分数组" class="headerlink" title="划分数组"></a><strong>划分数组</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// 为了保证第一个数组比第二个数组小(或者相等)</span></span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数</span></span><br><span class="line">        <span class="comment">//的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLeft</span> <span class="operator">=</span> (leftLength + rightLength + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> leftLength;</span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j]</span></span><br><span class="line">        <span class="comment">//  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// 循环条件结束的条件为指针重合，即分割线已找到</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置</span></span><br><span class="line">            <span class="comment">// 此处+1首先是为了不出现死循环，即left永远小于right的情况</span></span><br><span class="line">            <span class="comment">// left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right</span></span><br><span class="line">            <span class="comment">// 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了</span></span><br><span class="line">            <span class="comment">// i不会取到0值，即i-1不会小于0(另一说法：此处+1是为了避免出现死循环，同时+1后，不会出现下标越界的情况)</span></span><br><span class="line">            <span class="comment">// 此时i也代表着在一个数组中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和</span></span><br><span class="line">            <span class="comment">// 此时j就是第二个元素中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">            <span class="comment">// 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值</span></span><br><span class="line">            <span class="comment">// 说明又指针应该左移，即-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环时left一定等于right，所以此时等于left和right都可以</span></span><br><span class="line">        <span class="comment">// 为什么left一定不会大于right?因为left=i。</span></span><br><span class="line">        <span class="comment">// 此时i代表分割线在第一个数组中所在的位置</span></span><br><span class="line">        <span class="comment">// nums1[i]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums[i-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 此时j代表分割线在第二个数组中的位置</span></span><br><span class="line">        <span class="comment">// nums2[j]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums2[j-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">        <span class="comment">// 当i=0时，说明第一个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1LeftMax</span> <span class="operator">=</span> i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1RightMin</span> <span class="operator">=</span> i == leftLength ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="comment">// 当j=0时，说明第二个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LeftMax</span> <span class="operator">=</span> j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2RightMin</span> <span class="operator">=</span> j == rightLength ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        <span class="comment">// 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可</span></span><br><span class="line">        <span class="keyword">if</span> (((leftLength + rightLength) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一</span></span><br><span class="line">            <span class="comment">// 此处不能被向下取整，所以要强制转换为double类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（log min(m+n) )；空间：O（1）</p>
<h1 id="5-最长回文子串-M"><a href="#5-最长回文子串-M" class="headerlink" title="5.最长回文子串(M)"></a>5.最长回文子串(M)</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">输入：s = <span class="string">&quot;ac&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h3><p>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p>
<ul>
<li>首先往左寻找与当期位置相同的字符，直到遇到不相等为止。</li>
<li>然后往右寻找与当期位置相同的字符，直到遇到不相等为止。</li>
<li>最后左右双向扩散，直到左和右不相等。</li>
</ul>
<p>每个位置向两边扩散都会出现一个窗口大小（templen）。如果 templen &gt; maxLen，则更新 maxLen 的值。<br>因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 maxLen 时的起始，结尾位置（也可以只记录初始位置，结尾位置 &#x3D; 初始位置 + maxlen - 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> &amp;&amp; s.charAt(<span class="number">0</span>) == s.charAt(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>, templen = <span class="number">0</span>, lIndex = <span class="number">0</span>, rIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">1</span>; mid &lt; n - <span class="number">1</span>; mid++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid - <span class="number">1</span>, j = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == s.charAt(mid))&#123;</span><br><span class="line">                i--;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp;s.charAt(j) == s.charAt(mid))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    templen += <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxlen &lt; templen)&#123;</span><br><span class="line">                maxlen = templen;</span><br><span class="line">                lIndex = i + <span class="number">1</span>;</span><br><span class="line">                rIndex = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            templen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(lIndex, rIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n^2）空间复杂度： O（1）</p>
<h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。</p>
<p><strong>边界条件：</strong>子串长度小于2 时一定为回文串，即 ： j - 1 - ( i + 1 ) + 1 &lt; 2 ,整理得 <strong>j - i &#x3D; 3</strong> </p>
<p><strong>状态转移方程：</strong></p>
<p><strong>dp[ i ] [ j ] &#x3D; ( s [ i ] &#x3D;&#x3D; s [ j ] ) and ( j - i &lt; 3 or dp[ i + 1] [j - 1] )</strong></p>
<p>由于dp [ i ] [ j ] 参考它左下方的值，所以应该<strong>按列升序</strong>填写</p>
<p>例如： </p>
<table>
<thead>
<tr>
<th>字符</th>
<th>b</th>
<th>a</th>
<th>b</th>
<th>a</th>
<th>b</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>0</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>子串右边界</th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
</tr>
</thead>
<tbody><tr>
<td>子串左边界</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>0</td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
<td>false</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
<td>false</td>
</tr>
<tr>
<td>2</td>
<td></td>
<td></td>
<td></td>
<td>true</td>
<td>false</td>
<td><strong>true</strong></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>true</td>
<td>flase</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>true</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（n^2）空间复杂度： O（n^2）</p>
<h3 id="Manacher-马拉车-算法"><a href="#Manacher-马拉车-算法" class="headerlink" title="Manacher (马拉车)算法"></a>Manacher (马拉车)算法</h3><p>专门用于查找最长回文子串的算法，时间复杂度：O（n）</p>
<h1 id="10-正则表达式匹配-D"><a href="#10-正则表达式匹配-D" class="headerlink" title="10.正则表达式匹配(D)"></a>10.正则表达式匹配(D)</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘ . ‘ 和 ‘ * ‘ 的正则表达式匹配。</p>
<p>‘ . ‘ 匹配任意单个字符<br>‘ * ‘ 匹配零个或多个前面的那一个元素</p>
<p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p>
<h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>从左往右扫的话</p>
<ul>
<li>字符后面是否跟着星号会影响结果，分析起来有点复杂。<br><img src="https://pic.leetcode-cn.com/073085fa67286871f76e8e9daa162bdb291a101b4314666c75379a7b0441cad6-image.png" alt="image.png"></li>
</ul>
<p>所以选择从右往左扫描：</p>
<ul>
<li>星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。</li>
</ul>
<p><img src="https://pic.leetcode-cn.com/5e7b1748039a2a779d7378bebc4926ef3e584e88cc22b67f3a4e18c0590bcc55-image.png" alt="image.png"></p>
<ul>
<li>s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。</li>
<li>只是最右端可能是特殊符号，需要分情况讨论而已。</li>
</ul>
<p><strong>通用地表示出子问题：</strong></p>
<ul>
<li>大子串是否匹配，和剩余子串是否匹配，是规模不一样的同一问题。<br><img src="https://pic.leetcode-cn.com/e1bcac2ad07a3a5c959bf0fe5c8ceea9bbd033c3066e7ec7f384aedd98cd95aa-image.png" alt="image.png"></li>
</ul>
<p>*<em>情况1：s[i-1] 和 <em>p</em>[<em>j</em>−1] 是匹配的</em>*</p>
<ul>
<li>最右端的字符是匹配的，那么，大问题的答案 &#x3D; 剩余子串是否匹配。<br><img src="https://pic.leetcode-cn.com/f817caaa40b0c39fc3ddabfa1383a8218ab364b8e49b30e5ce85cb30a3cdc503-image.png" alt="image.png"></li>
</ul>
<p><strong>情况2：s[i-1] 和 p[j-1] 是不匹配的</strong></p>
<ul>
<li>右端不匹配，还不能判死刑——可能是 p[j-1]<em>p</em>[<em>j</em>−1] 为星号造成的不匹配，星号不是真实字符，它不匹配不算数。</li>
<li>如果 p[j-1]<em>p</em>[<em>j</em>−1] 不是星号，那就真的不匹配了。<br><img src="https://pic.leetcode-cn.com/fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image.png" alt="image.png"></li>
</ul>
<p><strong>p[j-1] &#x3D;&#x3D;”∗”，且 s[i-1] 和 p[j-2] 匹配</strong></p>
<ul>
<li>p[j-1]<em>p</em>[<em>j</em>−1]是星号，并且 s[i-1] 和 p[j-2] 匹配，要考虑三种情况：<ul>
<li>p[j-1] 星号可以让 p[j-2]在 p 串中消失、出现 1 次、出现 &gt;&#x3D;2 次。</li>
<li>只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。<br><img src="https://pic.leetcode-cn.com/a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image.png" alt="image.png"></li>
<li>a3 情况：假设 s 的右端是一个 a，p 的右端是a* ，* 让 a 重复 &gt;&#x3D; 2 次<ul>
<li>星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。</li>
<li>星号拷贝了 &gt;&#x3D;2 个 a，拿掉一个，剩下 &gt;&#x3D;1 个a，p 末端依旧是 a* 没变。</li>
<li>s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>p[j-1] &#x3D;&#x3D; “∗”，但 s[i-1] 和 p[j-2] 不匹配</p>
<ul>
<li>s[i-1] 和 p[j−2] 不匹配，还有救，p[j−1] 星号可以干掉 p[j−2]，继续考察 s(0 , i-1) 和 p(0 , j-3)。<br><img src="https://pic.leetcode-cn.com/dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image.png" alt="image.png"></li>
</ul>
<p>注意：</p>
<ul>
<li>p为空串，s不为空串，肯定不匹配。</li>
<li>s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。</li>
<li>s、p都为空串，肯定匹配。<br><img src="https://pic.leetcode-cn.com/140597adfd5f03dd481e136163d98e7160cce4761c7cb8227010d828f24b7498-image.png" alt="image.png"></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;  </span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();    </span><br><span class="line">        <span class="type">char</span>[] cp = p.toCharArray();    </span><br><span class="line">        <span class="comment">// dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配  </span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[cs.length + <span class="number">1</span>][cp.length + <span class="number">1</span>];   </span><br><span class="line">        <span class="comment">// 初期值  </span></span><br><span class="line">        <span class="comment">// s为空，p为空，能匹配上 </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">// p为空，s不为空，必为false(boolean数组默认值为false，无需处理) </span></span><br><span class="line">        <span class="comment">// s为空，p不为空，由于*可以匹配0个字符，所以有可能为true     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;   </span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];   </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 填格子   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cs.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;  </span><br><span class="line">                <span class="comment">// 文本串和模式串末位字符能匹配上  </span></span><br><span class="line">                <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">1</span>] || cp[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;    </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];     </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 模式串末位是*  </span></span><br><span class="line">                    <span class="comment">// 模式串*的前一个字符能够跟文本串的末位匹配上    </span></span><br><span class="line">                    <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">2</span>] || cp[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;     </span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>]      <span class="comment">// *匹配0次的情况   </span></span><br><span class="line">                            || dp[i - <span class="number">1</span>][j];     <span class="comment">// *匹配1次或多次的情况  </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模式串*的前一个字符不能够跟文本串的末位匹配     </span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];     <span class="comment">// *只能匹配0次     </span></span><br><span class="line">                    &#125;          </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> dp[cs.length][cp.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="29-两数相除-M"><a href="#29-两数相除-M" class="headerlink" title="29.两数相除(M)"></a>29.两数相除(M)</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，<strong>要求不使用乘法、除法和 mod 运算符</strong>。</p>
<p><strong>返回</strong> 被除数 dividend 除以 除数 divisor 得到的<strong>商</strong>。</p>
<p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure>

<p>提示：</p>
<blockquote>
<p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p>
</blockquote>
<p>指数递增</p>
<p>由于题目规定只能存储32位整数，所以<strong>只能使用int</strong>，要考虑除法结果溢出。</p>
<p>对于<strong>溢出或容易出错的边界</strong>情况：</p>
<ul>
<li>当<strong>被除数</strong>是32位有符号数的<strong>最小值-2的31次方</strong>时：<ul>
<li>如果除数为1，那么直接返回答案-2的31次方；</li>
<li>如果除数为-1，那么答案为2的31次方，产生了溢出。</li>
</ul>
</li>
<li>当<strong>除数</strong>为32位有符号整数的<strong>最小值-2的31次方</strong>：<ul>
<li>如果被除数同样为-2的31次方，那么直接返回答案1；</li>
<li>对于其余情况，直接返回0；</li>
</ul>
</li>
<li>当被除数为0时，直接返回答案0；</li>
</ul>
<p>对于<strong>除数和被除数的符号</strong>，需要考虑4种情况，为了方便，使 除数和被除数符号 符号相同，这样就只需考虑一种符号的情况，由于都取整数的话可能会溢出，因此将除数和被除数<strong>都取为负数</strong>。</p>
<p>方法一：二分法</p>
<h3 id="指数递增步长"><a href="#指数递增步长" class="headerlink" title="指数递增步长"></a>指数递增步长</h3><p>方法二：<strong>指数递增步长</strong>（类二分查找，快速加）：</p>
<ul>
<li>我们首先不断地将 Y 乘以 2（通过加法运算实现），并将这些结果放入数组中，其中数组的<strong>第 i 项</strong>就等于 <strong>Y * 2的 i 次方</strong>；这一过程直到 Y 的两倍严格小于 X 为止。</li>
<li>对数组进行逆序遍历。当遍历到第 i 项时，如果大于等于X， 就将答案增加2的 i 次方，并且将X减去这一项的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;        <span class="comment">// 考虑被除数为最小值的情况     </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;            </span><br><span class="line">            &#125;        </span><br><span class="line">    	&#125;        </span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE) &#123;           </span><br><span class="line">            <span class="type">return</span> <span class="variable">dividend</span> <span class="operator">=</span>= Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找       </span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况       </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="literal">false</span>;       </span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;           </span><br><span class="line">            dividend = -dividend;       </span><br><span class="line">            rev = !rev;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            divisor = -divisor;    </span><br><span class="line">            rev = !rev;     </span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();       	</span><br><span class="line">        candidates.add(divisor);   </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="comment">//填充数组，第i项相当于Y*2的i次方（Y为除数）;     </span></span><br><span class="line">        <span class="comment">// 注意溢出:判断A+B是否小于C时，A+B可能溢出，因此改为A&lt;C-B   </span></span><br><span class="line">        <span class="comment">// (任意两个负数的差一定在[-2的31次方+1,2的31次方-1]范围内)      </span></span><br><span class="line">        <span class="keyword">while</span> (candidates.get(index) &gt;= dividend - candidates.get(index)) &#123;     </span><br><span class="line">            candidates.add(candidates.get(index) + candidates.get(index));        </span><br><span class="line">            ++index;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candidates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (candidates.get(i) &gt;= dividend) &#123;      </span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i;          </span><br><span class="line">                dividend -= candidates.get(i);    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="166-分数到小数-M"><a href="#166-分数到小数-M" class="headerlink" title="166.分数到小数(M)"></a>166.分数到小数(M)</h1><p>给定两个整数，分别表示分数的<strong>分子 numerator</strong> 和<strong>分母 denominator</strong>，以 字符串形式返回小数 。</p>
<p>如果小数部分为循环小数，则<strong>将循环的部分括在括号内</strong>。</p>
<p>如果存在多个答案，只需返回任意一个 。</p>
<p>对于所有给定的输入，保证答案字符串的长度小于104。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：numerator = <span class="number">4</span>, denominator = <span class="number">333</span>输出：<span class="string">&quot;0.(012)&quot;</span></span><br></pre></td></tr></table></figure>



<h3 id="模拟长除法"><a href="#模拟长除法" class="headerlink" title="模拟长除法"></a>模拟长除法</h3><p>计算分子和分母相除的结果，可能有：整数，有限小数，无限循环小数；</p>
<p>如果分子可以被分母整除，则结果为整数</p>
<p>如果分子不能被分母整除，则为有限&#x2F;无限循环小数，需用模拟长除法 的方式来计算：</p>
<ol>
<li>先根据分子，分母的正负 决定结果的正负，并将分子，分母都转为正数；</li>
<li>先计算整数部分，并将整数部分和小数点拼接到结果中；</li>
<li>再计算小数部分：每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。<ul>
<li>如果余数为0，则结果为有限小数</li>
<li>如果找到循环节，则在循环节开始和结束位置加上括号；</li>
<li>判断循环节：因为相同的余数，计算得到的小数的下一位数字一定相同，所以如果有余数在之前已经出现过，则认为找到循环节；（用哈希表存储每个余数第一次出现的下标）</li>
</ul>
</li>
</ol>
<p><img src="https://assets.leetcode-cn.com/solution-static/166/2.png" alt="fig2"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">numeratorLong</span> <span class="operator">=</span> (<span class="type">long</span>) numerator;    </span><br><span class="line">        <span class="type">long</span> <span class="variable">denominatorLong</span> <span class="operator">=</span> (<span class="type">long</span>) denominator;    </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(numeratorLong / denominatorLong);  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();     </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">            sb.append(<span class="string">&#x27;-&#x27;</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">//整数部分  </span></span><br><span class="line">        numeratorLong = Math.abs(numeratorLong); </span><br><span class="line">        denominatorLong = Math.abs(denominatorLong);    </span><br><span class="line">        <span class="type">long</span> <span class="variable">integerPart</span> <span class="operator">=</span> numeratorLong / denominatorLong;     </span><br><span class="line">        sb.append(integerPart);  </span><br><span class="line">        sb.append(<span class="string">&#x27;.&#x27;</span>);    </span><br><span class="line">        <span class="comment">//小数部分    </span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">fractionPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">        Map&lt;Long, Integer&gt; remainderIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();   </span><br><span class="line">        <span class="type">long</span> <span class="variable">remainder</span> <span class="operator">=</span> numeratorLong % denominatorLong;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.containsKey(remainder)) &#123;   </span><br><span class="line">            remainderIndexMap.put(remainder, index);   </span><br><span class="line">            remainder *= <span class="number">10</span>;     </span><br><span class="line">            fractionPart.append(remainder / denominatorLong); </span><br><span class="line">            remainder %= denominator;   </span><br><span class="line">            index++;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;   <span class="comment">//有循环节      </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> remainderIndexMap.get(remainder); </span><br><span class="line">            fractionPart.insert(insertIndex, <span class="string">&#x27;(&#x27;</span>);     </span><br><span class="line">            fractionPart.append(<span class="string">&#x27;)&#x27;</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">        sb.append(fractionPart.toString());  </span><br><span class="line">        <span class="keyword">return</span> sb.toString();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="187-重复的DNA序列（M"><a href="#187-重复的DNA序列（M" class="headerlink" title="187.重复的DNA序列（M)"></a>187.重复的DNA序列（M)</h1><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p>
<p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span>输出：[<span class="string">&quot;AAAAACCCCC&quot;</span>,<span class="string">&quot;CCCCCAAAAA&quot;</span>]</span><br></pre></td></tr></table></figure>



<h3 id="滑动窗口-哈希表"><a href="#滑动窗口-哈希表" class="headerlink" title="滑动窗口+哈希表"></a>滑动窗口+哈希表</h3><p>从左到右处理字符串 ss，使用滑动窗口得到每个以 s[i]s[i] 为结尾且长度为 1010 的子串，同时使用哈希表记录每个子串的出现次数，如果该子串出现次数超过一次，则加入答案。</p>
<p>时间复杂度：O(NL)，其中 N 是字符串 s 的长度，L&#x3D;10即目标子串的长度。</p>
<p>空间复杂度：O(NL)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;    </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    </span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">10</span> &lt;= n; i++)&#123;     </span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> s.substring(i, i + <span class="number">10</span>);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(cur, <span class="number">0</span>);    </span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) list.add(cur);     </span><br><span class="line">            map.put(cur, cnt + <span class="number">1</span>);    </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="位运算-滑动窗口-哈希表"><a href="#位运算-滑动窗口-哈希表" class="headerlink" title="位运算+滑动窗口+哈希表"></a>位运算+滑动窗口+哈希表</h3><p>因为只有4种字符，所以可以将<strong>每个字符用2个比特表示</strong>，即：</p>
<p>A：00		C：01		G：10		T：11</p>
<p>这样，长为10个字符的字符串就可以用20个比特表示，这里<strong>用 int整数（有32）的低20位</strong>来表示它，</p>
<p>如果我们对每个长为 10 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 O(NL)。为了优化时间复杂度，我们可以用一个大小固定为 10 的滑动窗口来计算子串的整数表示。</p>
<p>设当前滑动窗口对应的整数表示为 x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：</p>
<ul>
<li>滑动窗口向右移动一位：x &#x3D; x &lt;&lt; 2，由于每个字符用 2 个比特表示，所以要左移 2 位；</li>
<li>一个新的字符 ch 进入窗口：x &#x3D; x | bin[ch]，这里 bin[ch] 为字符 ch 的对应二进制；</li>
<li>窗口最左边的字符离开窗口：x &#x3D; x &amp; ((1 &lt;&lt; 20) - 1)，由于我们只考虑 x 的低 20 位比特，需要将其余位置零，即与上 (1 &lt;&lt; 20) - 1。</li>
</ul>
<p>上面三步合并，就可以用O（1）的时间算出下一个子串的整数表示，即 x &#x3D; ((x &lt;&lt; 2) | bin[ch]) &amp; ((1 &lt;&lt; 20) - 1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">    Map&lt;Character, Integer&gt; bin = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line">        &#123;      </span><br><span class="line">            put(<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>);   </span><br><span class="line">            put(<span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>);     </span><br><span class="line">            put(<span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;   </span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();    </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= L) &#123;     </span><br><span class="line">            <span class="keyword">return</span> ans;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; L - <span class="number">1</span>; ++i) &#123;   </span><br><span class="line">            x = (x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i));     </span><br><span class="line">        &#125;      </span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - L; ++i) &#123;   </span><br><span class="line">            x = ((x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i + L - <span class="number">1</span>))) &amp; ((<span class="number">1</span> &lt;&lt; (L * <span class="number">2</span>)) - <span class="number">1</span>); </span><br><span class="line">            cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);    </span><br><span class="line">            <span class="keyword">if</span> (cnt.get(x) == <span class="number">2</span>) &#123;         </span><br><span class="line">                ans.add(s.substring(i, i + L));    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="223-矩形面积-E"><a href="#223-矩形面积-E" class="headerlink" title="223.矩形面积(E)"></a>223.矩形面积(E)</h1><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的 矩形</strong>，请你计算并返回两个矩形覆盖的总面积。</p>
<p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p>
<p>第一个矩形由其<strong>左下顶点 (ax1, ay1)</strong> 和<strong>右上顶点 (ax2, ay2)</strong> 定义。<br>第二个矩形由其<strong>左下顶点 (bx1, by1)</strong> 和<strong>右上顶点 (bx2, by2)</strong> 定义。</p>
<p>方法 ：直接计算重叠面积</p>
<p>如果两个矩形重叠，则两个矩形的重叠部分也是矩形，重叠部分的面积可以根据重叠部分的边界计算。</p>
<p>两个矩形的水平边投影到 x<em>x</em> 轴上的线段分别为[<em>ax</em>1,<em>ax</em>2] 和 [<em>bx</em>1,<em>bx</em>2]，竖直边投影到 y<em>y</em> 轴上的线段分别为[<em>ay</em>1,<em>ay</em>2] 和 [<em>by</em>1,<em>by</em>2]。如果两个矩形重叠，则重叠部分的水平边投影到 x 轴上的线段为 [max(ax1, bx1) , min(ax2, bx2)] , 竖直边投影到 <em>y</em> 轴上的线段为 [max(ay1, by1) , min(ay2, by2)] , 根据重叠部分的水平边投影到 x 轴上的线段长度和竖直边投影到 y 轴上的线段长度即可计算重叠部分的面积。只有当两条线段的长度都大于 0 时，重叠部分的面积才大于 0，否则重叠部分的面积为 0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">area1</span> <span class="operator">=</span> (ax2 - ax1) * (ay2 - ay1), area2 = (bx2 - bx1) * (by2 - by1); </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapWidth</span> <span class="operator">=</span> Math.min(ax2, bx2) - Math.max(ax1, bx1), overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapArea</span> <span class="operator">=</span> Math.max(overlapWidth, <span class="number">0</span>) * Math.max(overlapHeight, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> area1 + area2 - overlapArea; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="229-求众数2-M"><a href="#229-求众数2-M" class="headerlink" title="229.求众数2(M)"></a>229.求众数2(M)</h1><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 n&#x2F;3  次的元素。</p>
<blockquote>
<p> 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p>
</blockquote>
<p>哈希表计数：</p>
<p>一个朴素的做法是使用「哈希表」进行计数，在计数完成后将所有出现次数超过 n &#x2F; 3<em>n</em>&#x2F;3 的元素加入答案。</p>
<p>时间和空间复杂度都为O(n)</p>
<hr>
<h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>摩尔投票法的核心思想为<strong>对拼消耗</strong>。</p>
<p>最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 1&#x2F;2  的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实：</p>
<ul>
<li><strong>每次</strong>从序列里<strong>选择两个不相同的数字删除掉</strong>（或称为「抵消」），<strong>最后剩下</strong>一个数字或几个相同的数字，<strong>就是出现次数大于总数一半的那个元素</strong>。</li>
</ul>
<p>题目要求找出出现超过n&#x2F;3次的元素，可以用反证法推出满足条件的元素最多只有2个。所以可以利用摩尔投票法的核心思想，<strong>每次选择三个互不相同的元素进行删除</strong>（或称为「抵消」）。</p>
<p>摩尔投票法最后还需要计数阶段，来确定选出来的元素是否满足条件；</p>
<p>时间复杂度：O(n)，空间复杂度：O(1)，只使用了常数个元素来存储关键元素和统计次数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">        <span class="comment">// 摩尔投票：抵消阶段  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个元素的值     </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//第二个元素的值    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="comment">//第一个元素的可抵消个数    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote2</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="comment">//第二个元素的可抵消个数    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123; </span><br><span class="line">                <span class="comment">//如果该元素为第一个元素，则计数加1   </span></span><br><span class="line">                vote1++;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; <span class="comment">//如果该元素为第二个元素，则计数加1 </span></span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote1 == <span class="number">0</span>) &#123; <span class="comment">// 第一元素为空，则选择第一个元素      </span></span><br><span class="line">                element1 = num;     </span><br><span class="line">                vote1++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 == <span class="number">0</span>) &#123; <span class="comment">// 选择第二个元素       </span></span><br><span class="line">                element2 = num;        </span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果三个元素均不相同，则相互抵消1次      </span></span><br><span class="line">                vote1--;        </span><br><span class="line">                vote2--;         </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// 摩尔投票：计数阶段   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;   </span><br><span class="line">                cnt1++;        </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; </span><br><span class="line">                cnt2++;       </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="comment">// 检测元素出现的次数是否满足要求   </span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();      </span><br><span class="line">        <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="number">3</span>) &#123;      </span><br><span class="line">            ans.add(element1);     </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="number">3</span>) &#123;     </span><br><span class="line">            ans.add(element2);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="230-二叉搜索树中第k小的元素-M"><a href="#230-二叉搜索树中第k小的元素-M" class="headerlink" title="230.二叉搜索树中第k小的元素(M)"></a>230.二叉搜索树中第k小的元素(M)</h1><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>树中的节点数为 <code>n</code> 。</li>
<li><code>1 &lt;= k &lt;= n &lt;= 10的4次方</code></li>
<li><code>0 &lt;= Node.val &lt;= 10的4次方</code></li>
</ul>
<p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p>
</blockquote>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>由于题目中的树为搜索树，即树中左子节点小于当前节点，右子节点大于当前节点，各子树本身也是二叉搜索树；因此中序遍历二叉搜索树得到的结果是排序的；</p>
<p>时间复杂度：O(H + k)：H为树的高度</p>
<p>空间复杂度：O(H)：栈中最多存储H个元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();    </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;   </span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;     </span><br><span class="line">                stack.push(root);       </span><br><span class="line">                root = root.left;   </span><br><span class="line">            &#125;     </span><br><span class="line">            root = stack.poll(); </span><br><span class="line">            k--;       </span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;    </span><br><span class="line">                <span class="keyword">break</span>;     </span><br><span class="line">            &#125;          </span><br><span class="line">            root = root.right;   </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> root.val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="记录子树的节点数"><a href="#记录子树的节点数" class="headerlink" title="记录子树的节点数"></a>记录子树的节点数</h3><blockquote>
<p>如果要频繁地查找第k小的值，该如何优化？</p>
</blockquote>
<p>中序遍历中，以为我们不知道子树的节点数量，不得不通过遍历子树来获得前k个元素；</p>
<p>因此，我们可以记录下<strong>每个节点为根结点的子树的结点数</strong>，并在查找第 k 小的值时，使用如下方法搜索：</p>
<ul>
<li><p>令 node 等于根结点，开始搜索。</p>
</li>
<li><p>对当前结点 node 进行如下操作：</p>
<ul>
<li>如果 node 的左子树的结点数 left 小于 k-1，则第 k 小的元素一定在node 的右子树中，令 node 等于其的右子结点，k 等于 k - left−1，并继续搜索；</li>
<li>如果 node 的左子树的结点数 left 等于 k-1，则第 k 小的元素即为 node ，结束搜索并返回 node 即可；</li>
<li>如果 node 的左子树的结点数 left 大于 k-1，则第 k 小的元素一定在 node 的左子树中，令 node 等于其左子结点，并继续搜索。</li>
</ul>
</li>
</ul>
<p>可以再每个节点中存在子树节点数，也可以用哈希表记录；</p>
<p>时间复杂度：预处理的时间为O(N)：N为树中节点的总数（需要遍历所有节点来统计每个节点的为根的子树节点数）；搜索的时间为O（H)，H为树高；</p>
<p>空间复杂度 ：O(N)，哈希表存储每个节点的子树节点数信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">MyBst</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBst</span>(root); </span><br><span class="line">        <span class="keyword">return</span> bst.kthSmallest(k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBst</span> &#123; </span><br><span class="line">    TreeNode root;  </span><br><span class="line">    Map&lt;TreeNode, Integer&gt; nodeNum; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBst</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.root = root;   </span><br><span class="line">        <span class="built_in">this</span>.nodeNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, Integer&gt;();    </span><br><span class="line">        countNodeNum(root);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 返回二叉搜索树中第k小的元素   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;   </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getNodeNum(node.left);     </span><br><span class="line">            <span class="keyword">if</span> (left &lt; k - <span class="number">1</span>) &#123;    </span><br><span class="line">                node = node.right;   </span><br><span class="line">                k -= left + <span class="number">1</span>;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == k - <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = node.left;     </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> node.val; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 统计以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countNodeNum</span><span class="params">(TreeNode node)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;     </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">        &#125;      </span><br><span class="line">        nodeNum.put(node, <span class="number">1</span> + countNodeNum(node.left) + countNodeNum(node.right)); </span><br><span class="line">        <span class="keyword">return</span> nodeNum.get(node);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 获取以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> nodeNum.getOrDefault(node, <span class="number">0</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><blockquote>
<p>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <em>k</em> 小的值，你将如何优化算法？</p>
</blockquote>
<ul>
<li>平衡二叉搜索树中每个节点的左子树和右子树高度最多相差1；</li>
<li>其子树也是平衡二叉搜索树；</li>
<li>一棵存有n个节点的平衡二叉搜索树的高度为O(logn);</li>
</ul>
<p>在方法二中，其搜索的时间复杂度为O(H)，当树是平衡树时，时间复杂度可取到O(logN)；</p>
<p>时间复杂度：预处理的时间复杂度为 O(N)，其中 N 是树中结点的总数。插入、删除和搜索的时间复杂度均为 O(log N)。</p>
<p>空间复杂度：O(N)，用于存储平衡二叉搜索树。</p>
<h1 id="260-只出现一次的数字III-M"><a href="#260-只出现一次的数字III-M" class="headerlink" title="260.只出现一次的数字III (M)"></a>260.只出现一次的数字III (M)</h1><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p>
<blockquote>
<p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure>

<p>方法一：用哈希映射统计数组中每一个元素出现的次数。在统计完成后，对哈希映射进行遍历，将所有只出现了一次的数放入答案中。</p>
<p>时间复杂度：O(n)；空间复杂度：O(n)</p>
<hr>
<p>方法二：位运算</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>假设数组 nums 中只出现一次的元素分别是x1和x2，如果<strong>把nums 中的所有元素全部异或起来，得到结果 x，则x &#x3D; x1异或x2</strong>，因为数组中出现两次的元素都会因为异或运算而被抵消掉（如：a异或b异或b&#x3D;a）。</p>
<p>因为x1和x2不等，所以x不会等于0。此时，<strong>利用 x &amp; -x 得到 x 的最低有效位lowbit</strong>，即x二进制表示中最低位的1，设这个1在第i位；</p>
<p>这样，数组中的元素就可以分为两类：一类是二进制表示中第i位为1的，另一类是第i位为0的，而x1和x2不会在同一类里（因为只有x1和x2的第i位不同，异或得到的第i位才为1）；然后<strong>将同一类的元素全部异或起来，那么其中一类最终会得到x1，另一类得到x2</strong>（出现两次的元素都会被异或运算抵消，最后只留下x1或x2）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xorNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            xorNum ^= num;      <span class="comment">//最终xor=x1异或x2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lowBit</span> <span class="operator">=</span> (xorNum == Integer.MIN_VALUE ? xorNum : xorNum &amp; (-xorNum));</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">0</span>, x2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lowBit &amp; num) != <span class="number">0</span>) &#123;      <span class="comment">//将同属一类的元素异或起来，最后得到x1</span></span><br><span class="line">                x1 ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1, x2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="335-交叉路径-D"><a href="#335-交叉路径-D" class="headerlink" title="335.交叉路径(D)"></a>335.交叉路径(D)</h1><p>给定一个整数数组distance；</p>
<p>从X-Y平面上的原点（0，0）开始，每四个数字一组，分别向北，西，南，东移动。</p>
<p>判断你所经过的路径是否相交，如果相交，返回true，否则，返回false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"><span class="comment">//画图</span></span><br></pre></td></tr></table></figure>



<h3 id="归纳法-找规律"><a href="#归纳法-找规律" class="headerlink" title="归纳法(找规律)"></a>归纳法(找规律)</h3><p>首先，至少需要4条边才可能存在相交路径，如果distance长度小于4，可直接返回fasle；</p>
<p>对可能相交情况进行分情况讨论，设当前枚举到的边为 d[ i ] ，(画图理解！)</p>
<ol>
<li>d[i] 与 d[i - 3] 发生相交：此时满足 d[i] &gt;&#x3D; d[i - 2]，同时 d[i - 1] &lt;&#x3D; d[i - 3]；</li>
<li>d[i] 与 d[i - 4] 发生相交：此时满足 d[i - 1] &gt;&#x3D; d[i - 3]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]；</li>
<li>d[i] 与 d[i - 5] 发生相交：此时满足 d[i - 1] &lt;&#x3D; d[i - 3]，同时 d[i - 2] &gt; d[i - 4]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]，同时 d[i - 1] + d[i - 5] &gt;&#x3D; d[i - 3]</li>
</ol>
<p>综上，d[i] 不会与d[i - 1] 和 d[i - 2] 发生相交，而 d[i] 在与d[i - x] (x&gt;5)发生相交前，必然先与d[i - y] (3&lt;&#x3D;y&lt;5) 发生相交。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSelfCrossing</span><span class="params">(<span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> d.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">4</span> &amp;&amp; d[i - <span class="number">1</span>] == d[i - <span class="number">3</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">5</span> &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>] &amp;&amp; d[i - <span class="number">2</span>] &gt; d[i - <span class="number">4</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] + d[i - <span class="number">5</span>] &gt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h1 id="352-将数据流变为多个不相交区间-D"><a href="#352-将数据流变为多个不相交区间-D" class="headerlink" title="352.将数据流变为多个不相交区间(D)"></a>352.将数据流变为多个不相交区间(D)</h1><p> 给你一个由非负整数 a1, a2, …, an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p>
<p>（如：arr[1,2,3,7] ，则将其分为：[1,3]，[7,7]  ）</p>
<blockquote>
<p>实现 SummaryRanges 类：</p>
<p>SummaryRanges()：使用一个空数据流初始化对象。<br>void addNum(int val) ：向数据流中加入整数 val 。<br>int[][] getIntervals()： 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。</p>
</blockquote>
<h3 id="有序映射（TreeMap"><a href="#有序映射（TreeMap" class="headerlink" title="有序映射（TreeMap)"></a>有序映射（TreeMap)</h3><p>使用某一数据结构维护这些不相交的区间，在设计具体的数据结构之前，我们需要先明确 void addNum(int val) 这一操作会使得当前的区间集合发生的变化：</p>
<ul>
<li><p>情况一：如果存在一个区间 [ l , r ]，它完全包含 val，即 l ≤ val ≤ r，那么在加入 val 之后，区间集合不会有任何变化；</p>
</li>
<li><p>情况二：如果存在一个区间 [ l , r ]，它的右边界 r「紧贴着」val，即 r + 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l , r+1 ]；</p>
</li>
<li><p>情况三：如果存在一个区间 [ l , r ]，它的左边界 l「紧贴着」val，即 l - 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l−1 , r ]；</p>
</li>
<li><p>情况四：如果情况二和情况三同时满足，即存在一个区间 [ l0 , r0] 满足 r0 + 1 &#x3D; val， 并且存在一个区间 [ l1, r1] 满足 l1 - 1 &#x3D; val，那么在加入val后，这两个区间会合并成一个大区间；</p>
</li>
<li><p>情况五：在上述四种情况均不满足的情况下，val 会单独形成一个新的区间 [ val , val ]。</p>
</li>
</ul>
<p>一种可以<strong>找到「最近」区间</strong>的数据结构是<strong>有序映射</strong>。有序映射中的键和值分别表示区间的左边界 l 和右边界 r。由于有序映射支持查询「最大的比某个元素小的键」以及「最小的比某个元素大的键」这两个操作，因此我们可以快速地定位区间 [ l0 , r0 ] 和[ l1 , r1]；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; intervals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        intervals = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 l1 最小的且满足 l1 &gt; val 的区间 interval1 = [l1, r1]</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval1 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval1 = intervals.ceilingEntry(val + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 找到 l0 最大的且满足 l0 &lt;= val 的区间 interval0 = [l0, r0]</span></span><br><span class="line">        <span class="comment">// 在有序集合中，interval0 就是 interval1 的前一个区间</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval0 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval0 = intervals.floorEntry(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interval0 != <span class="literal">null</span> &amp;&amp; interval0.getKey() &lt;= val &amp;&amp; val &lt;= interval0.getValue()) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">leftAside</span> <span class="operator">=</span> interval0 != <span class="literal">null</span> &amp;&amp; interval0.getValue() + <span class="number">1</span> == val;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">rightAside</span> <span class="operator">=</span> interval1 != <span class="literal">null</span> &amp;&amp; interval1.getKey() - <span class="number">1</span> == val;</span><br><span class="line">            <span class="keyword">if</span> (leftAside &amp;&amp; rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况四</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval0.getKey(), right = interval1.getValue();</span><br><span class="line">                intervals.remove(interval0.getKey());</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(left, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftAside) &#123;</span><br><span class="line">                <span class="comment">// 情况二</span></span><br><span class="line">                intervals.put(interval0.getKey(), interval0.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况三</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> interval1.getValue();</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(val, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况五</span></span><br><span class="line">                intervals.put(val, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : intervals.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> entry.getKey(), right = entry.getValue();</span><br><span class="line">            ans[index][<span class="number">0</span>] = left;</span><br><span class="line">            ans[index][<span class="number">1</span>] = right;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="405-数字转换为十六进制数-E"><a href="#405-数字转换为十六进制数-E" class="headerlink" title="405.数字转换为十六进制数(E)"></a>405.数字转换为十六进制数(E)</h1><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p>
<p>注意:</p>
<blockquote>
<ol>
<li>十六进制中所有字母(a-f)都必须是小写。</li>
<li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li>
<li>给定的数确保在32位有符号整数范围内。</li>
<li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li>
</ol>
</blockquote>
<p><strong>模拟+进制转换</strong></p>
<p>利用通用的进制转换思路来做，不断循环 num % k 和 num &#x2F; k 的操作来构造出 k 进制每一位。</p>
<p>但需要处理「补码」问题：对于负数的 num，我们需要先在 num 基础上加上 2^32 的偏移量，再进行进制转换。</p>
<p>（将有符号整数 转化为 无符号整数，其二进制表示方式不变，十进制则相当于原数字加上2的n次方，n为二进制的位数，同样的，其十六进制表示方式也不变）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) temp = (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, <span class="number">32</span>) + num);        <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;            <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> temp % <span class="number">16</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            temp /= <span class="number">16</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>位运算 + 分组换算</strong></p>
<p>将长度为 32 的二进制转换为 16 进制数，本质是对长度为 32 的二进制数进行分组，</p>
<p>由于我们是直接对长度为 32 的二进制进行分组转算（4 个为一组，共 8 组），而长度为 32 的二进制本身就是使用补码规则来表示的，因此我们无须额外处理「补码」问题。</p>
<p>具体的，我们将 num 与 15的二进制 进行 &amp; 运算，然后对 num 进行无符号右移 4 位来实现每 4 位处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> num &amp; <span class="number">15</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            num &gt;&gt;&gt;= <span class="number">4</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure>



<h1 id="437-路径总和III-M"><a href="#437-路径总和III-M" class="headerlink" title="437.路径总和III(M)"></a>437.路径总和III(M)</h1><p>给定一个二叉树的根节点 <strong>root</strong> ，和一个整数 <strong>targetSum</strong> ，求该二叉树里<strong>节点值之和等于 targetSum 的 路径</strong> 的<strong>数目</strong>。</p>
<p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：root =[10,5,-3,3,2,null,11,3,-2,null,1]，targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure>

<h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和，就是到达当前元素的路径上，之前所有元素的和。</p>
<p>如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target，也就是说A和B之间的路径符合题目要求</p>
<p><strong>算法思路：</strong></p>
<p>抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。</p>
<p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;  </span><br><span class="line">        <span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数    </span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 前缀和为0的一条路径    </span></span><br><span class="line">        <span class="keyword">return</span> recursionPathSum(root, prefixSumCount, sum, <span class="number">0</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recursionPathSum</span><span class="params">(TreeNode node, Map&lt;Integer, Integer&gt; prefixSumCount, <span class="type">int</span> target, <span class="type">int</span> currSum)</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        currSum += node.val;   </span><br><span class="line">        <span class="comment">//如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了        res += prefixSumCount.getOrDefault(currSum - target, 0);    </span></span><br><span class="line">        <span class="comment">// 更新路径上当前节点前缀和的个数     </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);   </span><br><span class="line">        res += recursionPathSum(node.left, prefixSumCount, target, currSum);   </span><br><span class="line">        res += recursionPathSum(node.right, prefixSumCount, target, currSum);</span><br><span class="line">        <span class="comment">//回到本层，恢复状态，去除当前节点的前缀和数量  </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度：O（N），每个节点只遍历一次</p>
<p>；空间复杂度：O（N），用了一个hashMap</p>
<p>476.数字的补数(E)</p>
<p>对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。</p>
<ul>
<li>例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。（无视了前导零）</li>
</ul>
<p>给你一个整数 num ，输出它的补数。</p>
<blockquote>
<p>1 &lt;&#x3D; num &lt; 2的31次方</p>
</blockquote>
<p>模拟(lowbit)</p>
<p>如果 num 的二进制表示中最高位 1 的位置为 s 的话，那么实际上我们只需要对 num 的前 s - 1 位进行取反即是答案（第 s 位的取反结果始终为 0）。</p>
<p>因此我们可以先使用 lowbit 操作来得到 num 二进制表示中最高位 1 的位置为 1，其余位为 0 时所代表的数字 x。</p>
<p>然后 x - 1 即是二进制表示中前 s - 1 位均为 1，其余位为 0 的数字，将其与 num 的取反数执行「按位与」操作，即可达到「仅对 num 的前 s - 1 位进行取反」的效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i != <span class="number">0</span>; i -= i &amp; -i) x = i;      </span><br><span class="line">        <span class="keyword">return</span> ~num &amp; (x - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以用这种：</p>
<p>找到二进制表示最高位的 1 ：第 i (0≤i≤30) 位，后，</p>
<p>我们可以遍历 num 的第 0 ∼ i 个二进制位，将它们依次进行取反。也可以用更高效的方式，构造掩码 mask &#x3D; 2<br>的i+1次方 - 1，它是一个 i+1 位的二进制数，并且每一位都是 1。我们将 num 与mask 进行异或运算，即可得到答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">highbit</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &lt;&lt; i) &#123;      </span><br><span class="line">                highbit = i;      </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;          </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> highbit == <span class="number">30</span> ? <span class="number">0x7fffffff</span> : (<span class="number">1</span> &lt;&lt; (highbit + <span class="number">1</span>)) - <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> num ^ mask;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="483-密钥格式化-E"><a href="#483-密钥格式化-E" class="headerlink" title="483.密钥格式化(E)"></a>483.密钥格式化(E)</h1><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p>
<p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p>
<p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span>输出：<span class="string">&quot;5F3Z-2E9W&quot;</span>解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure>

<p><strong>模拟</strong></p>
<p>简单字符串模拟，从后往前处理，避免对首个分区的分情况讨论和取余操作。（注意答案字符串首部不要加上‘-’）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">licenseKeyFormatting</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, cnt = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h1 id="583-两个字符串的删除操作-M"><a href="#583-两个字符串的删除操作-M" class="headerlink" title="583.两个字符串的删除操作(M)"></a>583.两个字符串的删除操作(M)</h1><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure>

<h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>该问题等价于求解量字符的「最长公共子序列」，若两者长度分别为 n 和 m，而最长公共子序列长度为 max，则 n - max + m - maxn 即为答案。</p>
<p>f[i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符</p>
<p>当有了「状态定义」之后，基本上「转移方程」就是呼之欲出：</p>
<ul>
<li><strong>s1[i]&#x3D;&#x3D;s2[j] : f [i] [j] &#x3D; f [i-1] [j-1] +1</strong> </li>
<li><strong>s1[i] !&#x3D; s2[j] : f [i] [j]&#x3D;max( f [i-1] [j], f [i] [j-1] )</strong></li>
</ul>
<p>不加哨兵空格：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>])</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f[n][m] + m - f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加哨兵空格：</p>
<p>可以往字符串头部追加一个空格，以减少边界判断（使下标从 1 开始，并很容易构造出可滚动的「有效值」）。但实现上，不用真的往字符串中最佳空格，只需在初始化动规值时假定存在首部空格，以及对最后的 LCS 长度进行减一操作即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 假定存在哨兵空格，初始化 f[0][x] 和 f[x][0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>]) f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> f[n][m] - <span class="number">1</span>; <span class="comment">// 减去哨兵空格</span></span><br><span class="line">        <span class="keyword">return</span> n - max + m - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>更加契合题意的状态定义是根据「最长公共子序列（LCS）」的原始状态定义进行微调：定义 f [i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符（最终字符串不一定包含 s1[i] 或 s2[j]）时形成相同字符串的最小删除次数。</p>
<p>则转移方程 f [i] [j] 计算：</p>
<ul>
<li><strong>s1[i] &#x3D;&#x3D; s2[j]：f [i] [j] &#x3D; f [i - 1] [j - 1]，代表可以不用必然删掉 s1[i] 和 s2[j] 形成相同字符串；</strong></li>
<li><strong>s1[i] !&#x3D; s2[j]：f[i] [j] &#x3D; min(f[i - 1] [j] + 1, f[i] [j - 1] + 1)，代表至少一个删除 s1[i] 和 s2[j] 中的其中一个。</strong></li>
</ul>
<p>f [i] [j] 为上述方案中的最小值，最终答案为 f [n] [m]。</p>
<p><strong>动态规划的边界：</strong></p>
<p>当i 或 j &#x3D; 0 时，其中一个字符串为空，空字符串和任何字符串要变成相同，只有将另一个字符串的字符全部删除，所以 <strong>dp[i] [0] &#x3D; i</strong> 以及 <strong>dp[0] [j] &#x3D; j</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray(), c2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638.大礼包"></a>638.大礼包</h1><p>在 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p>
<p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <strong><code>price[i]</code> 是第 i 件物品的价格</strong>。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <strong><code>needs[i]</code> 是需要购买第 i 件物品的数量</strong>。</p>
<p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 n + 1 ，其中 <strong><code>special[i][j]</code> 表示第 i 个大礼包中内含第 j 件物品的数量</strong>，且 <strong><code>special[i][n]</code> （也就是数组中的最后一个整数）为第 i 个大礼包的价格</strong>。</p>
<p>返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p>
<blockquote>
<p>输入：price &#x3D; [2,3,4], special &#x3D; [[1,1,0,4],[2,2,1,9]], needs &#x3D; [1,2,1]<br>输出：11<br>解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。<br>可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。<br>需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。<br>不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</p>
</blockquote>
<h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>因为大礼包中可能包含多个物品，所以并不是所有状态都可以得到。因此，我们使用记忆化搜索而不是完全遍历的方法，来计算出满足每个购物清单 needs 所需花费的最低价格。</p>
<ul>
<li><p>首先，我们过滤掉不需要计算的大礼包。</p>
<p>如果大礼包完全没有优惠（大礼包的价格大于等于原价购买大礼包内所有物品的价格），或者大礼包内不包含任何的物品，那么购买这些大礼包不可能使整体价格降低。因此，我们可以不考虑这些大礼包，并将它们过滤掉，以提高效率和方便编码。</p>
</li>
<li><p>然后，计算满足购物清单所需花费的最低价格：</p>
<p>用 dp[needs] 表示满足购物清单 needs 所需花费的最低价格。在进行状态转移时，我们考虑在满足购物清单 needs 时的最后一次购买；其中，将原价购买购物清单中的所有物品也视作一次购买。则有两种情况：</p>
<ul>
<li><p>一，购买大礼包，状态转移方程为：</p>
<p>dp[needs] &#x3D; min{price<del>i</del> +dp[ needs - needs<del>i</del> ]} ( i ∈ K )，</p>
<ul>
<li><p>K 表示所有可以购买的大礼包的下标集合，i 表示其中一个大礼包的下标，</p>
</li>
<li><p>price<del>i</del> 表示第 i 个大礼包的价格，</p>
</li>
<li><p>needs<del>i</del> 表示大礼包中包含的物品清单，</p>
</li>
<li><p>needs−needs<del>i</del> 表示购物清单 needs 减去第 i 个大礼包中包含的物品清单后剩余的物品清单。</p>
</li>
</ul>
</li>
<li><p>二，不购买任何大礼包，原价购买购物清单中的所有物品，此时 dp [needs] 可以直接求出。</p>
</li>
</ul>
<p>对此，要求出当前购物清单 <code>cur_needs</code> 所需花费的最低价格 <code>min_price</code> ，具体做法为：</p>
<ul>
<li><p>将 min_price 初始化为原价购买购物清单cur_needs 中的所有物品的花费；</p>
</li>
<li><p>逐个遍历所有可以购买的大礼包，不妨设当前遍历的大礼包为 cur_special，其价格为special_price：</p>
<ul>
<li><p>计算购买大礼包 cur_special 后新的购物清单 next_needs，并递归地计算满足购物清单 next_needs 所需花费的最低价格 next_price；</p>
</li>
<li><p>计算满足当前购物清单 cur_needs 所需花费的最低价格 cur_price &#x3D; special_price + next_price；</p>
</li>
<li><p>如果 cur_price &lt; min_price，则将 min_price 更新为 cur_price。</p>
</li>
</ul>
</li>
<li><p>返回计算满足购物清单 cur_needs 所需花费的最低价格 min_price。</p>
</li>
</ul>
</li>
</ul>
<p>时间复杂度：O ( n × k × m^n^ )：k为大礼包数量，m为每种物品的需求量(等于最大需求量加1)，n表示物品数量</p>
<p>空间复杂度：O ( n × m^n^ )：用于存储记忆化搜索中 m^n^个状态的计算结果，每个状态需要存储 n  个商品的需求量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储 某个状态的清单~~它所需花费的最低值 的键值对</span></span><br><span class="line">    Map&lt;List&lt;Integer&gt;, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;List&lt;Integer&gt;, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> price.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; filterSpecial = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; sp : special) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp.get(i);</span><br><span class="line">                totalPrice += sp.get(i) * price.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp.get(n)) &#123;</span><br><span class="line">                filterSpecial.add(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(price, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; curNeeds, List&lt;List&lt;Integer&gt;&gt; filterSpecial, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(curNeeds)) &#123;      <span class="comment">//传进来的清单 还没有计算出最低花费</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds.get(i) * price.get(i); <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">specialPrice</span> <span class="operator">=</span> curSpecial.get(n);   <span class="comment">//sepcialPrice = 当前礼包的费用</span></span><br><span class="line">                List&lt;Integer&gt; nextNeeds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">//nextNeeds = 当前清单各物品数 - 礼包各物品数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial.get(i) &gt; curNeeds.get(i)) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextNeeds.add(curNeeds.get(i) - curSpecial.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nextNeeds.size() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = Math.min(minPrice, dfs(price, nextNeeds, filterSpecial, n) + specialPrice);  </span><br><span class="line">                    <span class="comment">//当递归到一个礼包都不能购买时，dfs返回的就是当时清单的各物品原价</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo.put(curNeeds, minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.get(curNeeds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h1 id="869-重新排序得到2的幂-M-待理解！"><a href="#869-重新排序得到2的幂-M-待理解！" class="headerlink" title="869.重新排序得到2的幂(M)  ~~ ~~ 待理解！"></a>869.重新排序得到2的幂(M)  ~~ ~~ 待理解！</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/" data-id="cl1yneflz0004swtu70is4aot" data-title="算法题" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/Java%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.221Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/Java%E5%AD%A6%E4%B9%A0/">java</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h2><h3 id="2-HashMap和Hashtable"><a href="#2-HashMap和Hashtable" class="headerlink" title="2. HashMap和Hashtable"></a>2. HashMap和Hashtable</h3><p><strong>相同点:</strong></p>
<p>hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口</p>
<p><strong>不同点:</strong></p>
<ol>
<li><p>底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树</p>
</li>
<li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>
</li>
<li><p>添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p>
</li>
<li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>
</li>
<li><p>扩容机制不同：当已用容量&gt;总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。</p>
</li>
<li><p>支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历</p>
</li>
<li><p>迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。</p>
</li>
<li><p>部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法</p>
</li>
<li><p>同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,</p>
<p>而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。sdfla</p>
</li>
</ol>
<h3 id="3-Arrays-asList"><a href="#3-Arrays-asList" class="headerlink" title="3.Arrays.asList"></a>3.Arrays.asList</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>( new 一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 是动态扩容的了。)</p>
<p>注意：</p>
<ul>
<li>不要将  原生数据类型的数组  作为参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());		<span class="comment">//输出结果为1，而不是3</span></span><br></pre></td></tr></table></figure>

<p>上述代码，遍历mylist的话，会得到一个带有hashCode 的对象。</p>
<p>（当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是<strong>数组对象</strong>本身）</p>
<p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 <strong>Integer</strong> 而不是 int。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>asList返回一个由指定数组生成的固定大小的List；</p>
<p>如果不new一个ArrayList，那么得到的list不能修改其大小，且Arrays的内部类ArrayList没有重写add等方法，用add会抛出异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);		<span class="comment">//异常</span></span><br></pre></td></tr></table></figure>





<h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h3><p>java允许将同一个类中的<strong>多个同名，同功能但参数个数不同的方法</strong>，封装成一个方法，即通过<strong>可变参数</strong>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int... 表示接受的是可变参数，类型是int， 即可接受多个int；可变参数的实参可以为0到任意多个；</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以作为数组；</span></span><br><span class="line"><span class="comment">//可变参数可以和普通类型的参数一起放在形参列表，但可变参数必须放在最后；列表里可变参数只能一个</span></span><br><span class="line"><span class="comment">//可变参数的本质就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;接受的参数个数：&quot;</span> + nums.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-字符"><a href="#5-字符" class="headerlink" title="5.字符"></a>5.字符</h3><h4 id="1-字符分割"><a href="#1-字符分割" class="headerlink" title="1.字符分割"></a>1.字符分割</h4><p>使用了 <strong>split(string)</strong> 方法通过指定分隔符将字符串分割为数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        String[] temp = str.split(d);</span><br><span class="line">        <span class="keyword">for</span>(String x : temp)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<p>使用 <strong>StringTokennizer</strong> 设置不同分隔符来分隔字符串，默认的分隔符是：<strong>空格、制表符（\t）、换行符(\n）、回车符（\r）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;this is string , split by stringtokenizer&quot;</span>;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用空格作为分隔符</span></span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//用逗号做分隔</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(st2.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st2.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this</span><br><span class="line">is</span><br><span class="line">string</span><br><span class="line">,</span><br><span class="line">split</span><br><span class="line">by</span><br><span class="line">stringtokenizer</span><br><span class="line"></span><br><span class="line">this is string </span><br><span class="line"> split by stringtokenizer</span><br></pre></td></tr></table></figure>



<h4 id="2-字符大小写"><a href="#2-字符大小写" class="headerlink" title="2.字符大小写"></a><strong>2.字符大小写</strong></h4><p>toUpperCase() 方法将字符串从小写转为大写</p>
<p>tolowerCase() 方法将字符串从大写转为小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;string runoob&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strUpper</span> <span class="operator">=</span> str.toUpperCase();</span><br></pre></td></tr></table></figure>

<h4 id="3-测试两个字符串区域是否相等"><a href="#3-测试两个字符串区域是否相等" class="headerlink" title="3.测试两个字符串区域是否相等"></a><strong>3.测试两个字符串区域是否相等</strong></h4><p> regionMatches() 方法测试两个字符串区域是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Welcome to Microsoft&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;I work with microsoft&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">//第一个参数 true 表示忽略大小写区别</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str1.regionMatches(<span class="literal">true</span>, <span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>) 表示将 str1 字符串从第<span class="number">11</span>个字符<span class="string">&quot;M&quot;</span>开始和 str2 字符串的第<span class="number">12</span>个字符<span class="string">&quot;M&quot;</span>开始逐个比较，共比较 <span class="number">9</span> 对字符，由于字符串区分大小写，所以结果为<span class="literal">false</span>。</span><br><span class="line">如果设置第一个参数为 <span class="literal">true</span> ，则表示忽略大小写区别，所以返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure>



<h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><h4 id="获取最大"><a href="#获取最大" class="headerlink" title="获取最大"></a>获取最大</h4><p>通过 Collections 类的 Collections.max() 和 Collections.min() 方法来查找数组中的最大和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.max(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure>

<h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><p>使用List类的Arrays.toString方法和list.Addall（list.Addall（array1.aslist(array2））方法将两个数组合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">String b[] = &#123; <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(a));</span><br><span class="line">list.addAll(Arrays.asList(b));</span><br><span class="line">Object[] c = list.toArray();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure>

<h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p>通过 Java Util 类的 <strong>Arrays.fill(arrayname,value)</strong> 方法和<strong>Arrays.fill(arrayname ,starting index ,ending index ,value)</strong> 方法向数组中填充元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(array, <span class="number">100</span>);	<span class="comment">//全部填充 </span></span><br><span class="line">Arrays.fill(array, <span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>);		<span class="comment">//填充第3 - 第6 d</span></span><br></pre></td></tr></table></figure>

<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">String[] extended = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">extended[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">extended[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"><span class="comment">//从names索引为0处 复制names.length长度的元素，到extend索引为0处</span></span><br><span class="line">System.arraycopy(names, <span class="number">0</span>, extended, <span class="number">0</span>, names.length);</span><br><span class="line"><span class="keyword">for</span> (String str : extended)&#123;</span><br><span class="line">    System.out.println(str);</span><br></pre></td></tr></table></figure>

<h4 id="数组差集，交集"><a href="#数组差集，交集" class="headerlink" title="数组差集，交集"></a>数组差集，交集</h4><p> 用<strong>removeAll</strong> () 方法来计算两个数组的差集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.removeAll(objArray2);		<span class="comment">//objArray中删去元素一样的，留下不一样的</span></span><br></pre></td></tr></table></figure>

<p>用 <strong>retainAll</strong> () 方法来计算两个数组的交集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.retainAll(objArray2);		<span class="comment">//objArray中删去元素不一样的，留下一样的</span></span><br></pre></td></tr></table></figure>



<h3 id="7-时间处理"><a href="#7-时间处理" class="headerlink" title="7.时间处理"></a>7.时间处理</h3><h4 id="当前时间及格式化"><a href="#当前时间及格式化" class="headerlink" title="当前时间及格式化"></a>当前时间及格式化</h4><p>用simpleDateFormat类的format(date)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Date对象，获取当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是&quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd日 E HH 点 mm分 ss 秒&quot;</span>)</span><br><span class="line">System.out.pritntln(f.format(now));<span class="comment">//将当前时间格式化为指定的格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 <span class="number">2019</span> 年 <span class="number">10</span> 月 <span class="number">15</span> 日 星期一 09 点 <span class="number">26</span> 分 <span class="number">23</span> 秒</span><br></pre></td></tr></table></figure>

<p>SimpDateFormat自定义格式中常用字母及含义</p>
<p><img src="https://img-blog.csdnimg.cn/20200304200839960.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc0Mzc5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="获取年份月份等"><a href="#获取年份月份等" class="headerlink" title="获取年份月份等"></a>获取年份月份等</h4><p>用Calendar类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//cal.getTime 可获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> cal.get(Calendar.DATE);	<span class="comment">//日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;	<span class="comment">//月</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);		<span class="comment">//年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_WEEK);	<span class="comment">//一周中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dom</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);	<span class="comment">//一个月中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR);	<span class="comment">//一年中的第几天</span></span><br></pre></td></tr></table></figure>



<h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h3><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Vector)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.Vector 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArrayList)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 &quot;</span> + o.getClass() + <span class="string">&quot; 类的实例&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象是 java.util.ArrayList 类的实例</span><br></pre></td></tr></table></figure>

<h4 id="标签（Label）"><a href="#标签（Label）" class="headerlink" title="标签（Label）"></a>标签（Label）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OUTER:  <span class="comment">//定标签义，可以是任意标识符（一般放在迭代语句之前）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Even number: &quot;</span> + i);</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span> OUTER;	<span class="comment">//在continue或break后使用标签，直接跳到标签处</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Varargs可变参数"><a href="#Varargs可变参数" class="headerlink" title="Varargs可变参数"></a>Varargs可变参数</h4><p>在一个形参的”类型”与”参数名”之间加上三个连续的”.”，就可以让它和不确定个实参相匹配。</p>
<p>本质上和字符串一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumvarargs</span><span class="params">(<span class="type">int</span>... intArrays)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, i;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; intArrays.length; i++) &#123;</span><br><span class="line">        sum += intArrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumstring</span><span class="params">(<span class="type">int</span>[] intArrays)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="Java练习"><a href="#Java练习" class="headerlink" title="Java练习"></a>Java练习</h2><h3 id="网上练习"><a href="#网上练习" class="headerlink" title="网上练习"></a>网上练习</h3><ol>
<li><p>JDK：java开发核心组件；JRE：java运行环境；JVM：java虚拟机</p>
</li>
<li><p>JDK，JRE，JVM的关系：</p>
<p>JDK &#x3D; JRE + Java的开发工具（javac.exe，java.exe，javadoc.exe)</p>
<p>JRE &#x3D; JVM + Java核心类库 </p>
</li>
<li><p>javac（java语言编译器）用于编译java源文件。</p>
</li>
<li><p>JDK工具中javadoc用于生成java文档，格式为HTML。</p>
</li>
<li><p>JVM运行于操作系统之上，依赖于操作系统；能够直接运行<strong>java字节码</strong>文件。</p>
</li>
<li><p>Java HotSpot是一种热编译技术，在运行Java代码时会被使用，只对程序的部分字节码进行优化。</p>
</li>
<li><p>环境变量PATH中包含多个路径时，路径之间用；（分号）分开。</p>
</li>
<li><p>CLASSPATH中的“ .  ” 表示当前目录。</p>
</li>
<li><p>JVM执行一个Java类时，大致流程为：</p>
<p>装载类—&gt;校验类—&gt;执行类中的代码</p>
</li>
<li><p>如果类的成员的访问权限设置为默认，则该成员被同一包中的类访问；</p>
</li>
<li><p>类具有封装性，但可以通过类的公共接口访问类中的数据；</p>
</li>
<li><p>super指的是当前对象的父类对象的内存地址；</p>
</li>
<li><p>尝试对null对象进行操作时，会产生NullPointerException类型的异常；</p>
</li>
<li><p>覆盖（重写）只能发生在父类与子类之间；</p>
<p>重载可以发生在同一个类中；</p>
</li>
<li><p>this和super不能用在main()方法中；</p>
</li>
<li><p>每一个Unicode码占用16个比特位；</p>
</li>
<li><p>封装：对外隐藏内部实现细节，增强程序的安全性；</p>
</li>
<li><p>自定义异常必须继承Exception，可以继承自Error；</p>
</li>
<li><p>使用JDBC（Java Data Base Connectivity）连接数据库的顺序：</p>
<p>导入驱动包 ——加载驱动——建立数据库的连接——发送并处理SQL语句——关闭连接</p>
</li>
</ol>
<p>19.java分了5片内存：寄存器，本地方法区，方法区，栈，堆。</p>
<p>​		栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；栈的存取速度要比堆快，次于CPU寄存器</p>
<p>  	 只要数据运算完成所在的区域结束，该数据就会被释放。</p>
<p>​		堆：用于存储数组和对象，也就是实体。</p>
<p> 		1：每一个实体都有内存首地址值。</p>
<p> 		2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p>
<p> 		3：垃圾回收机制。</p>
<h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><p>一、java入门</p>
<ol>
<li><p>java诞生：1995年5月；java特点：简单性，面向对象，安全性，跨平台性，支持多线程，分部性；</p>
</li>
<li><p>path环境变量的作用：使用jdk命令 &#x2F; 在任何目录下都可以使用javac和java命令；</p>
</li>
<li><p>java程序运行需要经过编译和运行两个步骤：<strong>编译器</strong>执行 <strong>.java文件</strong>，编译生成 .class的字节码文件，而<strong>Java虚拟机</strong>运行 <strong>.class文件</strong>；</p>
<p>java命令用于运行编译后的 .class文件，不需要文件后缀名；</p>
</li>
<li><p>JDK中可执行程序都放在bin目录下：Java编译器javac.exe 和 Java运行工具 java.exe；</p>
</li>
<li><p>一个java程序不一定要有main方法，需要独立运行的程序才要有main方法。</p>
</li>
</ol>
<p>二、java编程基础</p>
<ol>
<li>在Java中，浮点型数会被默认为double类型，所以给float赋值浮点型数据时，应该加F&#x2F;f，如 float &#x3D; 1F；</li>
<li>文档注释 格式： &#x2F;**      *&#x2F;</li>
</ol>
<p>三、面向对象</p>
<ol>
<li>public，static不能修饰局部变量；</li>
<li>构造方法不能被继承；</li>
<li>面向对象的三大特征：封装，继承，多态；</li>
<li>this关键字的作用：（简答题）<ul>
<li>this调用本类中的属性，即成员变量；</li>
<li>this调用本类的其他方法；</li>
<li>this调用本类的其他构造方法，调用时要放在构造方法的首行；</li>
</ul>
</li>
<li>成员变量和局部变量的区别：<ul>
<li>定义位置的区别：成员变量定义与方法之外，类之内；局部变量定义在方法之内；</li>
<li>生命周期：成员变量随着对象的创建而产生，随着对象的消失而消失；局部变量随着方法内的创建语句而产生，在代码运行至自己的作用域外即消失；</li>
<li>存储位置的区别：成员变量存储在堆中，局部变量存储在栈中；</li>
<li>初始值不同：成员变量有默认的初始值；局部变量没有，需要初始化才能使用；</li>
</ul>
</li>
<li>构造方法和普通成员方法的不同：<ul>
<li>构造方法与类名相同；</li>
<li>构造方法前没有返回类型的声明；</li>
<li>构造方法因为没有返回类型，所以不能返回任何值，但可以使用return来返回；</li>
</ul>
</li>
<li>面向对象的三特征：<ul>
<li>封装：将对象的属性和行为封装起来，不需要让外界知道具体的实现细节；</li>
<li>继承：描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类进行功能拓展；</li>
<li>多态：允许程序中出现重名现象，使同种类的多个对象，在接收到同一个消息时能产生不同反应和效果；（前提是有一个父类，多个子类）</li>
</ul>
</li>
<li>局部内部类只可以被final修饰，且只能访问被final修饰的局部变量；</li>
<li>super和this不能同时存在与同一个构造方法中；</li>
</ol>
<p>五、集合</p>
<ol>
<li>如果使用通配符“？”接收对象，则此对象只能接收，不能修改。</li>
</ol>
<p>六、IO</p>
<h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>src（source源文件）—package（包）—-class（类）</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>IDEA 中代码模板位置：setting - Editor - Live Templates &#x2F; postfix Completion</p>
<p>常用模板：</p>
<ol>
<li><p>psvm ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sout</p>
</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>删除当前行：ctrl + y</p>
<p>复制当前行：ctrl + d</p>
<p>补全代码：at + &#x2F;</p>
<p>添加取消注释：ctrl + &#x2F;</p>
<p>生成方法：alt + insert</p>
<p>生成环绕方式：ctrl + alt + t （即 if … else ，do…while，try…catch 之类的）</p>
<p>查看类的的层级关系：ctrl + H</p>
<p>定位方法：ctrl + B</p>
<p>自动分配变量名：alt + 回车   &#x2F;   ctrl + alt + v  &#x2F; 在后面加 .var</p>
<p>显示所有快捷键：ctrl + j</p>
<p>使用单元测试工具 JUnit 来运行调试 单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法上加上@Test，按Alt+Enter，点”将JUnit5加入到类路径中&quot;，之后方法右边会右绿色小箭头可以使用，之后在这个类中要使用JUnit5，只要加上@Test即可</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th align="left"><strong>功能点</strong></th>
<th align="left"><strong>Eclipse快捷键</strong></th>
<th align="left"><strong>IDEA快捷键</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>搜索</strong></td>
<td align="left">搜索文本</td>
<td align="left">Ctrl + F</td>
<td align="left">Ctrl + FCtrl + R 查找替换                                        Alt + P&#x2F;A 逐个&#x2F;全部替换                                       Alt + F3 查找当前选中词</td>
</tr>
<tr>
<td></td>
<td align="left">继续搜索</td>
<td align="left">Ctrl + K 向前        Ctrl + Shift + K 向后</td>
<td align="left">F3                                                                 Shift + F3</td>
</tr>
<tr>
<td></td>
<td align="left">搜索方法</td>
<td align="left">Ctrl + O</td>
<td align="left">Ctrl + F12</td>
</tr>
<tr>
<td></td>
<td align="left">搜索类</td>
<td align="left">Ctrl + Shift + T</td>
<td align="left">Ctrl + N</td>
</tr>
<tr>
<td></td>
<td align="left">搜索文件</td>
<td align="left">Ctrl + Shift + T</td>
<td align="left">Ctrl + Shift + N                                                         这两个都支持简单的正则表达式，还支持直接按大写字母的缩略，                                   例如：查找JsonTranscoder，只需要输入JT</td>
</tr>
<tr>
<td></td>
<td align="left">搜索所有引用处</td>
<td align="left">Ctrl + Alt + H</td>
<td align="left">Alt + F7</td>
</tr>
<tr>
<td></td>
<td align="left">搜索所有文本出现的位置</td>
<td align="left">Ctrl + H</td>
<td align="left">Ctrl + Shift + F</td>
</tr>
<tr>
<td><strong>编辑</strong></td>
<td align="left">自动代码补全</td>
<td align="left">Alt + &#x2F;</td>
<td align="left">Ctrl + J</td>
</tr>
<tr>
<td></td>
<td align="left">自动代码生成</td>
<td align="left"></td>
<td align="left">Alt + Insert</td>
</tr>
<tr>
<td></td>
<td align="left">快速修复错误</td>
<td align="left">Ctrl + 1</td>
<td align="left">Alt + Enter</td>
</tr>
<tr>
<td></td>
<td align="left">删除当前行</td>
<td align="left">Ctrl + D</td>
<td align="left">Ctrl + X</td>
</tr>
<tr>
<td></td>
<td align="left">复制到下一行</td>
<td align="left"></td>
<td align="left">Ctrl + D</td>
</tr>
<tr>
<td></td>
<td align="left">注释&#x2F;取消注释</td>
<td align="left">Ctrl + &#x2F;</td>
<td align="left">Ctrl + &#x2F;</td>
</tr>
<tr>
<td></td>
<td align="left">选中当前字</td>
<td align="left"></td>
<td align="left">Ctrl + W</td>
</tr>
<tr>
<td></td>
<td align="left">补全当前行</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + Enter神器，补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</td>
</tr>
<tr>
<td></td>
<td align="left">调出最近复制的N份内容</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + V</td>
</tr>
<tr>
<td></td>
<td align="left">查看最近编辑的文件</td>
<td align="left"></td>
<td align="left">Ctrl + E</td>
</tr>
<tr>
<td></td>
<td align="left">对比最近修改</td>
<td align="left"></td>
<td align="left">Alt + Shift + C</td>
</tr>
<tr>
<td></td>
<td align="left">格式化代码</td>
<td align="left">Ctrl + Shift + F</td>
<td align="left">Ctrl + Alt + L</td>
</tr>
<tr>
<td></td>
<td align="left">整理import</td>
<td align="left">Ctrl + Shift + O</td>
<td align="left">Ctrl + Alt + O</td>
</tr>
<tr>
<td><strong>跳转</strong></td>
<td align="left">显示方法层次</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + H</td>
</tr>
<tr>
<td></td>
<td align="left">显示类、方法说明</td>
<td align="left">F2</td>
<td align="left">Ctrl + Q</td>
</tr>
<tr>
<td></td>
<td align="left">跳到方法定义处</td>
<td align="left"></td>
<td align="left">Ctrl + B</td>
</tr>
<tr>
<td></td>
<td align="left">跳到方法实现处</td>
<td align="left"></td>
<td align="left">Ctrl + Alt + B</td>
</tr>
<tr>
<td></td>
<td align="left">跳到上&#x2F;下一方法</td>
<td align="left"></td>
<td align="left">Alt + Up&#x2F;Down</td>
</tr>
<tr>
<td></td>
<td align="left">上&#x2F;下一查看处</td>
<td align="left">Alt + &lt;-Alt + -&gt;</td>
<td align="left">Ctrl + Alt + Up&#x2F;Down</td>
</tr>
<tr>
<td></td>
<td align="left">跳到指定行</td>
<td align="left">Ctrl + L</td>
<td align="left">Ctrl + G</td>
</tr>
<tr>
<td><strong>重构</strong></td>
<td align="left">改名</td>
<td align="left">Alt + Shift + R</td>
<td align="left">Shift + F6</td>
</tr>
<tr>
<td></td>
<td align="left">其他常用</td>
<td align="left"></td>
<td align="left">Ctrl + F6 修改方法签名                                          Ctrl + Shift + F6 修改参数的类型                       Ctrl + Shift + V引入局部变量                              Ctrl + Shift + P 引入参数                              Ctrl + Shift + F 引入类变量                                     Ctrl + Shift + M 引入方法                         Ctrl + Shift + C 引入常量</td>
</tr>
<tr>
<td><strong>运行</strong></td>
<td align="left">启动调试</td>
<td align="left"></td>
<td align="left">Alt + Shift + F9</td>
</tr>
<tr>
<td></td>
<td align="left">启动运行</td>
<td align="left"></td>
<td align="left">Alt + Shift + F10</td>
</tr>
<tr>
<td></td>
<td align="left">单步进入</td>
<td align="left">F5</td>
<td align="left">F7</td>
</tr>
<tr>
<td></td>
<td align="left">单步跳过</td>
<td align="left">F6</td>
<td align="left">F8</td>
</tr>
<tr>
<td></td>
<td align="left">跳过</td>
<td align="left">F8</td>
<td align="left">F9</td>
</tr>
<tr>
<td></td>
<td align="left">执行选中语句</td>
<td align="left"></td>
<td align="left">Alt + F8</td>
</tr>
<tr>
<td><strong>窗口</strong></td>
<td align="left">调出界面</td>
<td align="left"></td>
<td align="left">Ctrl + Alt + S调出Settings界面                                 Ctrl + Alt + Shift + S调出项目Setting界面</td>
</tr>
<tr>
<td></td>
<td align="left">关闭界面</td>
<td align="left"></td>
<td align="left">Ctrl + F4 或 ESC</td>
</tr>
<tr>
<td></td>
<td align="left">打开窗口</td>
<td align="left"></td>
<td align="left">Alt + 窗口编号(例如项目窗口编号是1)</td>
</tr>
<tr>
<td></td>
<td align="left">最大化窗口</td>
<td align="left">Ctrl + M</td>
<td align="left">Ctrl + Shift + F12</td>
</tr>
<tr>
<td></td>
<td align="left">隐藏窗口</td>
<td align="left"></td>
<td align="left">Shift + ESC</td>
</tr>
<tr>
<td></td>
<td align="left">关闭当前文件</td>
<td align="left"></td>
<td align="left">Ctrl + F4</td>
</tr>
<tr>
<td></td>
<td align="left">垂直分屏</td>
<td align="left"></td>
<td align="left">Ctrl + | (自定义的)</td>
</tr>
<tr>
<td></td>
<td align="left">调整窗口位置</td>
<td align="left"></td>
<td align="left">Ctrl + M 将当前光标处显示到屏幕中央</td>
</tr>
<tr>
<td></td>
<td align="left">切换窗口</td>
<td align="left"></td>
<td align="left">Ctrl + Tab</td>
</tr>
</tbody></table>
<h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><p><img src="https://www.runoob.com/wp-content/uploads/2013/12/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p>
<p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>Java可以使用修饰符来修饰类中 方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li><p><strong>public</strong> : <strong>对所有类可见（对外公开）</strong>。使用对象：类、接口、变量、方法</p>
</li>
<li><p><strong>protected</strong> : 对<strong>所有子类 和 同一包内的类 可见</strong>。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
</li>
<li><p><strong>default</strong> (即默认，什么也不写）: 在<strong>同一包内可见</strong>。使用对象：类、接口、变量、方法。</p>
</li>
<li><p><strong>private</strong> : 仅在<strong>类本身内可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p>
</li>
</ul>
<p>可以通过以下表来说明访问权限：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同一包内</th>
<th align="left">子孙类(不同包)</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h5><p><strong>类变量，也叫静态变量，是该类的所有对象共享的变量，</strong>任何一个该类的对象去访问&#x2F;修改它，取到&#x2F;修改的都是相同的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure>

<p>jdk8以前，静态变量放在静态域（方法区），jdk8以后放在<strong>堆中</strong>，当这个类加载的时候会在堆生成这个类的class对象，静态变量就放在class实例的尾部。</p>
<p><strong>访问方式</strong>：类名.类变量名 或者 对象名.类变量名</p>
<p>（类变量在类加载时就初始化了，而不管new几次对象，类只会加载一次，类变量的生命周期与类相同）</p>
<hr>
<p><strong>类方法</strong>，也叫静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问方式</strong>：类名.类方法名 或者 对象名.类方法名</p>
<p>当方法中不涉及任何和对象相关的成员（包括this，super），则可以设计成静态方法，提高开发效率；如：工具类中的方法utils：Math类、Collections集合</p>
<hr>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol>
<li><p>这个关键字是一个修饰符，可以修饰类，方法，变量。</p>
</li>
<li><p>被final修饰的类是一个<strong>最终类，不可以被继承</strong>。</p>
</li>
<li><p>被final修饰的方法是一个<strong>最终方法，不可以被重写</strong>。</p>
</li>
<li><p>被final修饰的变量是一个<strong>常量，只能赋值一次</strong>。</p>
</li>
</ol>
<p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 <strong>_</strong> 连接。</p>
<p>注意点：</p>
<ul>
<li>final修饰的属性在定义时，必须赋初值，且不能再修改，可以在如下位置<strong>赋值</strong>：<ul>
<li><strong>定义时；</strong></li>
<li><strong>在构造器中</strong></li>
<li><strong>在代码块中</strong></li>
</ul>
</li>
<li>如果final修饰的<strong>属性是静态</strong>的，则只能在定义时和在静态代码块中赋值，<strong>不能在构造器中赋值</strong>；</li>
<li>final类不能继承，但可以实例化对象；</li>
<li>如果类不是final类，但含有final方法，则该方法虽不能重写，但能被继承</li>
<li>final类中，没有必要再将用final修饰方法；</li>
<li><strong>final不能修饰构造器；</strong></li>
<li><strong>final和static搭配使用，不会导致类加载；</strong></li>
<li>包装类（Integer，Double，Float，Boolean等都是final），String也是final类；</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">protected</td>
<td align="left">受保护的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">public</td>
<td align="left">公共的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">class</td>
<td align="left">类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">extends</td>
<td align="left">扩充,继承</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">final</td>
<td align="left">最终值,不可改变的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">interface</td>
<td align="left">接口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">native</td>
<td align="left">本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">new</td>
<td align="left">新,创建</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">static</td>
<td align="left">静态</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">strictfp</td>
<td align="left">严格,精准</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">synchronized</td>
<td align="left">线程,同步</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">transient</td>
<td align="left">短暂</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">volatile</td>
<td align="left">易失</td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">continue</td>
<td align="left">继续</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">do</td>
<td align="left">运行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">else</td>
<td align="left">否则</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">for</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">if</td>
<td align="left">如果</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">instanceof</td>
<td align="left">实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">return</td>
<td align="left">返回</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">while</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">try</td>
<td align="left">捕获异常</td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">package</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">byte</td>
<td align="left">字节型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">char</td>
<td align="left">字符型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">double</td>
<td align="left">双精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">float</td>
<td align="left">单精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int</td>
<td align="left">整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">long</td>
<td align="left">长整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">short</td>
<td align="left">短整型</td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td align="left">父类,超类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">this</td>
<td align="left">本类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void</td>
<td align="left">无返回值</td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">null</td>
<td align="left">空</td>
</tr>
</tbody></table>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><strong>作用：</strong></p>
<ol>
<li>区分相同名字的类</li>
<li>当类很多时，可以很好的管理类（Java API文档）</li>
<li>控制访问范围</li>
</ol>
<p><strong>包的基本语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包本质上，就是创建不同的文件夹&#x2F;目录来保存类文件</p>
<p><strong>包的命名规则：</strong></p>
<p>只能包含数字、字母、下划线、小圆点，不能数字开头，不能用关键字或保留字</p>
<p><strong>命名规范：</strong> 小写字母 + 小圆点 </p>
<p>一般是    <strong>com.公司名.项目名.业务模块名</strong></p>
<p><strong>常用的包：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*		<span class="comment">//lang包是基本包，默认导入</span></span><br><span class="line">java.util.*		<span class="comment">//util包是系统提供的工具包，工具类</span></span><br><span class="line">java.net.*		<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*		<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包：</strong> <strong>使用 import 关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javautil.Scanner;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只能声明一句package；</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解@"></a>注解@</h3><p>注解（Annotation），也叫元数据（Metadata），用于修饰包，类，方法，属性，构造器，局部变量等数据信息；</p>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息；</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等；而在JavaEE中，注解有更大的作用，如：配置应用程序的任何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等；</p>
<p><strong>使用：</strong></p>
<p>三个基本的Annotaton：</p>
<ol>
<li><p><strong>@Override：限定某个方法，是重写父方法的，该注解只能用于方法；</strong></p>
<ul>
<li><p>@Override 表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错；</p>
</li>
<li><p>@Override 只能用来修饰方法</p>
</li>
<li><p>查看@Override注解源码@Target(ElementType. METHOD)，说明只能修饰方法；</p>
</li>
<li><p>@Target是修饰注解的注解，称为元注解</p>
</li>
</ul>
</li>
<li><p><strong>@Deprecated：用于表示某个程序元素（类&#x2F;方法等）已过时；</strong></p>
<ul>
<li>@Target(vlaue &#x3D; {CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</li>
<li>@Deprecated的作用：新旧版本的兼容和过度</li>
</ul>
</li>
<li><p><strong>@SuppressWarnings：抑制编译器警告；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以指定的警告类型有 (可以查看黄色警告光标，看是什么类型的警告)</p>
<p>all，抑制所有警告 </p>
<p>boxing，抑制与封装&#x2F;拆装作业相关的警告 </p>
<p>cast，抑制与强制转型作业相关的警告 </p>
<p> dep-ann，抑制与淘汰注释相关的警告</p>
<p>deprecation，抑制与淘汰的相关警告  </p>
<p>fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告  </p>
<p>finally，抑制与未传回 finally 区块相关的警告 </p>
<p> hiding，抑制与隐藏变数的区域变数相关的警告 </p>
<p> incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告 </p>
<p> javadoc，抑制与 javadoc 相关的警告 </p>
<p> nls，抑制与非 nls 字串文字相关的警告 </p>
<p> null，抑制与空值分析相关的警告 </p>
<p> rawtypes，抑制与使用 raw 类型相关的警告 </p>
<p>resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>restriction，抑制与使用不建议或禁止参照相关的警告</p>
<p> serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>static-access，抑制与静态存取不正确相关的警告 </p>
<p>static-method，抑制与可能宣告为 static 的方法相关的警告 </p>
<p> super，抑制与置换方法相关但不含 super 呼叫的警告 </p>
<p> synthetic-access，抑制与内部类别的存取未最佳化相关的警告 </p>
<p> sync-override，抑制因为置换同步方法而遗漏同步化的警告 </p>
<p>unchecked，抑制与未检查的作业相关的警告 </p>
<p>unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>unused，抑制与未用的程式码及停用的程式码相关的警告</p>
</blockquote>
</li>
</ol>
<p> 补充说明：查看源码时，有个：@interface，表明是一个注解类，跟interface是不一样的          </p>
<hr>
<p><strong>四种元注解：</strong></p>
<ol>
<li>Retention  ：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<ol start="2">
<li>Target ： 指定注解可以在哪些地方使用 </li>
<li>Documented ：指定该注解是否会在 javadoc 体现</li>
<li>Inherited ：子类会继承父类注</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">引用类型(包装类)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
</tr>
</tbody></table>
<p>此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p>
<h4 id="包装类与其他的转换"><a href="#包装类与其他的转换" class="headerlink" title="包装类与其他的转换"></a>包装类与其他的转换</h4><p><strong>包装类与基本类型的相互转换</strong></p>
<p>jdk5后可以自动装箱和拆箱，自动装箱底层调用的是valueOf 方法，比如：Integer.valueOf()；</p>
<p>手动装箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(n);</span><br></pre></td></tr></table></figure>

<p>手动拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>包装类与String类型的相互转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 —&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;	<span class="comment">//方法一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();	<span class="comment">//方法二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);<span class="comment">//方法三</span></span><br><span class="line"><span class="comment">//String —&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4); <span class="comment">//构造器</span></span><br></pre></td></tr></table></figure>





<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>Integer和Character常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer.MIN_VALUE 	<span class="comment">//返回最小值</span></span><br><span class="line">Integer.MAX_VALUE	<span class="comment">//返回最大值</span></span><br><span class="line">    </span><br><span class="line">Character.isDigit(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//判断是否是数字</span></span><br><span class="line">Character.isLetter(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//判断是不是字母</span></span><br><span class="line">Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是大写</span></span><br><span class="line">Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是小写</span></span><br><span class="line">Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是空格</span></span><br><span class="line">    </span><br><span class="line">Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//转成大写</span></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)	<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure>

<p><strong>关于Integer的数据存放位置：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">127</span>;<span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//Integer.valueOf(n),如果传入的值在-128 ~ 127，直接返回等于这个数值的对象。如果超过了范围，则new一个Integer对象</span></span><br><span class="line"><span class="comment">//即-128 ~ 127范围内的数字，都已经有一个自己的对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;		<span class="comment">//valueOf源码</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">		<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i9 == i10);<span class="comment">//F，对象不同</span></span><br><span class="line"></span><br><span class="line">Integer i11=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> i12=<span class="number">127</span>;</span><br><span class="line">System.out.println(i11==i12); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//只要有基本数据类型，判断的是值是否相同</span></span><br></pre></td></tr></table></figure>



<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4字节</td>
<td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-32 768 ~ 32 767</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>-128 ~ 127</td>
</tr>
</tbody></table>
<p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p>
<p><strong>Java没有无符号形式的int,long,short,byte类型。</strong></p>
<p>（可以将有符号整数解释为无符号数，但需要非常仔细）</p>
<hr>
<p><strong>浮点型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td>
</tr>
</tbody></table>
<p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p>
<ul>
<li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p>
<p>1.正无穷大：Double.POSITIVE_INFINITY</p>
<p>2.负无穷大：Double.NEGATIVE_INFINITY</p>
<p>3.NaN(不是一个数字)：Double.NaN</p>
<ul>
<li>检测一个特定值是否等于Double.NaN：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isNaN(x))		<span class="comment">//检查x是否是一个数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</li>
</ul>
</li>
<li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，命令System.out.plantln(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p>
</li>
</ul>
<hr>
<p><strong>char</strong>类型</p>
<p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p>
<ul>
<li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p>
<p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p>
<p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p>
</li>
<li><p>java中，char类型描述了UTF-16编码中的一个代码单元，但辅助字符编码为一对连续的代码单元（即不止一个代码单元），所以<strong>建议不要在程序中使用char类型，除非确实要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</strong></p>
</li>
</ul>
<hr>
<h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a><strong>变量与常量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明与初始化</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12.0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//对于局部变量，如果可以从初始值推断出它的类型，可以不声明类型，只用关键字var即可：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>；  <span class="comment">//i is an int</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>  <span class="comment">//a is a string</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>常量</strong></p>
<p>利用关键字<strong>final</strong>指示常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//final表示这个变量只能被赋值一次，习惯上常量名用全大写</span></span><br></pre></td></tr></table></figure>

<p><strong>类常量</strong>：使某个常量在一个类的多个方法中使用，用关键字<strong>static final</strong>设置类常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Constant&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line">	<span class="comment">//类常量的定义位于main的外部</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h4><p>枚举类型的变量只能存储这个类型声明中给定的某个枚举值，或特殊值null（表示这个变量没有设置任何值）</p>
<hr>
<h4 id="关系运算boolean"><a href="#关系运算boolean" class="headerlink" title="关系运算boolean"></a><strong>关系运算boolean</strong></h4><ul>
<li><p>&amp;&amp;和||运算符按照短路方式求值，如果第一个操作数已能确定表达式的值，第二个操作数就不会进行计算。</p>
</li>
<li><p>&amp;和|不采用短路方式求值，即两个操作数都会进行计算。</p>
</li>
</ul>
<p>&amp;：对应位都为1则结果为1，否则为0；</p>
<p>|：对应位都为0则结果为0，否则为1；</p>
<p>^：对应位值相同则为0，否则为1；</p>
<p>~：按位取反每一位；</p>
<p>位模式左移：&gt;&gt;</p>
<p>右移：&lt;&lt;</p>
<p>运算符&gt;&gt;&gt;会用0填充高位，不存在&lt;&lt;&lt;</p>
<hr>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a><strong>子串</strong></h4><p>String类的substring方法：从字符串中<strong>提取</strong>出一个子串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.substring(<span class="number">0</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="comment">//substring方法中第二个参数是不想复制的第一个位置，即复制0，1，2位</span></span><br><span class="line"><span class="comment">//substring有个优点，就是子串b的长度容易计算，为3-0 = 3，即第2个参数减第1个参数</span></span><br></pre></td></tr></table></figure>

<p>java可以用+号<strong>连接</strong>两个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br></pre></td></tr></table></figure>

<p>静态join方法：将多个字符串放在一起，用<strong>界定符分开</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String all = String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);</span><br><span class="line">//结果：all = &quot;S/M/L/XL&quot;</span><br></pre></td></tr></table></figure>

<p>repeat方法：将字符串<strong>复制n次</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//结果：a = &quot;javajavajava&quot;</span></span><br></pre></td></tr></table></figure>

<p>java没有提供<strong>修改字符串</strong>的方法，因此要通过其他操作来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a = a.substring(<span class="number">0</span>,<span class="number">3</span>) +<span class="string">&quot;p!&quot;</span>;</span><br><span class="line"><span class="comment">//结果为a = help!</span></span><br></pre></td></tr></table></figure>

<p>（尽管通过这种方式修改字符串效率不高，但不可变字符串有其他的优点：编译器可以让字符串共享，即原始字符串与复制字符串共享相同的字符（地址））。</p>
<p><strong>检测字符串是否相等</strong>：equals方法——s.equals(t）——其中s和t可以是字符串变量，也可以是字符串字面量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(a);</span><br><span class="line"><span class="comment">//如果相等，返回true，否则返回false</span></span><br><span class="line"><span class="comment">//不要使用==运算符来检测两字符串！==只能确定两个字符串是否存放在同一位置，但只有字符串字面量是共享的，而+获substring等操作得到的字符串并不共享。</span></span><br></pre></td></tr></table></figure>





<hr>
<p>localDate类的程序：（显示当前月的日历）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">data</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">//下面获得当前的月份和日期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> data.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> data.getDayOfMonth();</span><br><span class="line">        <span class="comment">//将data设置为这个月的第一天，并得到这一天为星期几</span></span><br><span class="line">        data = data.minusDays(today - <span class="number">1</span>);</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> data.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();</span><br><span class="line">        <span class="comment">//打印日历的表头和第一行缩进</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入循环，使data遍历月的每一天，并打印日期；</span></span><br><span class="line">        <span class="keyword">while</span>(data.getMonthValue() == month)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,data.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfMonth() == today)&#123;      <span class="comment">// 如果data是当前日期，则用*标记；</span></span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            data = data.plusDays(<span class="number">1</span>);    <span class="comment">// 接下来将data推进到下一天，如果到达新一周，则换行打印</span></span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfWeek().getValue() == <span class="number">1</span>) System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mon Tue Wed Thu Fri Sat Sun</span><br><span class="line">              <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span> </span><br><span class="line"> <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>*</span><br><span class="line"> <span class="number">26</span>  <span class="number">27</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">30</span> </span><br></pre></td></tr></table></figure>



<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>main方法时虚拟机调用</li>
<li>jvm需要调用类的main()方法，所以该方法的访问权限必须是public</li>
<li>jvm在执行main()方法时不必创建对象，所以main()为static</li>
<li>main()接受String类型的参数数组，该数组中保存执行java命令时传递给所运行的类的参数</li>
</ol>
<p>在main()方法中，可以直接调用main方法所在类的静态方法和静态变量，但不能访问非静态的方法和变量，必须创建该类的一个实例对象后，才能这个对象去访问；</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类（Class）和对象（object"><a href="#类（Class）和对象（object" class="headerlink" title="类（Class）和对象（object)"></a>类（Class）和对象（object)</h3><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态</p>
<p>(类包含：<strong>属性，方法，构造器，代码块，内部类</strong>)</p>
<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>（非静态变量）：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>（静态变量）：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<blockquote>
<p>类什么时候会被加载？</p>
<ol>
<li>创建对象实例时；</li>
<li>创建子类对象实例，父类也会被加载；</li>
<li>使用类的静态成员</li>
</ol>
</blockquote>
<hr>
<p><strong>代码块：</strong>又称初始化块，类似于方法，将语句封装在方法体中，用{}包起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">	代码</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//修饰符可选，但只能写static</span></span><br><span class="line"><span class="comment">// ; 号可写可不写</span></span><br></pre></td></tr></table></figure>

<p><strong>静态代码块</strong>，作用就是对类初始化，随着类的加载而执行，且<strong>只会执行一次</strong>，如果<strong>是普通代码块，每创建一个对象都会执行一次</strong>（如果只是使用类的静态成员，普通代码不会执行）；</p>
<hr>
<p><strong>对象</strong>：对象是类的一个示例，有状态和行为。软件对象的状态就是属性，行为通过方法体现</p>
<p><strong>创建对象</strong></p>
<p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用顺序：</strong></p>
<ol>
<li><strong>调用静态代码块和静态属性初始化（有多个则顺序调用）；</strong></li>
<li><strong>调用普通代码块和普通属性的初始化；</strong></li>
<li><strong>调用构造方法；</strong></li>
</ol>
<hr>
<p><strong>源文件声明规则</strong></p>
<p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>好处：</p>
<p>1：提高了代码的复用性。</p>
<p>2：提高了代码的拓展性和维护性，让类与类之间产生了关系，提供了另一个特征多态的前提。</p>
<ul>
<li><p><strong>一般类只能单继承；内部类实现多继承；接口可以多继承；</strong></p>
</li>
<li><p>子类继承了所有的属性和方法，<strong>非私有的</strong>属性和方法可以在子类<strong>直接访问</strong>，但是<strong>私有的</strong>属性和方法要通过父类提供的<strong>公共方法去访问</strong>；</p>
</li>
<li><p><strong>子类必须调用父类的构造器，完成父类的初始化；</strong></p>
</li>
</ul>
<ol>
<li><strong>对与成员变量：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关键字：</span><br><span class="line"><span class="built_in">this</span>：是本类类型的对象引用</span><br><span class="line"><span class="comment">//this从本类中开始查找，没有才从父类中找</span></span><br><span class="line"><span class="built_in">super</span>：是子类所属的父类中的内存空间引用</span><br><span class="line"><span class="comment">//super直接从父类中查找</span></span><br><span class="line"><span class="comment">//super不能访问父类的private属性或方法</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>子父类中通常是不会出现同名成员变量的</strong>，因为父类中只要定义了，子类就不用在定义，直接继承过来用。（当有属性&#x2F;方法<strong>重名时</strong>，<strong>只能用super访问父类的重名属性&#x2F;方法</strong>；super的访问不限于直接父类，如果爷爷类也有与本类重名的属性&#x2F;方法，也能用super去访问；即<strong>多个基类中都有重名的成员，super的访问遵循就近原则</strong>）</p>
<ol start="2">
<li><strong>成员函数：</strong></li>
</ol>
<p>当子父类可以出现一样的方法，即可以覆盖（重写）函数（当一个类的功能需要修改时，可以通过覆盖来实现）</p>
<ol start="3">
<li><strong>构造函数</strong></li>
</ol>
<p>子类的构造函数运行时，一定会先运行父类的构造函数；</p>
<p>原因：子类的构造函数中的第一行，都有一条隐身的语句super()，而这个super（）是在调用父类中空参数的构造函数；</p>
<blockquote>
<p>因为子类继承父类，会继承父类中的数据，所以必须要看到父类对自己数据进行初始化的过程</p>
</blockquote>
<p>子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p>
<blockquote>
<p>注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</p>
<p>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</p>
<p>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p>
</blockquote>
<p><strong>在方法覆盖（重写）时，注意：</strong></p>
<ol>
<li><p>子类覆盖父类时，必须要保证，<strong>子类方法的权限必须大于等于父类方法权限</strong>可以实现继承。否则，编译失败。</p>
</li>
<li><p>覆盖时，要么<strong>都静态</strong>，要么<strong>都不静态</strong>。 (静态只能覆盖静态，或者被静态覆盖)</p>
</li>
<li><p>子类中重写父类的方法，必须与父类的那个方法：<strong>名称，返回类型，参数一样</strong>；</p>
</li>
</ol>
<p><strong>而对于重载：只要同一类中，且方法名一致，参数列表不一样即可，对返回类型，修饰符无要求；</strong></p>
<p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p>
<p>此时可以用到final;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：这个关键字是一个修饰符，可以修饰类，方法，变量。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：被<span class="keyword">final</span>修饰的类是一个最终类，不可以被继承。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：被<span class="keyword">final</span>修饰的方法是一个最终方法，不可以被覆盖。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：被<span class="keyword">final</span>修饰的变量是一个常量，只能赋值一次。</span><br></pre></td></tr></table></figure>

<p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p>
<p><strong>创建子类对象时的调用顺序：</strong></p>
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性初始化；</li>
<li>父类的构造方法；</li>
<li>子类的普通代码块和普通属性初始化；</li>
<li>子类的构造方法；</li>
</ol>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现 细节部分 包装、隐藏起来的方法。</p>
<p>也就是说：<strong>将数据和对数据的操作封装起来，程序的其他部分只有通过被允许的操作才能对数据进行修改。</strong></p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p><strong>封装的优点：</strong></p>
<ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节。</p>
</li>
</ol>
<hr>
<p><strong>实现Java封装的步骤：</strong></p>
<ol>
<li><p>修改属性的可见性来<strong>限制对属性的访问</strong>（一般限制为<strong>private</strong>）,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">person</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<p><strong>访问权限控制：public &gt; protected &gt; 包 &gt; private</strong> </p>
</li>
<li><p>对每个值属性<strong>提供对外的公共方法访问</strong>，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>static关键字</strong>：可对数据进行静态修饰</p>
<blockquote>
<ol>
<li><p><strong>被静态修饰的成员，可以直接被类名所调用。</strong>也就是说，静态的成员多了一种调用方式。<strong>类名.静态方式。</strong></p>
</li>
<li><p><strong>静态随着类的加载而加载，而且优先于对象存在。</strong></p>
</li>
<li><p><strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p>
</li>
<li><p><strong>静态方法中不能使用this，super关键字。</strong></p>
</li>
</ol>
<p>   因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p>
</blockquote>
<p>成员变量和静态变量的区别：</p>
<p>1，成员变量所属于对象，所以也称为<strong>实例变量</strong>。</p>
<p>   静态变量所属于类，所以也称为<strong>类变量</strong>。</p>
<p>2，成员变量存在于<strong>堆内存</strong>中。</p>
<p>   静态变量存在于<strong>方法区</strong>中。</p>
<p>3，成员变量随着对象创建而存在，随着对象被回收而消失。</p>
<p>   静态变量随着类的加载而存在，随着类的消失而消失。</p>
<p>4，成员变量只能被对象所调用。</p>
<p>   静态变量可以被对象调用，也可以被类名调用。</p>
<p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>实现多态的三个必要条件：<strong>继承，重写（重载也是），向上转型</strong>；</p>
<p><strong>向上转型：子类对象被父类引用；</strong></p>
<p><strong>向下转型：向下转型是子类对象被父类引用之后，再把父类引用强转成子类；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//向上转型</span></span><br><span class="line">        b.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird)b;<span class="comment">//向下转型</span></span><br><span class="line">        bird.run();</span><br><span class="line">        bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>向下转型的意义：当多个子类继承同一个父类或接口时，可以写一个公用的方法，方法传入的形参为父类或接口，这样每个子类实参就可以传入这个父类形参中，进而实现公用性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="comment">//传入子类的实参引用</span></span><br><span class="line">        sleep(b);</span><br><span class="line">        sleep(tom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法的参数是父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(Animal A)</span>&#123;</span><br><span class="line">        A.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用例子： </p>
<ol>
<li><p><strong>多态参数：</strong>可以<strong>在方法实参中使用父类，然后调用方法时传入子类，即向上转型</strong></p>
</li>
<li><p><strong>多态数组：</strong>数组的定义类型为父类，里面保存的实际元素类型为子类类型</p>
<p>如果要调用数组中子类特有的方法，可以使用<strong>类型判断+向下转型</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu[] f = <span class="keyword">new</span> <span class="title class_">Fu</span>[n];</span><br><span class="line"><span class="keyword">if</span>(f[i] instancef Zi)&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> (Zi)f[i];</span><br><span class="line">    z.方法();</span><br><span class="line">    <span class="comment">//两句直接写成：((Zi)f[i]).方法();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>多态 体现在：<strong>父类引用变量可以指向子类对象</strong></p>
<p>多态的定义格式：</p>
<blockquote>
<p>父类类型 变量名 &#x3D; new 子类类型（）；</p>
</blockquote>
<p>多态成员特点：</p>
<ol>
<li>多态成员<strong>变量</strong>：编译类型 运行类型 <strong>都看左边</strong></li>
<li>多态成员<strong>方法</strong>：<strong>编类型看左边，运行类型看右边</strong></li>
</ol>
<p><strong>java的动态绑定机制</strong></p>
<ul>
<li><strong>当调用对象方法时，该方法会和对象的内存地址&#x2F;运行类型绑定；</strong></li>
<li><strong>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"><span class="comment">//f是父类Fu中的值，只能取到父中的值</span></span><br><span class="line"><span class="comment">//f表面是Fu，实际类型是Zi，所以调用到的方法是重写后的方法，</span></span><br><span class="line"><span class="comment">//方法里所用到的值，是当前类的值，即调用的方法在哪个类，就用哪那个类的值；</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>instanceof关键字：</strong>用于判断对象是否属于某种数据类型（返回值为布尔类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   Fu f1=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        Fu f2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">if</span>(f1 <span class="keyword">instanceof</span> Zi)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Zi的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Son的类型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>多态的转型：</strong></p>
<p>向上转型：多态本身就是向上转型过的过程</p>
<ul>
<li>使用格式：父类类型 变量名&#x3D;new 子类类型();</li>
</ul>
<blockquote>
<p>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。</p>
</blockquote>
<p>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型</p>
<ul>
<li>使用格式：子类类型 变量名&#x3D;（子类类型） 父类类型的变量；</li>
</ul>
<blockquote>
<p>适用场景：当要使用子类特有功能时。</p>
</blockquote>
<hr>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整嵌套了另一个结构，被嵌套的类被称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。</p>
<p>内部类最大的特点是<strong>可以直接访问外部类的所有成员，包括私有属性</strong>。</p>
<p>按定义的位置：</p>
<ol>
<li>定义<strong>在局部位置</strong>（方法&#x2F;代码块）：<ul>
<li><strong>局部内部类</strong></li>
<li><strong>匿名内部类</strong></li>
</ul>
</li>
<li>定义<strong>在成员位置</strong>：<ul>
<li><strong>成员内部类</strong>（不加static）&#x2F; 普通内部类</li>
<li><strong>静态内部类</strong>（加static）</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>在类里面作为一个字段直接定义即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 B 类为 A 类的普通内部类，在这种定义方式下，普通内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="comment">//不在外部类内部，要用：外部类对象.new 内部构造器()；的方式创建对象</span></span><br><span class="line">        a.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一个类的静态成员独立于这个类的任何一个对象存在，只要在具有访问权限的地方，我们就可以通过 <strong>类名.静态成员名</strong> 的形式来访问这个静态成员，同样的，静态内部类也是作为一个外部类的静态成员而存在，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。</p>
<p>与静态成员一样，静态内部类 无法访问外部类的非静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在同一个外部类中，且同样是静态的，可以直接new</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不在外部类内部，用：外部类名.静态成员名 进行访问</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类没有名字，定义在外部类的局部位置（方法&#x2F;代码块）</p>
<p>某个类实现接口&#x2F;抽象类，但只使用一次，可以使用匿名内部类（简化开发）  </p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基于接口的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;	<span class="comment">//接口</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;	<span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//anonymity的编译类型是IA，运行类型是匿名内部类</span></span><br><span class="line">        <span class="comment">//匿名内部类其实在底层会分配一个名字，不会显示出来</span></span><br><span class="line">        <span class="comment">//jdk底层在创建匿名内部类anomymity$1,立刻就创建了其实例，并把地址返回给anomymity;</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">anonymity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="comment">//查看一下运行类型，即在原名字后加$1: anomymity$1</span></span><br><span class="line">        system.out.println(anomymity.getclass());</span><br><span class="line">        <span class="comment">//匿名内部类anomymity$1使用一次就回收掉，但anonymity是一个对象，仍可以反复调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于类的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;		<span class="comment">//A可以为普通类或抽象类</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类可以直接当作实参直接传递，简洁高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">//当做实参直接传递，简洁高效</span></span><br><span class="line">	f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//传统方法</span></span><br><span class="line">	f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在外部类的局部位置，有名字。</p>
<p>不能添加访问修饰符，但可以使用final修饰（跟局部变量一样）</p>
<p>作用域：仅在定义它的方法或代码块中</p>
<ul>
<li><p>访问方式：</p>
<ul>
<li>局部内部类访问外部类的成员：直接访问</li>
<li>外部类访问局部内部类的成员：<strong>在它的作用域中创建对象</strong>，再访问；</li>
</ul>
</li>
<li><p>外部其他类不能访问局部内部类（地位相当于是一个局部变量）</p>
</li>
<li><p>如果外部类和局部内部类的成员<strong>同名</strong>，默认遵循就近原则，如果想访问外部类成员，可以用：<strong>外部类名. this. 成员名</strong> ，去访问</p>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，</p>
<p>如果一个类中<strong>没有包含足够的信息来描绘一个具体的对象</strong>，这样的类就是<strong>抽象类</strong>。</p>
<p>抽象类除了<strong>不能实例化对象</strong>之外，类的<strong>其它功能依然存在</strong>，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承，才能被使用</strong>。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p><strong>使用abstract class来定义抽象类。</strong></p>
<p>抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，<strong>抽象方法只包含一个方法名，而没有方法体。</strong></p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类<strong>包含抽象方法</strong>，那么该类<strong>必须是抽象类</strong>。</li>
<li>任何<strong>子类必须重写父类的抽象方法</strong>，<strong>或者声明自身为抽象类</strong>。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<p> <strong>抽象类总结规定</strong></p>
<ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
<li>抽象关键字abstract 和 final, private, static不共存</li>
</ol>
<p>设计模式：</p>
<p>解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span>&#123; <span class="comment">//此功能如果不需要复写，可加final限定</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">//不确定的功能部分，提取出来，通过抽象方法实现</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;毫秒是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>; <span class="comment">//抽象不确定的功能，让子类复写实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123; &lt;font color=red &gt;<span class="comment">//子类复写功能方法&lt;/font&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;<span class="number">1000</span>; y++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface），在JAVA中是一个抽象类型，是抽象方法的集合，</p>
<p>接口通常以interface来声明。一个类通过继承接口，从而继承接口中的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p><strong>接口声明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口 允许继承 多个其他接口</span></span><br></pre></td></tr></table></figure>

<p><strong>接口实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口与类相似点：</strong></p>
<ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<p><strong>接口与类的区别：</strong></p>
<ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<p><strong>接口特性：</strong></p>
<ul>
<li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</p>
</li>
<li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</p>
<ul>
<li><p>使用static可以 在继承多接口时，如果存在多个同名变量，可以使用接口名.变量名来区分；</p>
</li>
<li><p>使用final，让接口中的变量不可更改，否则，每个实现接口的类都可以改变这个变量的值，就违背了OCP原则；</p>
</li>
</ul>
</li>
<li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p>
</li>
<li><p>接口的修饰符只能是public和默认。</p>
</li>
</ul>
<p><strong>抽象类和接口的区别：</strong></p>
<ol>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</p>
</li>
<li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ol>
<p>注：</p>
<ol>
<li><p>JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
</li>
<li><p>JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。</p>
</li>
<li><p>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p>
</li>
</ol>
<hr>
<p><strong>实现接口和继承类的区别</strong></p>
<p>当子类继承了父类，就自动拥有父类的功能，是 is-a的关系</p>
<p>如果子类<strong>需要扩展功能</strong>，可以通过实现接口的方式扩展，是like - a 的关系，可以理解 ” 实现接口“ 是对java单继承机制的补充；</p>
<p>继承的价值只要是：解决代码的复用性和可维护性。</p>
<p>接口的价值主要是：<strong>设计好各种规范</strong>（方法），让其它子类去实现，更加灵活。且接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）。</p>
<hr>
<p><strong>接口与多态</strong></p>
<p>接口也能利用动态参数 和 多态数组</p>
<p>接口存在多态传递现象</p>
<hr>
<p>在重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<p><strong>标记接口：</strong></p>
<p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口。它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的两种实现：</p>
<ol>
<li>自定义枚举类；</li>
<li>使用enum关键字实现枚举；</li>
</ol>
<hr>
<p> 枚举是一个特殊的类，一般表示一组常量，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ...&#123;</span><br><span class="line">	... , ... , ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用enum，要求将定义常量<strong>对象写在最前面</strong>;</li>
<li>直接使用： <strong>常量名（实参列表）</strong>; 如果使用无参构造器，则实参列表和小括号都可以省略；</li>
<li>如果有多个常量&#x2F;对象,使用<strong>逗号间隔</strong>即可；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//使用enum，要求将定义常量对象写在最前面</span></span><br><span class="line">    <span class="comment">//直接使用： 常量名（实参列表）</span></span><br><span class="line">    <span class="comment">//如果有多个常量/对象,使用逗号间隔即可；</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>values(), ordinal() 和 valueOf() 方法:</strong></p>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>（所以使用enum关键字后，就<strong>不能再继承其他类</strong>了，因为enum隐式继承了Enum类）</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li><strong>values() 返回枚举类中所有的值。</strong></li>
<li><strong>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</strong></li>
<li><strong>valueOf()方法返回指定字符串值的枚举常量。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举类成员:</strong></p>
<p>枚举跟普通类一样可以用<strong>自己的变量、方法和构造函数</strong>，构造函数只能使用 <strong>private</strong> 访问修饰符，让外部无法调用。</p>
<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>
<hr>
<p><strong>自定义枚举类</strong></p>
<ol>
<li>将构造器私有化，防止外部直接new；</li>
<li>去掉set方法，防止属性被修改；</li>
<li>在枚举类内部，直接创建固定的对象；</li>
<li>对外暴露对象：对枚举对象&#x2F;属性使用public + final + static共同修饰，实现底层优化； </li>
<li>枚举对象名通常全部大写（这是常量的命名规范）；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = neme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h3><p>包是Java语言提供的一种区别类名字命名空间的机制，它是类的一种文件组织和管理方式、是一组功能相似或相关的类或接口的集合。</p>
<p>Java package提供了访问权限和命名的管理机制。</p>
<p>一、<strong>包的作用</strong> </p>
<ol>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 </li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ol>
<p>二、<strong>包的定义</strong><br>在一个.java文件中可以一个public类和多个非public类，如果要将这些类组织在一个包当中，则在.java文件中除注释以外的第一行使用关键字package即可实现。</p>
<p>当需要调用此包中的类时，就可以使用关键字import进行导入。在定义包的时候，应该注意几点: </p>
<ol>
<li>为了尽量使包名保持唯一性，包名通常采用小写、按倒写互联网址的形式进行定义。</li>
<li>在进行命名包时，应该避免使用与系统发生冲突的名字。</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常：程序执行中发生的不正常情况</p>
<p>异常分为两大类：</p>
<ol>
<li><strong>Error</strong>（错误）：JVM无法解决的严重问题，如：JVM系统内部错误，资源耗尽等严重情况</li>
<li><strong>Exception</strong>：其他因编程错误或外在因素导致的一般性问题，可以使用针对性代码进行处理；Exception分为两大类：<strong>运行时异常</strong>（程序运行时发生的异常），<strong>编程时异常</strong>（编程时，编译器检查出的异常，编译器要求必须处理）</li>
</ol>
<p><strong>常见的运行时异常：</strong></p>
<ol>
<li><p>**NullPointerException  空指针异常 **</p>
<p>如：当应用程序试图在需要对象的地方使用 null 时，会抛出该异常；</p>
</li>
<li><p>**ArithmeticException  数学运算异常 **</p>
<p>如：当出现异常的运算条件时，抛出此异常，比如整数除以零时；</p>
</li>
<li><p><strong>ArrayIndexOutOfBoundsException</strong> <strong>数组下标越界异常</strong></p>
<p>用非法索引访问数组时抛出的异常，比如索引为负或大于等于数组大小，则该索引为非法索引；</p>
</li>
<li><p><strong>ClassCastException</strong> <strong>类型转换异常</strong></p>
<p>当试图将对象强制转换为不是实例的子类时，抛出该异常；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastException_</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">		<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b;<span class="comment">//向下转型，这里是 OK</span></span><br><span class="line">		<span class="type">C</span> <span class="variable">c2</span> <span class="operator">=</span> (C)b;<span class="comment">//这里抛出 ClassCastException</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NumberFormatException</strong> <strong>数字格式不正确异常</strong></p>
<p>当程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常（使用此异常可以确保输入满足条件的数字）</p>
</li>
</ol>
<p><strong>常见的编译异常：</strong></p>
<ol>
<li>SQLException ：操作数据库时，查询表可能发生异常</li>
<li>IOException ：操作文件时，发生的异常</li>
<li>FileNotFoundException ：当操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException：加载类，而该类不存在时，异常</li>
<li>EOFException：操作文件时，到文件末尾，发生异常</li>
<li>IllegalArguementException：参数异常</li>
</ol>
<hr>
<p><strong>异常处理机制</strong></p>
<ol>
<li><p><strong>try - catch - finally</strong></p>
<p>程序员在代码中捕获发生的异常，自行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能有异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//当异常发生时，系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//得到异常对象后，程序员自己处理</span></span><br><span class="line">    <span class="comment">//如果没有发生异常，catch代码块不执行</span></span><br><span class="line">    <span class="comment">//可以有多个catch语句，捕获不同的异常，要求子类异常写在前，父类异常在后（只会匹配一个catch）</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块有没有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将释放资源的代码放在finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>就算在catch中ruturn了，但因为finally必须执行，所以catch的return中的语句会执行，但不会立即返回（return）；</li>
<li>如果catch中 ruturn  i  ；但finally中又用到了 变量 i  ，底层会保存临时变量temp &#x3D; i ，执行完finally后，catch返回temp（finally有return的话则在finally中return）；</li>
</ul>
</li>
<li><p><strong>throws</strong></p>
<p>将发生的异常抛出，交给调用者（方法）处理，最高级的处理者是JVM（JVM会直接打印异常信息，退出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> XXException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要和父类的一致或其异常类型的子类型；</li>
</ul>
</li>
<li><p><strong>自定义异常</strong></p>
<p>自定义异常 需要继承 Excption或RuntimeException；如果继承Exception属于编译异常， 继承RuntimeException属于运行异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">		<span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line">		<span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">			<span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;  <span class="comment">//构造器</span></span><br><span class="line">		<span class="built_in">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>throw和throws的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的是</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合主要有 单列集合 和 双列集合：</p>
<ul>
<li><p>Collection接口有两个重要的子接口List，Set，它们实行的都是单列集合；</p>
</li>
<li><p>Map接口的实现子类，是双列集合，从存放K - V；</p>
</li>
</ul>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707036.png" alt="image-20211003183537824"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707037.png" alt="image-20211003183548688"></p>
<hr>
<p><strong>如何选择</strong>集合实现类：判断存储的类型：单列&#x2F;双列</p>
<ul>
<li><p>一组对象（单列）：Collection接口</p>
<ul>
<li><p>允许重复：List</p>
<ul>
<li>增删多：LinkedList（底层是双向链表）</li>
<li>查改多：ArrayList（底层是可变数组）</li>
</ul>
</li>
<li><p>不允许重复：Set</p>
<ul>
<li><p>无序：HashSet（底层HashMap）</p>
</li>
<li><p>排序：TreeSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入和取出顺序一致：LinkedHashSet（维护数组和双向链表）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一组键值对（双列）：Map</p>
<ul>
<li><p>键无序：HashMap（底层：维护了一个哈希表：数组+链表+红黑树）</p>
</li>
<li><p>键排序：TreeMap</p>
</li>
<li><p>键插入和取出顺序一致：LinkedHashMap</p>
</li>
<li><p>读取文件：Properties</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h3><p>Collection接口的常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll（All都是指多个元素）</p>
<p>遍历方式：</p>
<ol>
<li>使用 <strong>Iterator</strong> 迭代器（快捷模板：while-&gt;itit）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//先得到col对应的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在调用iterator.next()之前必须先用iterator.hasNext()进行检测，不然，如果下一条记录无效，且直接调用next方法会抛出NoSuchElementException异常</p>
</li>
<li><p>当退出while循环后，iterator迭代器指向最后的元素，如果要再次遍历，需重置迭代器：ite &#x3D; col.iterator();</p>
</li>
<li><p>iterator迭代器的remove方法是迭代过程中唯一能 线性安全地 删除集合元素的方法，因为iterator在遍历过程中，会锁定集合中的元素。</p>
</li>
<li><p>不能直接使用集合的remove方法：因为集合中会有变量modCount记录修改次数，当调用remove方法时，modCount ++，而迭代开始时，会先把modCount 记录下来，在调用iterator.next时会检查修改次数是否一致，如果不一致，则会报错ConcurrentModificationException；</p>
<blockquote>
<p>注：由于hasnext是检查当前已经迭代的数量是否等于集合大小，如果删除倒数第二个数据，集合size–，就会使size &#x3D;&#x3D; 已经迭代的个数，所以会漏掉最后一项数据，即最后一遍循环不执行，iterator.next不执行，也就不会报错。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>使用for循环增强</p>
<p>增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名 ： 集合名/数组名)&#123;</span><br><span class="line">	访问元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li>元素有序（添加和取出的顺序一致），有索引</li>
<li>元素可重复</li>
</ul>
<p>List接口常用方法：add，add（index，Object），get，indexOf，lastIndexOf，remove，set，subList（fromIndex，toIndex）(注意fromIndex &lt;&#x3D; subList &lt; toIndex)</p>
<p>ArrayList和Vector基本等同，区别在线程是否安全</p>
<p>ArrayList类：效率较高，但线程不安全</p>
<p>创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为0，第一次添加，则扩容elementData 为10，后面再次扩容，则扩容为原来的1.5倍 + 1；如果使用指定大小的构造器，则初始elementData 为指定大小，再次扩容，则为原来的1.5倍 + 1。</p>
<hr>
<p>Vector类：线程安全，效率比ArrayList低</p>
<p>Vector类的操作方法带有synchronized。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= elementCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector扩容：无参构造，默认10；扩容为原来的2倍</p>
<hr>
<p>LinkList类：底层实现了双向链表和双端队列的特点，线程不安全，没有实现同步；</p>
<ul>
<li>LinkList维护了两个属性：first指向首节点，last指向尾节点，</li>
<li>每个节点（Node对象）又维护了三个属性：prev指向前一个，next指向下一个，item存放数值；</li>
</ul>
<hr>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>无序（添加和取出的顺序不一致，但存放位置是固定的），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
</ul>
<p>Set常用方法，因为也是Collection的子接口，所以常用方法和Collection接口一样</p>
<p>遍历方式：迭代器，增强for（但不能使用索引方式来获取）</p>
<p><strong>HashSet类</strong></p>
<p>HashSet实现了Set接口，实际上是HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的构造器</span></span><br><span class="line">pUblic <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>LinkedHashSet类</strong></p>
<p>LinkedHashSet是HashSet的子类，底层是LinkedHashMap，底层中维护了一个hash表和双向链表；</p>
<p><strong>LinkedHashMap类</strong></p>
<p>LinkedHashMap中有<strong>头节点head和尾节点tail</strong>（指向第一个添加的节点和最后添加的节点），还创建了<strong>Entry类</strong>来存放节点，它继承自HashMap.Node类，<strong>每个节点有before和after属性</strong>。</p>
<ul>
<li>LinkedHashMap根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElenment</span><br><span class="line">newElement.pre = tail;</span><br><span class="line">tail = newElement;</span><br><span class="line"><span class="comment">//新加入节点和末尾节点相连；</span></span><br><span class="line"><span class="comment">//这样，遍历LinkedHashMap时也能确保插入顺序和遍历顺序一致</span></span><br></pre></td></tr></table></figure>



<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map中用于保存具有映射关系的数据：Key - Value</p>
<p>key不允许重复，只能有一个key为null；value允许重复，可以有多个null；</p>
<p><strong>遍历方式：</strong></p>
<p><strong>containsKey：查找键是否存在</strong></p>
<p><strong>keySet：获取所有的键</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">ks</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object key : ks)&#123;</span><br><span class="line">	System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> ks.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>entrySet：获取所有的关系k - v</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">	<span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">	Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">	System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> ite.next();</span><br><span class="line">	<span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">	Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">	System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValues());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>values：获取所有的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">val</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object value : val)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> val.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>HashMap类</strong></p>
<p>如果添加相同的key，则会<strong>覆盖原来的key - value，相当于修改了value</strong>；</p>
<p>底层没有实现同步，<strong>线程不安全</strong>；</p>
<p>HashMap底层：<strong>数组+链表+红黑树</strong>（不保证映射顺序）</p>
<ol>
<li>先获取元素的哈希值（hashcode方法）；</li>
<li>对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置；（用（length-1）&amp;hash得到数组下标）</li>
<li>如果该位置上没有其他元素，则直接存放，如果有，则需要进行equals判断，如果相等，则不添加，如果不等，则以链表的方式添加；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算hash值的算法，“扰动函数”</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容机制：</p>
<ol>
<li>第一次添加时，table数组扩容到<strong>16</strong>，临界值（threshold）是16 * <strong>加载因子（loadFactor &#x3D; 0.75）</strong>&#x3D; 12；</li>
<li>如果table数组使用到临界值12，就会扩容到16*2 &#x3D; 32，新的临界值为32 * 0.75 &#x3D; 24；</li>
<li>在Java8中，如果一条链表的<strong>元素个数到达TREEIFY_THRESHOLD（默认是8），且table大小&gt;&#x3D;MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树）</strong>；（table是HashMap的一个数组，类型是Node[]）</li>
<li>如果链表的元素个数达到8以上，但table不足64，会将元素加入链表后，对table进行一次扩容。</li>
</ol>
<hr>
<p><strong>Hashtable类</strong></p>
<p>存放的元素的键值对：K - V ，键和值都<strong>不能为null</strong>，否则会抛出NullPointerException；</p>
<p>是<strong>线程安全</strong>的（效率比HashMap低）</p>
<p>（使用方法和HashMap基本一样）</p>
<hr>
<p><strong>Properties类</strong></p>
<p>Properties类<strong>继承自Hashtable类并实行了Map接口</strong>；键和值同样<strong>不能为null</strong>，否则会抛出NullPointerException；</p>
<p>特点：可以用于<strong>从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</strong>（工作中，xxx.properties文件<strong>通常为配置文件</strong>）</p>
<hr>
<p>一道<strong>练习</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(p1);<span class="comment">//OK</span></span><br><span class="line">set.add(p2);<span class="comment">//OK</span></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//name被修改过，找不到，删除失败</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>





<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型又称参数化类型。</p>
<p>java中的泛型<strong>只在编译阶段有效</strong>，在编译之后程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型声明</span></span><br><span class="line">interface 接口&lt;T&gt; &#123;&#125;	<span class="comment">//泛型接口</span></span><br><span class="line">class 类&lt;K,V&gt;&#123;&#125;	<span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>&#123;&#125;<span class="comment">//泛型方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化,在类名后面指定类型参数的值</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>T，E …只能是引用类型，不能是基本数据类型</p>
</li>
<li><p>在给泛型指定具体类型后，可以传入该类型的子类类型</p>
</li>
<li><p>要注意，在静态方法中使用泛型，必须将静态方法定义成泛型方法。因为静态方法访问在类上定义的泛型，不能引用不确定的数据类型。</p>
</li>
<li><p>如果在创建对象时，没有指定类型，默认为Object</p>
</li>
<li><p>泛型接口的类型，在<strong>继承接口</strong>或<strong>实现接口</strong>时确定</p>
</li>
<li><p>java中不能创建一个确切的泛型类型的数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//这样是不允许的</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>];<span class="comment">//这样可以</span></span><br><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];<span class="comment">//这样也可以</span></span><br></pre></td></tr></table></figure>

<p>解释：由于JVM泛型的擦除机制，在运行时JVM不知道泛型信息，可以将一个确切数据类型的数据加入，但在取出数据时却还要做一次类型转换，所以有可能出现ClassCastException。如果可以进行泛型数组的声明，则这种情况不会在编译期进行警告和错误，只有到运行时才出错，所有对泛型数据的声明进行限制可以防止运行时的错误发生；</p>
<p>而使用通配符，最后取出数据要做显式的类型转换，所以没问题；</p>
</li>
</ul>
<hr>
<p><strong>泛型上下边界</strong></p>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行<strong>上下边界的限制</strong>，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p><strong>泛型通配符 &lt;?&gt;</strong> ：支持任意泛型类型</p>
<p><strong>&lt; ? extends A &gt;</strong> ：支持<strong>A类以及A类的子类</strong>，规定了泛型的上限</p>
<p><strong>&lt; ? super A&gt;</strong> ：支持<strong>A类以及A类的父类</strong>，不限于直接父类，规定了泛型的下限</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>创建文件</strong>的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：new File(String pathname) </span></span><br><span class="line">   <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">   <span class="comment">//上面的file1对象，在java程序中，只是一个对象，只有执行了CreatNewFile方法，才会在磁盘创建该文件</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;creat successful&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法二：new File(File parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录文件+之路径构建</span></span><br><span class="line">   <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file1.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法三：new File(String parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录+子目录构建</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName1);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>获取文件的相关信息：</strong></p>
<p>getName()，length()，</p>
<p>getAbsolutePath()：获取绝对路径</p>
<p>getParent()：获取父目录</p>
<p>exist()：文件是否存在</p>
<p>isFile()：是不是文件</p>
<p>isDirectory()：是不是目录</p>
<hr>
<p><strong>目录的操作和文件删除：</strong></p>
<p>mkdir：创建一级目录</p>
<p>mkdirs：创建多级目录</p>
<p>delete：删除空目录或空文件</p>
<h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><p>I&#x2F;O 是Input &#x2F; Output 的缩写，用于处理数据传输，如：读写文件、网络通讯等；</p>
<p><strong>输入input</strong>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</p>
<p><strong>输出output</strong>：将程序（内存)中的数据输出到磁盘等存储设备中；</p>
<p><strong>分类：</strong></p>
<ul>
<li>按操作的数据单位不同：字节流文件（二进制文件），字符流文件（文本文件）；</li>
<li>按数据流的流向不同：输入流，输出流；</li>
<li>按流的角色的不同：节点流，处理流（包装流）；</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>由上面四个类派生出来的子类名称 都是以其父类名作为子类名后缀</p>
<p>体系图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200307125658523.png" alt="img"></p>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次接受一个字节的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//接受单个直接的数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read()无参时会返回单个字节的数据</span></span><br><span class="line">        <span class="comment">//读取完毕，会返回-1</span></span><br><span class="line">        <span class="keyword">while</span>((readData = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);<span class="comment">//转为char显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();<span class="comment">//记得要关闭文件流，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字节数据一次接受多个数据，效率更高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次读取8个字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//一次最多读取8字节，返回读取读取字节的数量</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);<span class="comment">//再加一个true，表示写入内容追加到文件末尾，不加true，则表示覆盖原来的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        fos.write(str.getBytes(),<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="FileReader-和-FileWriter"><a href="#FileReader-和-FileWriter" class="headerlink" title="FileReader 和 FileWriter"></a>FileReader 和 FileWriter</h4><p>FileReader —&gt; InputStreamReader —&gt;Reader</p>
<p>FileReader  —&gt;  InputStreamReader —&gt;Reader</p>
<p>使用方法跟上面的差不多</p>
<p>注意：<strong>对于字符流，记得操作完后要关闭文件流，或使用flush()，否则更新内容不会保存</strong></p>
<hr>
<h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流 ：从一个特定的数据源读写数据，如FileReader，FileWriter；</p>
<p>处理流（包装流）：是连接在已存在的流（节点流&#x2F;处理流）之上，提供了更方便，更强大的读写功能，如BufferedReader，BufferedWriter。</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707038.png" alt="image-20211007204910829"></p>
<p>节点流是底层流，直接跟数据源相接。</p>
<p>处理流包装节点流，既可以<strong>消除不同节点流的实现差异，也可以提供更方便的方法</strong>；处理流使用了修饰器设计模式，<strong>不会直接与数据源相连</strong>。</p>
<p>处理流对性能的提高：主要<strong>以增加缓冲的方式来提高输入输出的效率</strong>；</p>
<hr>
<p>（BufferedReader，BufferedWriter是字符流，不要去操作二进制文件（声音、视频、pdf等），可能造成文件损坏）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedReader</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));<span class="comment">//将</span></span><br><span class="line">    String line;<span class="comment">//按行读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;	<span class="comment">//读取完毕，返回null</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();	<span class="comment">//关闭外层流即可，以为底层会去关闭内层的流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedWriter</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">    bw.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    bw.newLine();	<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">    bw.write(<span class="string">&quot;hello,hello,world&quot;</span>);</span><br><span class="line">    bw.close();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>BufferedInputStream 和 BufferedOutputStream</strong></p>
<p>（是字节流，创建时，内部会创建一个缓冲区数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用BufferedInputStream 和 BufferedOutputStream将一个二进制文件的内容拷贝到另一个文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;  <span class="comment">//因为对象为空会被自动回收，但此时对象还在，需要手动关闭</span></span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p><strong>ObjectOutputStream ：提供 序列化功能 ObjectInputStream ：提供 反序列化</strong></p>
<hr>
<p>序列化：在保存数据时，保存数据的值和数据类型</p>
<p>反序列化：恢复数据时，恢复数据的值和数据类型</p>
<p>想要让对象支持序列化机制，其类应该是可序列化的，必须实现两个接口之一：<strong>Serializable</strong>（是一个标记接口，没有方法）或  Externalizable（有方法需要实现，所以一般实现Serializable接口）</p>
<hr>
<p>注意：</p>
<ul>
<li>读写顺序要一致；</li>
<li>要求对象实现Serializable</li>
<li>为了提高版本的兼容性，序列化的类中建议添加SerialVersionUID</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li>
<li>序列化对象时，要求其属性的类型也实现序列化接口</li>
<li>序列化具备可继承性，即实现了序列化的类，它的子类默认也实现了序列化</li>
</ul>
<hr>
<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>默认设备</th>
</tr>
</thead>
<tbody><tr>
<td>System.in	标准输入</td>
<td>InputStream</td>
<td>键盘</td>
</tr>
<tr>
<td>System.out	标准输出</td>
<td>PrintStream</td>
<td>显示器</td>
</tr>
</tbody></table>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong>和<strong>OutputStreamWriter</strong></p>
<p>可以将字节流转换成字符流，同时可以指定编码格式（如：utf-8，gbk等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="comment">//把 FileInputStream 转成 InputStreamReader，并指定编码</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流只有输出流，没有输入流</p>
<p><strong>PrintStream</strong> 和  <strong>PrintWriter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line"><span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印输出(当s为空时，print方法会打印&quot;null&quot;);</span></span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改打印流输出的位置/设备</span></span><br><span class="line"><span class="comment">//这里修改，打印到 e:\\f1.txt</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;e:\\f1.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="properties类"><a href="#properties类" class="headerlink" title="properties类"></a>properties类</h4><p>专门用于<strong>读写配置文件</strong>的集合类</p>
<p>配置文件的格式：<strong>键&#x3D;值</strong></p>
<p>（不用空格，值不需要引号，默认类型时String）</p>
<hr>
<p>常用方法：</p>
<p><strong>load</strong>：加载配置文件的键值对到Properties对象；</p>
<p><strong>list</strong>：将数据显示到指定设备；</p>
<p><strong>getProperty（key）</strong>：根据键 取 值</p>
<p><strong>setProperty（key，value）</strong>：设置键值对</p>
<p><strong>store</strong>：键Properties对象中的键值对存储到配置文件（在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">   p.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">   p.list(System.out); <span class="comment">//将K-V显示到控制台</span></span><br><span class="line">   p.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line">   p.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>







<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><p>进程：一个独立的正在执行的程序；</p>
<p>多进程：在操作系统中，同时运行多个程序；</p>
<ul>
<li>多进程好处：可以充分利用CPU，提高CPU使用率；</li>
</ul>
</li>
<li><p>线程：一个进程的最基本的执行单位，执行路径；</p>
<p>多线程：在同一个进程（应用程序）中同时执行多个线程</p>
<ul>
<li>多线程好处：提高进程的执行使用率，提高CPU的使用率</li>
</ul>
</li>
<li><p>并发：同一时刻，多个任务交替执行；</p>
<p>并行：同一时刻，多个任务同时执行，多核cpu可以实现并行；</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>在同一个时间点，一个CPU中只能有一个线程在执行；</li>
<li>多线程会降低效率，但可以提高CPU使用率；</li>
<li>一个进程如果有多条执行路径，则称为多线程程序；</li>
<li>Java虚拟机的启动至少开启两条进程：主线程和垃圾回收线程；</li>
<li>一个线程可以理解为进程的子任务；</li>
</ol>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ol>
<li>继承Thread类，重写run方法；</li>
<li>实现Runnable接口，重写run方法；</li>
</ol>
<p>（Thread类实现了Runnable接口，Runnable接口里面只有一个方法run() ）</p>
<ul>
<li>调用start方法，才是真正开启了一个子线程，调用run方法不会开启新的线程（所处的线程还是执行调用的那个线程）</li>
<li>start() 方法调用了start0()方法， start0()方法是本地方法，由JVM调用，底层是C&#x2F;C++实现， start0()真正实现多线程的效果。</li>
<li>start() 方法调用start() 方法后，该线程不一定会立即执行，只是将线程变成了可运行的状态。具体什么时候执行，取决于CPU，由CPU统一调度。</li>
</ul>
<p><strong>方法一：继承Thread类</strong></p>
<p>当一个类继承了Thread类，该类就可以当作线程使用，并在run方法里写上自己的业务代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;	<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread01.start();<span class="comment">//开启线程</span></span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);	<span class="comment">//让主线程休眠1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>方法二：实现Runnable接口</strong></p>
<p>可能一个类已经继承了某个父类，再继承Thread类来创建线程显然不可能。此时可以通过实现Runnable接口来创建进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;	<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">//不能用aa.start()来调用start，</span></span><br><span class="line">        <span class="comment">//应该创建Thread对象，把对象aa（需要实现了Runnable）放进Thread；</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(aa);</span><br><span class="line">        thead.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>继承Thread 和 实现Runnable 的区别</strong></p>
<p>从本质上来讲是没有区别的；</p>
<p>不过实现Runnable接口的方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制（建议使用Runnable）</p>
<hr>
<p><strong>线程终止</strong></p>
<ol>
<li>当线程完成任务后，会自动退出；</li>
<li>可以通过<strong>使用变量</strong>来控制run方法退出的方式来停止线程，即<strong>通知方式</strong></li>
</ol>
<hr>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><strong>setName</strong>  ： 设置线程名称，赋值给name；</p>
<p><strong>getName</strong> ： 返回该线程的名称；</p>
<p><strong>start</strong>：使该线程开始执行（JVM底层调用该线程的start0方法）；</p>
<p><strong>run</strong>：调用该线程对象的run方法；</p>
<p><strong>setPriority</strong>：更改线程的优先级；</p>
<p><strong>getPriority</strong>：获取线程的优先级；</p>
<p><strong>sleep</strong>：让当前正在执行的线程在指定的毫秒数内休眠（线程的静态方法，使当前线程暂停休眠）</p>
<p><strong>interrupt</strong>：中断线程（不是终止线程，一般用于中断线程的休眠状态）；</p>
<p><strong>yield</strong>：线程的礼让。让出CPU，让其他线程先执行，但礼让的时间不确定，也不一定能礼让成功；</p>
<p><strong>join</strong>：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务；（t1.join() ）</p>
<hr>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>用户线程和守护线程：</strong></p>
<ul>
<li>用户线程：也叫工作线程</li>
<li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。（常见的守护线程：垃圾回收机制）</li>
</ul>
<p>使用<strong>setDaemon</strong>方法将普通线程设为守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>守护线程的优先级非常低；</p>
<p><strong>TimerTask</strong></p>
<p>守护线程经常要做一些周期性的操作，如：每5分钟执行某操作，每天12点执行某操作等；此时可以用到Java的计时器的工具类：Timer和TimerTask</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>JDK中用<strong>Thread.State</strong>枚举了线程的六种状态：</p>
<ol>
<li><strong>NEW</strong>：（new）尚未启动的线程 处于此状态</li>
<li><strong>RUNNABLE</strong>：（runnable）在java虚拟机中执行的线程 处于此状态</li>
<li><strong>BLOCKED</strong>：（blocked）被阻塞等待监视器锁定的线程 处于此状态</li>
<li><strong>WAITING</strong>：正在等待另一个线程执行特定动作的线程 处于此状态</li>
<li><strong>TIMED_WAITING</strong>：正在等待另一个线程执行动作达到指定等待时间的线程 处于此状态</li>
<li><strong>TERMINATED</strong>：已退出的线程 处于此状态</li>
</ol>
<p>线程状态转换图：</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707039.png" alt="image-20211006205038275"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707040.png" alt="image-20211007085636266"></p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>在多线程编程中，为了防止部分数据被多个线程同时访问，所有就使用同步访问计数，保证数据在任何 同一时刻，最多被一个线程访问，以保证数据的完整性</p>
<p>实现同步的方法：<strong>Synchronized &#x2F; Lock</strong></p>
<p><strong>Synchronized</strong></p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;	<span class="comment">//需要对象的锁，才能操作同步代码</span></span><br><span class="line">    被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">     被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态同步方法的锁是加在当前类本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> vodi <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同步方法如果没有使用static修饰，默认锁对象是this，如果方法由static修饰，默认锁对象：当前类.class</p>
<p><strong>Lock</strong></p>
<p>Lock 是一种比 Synchroized更加灵活的一种加锁方式，使用的时候必须显示的加锁 ：lock.lock ，然后 在释放锁的时候我们也需要显示的 lock.unlock 调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>互斥锁：</strong></p>
<p>保证共享数据操作的完整性；每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，都只能有一个线程访问该对象；</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问；</p>
<p><strong>死锁：</strong></p>
<p>多个线程都占用了对方的锁资源，但不肯让出资源，导致了死锁（必须要避免死锁发生）</p>
<p><strong>释放锁：</strong></p>
<ol>
<li>当前线程的同步方法，同步代码块执行结束；</li>
<li>当前线程在同步方法，同步代码块中遇到break，return；</li>
<li>当前线程在同步方法，同步代码块中出现了未处理的Error或Exception，导致异常结束；</li>
<li>当前线程在同步方法，同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁；</li>
</ol>
<p>注意：下面操作不会释放锁</p>
<ol>
<li>线程执行同步方法，同步代码块时，程序调用了Thread.sleep()，Thread.yied()方法暂停当前线程的执行，不会释放锁；</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend() 方法将该线程挂起，该线程不会释放锁；（尽量避免使用suspend() 和resume() 来控制程序，方法不再推荐使用）</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>java.net包中包含的类和接口，提供了低层次的通信细节，因此我们专注于网络程序开发，而不用考虑通信的细节。</p>
<p><strong>java.net</strong>包中提供了两种常见的网络协议的支持：<strong>TCP和UDP</strong>；</p>
<p>而对于IP地址，java中的<strong>InetAddress类</strong>表示<strong>互联网协议（IP）地址</strong>；</p>
<hr>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>无构造方法</p>
<p>常用方法：</p>
<p>**type[] getAddress( )**：返回此InetAddress对象的原始IP地址</p>
<p>**static Inetaddress getByName(String host)**：在给定主机名的情况下确定主机的IP地址</p>
<p>**String getHostAddress( )**：返回IP地址字符串（以文本表现形式）</p>
<p>**String getHostName( )**：获取此IP地址的主机名</p>
<p>**static InetAddress getLocalHost( )**：返回本地主机</p>
<blockquote>
<p>127.0.0.1：本地主机，主要用于测试。</p>
<p>别名：Localhost</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">// 获取此 IP 地址的主机名。</span></span><br><span class="line">System.out.println(inetAddress.getHostName());</span><br><span class="line"><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line">System.out.println(inetAddress.getHostAddress());</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="comment">//14.215.177.39</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a>InetSocketAddress类</h3><p>InetSocketAddress类实现了<strong>IP套接字地址（IP地址+端口号）</strong></p>
<p>注意：</p>
<ul>
<li>编写的程序要占用端口号的话 只占用1024以上的端口号，<strong>1024以下的端口号不要去占用，因为系统有可能会随时征用。端口号本身又分为TCP端口和UDP端口，TCP的8888端口和UDP的8888端口是完全不同的两个端口。TCP端口和UDP端口都有65536个</strong>。（端口的表示是一个16位的二进制整数，2个字节，对应十进制的<strong>0~65535</strong>）(ssh 22, ftp 21, smtp, 25, http 80, tomcat 2020, mysql 3306, oracle 1521, sqlserver 1433)</li>
</ul>
<blockquote>
<p><strong>DOS命令查看端口：</strong></p>
<ul>
<li>查看所有端口：netstat  -ano</li>
<li>查看指定端口：netstat  -ano|findstr “端口号”</li>
<li>查看指定端口的进程：tasklist|findstr “端口号”</li>
</ul>
</blockquote>
<p>InetSocketAddress类：</p>
<p><strong>构造方法</strong>：</p>
<p><strong>InetSocketAddress ( InetAddress addr, int port)</strong> ：根据IP地址和端口号创建套接字地址。</p>
<p>**InetSocketAddress ( int port)**：创建套接字地址，其中IP地址为通配符地址，端口号为指定值。</p>
<p>**InetSocketAddress ( String hostname, int port)**：根据主机名和端口号创建套接字地址。</p>
<p>常用方法：</p>
<p>**InetAddress getAddress( )**：获取InetAddress（IP对象)</p>
<p><strong>String</strong> getHostName( )：获取主机名</p>
<p>**int getPort( )**：获取端口号</p>
<hr>
<h3 id="TCP网络编程："><a href="#TCP网络编程：" class="headerlink" title="TCP网络编程："></a>TCP网络编程：</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要<strong>严格区分为客户端（Client）与服务端（Server）。</strong></p>
<p><strong>两端通信时步骤</strong>：</p>
<ol>
<li>服务端程序，需要<strong>事先启动</strong>，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能实现通信。服务端不可以主动连接客户端。</li>
</ol>
<p>java提供了两个类用于实现TCP通信程序：</p>
<ol>
<li>客户端：用 java.net.Socket类实现。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：用 java.netServerSocket类实现。创建ServerSocket对象，相当于开启一个服务，等待客户端的连接。</li>
</ol>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707041.png" alt="image-20211011200948784"></p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket类实现客户端套接字，套接字指的是两台设备间通讯的端点。</p>
<p><strong>构造方法：</strong></p>
<p>**public Socket ( String host, int port)**：创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。</p>
<blockquote>
<p>回送地址（127.0.0.1）是本机回送地址（Loopback   Address），主要用于网络让江测试以及本地机进程间通讯，无论什么程序，一旦使用回送地址发送数据，会立即返回，不进行任何网络传输。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<p>**public InputStream getInputStream( )**：返回此套接字的输入流</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
<p>**public OutputStream getOutputStream( )**：返回此套接字的输出流</p>
<ul>
<li>如果此Socket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
<p>**public void closs( )**：关闭此套接字</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li>
</ul>
<p><strong>public void shutdownOutput( )</strong> ： 禁用此套接字的输出流。</p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。</li>
</ul>
<hr>
<h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p><code>ServerSocket</code>类实现了服务器套接字，该对象等待通过网络的请求。</p>
<p><strong>构造方法：</strong></p>
<p>**public ServerSocket( int port)**：创建ServerSocket对象，并将其绑定到一个指定的端口号上，参数port就是端口号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<p>**public Socket accept( )**：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直柱塞直到建立连接。</p>
<p>注意：</p>
<ul>
<li>服务器是没有IO流的，服务器可以获取到请求的客户端对象socket；</li>
<li>使用每个客户端socket中提供的IO流和客户端进行交互；</li>
<li>服务器使用客户端的字节输入流读取客户端发送的数据；</li>
<li>服务器使用客户端的字节输出流给客户端回写数据；</li>
</ul>
<hr>
<p>示例：客户端向客户端发送消息，服务端向客户端回写消息</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建Socket对象，它的第一个参数需要的是服务端的IP，第二个参数是服务端的端口</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、获取一个输出流，用于写出要发送的数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">//==========================解析回复==================================</span></span><br><span class="line">            <span class="comment">//4、首先必须通知服务器，我已经输出完毕了，不然服务端不知道什么时候输出完毕</span></span><br><span class="line">            <span class="comment">//服务端的while循环会一直执行，会阻塞</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            <span class="comment">///5、获取输入流，用于读取服务端回复的数据</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自服务端的消息：&quot;</span> + baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//6、释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建服务端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、调用accept接收到来自于客户端的socket</span></span><br><span class="line">            socket = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待客户端接入</span></span><br><span class="line">            <span class="comment">//3、获取socket的输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        不建议这样写：因为如果我们发送的数据有汉字，用String的方式输出可能会截取汉字，产生乱码</span></span><br><span class="line"><span class="comment">//        int len=0;</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        while ((len=is.read(buffer))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//            System.out.println(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、读取输入流中的数据</span></span><br><span class="line">            <span class="comment">//ByteArrayOutputStream的好处是它可以根据数据的大小自动扩充</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于客户端&quot;</span> + socket.getInetAddress().getHostName()</span><br><span class="line">                    + <span class="string">&quot;的消息：&quot;</span> + baos.toString());</span><br><span class="line">            <span class="comment">//===========================回复==========================================</span></span><br><span class="line">            <span class="comment">//5、获取一个输出流，写出回复给客户端</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//6、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//7、关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p><code>java.net</code>包提供了两个类DatagramSocket类和DatagramPacket类</p>
<ul>
<li><code>DatagramSocket</code>类：表示用于发送和接收数据报的套接字</li>
<li><code>DatagramPacket</code>类：表示数据报的数据包。</li>
</ul>
<hr>
<h4 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h4><p><strong>构造方法：</strong></p>
<p>**protected DatagramSocket()**：构造数据报套接字并将其绑定到本地主机上的任何可用端口。</p>
<p>**protected DatagramSocket(int port)**：构造数据报套接字并将其绑定到本地主机上的指定端口。</p>
<p>**protected DatagramSocket(int port, InetAddress laddr)**：创建一个数据报套接字，绑定到指定的本地地址。</p>
<hr>
<h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p><strong>构造方法：</strong></p>
<p><strong>DatagramPacket( byte[] buf, int offset, int length)</strong> ：构造一个DatagramPacket对象用于接受指定长度的数据报 包到缓冲区。</p>
<p>**DatagramPacket（ byte[] buf, int offset, int length, InetAddress address, int port)**：构造用于发送指定长度的数据报包 到指定主机的指定端口号上。</p>
<p><strong>常用方法：</strong></p>
<p><strong>byte[] getData()</strong> ：返回数据报包中的数据。</p>
<p>**InetAddress getAddress()**：返回该数据报发送或接收数据报的计算机的IP地址。</p>
<p>**int getLength()**：返回要发送的数据的长度或接收到的数据的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        String msg=<span class="string">&quot;你好，很高兴认识你！&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">        <span class="comment">//2、创建一个包（要发送给谁）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inet,<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//3、发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket，开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//2、创建一个包接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        <span class="comment">//3、接收数据</span></span><br><span class="line">        socket.receive(packet);<span class="comment">//阻塞式接收</span></span><br><span class="line">        <span class="comment">//将数据包转换为字符串输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>如果是TCP中先启动客户端会报错；而UDP中先启动发送方不会报错，但会正常退出；</strong></p>
<p>案例：在线咨询功能，学生和老师一对一交流（多线程）</p>
<p>发送方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//创建一个流 用于录入键盘的数据</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//发送数据目的地的IP</span></span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="comment">//发送数据目的地的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPSender</span><span class="params">(String toIP, <span class="type">int</span> toPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toIP = toIP;</span><br><span class="line">        <span class="built_in">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        bfr = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));<span class="comment">//从键盘录入数据到流中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环发送数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bfr.readLine();<span class="comment">//从流中读取数据</span></span><br><span class="line">                <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(toIP);</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length, inet, toPort);</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                <span class="comment">//如果发送了拜拜，则退出发送</span></span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bfr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bfr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//接收方自己所在的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromPort;</span><br><span class="line">    <span class="comment">//数据发送者的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPReceiver</span><span class="params">(<span class="type">int</span> fromPort, String msgFrom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromPort = fromPort;</span><br><span class="line">        <span class="built_in">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(fromPort);<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                socket.receive(packet);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(msgFrom + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;<span class="comment">//如果接收到的数据为拜拜，则退出接收</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">7777</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老师线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">8888</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>位于java.net包下</p>
<p><strong>构造方法：</strong><br>**URL(String spec)**：根据 String 表示形式创建 URL 对象。<br><strong>URL(String protocol, String host, int port, String file)</strong> ：根据指定协议名、主机名、端口号和文件名创建 URL 对象。<br>**URL(String protocol, String host, String file)**： 根据指定的协议名、主机名和文件名创建 URL。</p>
<p><strong>常用方法：</strong></p>
<p>**String getProtocol()**：获取此 URL的协议名称。</p>
<p><strong>String getHost()</strong> ：获取此 URL 的主机名。</p>
<p><strong>int getPort()</strong> ：获取此 URL 的端口号。</p>
<p><strong>String getPath()</strong> ：获取此 URL 的文件路径。</p>
<p>**String getFile()**：获取此 URL 的文件名。</p>
<p>**String getQuery()**：获取此 URL的查询部分。</p>
<p><strong>URLConnection openConnection()</strong> ：返回一个URLConnection实例，表示与URL引用的远程对象的URL </p>
<ul>
<li>URLConnection类中又有一个方法：<br><strong>InputStream getInputStream()</strong> ：返回从此打开的连接读取的输入流。</li>
</ul>
<p>演示案例：URL下载网络资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//下载地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://img.t.sinajs.cn/t6/style/images/global_nav/WB_logo.png?id=1404211047727&quot;</span>);</span><br><span class="line">        <span class="comment">//连接到这个资源 HTTP</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;weibo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        urlConnection.disconnect();<span class="comment">//断开连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到一张图片：微博t</span></span><br></pre></td></tr></table></figure>





<p>a</p>
<table>
<thead>
<tr>
<th>x</th>
<th>f1(x)</th>
<th>f2(x)</th>
<th>f3(x)</th>
<th>f4(x)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>0</td>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>5</td>
<td>10</td>
<td>21</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>10</td>
<td>30</td>
<td>22</td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>30</td>
<td>32</td>
<td>23</td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>20</td>
<td>40</td>
<td>24</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>x</th>
<th>F1(x)</th>
<th>F2(x)</th>
<th>F3(x)</th>
<th>F4(x)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>31</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>16</td>
<td>30</td>
<td>33</td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>21</td>
<td>41</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>26</td>
<td>43</td>
<td>61</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//n为项目</span></span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; maxMomey; j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> maxMomey - j;</span><br><span class="line">        temp = F[j][i - <span class="number">1</span>] + f[k][i] </span><br><span class="line">        F[j][i] = max&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote>
<p><strong>java程序有三个阶段：</strong></p>
<ul>
<li>代码阶段&#x2F;编译阶段</li>
<li><strong>Class类阶段（加载阶段）：当new一个对象时（类实例化），会在堆里加载一个Class类，里面存放类的成员变量，构造器，成员方法</strong>(通过类加载器ClassLoader从.class字节码文件中加载数据，体现了反射)；会<strong>在方法区生成该类的字节码二进制数据&#x2F;元数据</strong>；</li>
<li>运行阶段</li>
</ul>
</blockquote>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul>
<li>反射机制允许程序在<strong>运行期</strong>借助Reflection API 取得<strong>任何类的内部信息</strong>（比如成员变量，构造器，成员方法等），并<strong>能操作对象的属性及方法</strong>，反射在设计模式和框架底层都会用到；</li>
<li>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，反射可以通过这个对象得到类的结构。</li>
<li>功能：<ul>
<li>在运行时<strong>判断</strong>任意一个<strong>对象所属的类</strong>；</li>
<li>在运行时<strong>构造</strong>任意一个<strong>类的对象</strong>；</li>
<li>在运行时<strong>得到</strong>任意一个<strong>类所具有的成员变量和方法</strong>；</li>
<li>在运行时<strong>调用</strong>任意一个<strong>对象的成员变量和方法</strong>；</li>
<li>生成<strong>动态代理</strong>；</li>
</ul>
</li>
</ul>
<hr>
<h4 id="反射的主要类"><a href="#反射的主要类" class="headerlink" title="反射的主要类"></a>反射的主要类</h4><p>java.lang.<strong>Class</strong>：代表一个<strong>类</strong>，Class对象表示某个类加载在堆中的对象；</p>
<p>java.lang.<strong>reflect.Method</strong>：代表类的<strong>方法</strong>，Method对象表示某个类的方法；</p>
<p>java.lang.<strong>reflect.field</strong>：代表类的成员<strong>变量</strong>，Field对象表示某个类的成员变量；</p>
<p>java.lang.<strong>reflect.Constructor</strong>：代表类的<strong>构造方法</strong>，Constructor对象表示构造器；</p>
<hr>
<p>反射优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活。</p>
<p>反射缺点：使用反射基本是解释执行，对执行速度又影响；</p>
<p>反射调用优化：Method和Field，Constructor对象都有setAccessible方法； 使用setAccessible（true）可以金庸访问安全检查的开关；</p>
<hr>
<p>使用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//2. 使用反射机制解决</span></span><br><span class="line">        <span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line">        <span class="comment">//(3) 通过 cls 得到你加载的类的&quot;methodName&quot;的方法对象</span></span><br><span class="line">        <span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">        method1.invoke(o); <span class="comment">//传统方法: 对象.方法() ; 反射机制: 方法.invoke(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量</span></span><br><span class="line">        <span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(nameField.get(o)); <span class="comment">// 传统写法: 对象.成员变量 , 反射: 成员变量对象.get(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象 表示构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getConstructor(); <span class="comment">//()中可以指定构造器参数类型, 返回无参构造器</span></span><br><span class="line">        System.out.println(constructor);   <span class="comment">//打印方法名，无参</span></span><br><span class="line">        Constructor&lt;?&gt; constructor2 = cls.getConstructor(String.class); <span class="comment">//这里传入的String.class就是String类的Class对象</span></span><br><span class="line">        System.out.println(constructor2);<span class="comment">// 打印方法名，有参 (String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol>
<li>Class类也继承Object类；</li>
<li>Class类对象不是new出来的，而是<strong>系统创建</strong>的；</li>
<li>对于每个类的Class类对象，在<strong>内存中只有一份</strong>，因为<strong>类只加载一次</strong>；</li>
<li>每个类的实例 都知道自己是由哪个Class实例生成的；</li>
<li>通过Class对象可以<strong>完整地得到一个类的完整结构;</strong></li>
<li>Class对象<strong>存放在堆中</strong>；</li>
<li>类的 字节码二进制数据&#x2F;元数据 是放在<strong>方法区</strong>的（包括类的方法代码，变量名，方法名，访问权限，返回值等）；</li>
</ol>
<h4 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h4><p>**static Class forName (String name)**：返回指定类名name的Class对象；</p>
<p><strong>Object newInstance( )</strong> ：调用缺省构造函数，返回该Class对象的一个实例；</p>
<p><strong>getName( )</strong> ：返回此Class对象所表示的实体（类，接口，数组类，基本类型等）名称；</p>
<p>**Class[] getInterfaces( )**：获取当前Class对象的接口；</p>
<p>**ClassLoader getClassLoader( )**：返回该类的类加载器；</p>
<p><strong>Class getSuperclass( )</strong> ：返回此Class所表示的试题的超类的Class；</p>
<p><strong>Constructor[] getConstructors( )</strong> ：返回一个包含某些Constructor对象的数组；</p>
<p>**Field[] getDeclaredFields( )**：返回Field对象的一个数组；</p>
<p><strong>Method getMethod( )</strong> ：返回一个Method对象，此对象的形参类型为paramType；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.leaning.Car&quot;</span>;</span><br><span class="line">       <span class="comment">//1 . 获取到 Car 类 对应的 Class 对象</span></span><br><span class="line">       Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">       <span class="comment">//2. 输出 cls</span></span><br><span class="line">       System.out.println(cls); <span class="comment">//显示 cls 对象, 是哪个类的 Class 对象 com.leaning.Car</span></span><br><span class="line">       System.out.println(cls.getClass());<span class="comment">//输出 cls 运行类型 java.lang.Class</span></span><br><span class="line">       <span class="comment">//3. 得到包名</span></span><br><span class="line">       System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">       <span class="comment">//4. 得到全类名</span></span><br><span class="line">       System.out.println(cls.getName());</span><br><span class="line">       <span class="comment">//5. 通过 cls 创建对象实例</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">       System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">       <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//得到属性的赋值：宝马</span></span><br><span class="line">       <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">       brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//奔驰</span></span><br><span class="line">       Field[] fields = cls.getFields();   <span class="comment">//得到所有的属性(字段)</span></span><br><span class="line">       <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">           System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName( ) 获取，如：**Class cls &#x3D; Class.forName(“java.lang.Cat”)**；</p>
<p>应用场景：<strong>多用于配置文件，读取类全路径，加载类</strong>；</p>
</li>
<li><p>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高；如：<strong>Class cls &#x3D; Cat.class</strong>；</p>
<p>应用场景：多用于<strong>参数传递</strong>，比如通过反射得到对应构造器对象；</p>
</li>
<li><p>前提：已知某个类的实例，调用该实例的getClass() 方法获取Class对象，如：<strong>Class cls &#x3D; 对象.getClass()</strong>; &#x2F;&#x2F;运行类型</p>
<p>应用场景：通过创建好的对象，获取Class对象；</p>
</li>
<li><p>先得到类加载器，再<strong>通过类加载器得到Class对象</strong>：</p>
<p>ClassLoader cl&#x3D;对象.getClass().getClassLoader()；</p>
<p>Class cls &#x3D; cl.loadClass(“类的全类名”)；</p>
</li>
<li><p>基本数据（int, char, boolean, float, double, byte, long, short）得到Class类对象：</p>
<p>Class cls &#x3D; <strong>基本数据类型.class</strong></p>
</li>
<li><p>基本数据类型对应的包装类，可以通过 .TYPE得到Class对象：Class cls &#x3D; <strong>包装类.type</strong></p>
</li>
</ol>
<hr>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><strong>静态加载</strong>：<strong>编译时加载相关的类</strong>，如果没有则报错，依赖性强；</p>
<p><strong>动态加载</strong>：<strong>运行时加载需要的类</strong>，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性；</p>
<hr>
<p><strong>类加载时机</strong>：</p>
<ul>
<li>当创建对象时（new）&#x2F;&#x2F;静态加载</li>
<li>当子类被加载时，父类也加载 &#x2F;&#x2F;静态加载</li>
<li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li>
<li>通过反射 &#x2F;&#x2F;动态加载</li>
</ul>
<hr>
<p><strong>类加载的三个阶段：</strong></p>
<p>Java源码 —(javac编译)—&gt; 字节码文件 —(java运行)—&gt; <strong>加载 –&gt; 连接（验证，准备，解析）–&gt; 初始化</strong></p>
<ul>
<li><p><strong>加载阶段</strong>：将类的字节码从不同的数据源（可能是Class文件，jar包，网络）转化为二进制字节流加载到内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成；</p>
</li>
<li><p><strong>连接阶段</strong>：将类的二进制数据合并到JRE中；</p>
<ul>
<li><p><strong>验证</strong>：</p>
<p>目的：是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。</p>
<p>包括：文件格式验证（是否以魔数oxcafebabe开头），元数据验证，字节码验证，符号引用验证；</p>
<p>可以考虑使用 -Xverify : none参数来关闭大部分的类验证措施，缩短虚拟机 类加载的时间；</p>
</li>
<li><p><strong>准备</strong>：</p>
<p>JVM会在该阶段对静态变量分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;	<span class="comment">//n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;	<span class="comment">//n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析</strong>：</p>
<p>到这里，才真正开始执行类中定义的Java程序代码，此阶段是执行 &lt; clinit &gt; ( ) 方法的过程；</p>
<p>&lt; clinit &gt; ( ) 方法 是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<strong>静态变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句，并进行合并；</p>
<p>虚拟机会保证一个类的&lt; clinit &gt; ( ) 方法在多线程环境中被正确地<strong>加锁、同步</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">	<span class="comment">//因为有同步机制，能保证某个类在内存中, 只有一份 Class 对象</span></span><br><span class="line">	<span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">		<span class="comment">//.... </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化阶段</strong>：JVM负责对类进行初始化，这里主要是指静态成员；</p>
</li>
</ul>
<h3 id="反射获取类结构信息"><a href="#反射获取类结构信息" class="headerlink" title="反射获取类结构信息"></a>反射获取类结构信息</h3><ul>
<li><p>java.lang.<strong>Class</strong>类</p>
<ol>
<li>getName：获取全类名</li>
<li>getSimpleName：获取简单类名</li>
<li>getFields：获取所有public修饰的属性，包括本类以及父类的</li>
<li>getDeclaredFields：获取本类中所有属性</li>
<li>getMethods：获取所有public修饰的方法，包括本类以及父类的</li>
<li>getDeclaredMethods：获取本类中所有方法</li>
<li>getConstructors：获取本类中所有public修饰的构造器</li>
<li>getDeclaredConstructors：获取本类中所有构造器</li>
<li>getPackage：以Package形式返回 包信息</li>
<li>getSuperClass：以Class形式返回父类信息</li>
<li>getInterfaces：以Class[] 形式返回接口信息</li>
<li>getAnnotations：以Annotation[] 形式返回注解信息</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Field</strong>类</p>
<ol>
<li><p>getModifiers：以int形式返回修饰符</p>
<p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p>
</li>
<li><p>getType：以Class形式返回 类型</p>
</li>
<li><p>getName：返回属性名</p>
</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Method</strong>类</p>
<ol>
<li><p>getModifiers：以int形式返回修饰符</p>
<p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p>
</li>
<li><p>getReturnType：以Class形式获取 返回类型</p>
</li>
<li><p>getParameterTypes：以Class[] 返回参数类型数组</p>
</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Constructor</strong>类</p>
<ol>
<li>getModifiers：以int形式返回修饰符</li>
<li>getName：返回构造器名（全名）</li>
<li>getParameterTypes：以Class[] 形式返回参数类型数组</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="comment">//第一组方法 API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//homework.OrangeJuice</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//OrangeJuice</span></span><br><span class="line">        <span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以 Package 形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//package homework</span></span><br><span class="line">        <span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);<span class="comment">//class homework.Drink</span></span><br><span class="line">        <span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第2，3，4组api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是 0 ， public 是 1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里只输出名</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">reflect</span> <span class="variable">reflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">reflect</span>();</span><br><span class="line">        reflect.api_01();</span><br><span class="line">        reflect.api_02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><p>方式一：调用类中的public修饰的无参构造器</p>
<p>方式二：调用类中的指定构造器</p>
<p>方式三：Class类相关方法：newInstance，getConstructor，getDecalaredConstructor</p>
<p>方式四：Constructor类相关方式：setAccessible，newInstance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 先获取到 User 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;leaning.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通过 public 的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3. 通过 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//3.2 创建实例，并传入实参</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hsp</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;屏平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;屏平 = &quot;</span> + hsp);</span><br><span class="line">        <span class="comment">//4. 通过非 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//4.1 得到 private 的构造器对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">        <span class="comment">//4.2 创建实例</span></span><br><span class="line">        <span class="comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2 = &quot;</span> + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">//User 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;灿灿灿&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;<span class="comment">//无参 public</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;<span class="comment">//public 的有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;<span class="comment">//private 有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="反射访问类中成员"><a href="#反射访问类中成员" class="headerlink" title="反射访问类中成员"></a>反射访问类中成员</h3><p><strong>访问属性：</strong></p>
<ol>
<li><p>根据属性名获取Field对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> class对象.getDeclaredField(属性名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>爆破：f.setAccessible (true);   &#x2F;&#x2F;f是Field</p>
</li>
<li><p>访问：</p>
<p>f.set(o值)； &#x2F;&#x2F;o表示对象</p>
<p>syso(f.get(o))；&#x2F;&#x2F;o表示对象</p>
<p>（如果是静态属性，则set和get中的参数o可以写成null）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;leaning.Student2&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student</span></span><br><span class="line">        System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line">        <span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">        System.out.println(o);<span class="comment">//</span></span><br><span class="line">        System.out.println(age.get(o));<span class="comment">//返回 age 属性的值</span></span><br><span class="line">        <span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//name.set(o, &quot;小郑&quot;);</span></span><br><span class="line">        name.set(<span class="literal">null</span>, <span class="string">&quot;小郑~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">        System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//获取属性值, 要求 name 是 static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问方法：</strong></p>
<ol>
<li><p>根据方法名和参数列表获取Method方法对象：Method m &#x3D; class.getDeclaredMethod(方法名，XX.class)；&#x2F;&#x2F;得到本类的所有方法</p>
</li>
<li><p>获取对象：Object o &#x3D; class.newInstance()；</p>
</li>
<li><p>爆破：m.setAccessible(true)；</p>
</li>
<li><p>访问：Object.returnValue &#x3D; m.invoke(o，实参列表)； &#x2F;&#x2F;o就是对象</p>
<p>（如果是静态方法，则invoke的参数o，可以写成null）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Boss 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;leaning.Boss&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用 public 的 hi 方法</span></span><br><span class="line">        <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">        <span class="comment">//3.1 得到 hi 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//3.2 调用</span></span><br><span class="line">        hi.invoke(o, <span class="string">&quot;调用了hi方法&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 调用 private static 方法</span></span><br><span class="line">        <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class);</span><br><span class="line">        <span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">        <span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null</span></span><br><span class="line">        System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line">        <span class="comment">//5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示一个返回的案例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal2</span> <span class="operator">=</span> m1.invoke(o);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal2 的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;<span class="comment">//静态方法</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;<span class="comment">//普通 public 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>（String能使用正则表达式，如</p>
<p>string.replaceAll(“aaa”, “AAA”);  	</p>
<p>string.matches(“1(38|39)\d{8}”)；（返回true或false） </p>
<p>String[] split &#x3D; string.split(“#|-|~|\\d+”); </p>
<p>（stirng都是指一个字符串）</p>
<p>)</p>
<h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String content;	<span class="comment">//目标串</span></span><br><span class="line">String regStr;	<span class="comment">//模式串</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);	<span class="comment">//创建模式对象，参数如果加上Pattern.CASE_INSENSITIVE,表示不区分大小写</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);	<span class="comment">//创建匹配器matcher，按照 正则表达式的规则 去匹配content字符串;</span></span><br></pre></td></tr></table></figure>

<p>正则表达式中的（）表示分组，第一个（）表示第一组..</p>
<p>底层：</p>
<ul>
<li><p>根据指定的表达式规则，定位到满足规则的子字符串；</p>
</li>
<li><p>找到后，将子字符串的开始索引值和结束索引值+1记录到 int[] groups;</p>
</li>
<li><p>同时记录oldLast的值为子字符串的结束索引值+1，即下一次执行find时，就从oldLast开始；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//源码</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (group &lt; <span class="number">0</span> || group &gt; groupCount())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;No group &quot;</span> + group);</span><br><span class="line">        <span class="keyword">if</span> ((groups[group * <span class="number">2</span>] == -<span class="number">1</span>) || (groups[group * <span class="number">2</span> + <span class="number">1</span>] == -<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> getSubSequence(groups[group * <span class="number">2</span>], groups[group * <span class="number">2</span> + <span class="number">1</span>]).toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//group(0)表示匹配到的子字符串</span></span><br><span class="line"><span class="comment">//group(1)表示匹配到的子字符串的第一组子串</span></span><br><span class="line"><span class="comment">//group(2)表示匹配的子字符串的第二组子串</span></span><br><span class="line"><span class="comment">//...但是分组的数不能越界，否则报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;第 1 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>指定字符字符重复0到多次</td>
<td>(abc)*</td>
<td>仅包含任意个abc字符串</td>
</tr>
<tr>
<td>+</td>
<td>指定字符重复1到多次</td>
<td>(abc)+</td>
<td>仅包含至少一个abc字符串</td>
</tr>
<tr>
<td>？</td>
<td>指定字符重复0或1次</td>
<td>abc？</td>
<td>ab或abc</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>由abcd中字母组成的任意长度为3的字符串</td>
</tr>
<tr>
<td>{n,}</td>
<td>指定至少n个匹配</td>
<td>[abcd]{3,}</td>
<td>由abcd中字母组成的任意长度不小于3的字符串</td>
</tr>
<tr>
<td>{n,m}</td>
<td>指定至少n个到m个之间的匹配</td>
<td>[abcd]{3,5}</td>
<td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td>
</tr>
</tbody></table>
<hr>
<h4 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h4><p>有选择性的匹配字符：|</p>
<p>|：匹配之前或之后的表达式</p>
<p>如：ab|cd ：匹配ab或cd</p>
<hr>
<h4 id="分组组合和方向应用符"><a href="#分组组合和方向应用符" class="headerlink" title="分组组合和方向应用符"></a>分组组合和方向应用符</h4><p>在表达式分组中:</p>
<p><strong>（表达式）</strong>：非命名捕获，编号为0的第一个捕获是整个表达式模式匹配的文本，其他捕获则根据括号顺序从1开始编号；</p>
<p>**(?&lt; name&gt;表达式)**：命名捕获，将匹配到的子字符串捕获到一个组名或编号name中。name不能包含任何标点符号，不能以数字开头，可以使用单引号代替&lt;&gt;</p>
<hr>
<p><strong>（?:表达式）</strong>：</p>
<p>非捕获匹配（即匹配但不存储）,例：“industr(?:y|ies)”效果与”industry|intdustries“相同，但更经济；</p>
<p><strong>（?&#x3D;表达式）</strong>：</p>
<p>是非捕获匹配 ，例：“Windows(?&#x3D;95|98|NT)”匹配“Windows 95”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”；</p>
<p><strong>（?!表达式）</strong>：</p>
<p>非捕获匹配，例：“Windows(?!95|98|NT)”匹配“Windows 3.1”中的“Windows”，但不匹配“Windows 98”中的“Windows”；</p>
<hr>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>对于已经有特殊的含义的字符，想要匹配这些字符，就需要加上转义符号：**\\**（java中使用两个\，其他语言使用一个\）；</p>
<p>需要用到转义符号的字符有： <strong>.  *  +  ( )  $  &#x2F; \  ?  [ ]  ^  { }</strong></p>
<hr>
<p><strong>字符匹配符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中任意一个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>不可接收的字符列表</td>
<td>[^abc]</td>
<td>除了a，b，c之外的任意一个字符，包括特殊符号</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意单个大写字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n外的任何字符</td>
<td>a..b</td>
<td>以a开头，b结尾，中间任意2个字符</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字字符，相当于[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含3个或4个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字字符，相当于[ ^ 0-9 ]</td>
<td>\\D(\\d)*</td>
<td>以单个非数字字符开头，后接任意个数字</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字，大小写字母，相当于[0-9a-zA-Z]</td>
<td>\\w{4}</td>
<td>长度为4的数字字母字符串</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字，大小写字母，相当于[ ^ 0-9a-zA-Z]</td>
<td>\\W+\\d{2}</td>
<td>以至少一个非数字字母字符开头，2个数字结尾</td>
</tr>
<tr>
<td>\\s</td>
<td>匹配任何空白字符（空格，制表符）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始字符</td>
<td>^[0-9]+[a-z]*</td>
<td>至少一个数字开头，后接任意小写字母</td>
</tr>
<tr>
<td>$</td>
<td>指定结束字符</td>
<td>^[0-9] [a-z]+$</td>
<td>以一个数字开头，后接至少一个小写字母结尾</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>can\\b</td>
<td>边界指空格或结束位置，如：can<strong>can</strong>  c<strong>can</strong></td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>can\\B</td>
<td>如：<strong>can</strong>can can</td>
</tr>
</tbody></table>
<hr>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>Pattern类，Matcher类，PatternSyntaxException</p>
<p>Pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建对象，应调用其公共静态方法，它接收一个正则表达式作为参数，返回一个Pattern对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure>

<p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法或获得一个Matcher对象；</p>
<p>PatternSyntaxException是一个非强制性异常类，它表示一个正则表达式模式中的语法错误；</p>
<hr>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>分组：</p>
<p>正则表达式中的 一个括号的部分可以看成是一个分组&#x2F;子表达式；</p>
<p>捕获：</p>
<p>分组匹配到的内容，会保存到以数字编号或显示命名的组里，方便后面引用；</p>
<p><strong>反向引用：</strong></p>
<p>圆括号（分组）的内容被捕获后，可以在这个括号后被使用；这种引用可以在内部使用，也可以在外部使用；</p>
<p>内部：<strong>\\分组号</strong></p>
<p>外部：**$分组号**</p>
<p>如：要匹配两个连续的相同数字： (\\d)\\1</p>
<p>​	要匹配五个连续的相同数字：(\\d)\\1{4}</p>
<p>​	要匹配个位与千位相同，十位与百位相同的数(5225,1551)：(\\d)(\\d)\\2\\1</p>
<p>程序案例：<strong>结巴去重</strong></p>
<p>把 类似 : “我….我要….学学学学….编程 java!”</p>
<p>通过正则表达式 修改成 “我要学编程 java” ；（即没有连续重复的字符）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;我....我要....学学学学....编程 java!&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 去掉所有的. </span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">      content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">//2. 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">      <span class="comment">// 思路</span></span><br><span class="line">      <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">      <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">      <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line">       pattern = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>);<span class="comment">//分组的捕获内容记录到$1</span></span><br><span class="line">       matcher = pattern.matcher(content);</span><br><span class="line">       <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">      <span class="comment">//使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">       content = matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure>

<p>简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 使用一条语句 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure>







<h3 id="元字符-详细说明"><a href="#元字符-详细说明" class="headerlink" title="元字符-详细说明"></a>元字符-详细说明</h3><table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</strong></td>
</tr>
<tr>
<td><strong>^</strong></td>
<td><strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></td>
</tr>
<tr>
<td><strong>$</strong></td>
<td><strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></td>
</tr>
<tr>
<td>*****</td>
<td><strong>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</strong></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td><strong>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</strong></td>
</tr>
<tr>
<td><strong>{*n*}</strong></td>
<td>*<strong>n*</strong> <strong>是非负整数。正好匹配 *n* 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</strong></td>
</tr>
<tr>
<td><strong>{*n*,}</strong></td>
<td>*<strong>n*</strong> <strong>是非负整数。至少匹配 *n* 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*“。</strong></td>
</tr>
<tr>
<td><strong>{*n*,*m*}</strong></td>
<td>*<strong>m*</strong> <strong>和 *n* 是非负整数，其中 *n* &lt;&#x3D; *m*。匹配至少 *n* 次，至多 *m* 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于  ‘o?’。注意：您不能将空格插入逗号和数字之间。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</strong></td>
</tr>
<tr>
<td><strong>.</strong></td>
<td><strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></td>
</tr>
<tr>
<td><strong>(*pattern*)</strong></td>
<td><strong>匹配 *pattern* 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</strong></td>
</tr>
<tr>
<td><strong>(?:*pattern*)</strong></td>
<td><strong>匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’  更经济的表达式。</strong></td>
</tr>
<tr>
<td><strong>(?&#x3D;*pattern*)</strong></td>
<td><strong>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows  2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><strong>(?!*pattern*)</strong></td>
<td><strong>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows  3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><em><strong>x*</strong></em><em>|*y*</em>*</td>
<td><strong>匹配 *x* 或 *y*。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></td>
</tr>
<tr>
<td><strong>[*xyz*]</strong></td>
<td><strong>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</strong></td>
</tr>
<tr>
<td><strong>[^*xyz*]</strong></td>
<td><strong>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</strong></td>
</tr>
<tr>
<td><strong>[*a-z*]</strong></td>
<td><strong>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</strong></td>
</tr>
<tr>
<td><strong>[^*a-z*]</strong></td>
<td><strong>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</strong></td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td><strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td><strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\c*x*</strong></td>
<td><strong>匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或  a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</strong></td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td><strong>数字字符匹配。等效于  [0-9]。</strong></td>
</tr>
<tr>
<td><strong>\D</strong></td>
<td><strong>非数字字符匹配。等效于  [^0-9]。</strong></td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td><strong>换页符匹配。等效于  \x0c 和 \cL。</strong></td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行符匹配。等效于  \x0a 和 \cJ。</strong></td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td><strong>匹配一个回车符。等效于  \x0d 和 \cM。</strong></td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td><strong>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td><strong>匹配任何非空白字符。与  [^ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>制表符匹配。与  \x09 和 \cI 等效。</strong></td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td><strong>垂直制表符匹配。与  \x0b 和 \cK 等效。</strong></td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td><strong>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\W</strong></td>
<td><strong>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\x*n*</strong></td>
<td><strong>匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</strong></td>
</tr>
<tr>
<td><strong>*num*</strong></td>
<td><strong>匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</strong></td>
</tr>
<tr>
<td><strong>*n*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。</strong></td>
</tr>
<tr>
<td><strong>*nm*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 *nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。</strong></td>
</tr>
<tr>
<td><strong>\nml</strong></td>
<td><strong>当 *n* 是八进制数  (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。</strong></td>
</tr>
<tr>
<td><strong>\u*n*</strong></td>
<td><strong>匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</strong></td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>采用一定的方法保证在整个软件系统中，<strong>对某个类，只能存在一个对象实例，且该类只提供一个取得其对象实例的方法</strong>。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><strong>构造器私有化，防止直接new；</strong></li>
<li><strong>在类的内部创建对象；</strong></li>
<li><strong>向外暴露一个静态的公共方法</strong></li>
</ul>
<p>饿汉式和懒汉式<strong>区别</strong>：</p>
<ol>
<li>创建时机不同，<strong>饿汉式是在类加载就创建了对象实例</strong>，而<strong>懒汉式是使用时才创建</strong>；</li>
<li><strong>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</strong>；</li>
<li><strong>饿汉式存在资源浪费问题</strong>，如果使用时一个对象实例都没使用，饿汉式创建的对象就浪费了；</li>
</ol>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了能在静态方法中返回这个对象，使用static</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;饿汉&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是一个引用，还没有创建对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Instance ins;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="comment">//若对象还未创建，才去创建，即第一次调用了这个方法，对象才会被创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">null</span>)&#123;</span><br><span class="line">            ins = <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>





<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>**equals（object o)**：指示其他对象是否与此对象相等</p>
<p><strong>finalize()</strong></p>
<p>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。</p>
<p>**getclass()**：返回此 <code>Object</code>的运行时类。 </p>
<p>**hashcode()**：返回对象的哈希码值</p>
<p>**toString()**：返回对象的字符串表示形式</p>
<p>**clone()**：创建并返回此对象的一个副本</p>
<p><strong>notify()</strong></p>
<p><strong>notifyAll()</strong></p>
<p><strong>wait()</strong></p>
<hr>
<p><strong>&#x3D;&#x3D;与equals的对比</strong>：</p>
<p>&#x3D;&#x3D;是一个比较运算符</p>
<ul>
<li><strong>&#x3D;&#x3D; 判断基本类型时，判断值是否相等</strong></li>
<li><strong>&#x3D;&#x3D; 判断引用类型时，判断地址是否相等</strong>，即是不是同一个对象</li>
</ul>
<p><strong>equals</strong>是Objects类中的方法，<strong>只能判断引用类型，默认判断地址是否相等</strong>，不过其<strong>子类往往重写该方法，用于判断内容是否相等</strong>，如Integer, String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((integer)obj).intValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>hashcode方法</strong></p>
<ol>
<li>提高具有哈希结构的容器的效率；</li>
<li>两个引用，如果指向同一个对象，则哈希值肯定是一样的；</li>
<li>两个引用，如果指向不同的对象，则哈希值不一样；</li>
<li>哈希值主要根据地址号 计算得来的，不能完全将哈希值等价与地址</li>
</ol>
<p>重写hahscode：</p>
<hr>
<p><strong>toString方法</strong></p>
<p>Object的toString方法默认返回：全类名 + @ + 哈希值的十六进制；子类往往重写toString方法，用于返回对象的属性信息；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>finalize方法</strong></p>
<ul>
<li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法；</p>
</li>
<li><p>垃圾回收机制的调用，是由系统来决定 ( 即有自己的 GC 算法 ) ，也可以通过 System.gc() 主动触发垃圾回收机制</p>
<p>（实际开发中，几乎不会用到finalize）</p>
</li>
</ul>
<hr>
<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p><strong>reverse（List）</strong>：反转List中元素的顺序；</p>
<p><strong>shuffle（List</strong>）：对List中元素进行随机排序；</p>
<p><strong>swap（List， int ，int）</strong>：交换List中两个元素的位置</p>
<p>Object max（Collection）：返回给定集合中最大元素</p>
<p><strong>Object max（Collection，Comparator）</strong>：根据Comparator指定的顺序，返回最大元素；</p>
<p>min跟max一样</p>
<p><strong>int frequency（Collection， Object）</strong>：返回指定集合中指定元素的出现次数</p>
<p><strong>void copy（List dest，List src）</strong>：将src复制到dest中</p>
<p><strong>boolean replaceAll（List list，Object oldVal，Object newVal）</strong>：使用新值，替换掉List中所有旧值</p>
<hr>
<p><strong>sort（）：</strong></p>
<p>Map, Set, List等集合中，都提供了一个排序方法：**sort()**，不过要保证集合中的对象是可比较的；</p>
<p>让对象是 可比较的， 可以让对象实现 <strong>Comparable&lt; T&gt;接口</strong>，然后重写里面的**compareTo()**方法，</p>
<p><strong>compareTo（Object o）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">	<span class="comment">//降序</span></span><br><span class="line">	<span class="comment">//return o.age - this.age;</span></span><br><span class="line">	<span class="comment">//升序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>负整数</td>
<td>当前对象的值 <strong>&lt;</strong> 比较对象的值 ， 位置排在前</td>
</tr>
<tr>
<td>零</td>
<td>当前对象的值 <strong>&#x3D;</strong> 比较对象的值 ， 位置不变</td>
</tr>
<tr>
<td>正整数</td>
<td>当前对象的值 <strong>&gt;</strong> 比较对象的值 ， 位置排在后</td>
</tr>
</tbody></table>
<p><strong>比较器的使用：</strong></p>
<p>(例题可看 笔记（数据结构 ) —堆 692.前k个高频词)</p>
<p>想要排序集合中的其他元素，可以使用Comparator :</p>
<ul>
<li>Collertions.sort ( list , Comparator&lt; T&gt; ) ;</li>
<li>list.sort ( Comparator&lt; T&gt;) ;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序1</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序2</span></span><br><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> hh.nextInt();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.next  -&gt;  输入字符串</span></span><br><span class="line"><span class="comment">//.nextDouble  -&gt;  输入双精度浮点数</span></span><br><span class="line"><span class="comment">//其他类型 输入样式 相似</span></span><br></pre></td></tr></table></figure>

<p>当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。</p>
<p>如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">string</span> <span class="variable">line</span> <span class="operator">=</span>  s.nextLine;</span><br></pre></td></tr></table></figure>

<p>Scanner类主要提供了两个方法来扫描输入：</p>
<p>1）**hasNextXx()**：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。</p>
<p>2）**nextXxx()**：获取下一个输入项。Xxx的含义同上。</p>
<p>默认情况下，Scanner使用空白（包括空格、Tab空白和回车）作为多个输入项的分隔符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="comment">//System.in代表键盘输入</span></span><br><span class="line">	<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//使用回车作为分隔符</span></span><br><span class="line">    sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>String 类是<strong>被 final 修饰的，即 String 类不能被继承</strong>。</p>
<p>其中有一个很重要的数组，char 数组，用来保存字符串的，既然是用 final 关键字来修饰的，那就代表 <strong>String 是不可变的</strong>（不能指向新地址，但char[]里面的单个字符可改）</p>
<p>在源代码中，substring，replace 最后都是通过 new String(xxx) 来产生了一个新的 String 对象，最原始的字符串并没有改变。</p>
<p>（String实现了serializable接口，说明可以串行化（可以在网络上传输），实现了comparable接口，说明String对象可以比较；）</p>
<p>而<strong>StringBuilder</strong>中的字符可变</p>
<p>比如使用append方法，返回的依然是 StringBuffer 对象本身，说明他确实是值改变了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法实际调用的是 StringBuilder 的父方法。该父方法，会先检测容量够不够，不够的话会进行扩容，然后调用 String 的 getChars 方法。注意，最后返回的依旧是 StringBuffer 对象</p>
<p><strong>关于字符串相加：</strong><br>使用“+”对两个字符串相加的过程：</p>
<p>String 对象的操作符“+”其实被赋予了特殊的含义，该操作符是 Java 中仅有的两个重载过的操作符。</p>
<p>String 对象在进行“+”操作的时候，其实是调用了StringBuilder 对象的 append() 方法来加以构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;	<span class="comment">//a1指向常量区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//也指向常量区</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> b + c;	<span class="comment">//指向堆中的String对象</span></span><br><span class="line"><span class="comment">//a1 == a</span></span><br><span class="line"><span class="comment">//a != d</span></span><br><span class="line"><span class="comment">//a1 != d</span></span><br></pre></td></tr></table></figure>

<p>看 String a，“hello” + “world” 在 String 编译期间进行优化，优化结果为 “helloworld”，而该值在常量池中已经存有一份，因此 a 也指向了该常量池中的字符串，因此 a1 和 a 相等;</p>
<p>在对 b 和 c 进行相加的过程中：1. xia你创建StringBuilder sb &#x3D; StringBuilder()；2. 执行sb.append(“hello”);  再执行一次sb.append(“world”)； 3. String d &#x3D; sb.toString();</p>
<p>很明显 d 对象指向的是堆中的 String 对象，而 a1 则指向的是常量池中的字符串，两者引用明显不同，</p>
<p><strong>小结：String s &#x3D; “ab” + “cd”：常量相加，看的是池；String s &#x3D; a + b :  变量相加，是在堆中</strong></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707042.png" alt="image-20211002201859440"></p>
<hr>
<p><strong>创建</strong>的两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="comment">//一，先从常量池查看是否有“ssss”数据空间，如果有，直接指向；没有则重新创建，然后指向。s最终指向的是常量池的空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line"><span class="comment">//二，先在堆中创建空间，里面维护了value属性，指向常量池的“ssss”空间。如果常量池没有，重新创建，有的话则直接通过value指向。s最终指向的是堆中的空间地址。</span></span><br></pre></td></tr></table></figure>

<p>构造器 参数列表有多种：(String s)， (char[] a ), (char[] a, int startIndex, int count), (byte[] b) ….</p>
<p>int **indexOf(int ch) : ** <strong>lastIndexOf(int ch) :</strong></p>
<p>返回指定字符第一次(最后一次)出现处的索引</p>
<p>int **indexOf(String str) ** <strong>&#x2F; lastIndexOf(String str)</strong></p>
<p>返回指定 子字符串 第一次出现处的索引</p>
<p>char <strong>cahrAt(int index) :</strong></p>
<p>返回index’位置上的字符</p>
<p><strong>concat( String s) :</strong>  拼接字符串</p>
<p>boolean <strong>endsWith(String suffix) :</strong></p>
<p>判断此字符串是否以指定的字符串结尾</p>
<p>boolean <strong>startsWith(String prefix) :</strong></p>
<p>判断此字符串是否以指定的字符串开始</p>
<p>int <strong>length() :</strong>  返回此字符串的长度</p>
<p>boolean <strong>equals (Object anObject) :</strong></p>
<p>将此字符串与指定的字符串比较</p>
<p><strong>equaIsIgnoreCase</strong> :忽略大小写的判断内容相等</p>
<p>boolean <strong>isEmpty() :</strong></p>
<p>此字符串长度为0时返回true</p>
<p>boolean <strong>contains(CharSequence cs) :</strong></p>
<p>判断是否包含指定的字符序列</p>
<p>String <strong>toLowerCase() :</strong></p>
<p>将String中的所有字符都转换为小写（使用默认语言环境的规则）</p>
<p>String <strong>toUpperCase() :</strong></p>
<p>将String中的所有字符都转换为大写</p>
<p>static <strong>String valueOf(int i) :</strong></p>
<p>返回int参数的字符串表示形式</p>
<p>char[] <strong>toCharArray() :</strong></p>
<p>将此字符串转换为一个字符数组</p>
<p>String <strong>replace(CharSequence oldstr, CharSequence newstr) :</strong></p>
<p>返回新的字符串，用newstr替换所有的oldstr</p>
<p>String[] <strong>split(String regex) :</strong></p>
<p>根据参数regex（regex是一个正则表达式，用于限定分隔规则）将此字符串分割为若干个字符串</p>
<p>String <strong>substring(itn beginIndex) :</strong> </p>
<p>返回一个新字符串，从指定的beginIndex开始，直至末尾</p>
<p>String <strong>substring(itn beginIndex， int endIndex) :</strong> </p>
<p>返回一个新字符串，从指定的beginIndex到endIndex - 1</p>
<p>String <strong>trim() :</strong></p>
<p>返回一个新字符串，它去除了原字符串 首尾的空格</p>
<p><strong>format（String s, …）</strong>：格式化字符串，%s 字符串，%c 字符 … </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(s, ....);</span><br><span class="line"><span class="comment">//format的第一个参数是要格式化的字符串，后面是要替换s中占位符%的变量；</span></span><br><span class="line">system.out.println(<span class="string">&quot;s = &quot;</span> + info);</span><br></pre></td></tr></table></figure>

<p>Strng方法练习：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span> &#123;<span class="comment">//定义一个静态方法，获取变量的类型，通过类Main来调用它</span></span><br><span class="line">		<span class="keyword">return</span> o.getClass().getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice!&quot;</span>);<span class="comment">//这里全部使用String类的构造方法来初始化字符串对象</span></span><br><span class="line">		String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice&quot;</span>);</span><br><span class="line">		String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">		String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">		String s5=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		String s6=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot; abcd &quot;</span>);</span><br><span class="line">		String s7=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a123a123b456&quot;</span>);</span><br><span class="line">		<span class="type">char</span>[] str=s1.toCharArray();</span><br><span class="line">		<span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;↓↓↓String类的一些常用方法如下↓↓↓&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1的长度为：&quot;</span> + s1.length());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符&#x27;J&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&#x27;J&#x27;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;从指定的索引2开始搜索，返回字符串&#x27;a1&#x27;在字符串s7中第一次出现的索引：&quot;</span> + s7.indexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符&#x27;a&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;从指定的索引8开始反向搜索，返回字符串&#x27;a1&#x27;在字符串s7中最后一次出现的索引：&quot;</span>+s7.lastIndexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;获取字符串s1中第3个位置上的字符：&quot;</span> + s1.charAt(<span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串开始：&quot;</span> + s1.startsWith(<span class="string">&quot;我喜欢&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串结尾：&quot;</span> + s1.endsWith(<span class="string">&quot;nice&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.equals(s2));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.equalsIgnoreCase(s4));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.compareTo(s2));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.compareToIgnoreCase(s4));</span><br><span class="line">		<span class="comment">/*compareTo(String anotherString)方法将当前字符串与参数字符串进行比较，</span></span><br><span class="line"><span class="comment">		如果相同，则返回0。</span></span><br><span class="line"><span class="comment">		不相同时，从两个字符串第1个字符开始比较，返回第一个不相等的字符差，按照字典顺序</span></span><br><span class="line"><span class="comment">		另一种情况，某个字符串和其子串进行比较，返回它们的长度差。</span></span><br><span class="line"><span class="comment">		compareToIgnoreCase(str)与compareTo的区别是忽略了大小写*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s5的长度是否为0：&quot;</span> + s5.isEmpty());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1中是否包含指定的序列：&quot;</span> + s1.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s4连接到s3的结尾：&quot;</span> + s3.concat(s4));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s4的所有字符转为小写：&quot;</span> + s4.toLowerCase());</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s3的所有字符转为大写：&quot;</span> + s3.toUpperCase());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将int类型转为字符串，并获取a的变量类型：&quot;</span> + Main.getType(String.valueOf(a)));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;将字符串s1转为字符数组str：&quot;</span>);<span class="comment">//见代码第13行</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s2中的&#x27;Java&#x27;全部替换为&#x27;Python&#x27;：&quot;</span> + s2.replace(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;截取字符串s1从第3个位置开始到结尾：&quot;</span> + s1.substring(<span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;截取字符串s1从0个位置开始到第7个位置结尾：&quot;</span> + s1.substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;去掉字符串s6首尾的空格：&quot;</span> + s6.trim());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删；是一个final类，不能被继承；</p>
<p>很多方法与String相同，StringBuffer是一个容器；</p>
<p>StringBuffer中的char[] value<strong>没有加final</strong>，所以可以增删字符，且<strong>放在堆中</strong></p>
<hr>
<p><strong>String与StringBuffer的转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//一，使用构造器，返回的是StringBuffer对象，对s没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//二，使用append方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb2 =sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//使用StringBuffer的toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb3.toString();</span><br><span class="line"><span class="comment">//使用构造器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb3);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>StringBuffer方法</strong></p>
<p><strong>append( String s)</strong> ：末尾增添字符串</p>
<p><strong>delete( int start, int end)</strong> ：删，将start到end的内容删掉，不包括end</p>
<p><strong>replace( int start, int end, String s)</strong> ：改，将start到end的内容换掉，不包括end</p>
<p><strong>insert（int index， String s)</strong> ：插，在索引n处插入字符串，索引n后的内容自动后移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(s);	<span class="comment">//传入一个空的字符串，但这里没问题</span></span><br><span class="line"><span class="comment">//底层调用了父类的AbstractStingBuffer的appendNull方法，加入一个字符串“null”。</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//构造器传入空的字符串，会出现异常；因为底层调用的父类构造器传入的参数是字符串的长度+16，而字符串为空，显然会出现异常</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>StringBulider类</strong></p>
<p>StringBulider提供一个与 StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计作为StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。</p>
<p>StringBuilder类的方法和StringBuffer类的一样</p>
<hr>
<p><strong>String，StringBuffer，StringBuilder的比较</strong></p>
<ul>
<li>String：不可变字符序列，效率低，但复用率高</li>
<li>StringBuffer：可变序列，效率较高，线程安全</li>
<li>StringBuilder：可变序列，效率最高，线程不安全</li>
</ul>
<p>所以，如果字符串存在大量修改操作：在<strong>单线程时用StringBuilder</strong>，在<strong>多线程时用StringBuffer</strong>；如果字符串<strong>很少修改，且被多个对象引用，使用String</strong>。</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p><strong>数组转List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(arr).contains(<span class="number">3</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(array).contains(<span class="number">3</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的转换，拆开：</span></span><br><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; integers = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(array);</span><br><span class="line"><span class="comment">//区别:原始数据类型int的数组调用asList之后得到的List只有一个元素，这个元素就是元素类型的数组。而封装类Integer数组调用asList是把数组中每个元素加到了List中。</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.fill() ;填充数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">4</span>);<span class="comment">//给所有值赋值4</span></span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//给第2位（0开始）到第4位（不包括）赋值6</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.sort(); &#x2F;&#x2F;数组排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intArray);</span><br><span class="line"><span class="comment">//数字排序：从小到大；</span></span><br><span class="line"><span class="comment">//字符串排序：先大写后小写（ASCII码）</span></span><br><span class="line"></span><br><span class="line"> Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"><span class="comment">//严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"><span class="comment">//反向排序， Reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER); Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"><span class="comment">//忽略大小写反向排序 Case-insensitive reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//选择数组指定位置进行排序：给第0位（0开始）到第3位（不包括）排序</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)  &#x2F;&#x2F;自定义数组排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o1 - o2; <span class="comment">//返回&gt;0或&lt;0会影响排序结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Arrays.toString(); &#x2F;&#x2F;将数组中的内容全部打印出来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(arr);<span class="comment">//直接将数组打印输出</span></span><br><span class="line"><span class="comment">//输出：[I@7852e922 (数组的地址)</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部转为字符串输出</span></span><br><span class="line"><span class="comment">//System.out.print(str);</span></span><br><span class="line"><span class="comment">//输出：[3, 2, 1, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.toString(deepArray)); <span class="comment">//[[I@1540e19d, [I@677327b6]</span></span><br><span class="line">out.println(Arrays.deepToString(deepArray)); <span class="comment">//[[1, 3], [2, 4]]</span></span><br><span class="line"><span class="comment">//对于多维数组，需要使用deepToString</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.equals(); &#x2F;&#x2F;比较数组元素是否相等</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] deepArray2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.equals(deepArray1, deepArray2)); <span class="comment">//false</span></span><br><span class="line">out.println(Arrays.deepEquals(deepArray1, deepArray2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对多维数组，同样要用deepEquals</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.binarySearch(); &#x2F;&#x2F;二分查找法找指定元素的索引值（下标）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.binarySearch(arr, <span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （下标索引值从0开始）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">36</span>)</span><br><span class="line"><span class="comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">40</span>)</span><br><span class="line"><span class="comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.copeOf() 和Arrays.copeOfRange(); &#x2F;&#x2F;截取数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[10, 20, 30] （截取arr数组的3个元素赋值给新数组arr1）</span></span><br><span class="line"><span class="type">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span></span><br></pre></td></tr></table></figure>

<p> <strong>对数组元素采用指定的方法计算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelPrefix(array, (x,y)-&gt;(x+y)); <span class="comment">//[3, 13, 17, 17, 19]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelSetAll(array, (x)-&gt;(x*x)); <span class="comment">//[0, 1, 4, 9, 16]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">Arrays.setAll(array, (x)-&gt;(x%<span class="number">3</span>));</span><br><span class="line">out.println(Arrays.toString(array)); <span class="comment">//[0, 1, 2, 0, 1], 与parallelSetAll相比只是不并行</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义排序规则</strong></p>
<p><code>Arrays.sort</code>方法和<code>Collections.sort</code>方法都提供了一个可以接收<code>Comparator</code>实例作为第二个参数的版本。</p>
<p>像Comparator、Runable等这&#x3D;一些接口有一个特点就是只有一个抽象方法（其他的都是static或者default的方法），比如继承Comparator接口只需要重写compare方法，继承Runnable接口只需要重写run方法，这种类型的接口被称为函数式接口，可以被lambda表达式所代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line">Arrays.sort(names, comp);</span><br></pre></td></tr></table></figure>

<p>或者更简单些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>









<h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p><strong>add()</strong></p>
<p>将元素插入指定位置的动态数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.add（<span class="type">int</span> index，E element）</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure>

<p><strong>insert(itn index, object value)</strong></p>
<p>将元素插入到索引处(不过其有一定的限制性,必须在数组长度以内插入数组)</p>
<p><strong>addAll()</strong></p>
<p>将给定集合中的所有元素添加到 arraylist 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.addAll(<span class="type">int</span> index, Collection c)</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure>

<p><strong>clear()</strong></p>
<p>用于删除动态数组中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clear()</span><br></pre></td></tr></table></figure>

<p><strong>clone()</strong></p>
<p>用于拷贝一份动态数组，属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clone()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：sites为已设置好的数组，使用clone将其拷贝给clonesites;</span></span><br><span class="line">ArrayList&lt;String&gt; cloneSites = (ArrayList&lt;String&gt;)sites.clone();</span><br></pre></td></tr></table></figure>

<p><strong>拓展：</strong></p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存， 所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p>
<p>浅拷贝对应的就是深拷贝，深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p>
<p><strong>contains()</strong></p>
<p>判断元素是否在动态数组中。</p>
<p>存在于动态数组中，则返回 true。</p>
<p>不存在于动态数组中，则返回 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.contains(Object obj)</span><br></pre></td></tr></table></figure>

<p><strong>set()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.set(<span class="type">int</span> index,E element) ;</span><br><span class="line">修改指定索引处的元素，返回被修改的元素。</span><br></pre></td></tr></table></figure>

<p><strong>get()</strong></p>
<p>通过索引值获取动态数组中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.get(<span class="type">int</span> index)</span><br></pre></td></tr></table></figure>

<p><strong>indexOf()</strong></p>
<p><strong>remove()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arraylist.remove(<span class="type">int</span> index) ;</span><br><span class="line">移除此集合中指定位置上的元素。返回被删除的元素。</span><br><span class="line">arraylist.remove(Object o) ;</span><br><span class="line">删除指定的元素，返回删除是否成功    </span><br></pre></td></tr></table></figure>

<p><strong>size()</strong></p>
<p>返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p>
<p><strong>isEmpty()</strong></p>
<p><strong>subList()</strong></p>
<p><strong>sort()</strong></p>
<p><strong>toArray()</strong></p>
<p><strong>toString()</strong></p>
<p><strong>ensureCapacity()</strong></p>
<p><strong>lastIndexOf()</strong></p>
<p><strong>retainAll()</strong></p>
<p><strong>containAll()</strong></p>
<p><strong>trimToSize()</strong></p>
<p><strong>removeRange()</strong></p>
<p> <strong>replaceAll()</strong></p>
<p><strong>removeIf()</strong></p>
<p><strong>forEach()</strong></p>
<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p><strong>add(E e)</strong> 将指定元素添加到此列表的结尾。</p>
<p><strong>add(int index, E element)</strong> 在此列表中指定的位置插入指定的元素。</p>
<p><strong>get(int index)</strong> 返回此列表中指定位置处的元素。</p>
<p><strong>getFirst()</strong> 返回此列表的第一个元素。</p>
<p><strong>getLast</strong>() 返回此列表的最后一个元素。</p>
<p><strong>remove(int index)</strong> 移除此列表中指定位置处的元素。</p>
<p><strong>remove()</strong> 获取并移除此列表的头（第一个元素）。</p>
<p><strong>remove(Object o)</strong> 从此列表中移除首次出现的指定元素（如果存在）。</p>
<p><strong>size()</strong>   返回此列表的元素数。</p>
<p><strong>push(E e)：</strong>与addFirst一样，实际上它就是addFirst；</p>
<p><strong>pop()  :</strong> removeFirst一样，实际上它就是removeFirst；</p>
<p><strong>E poll()：</strong>查询并移除第一个元素；</p>
<p><strong>peek()  :</strong> 获取第一个元素，但是不移除；</p>
<p> <strong>offer(E e)：</strong>在链表尾部插入一个元素；</p>
<p><strong>isEmpty :</strong> 判空</p>
<p><strong>contains(Object o) ：</strong>是否包含</p>
<h3 id="Hashset类"><a href="#Hashset类" class="headerlink" title="Hashset类"></a>Hashset类</h3><h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p><strong>put(key, value) ：</strong>将键&#x2F;值 映射 存放到Map集合中（如果key重复，则会覆盖原先的value值）</p>
<p><strong>get(key) ：</strong>返回指定键 所映射的值，没有该key对应的值则返回null</p>
<p><strong>getOrDefault ( key, defaultvalue) :</strong> 当集合中有这个key时，就返回key对应的value，没有这个key的话，返回默认值；</p>
<p><strong>size( ) ：</strong>返回Map集合中的 key-value的组数</p>
<p><strong>clear( )：</strong>清空Map集合</p>
<p><strong>isEmpty( )：</strong>判空，集合中为空则返回true</p>
<p><strong>remove（key）：</strong>删除集合中键为key的数据，并返回对应的value值</p>
<p>getOrDefault( key, defaultValue) :  返回key对应的value值，如果没有该key值，就返回默认值defaultValue</p>
<p><strong>values（）：</strong>返回Map集合中所有value组成的以Collection数据类型格式数据（一般用于遍历HashMap集合中value值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">Collection&lt;Integer&gt; con = map.values();</span><br><span class="line"><span class="keyword">for</span> (Integer score : con) &#123;</span><br><span class="line">	System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>keyset（）：</strong>返回Map集合中所有key组成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key作为元素转存入一个set集合。</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历HashMap集合中的key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>entrySet（）：</strong> 将Map集合每个key-value转换为一个Entry对象，并返回由所有的Entry对象组成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每一组key-value变为一个entry对象存入set集合</span></span><br><span class="line">Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : set)&#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable定义了四个构造方法。第一个是默认构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable()</span><br></pre></td></tr></table></figure>

<p>第二个构造函数创建指定大小的哈希表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size)</span><br></pre></td></tr></table></figure>

<p>第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。</p>
<p>填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size,float fillRatio)</span><br></pre></td></tr></table></figure>

<p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表。</p>
<p>哈希表的容量被设置为M的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(Map m)</span><br></pre></td></tr></table></figure>



<p>Hashtable中除了从Map接口中定义的方法外，还定义了以下方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void clear( )</strong>  将此哈希表清空，使其不包含任何键。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>Object clone( )</strong> 创建此哈希表的浅表副本。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>boolean contains(Object value)</strong>  测试此映射表中是否存在与指定值关联的键。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>boolean containsKey(Object key)</strong> 测试指定对象是否为此哈希表中的键。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>boolean containsValue(Object value)</strong> 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>Enumeration elements( )</strong> 返回此哈希表中的值的枚举。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>Object get(Object key)</strong>  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>boolean isEmpty( )</strong> 测试此哈希表是否没有键映射到值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>Enumeration keys( )</strong>  返回此哈希表中的键的枚举。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>Object put(Object key, Object value)</strong> 将指定 key 映射到此哈希表中的指定 value。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>void rehash( )</strong> 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>Object remove(Object key)</strong> 从哈希表中移除该键及其相应的值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>int size( )</strong>  返回此哈希表中的键的数量。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>String toString( )</strong> 返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 “, “ （逗号加空格）分隔开的、括在括号中的一组条目。</td>
</tr>
</tbody></table>
<p>TreeMap类</p>
<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><p>Properties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个<strong>字符串</strong>。</p>
<p>这个类的优势是可以从流中加载属性集，或者把属性集报错到流中。</p>
<p>除了从 Hashtable 中所定义的方法，Properties 还定义了以下方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>String getProperty(String key)</strong>  用指定的键在此属性列表中搜索属性。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>String getProperty(String key, String defaultProperty)</strong> 用指定的键在属性列表中搜索属性。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void list(PrintStream streamOut)</strong>  将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void list(PrintWriter streamOut)</strong> 将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>void load(InputStream streamIn) throws IOException</strong>  从输入流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>Enumeration propertyNames( )</strong> 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>Object setProperty(String key, String value)</strong>  调用 Hashtable 的方法 put。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>void store(OutputStream streamOut, String description)</strong>  以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</td>
</tr>
</tbody></table>
<h3 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h3><p>Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h3><h5 id="xxxValue"><a href="#xxxValue" class="headerlink" title="xxxValue()"></a>xxxValue()</h5><p>以xxx类型返回指定的数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxValue()	</span><br><span class="line">byteValue()  	<span class="comment">//以byte类型返回指定的数值</span></span><br><span class="line"><span class="comment">//有byte,double,float,int,long,short</span></span><br><span class="line"><span class="comment">//此函数不接受参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 返回 byte 原生数据类型</span></span><br><span class="line">      System.out.println( x.doubleValue() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：5.0</span><br></pre></td></tr></table></figure>

<h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h5><p>用于两个相同数据类型的比较；</p>
<p>两个不同类型的数据不能用此方法来比较。</p>
<ul>
<li>如果指定的数与参数<strong>相等返回0</strong>。</li>
<li>如果指定的数<strong>小于</strong>参数<strong>返回 -1</strong>。</li>
<li>如果指定的数<strong>大于</strong>参数<strong>返回 1</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(referenceName)</span></span><br><span class="line"><span class="comment">//referenceName -- 可以是一个 Byte, Double, Integer, Float, Long 或 Short 类型的参数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Interger</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		System.out.println(x.compareTo(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：1</span><br></pre></td></tr></table></figure>

<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>判断 Number 对象与方法的参数是否相等（类型和数值）</p>
<ul>
<li>如果Number 对象不为 Null，且与方法的参数类型与数值都相等返回 True，否则返回 False。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object x)</span> <span class="comment">//x为任何对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(x.equals(y));</span><br><span class="line">        System.out.println(x.equals(z));</span><br><span class="line">        System.out.println(x.equals(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回给定参数的原生 Number 对象值，</p>
<p>参数可以是原生数据类型，如String等。</p>
<p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的对象值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> Double.valueOf(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Float</span> <span class="variable">a</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;444&quot;</span>, <span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">80.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure>

<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>返回以一个字符串表示的 Number 对象值。</p>
<p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串参数作为有符号的十进制整数进行解析。</p>
<p>如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span>Integer.parseInt(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure>

<h3 id="Math数学类"><a href="#Math数学类" class="headerlink" title="Math数学类"></a>Math数学类</h3><p>在源文件顶部加上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>

<p>Math类</p>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h4><p>返回参数的<strong>绝对值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line">                        </span><br><span class="line">        System.out.println(Math.abs(a));</span><br><span class="line">        System.out.println(Math.abs(d));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure>

<h4 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h4><p>返回参数的算术平方根。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;sqrt(%.3f) 为 %.3f%n&quot;</span>, x, Math.sqrt(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt(<span class="number">11.635</span>) 为 <span class="number">3.411</span></span><br></pre></td></tr></table></figure>



<h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>返回一个最接近的int ,long型值，”<strong>四舍五入</strong>“，算法为**Math.floor(x+0.5)**；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        System.out.println(Math.round(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure>

<h4 id="min-和max"><a href="#min-和max" class="headerlink" title="min()和max()"></a>min()和max()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Math.min(<span class="number">12</span>,<span class="number">30</span>)); </span><br><span class="line">        System.out.println(Math.max(<span class="number">12</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h4 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h4><p>返回一个随机数，随机数范围为 0.0 &lt;&#x3D; x &lt; 1.0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println( Math.random() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5444085967267008</span><br></pre></td></tr></table></figure>

<h4 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h4><p>返回第一个参数的第二个参数次方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2.76</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;pow(%.3f, %.3f) 为 %.3f%n&quot;</span>, x, y, Math.pow(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(11.635, 2.760) 为 874.008</span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><p>返回自然数底数e的参数次方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;exp(%.3f) 为 %.3f%n&quot;</span>, x, Math.exp(x));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">exp(<span class="number">11.635</span>) 为 <span class="number">112983.831</span></span><br></pre></td></tr></table></figure>

<h4 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h4><p>返回参数的自然数底数的对数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;log(%.3f) 为 %.3f%n&quot;</span>, x, Math.log(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">log(<span class="number">11.635</span>) 为 <span class="number">2.454</span></span><br></pre></td></tr></table></figure>

<h4 id="rint"><a href="#rint" class="headerlink" title="rint()"></a>rint()</h4><p>返回最接近参数的整数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">100.500</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">100.200</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.rint(d));</span><br><span class="line">        System.out.println(Math.rint(e)); </span><br><span class="line">        System.out.println(Math.rint(f)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101.0</span><br><span class="line">100.0</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure>

<h4 id="floor-x2F-ceil"><a href="#floor-x2F-ceil" class="headerlink" title="floor()&#x2F;ceil()"></a>floor()&#x2F;ceil()</h4><p>floor()：对一个数进行下舍入，返回给定参数最大的整数，该整数小于或等给定的参数。</p>
<p>ceil()：对一个数进行上舍入，返回值大于或等于给定的参数，类型为双精度浮点型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> -<span class="number">90</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.floor(d));</span><br><span class="line">        System.out.println(Math.floor(f));</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.ceil(d));</span><br><span class="line">        System.out.println(Math.ceil(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><p><strong>枚举</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>boolean hasMoreElements( )</strong></th>
<th>测试此枚举是否包含更多的元素。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><strong>Object nextElement( )</strong></td>
<td>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td>
</tr>
</tbody></table>
<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：</p>
<ul>
<li>Vector 是同步访问的。</li>
<li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li>
</ul>
<p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p>
<p>Vector 类支持 <strong>4 种构造方法</strong>。</p>
<p>第一种构造方法创建一个默认的向量，默认大小为 10：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector()</span><br></pre></td></tr></table></figure>

<p>第二种构造方法创建指定大小的向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size)</span><br></pre></td></tr></table></figure>

<p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size,int incr)</span><br></pre></td></tr></table></figure>

<p>第四种构造方法创建一个包含集合 c 元素的向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(Collection c)</span><br></pre></td></tr></table></figure>



<p>Vector还拥有以下方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void add(int index, Object element)   在此向量的指定位置插入指定的元素。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">boolean add(Object o)   将指定元素添加到此向量的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">int capacity()  返回此向量的当前容量。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">void clear()  从此向量中移除所有元素。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Object clone()  返回向量的一个副本。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void copyInto(Object[] anArray)   将此向量的组件复制到指定的数组中。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">Object elementAt(int index)  返回指定索引处的组件。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">Enumeration elements()  返回此向量的组件的枚举。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">boolean equals(Object o)  比较指定对象与此向量的相等性。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">Object get(int index)  返回向量中指定位置的元素。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">int hashCode()  返回此向量的哈希码值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">boolean isEmpty()  测试此向量是否不包含组件。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">Object lastElement()  返回此向量的最后一个组件。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">Object remove(int index)   移除此向量中指定位置的元素。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">void removeElementAt(int index)  删除指定索引处的组件。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left">Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left">void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left">void setSize(int newSize)   设置此向量的大小。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left">int size()   返回此向量中的组件数。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left">List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left">Object[] toArray(Object[] a)  返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left">String toString()  返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left">void trimToSize()   对此向量的容量进行微调，使其等于向量的当前大小。</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// initial size is 3, increment is 2</span></span><br><span class="line">      <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial size: &quot;</span> + v.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Capacity after four additions: &quot;</span> +</span><br><span class="line">          v.capacity());</span><br><span class="line"></span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">5.45</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">6.08</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">7</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">9.4</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First element: &quot;</span> +</span><br><span class="line">         (Integer)v.firstElement());</span><br><span class="line">      System.out.println(<span class="string">&quot;Last element: &quot;</span> +</span><br><span class="line">         (Integer)v.lastElement());</span><br><span class="line">      <span class="keyword">if</span>(v.contains(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)))</span><br><span class="line">         System.out.println(<span class="string">&quot;Vector contains 3.&quot;</span>);</span><br><span class="line">      <span class="comment">// enumerate the elements in the vector.</span></span><br><span class="line">      <span class="type">Enumeration</span> <span class="variable">vEnum</span> <span class="operator">=</span> v.elements();</span><br><span class="line">      System.out.println(<span class="string">&quot;\nElements in vector:&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(vEnum.hasMoreElements())</span><br><span class="line">         System.out.print(vEnum.nextElement() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial size: <span class="number">0</span></span><br><span class="line">Initial capacity: <span class="number">3</span></span><br><span class="line">Capacity after four additions: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">7</span></span><br><span class="line">Current capacity: <span class="number">9</span></span><br><span class="line">First element: <span class="number">1</span></span><br><span class="line">Last element: <span class="number">12</span></span><br><span class="line">Vector contains <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Elements in vector:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5.45</span> <span class="number">6.08</span> <span class="number">7</span> <span class="number">9.4</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>









<h3 id="Bitset类"><a href="#Bitset类" class="headerlink" title="Bitset类"></a>Bitset类</h3><p>Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。</p>
<p>BitSet定义了两个构造方法。</p>
<p>第一个构造方法创建一个默认的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet()</span><br></pre></td></tr></table></figure>

<p>第二个方法允许用户指定初始大小。所有位初始化为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet(int size)</span><br></pre></td></tr></table></figure>





<p>BitSet中实现了Cloneable接口中定义的方法如下表所列：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void and(BitSet set) 对此目标位 set 和参数位 set 执行逻辑与操作。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">void andNot(BitSet set) 清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">int cardinality( ) 返回此 BitSet 中设置为 true 的位数。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">void clear( ) 将此 BitSet 中的所有位设置为 false。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">void clear(int index) 将索引指定处的位设置为 false。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">void clear(int startIndex, int endIndex) 将指定的 startIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Object clone( ) 复制此 BitSet，生成一个与之相等的新 BitSet。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">boolean equals(Object bitSet) 将此对象与指定的对象进行比较。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">void flip(int index) 将指定索引处的位设置为其当前值的补码。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">void flip(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">boolean get(int index) 返回指定索引处的位值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">BitSet get(int startIndex, int endIndex) 返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">int hashCode( ) 返回此位 set 的哈希码值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">boolean intersects(BitSet bitSet) 如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">boolean isEmpty( ) 如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">int length( ) 返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">int nextClearBit(int startIndex) 返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">int nextSetBit(int startIndex) 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">void or(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑或操作。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">void set(int index) 将指定索引处的位设置为 true。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">void set(int index, boolean v)  将指定索引处的位设置为指定的值。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">void set(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">void set(int startIndex, int endIndex, boolean v) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">int size( ) 返回此 BitSet 表示位值时实际使用空间的位数。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">String toString( ) 返回此位 set 的字符串表示形式。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">void xor(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑异或操作。</td>
</tr>
</tbody></table>
<h3 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map 接口中键和值一一映射. 可以通过键来获取值。</p>
<ul>
<li>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li>
<li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li>
<li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li>
<li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void clear( )  从此映射中移除所有映射关系（可选操作）。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">int hashCode( ) 返回此映射的哈希码值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Set keySet( ) 返回此映射中包含的键的 Set 视图。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">int size( ) 返回此映射中的键-值映射关系数。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">Collection values( ) 返回此映射中包含的值的 Collection 视图。</td>
</tr>
</tbody></table>
<h3 id="system类"><a href="#system类" class="headerlink" title="system类"></a>system类</h3><p><strong>exit  退出当前程序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">//表示程序退出，0表示一个正常的状态</span></span><br></pre></td></tr></table></figure>

<p><strong>arraycopy ：复制数组元素</strong>，比较适合底层调用，一般使用Arrays.copyOf 完成复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line"><span class="comment">//src: 源数组</span></span><br><span class="line"><span class="comment">//srcPos: 从源数组的哪个索引开始拷贝</span></span><br><span class="line"><span class="comment">//dest: 目标数组</span></span><br><span class="line"><span class="comment">//destPos：源数组的数据拷贝到目标数组的哪个索引处</span></span><br><span class="line"><span class="comment">//length： 从源数组拷贝多少数据</span></span><br></pre></td></tr></table></figure>

<p><strong>currentTimeMillens ： 返回当前时间距离1970-1-1的毫秒数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillens();</span><br></pre></td></tr></table></figure>

<p><strong>gc：运行垃圾回收机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure>





<h3 id="大数类型"><a href="#大数类型" class="headerlink" title="大数类型"></a>大数类型</h3><p><strong>BigInteger类：适合保存比较大的整型</strong></p>
<p><strong>BigDecimal类：适合保存进度更高的浮点型（小数）</strong></p>
<p>方法（算术）：</p>
<p>add  加</p>
<p>subtract   减</p>
<p>multiply    乘</p>
<p>divide    除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigInter.add(bigInteger2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigInter.subtract(bigInteger2);	 <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigInter.multiply(bigInteger2);	 <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigInter.divide(bigInteger2);	 <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100.11&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigDecimal.add(bigDecimal2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigDecimal.subtract(bigDecimal2);	 <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigDecimal.multiply(bigDecimal2);	 <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING);	 <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"><span class="comment">//因为除法可能会出现除不尽的情况，所以调用divide方法时，可以指定精度（在参数列表加上BigDecimal.ROUND_CEILING，如果出现无限循环小数，就会保留分子的进度）</span></span><br></pre></td></tr></table></figure>







<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>第三代日期类（jdk8加入）</p>
<p>LocalDate（日期&#x2F;年月日）</p>
<p>LocalTime（时间&#x2F;时分秒）</p>
<p>LocalDateTime（时间&#x2F;年月日时分秒）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"><span class="comment">//输出：2021-10-03T16:20:05.137</span></span><br></pre></td></tr></table></figure>

<p>使用DateTimeFormatter对象来进行格式化（ofPattern方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期 = &quot;</span> + format);</span><br><span class="line"><span class="comment">//输出：格式化的日期 = 2021-10-03 16:22:05</span></span><br></pre></td></tr></table></figure>

<p>日期类还有plus增加时间的某个部分，minus查看一年前和一年后的日期 …等等（具体看API文档）</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/Java%E5%AD%A6%E4%B9%A0/" data-id="cl1ynefly0003swtud1qn83xz" data-title="java" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Java框架&amp;技术" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/Java%E6%A1%86%E6%9E%B6&%E6%8A%80%E6%9C%AF/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.213Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/Java%E6%A1%86%E6%9E%B6&%E6%8A%80%E6%9C%AF/">java框架&amp;技术</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Manven"><a href="#Manven" class="headerlink" title="Manven"></a>Manven</h2><p>Maven 是专门用于<strong>管理和构建java项目的工具</strong>，它的主要功能有：</p>
<ul>
<li><p>提供了一套标准化的项目结构；</p>
</li>
<li><p>提供了一套标准化的构建流程 (编译，测试，打包，发布…)；</p>
</li>
<li><p>提供了一套依赖管理机制（指jar包，插件）；</p>
</li>
</ul>
<h4 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h4><blockquote>
<p>jar包查找顺序：本地仓库——远程仓库——中央仓库</p>
<p>远程仓库（私服）：一般由公司团队搭建的私有仓库。</p>
</blockquote>
<p>使用坐标导入jar包：</p>
<ol>
<li>在 pom.xml 中编写 &lt; dependencies &gt; 标签；</li>
<li>在&lt; dependencies &gt;标签中使用&lt; dependency &gt;引入坐标；</li>
<li>定义坐标的 groupld, artifactld, version；</li>
</ol>
<p><u>资源直接网上搜索：资源名 maven，如 mysql maven，然后会出现maven repository的网页，点进去复制坐标即可。</u></p>
<blockquote>
<p>Maven坐标：是资源的唯一标识，使用坐标来定义项目或引入项目中需要的依赖。</p>
<p>坐标组成：</p>
<ul>
<li>groupld：定义当前Maven项目隶属组织的名称（通常是域名反写，如：com.itheima）</li>
<li>artifactld：定义当前Maven项目名称（通常是模块名称，如：order-service，goods-service）</li>
<li>version：定义当前项目的版本号</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.46<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h4><p>通过设置坐标的依赖范围(scope),可以设置对应ja包的作用范围：编译环境、测试环境、运行环境</p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707938.png" alt="image-20220224164841772"></p>
<table>
<thead>
<tr>
<th>依赖范围</th>
<th>编译</th>
<th>测试</th>
<th>运行</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>compile</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>logback</td>
</tr>
<tr>
<td>test</td>
<td>-</td>
<td>Y</td>
<td>-</td>
<td>Junit</td>
</tr>
<tr>
<td>provided</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>servlet-api</td>
</tr>
<tr>
<td>runtime</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>jdbc驱动</td>
</tr>
<tr>
<td>system</td>
<td>Y</td>
<td>Y</td>
<td></td>
<td>存储在本地的jar包</td>
</tr>
<tr>
<td>import</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h2><p>Spring就是一个轻量级的控制反转（IOC）和面向切面编程（AOP）的框架</p>
<blockquote>
<p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。</strong></p>
</blockquote>
<blockquote>
<p>拓展：</p>
<ul>
<li>SpringBoot<ul>
<li>一个快速开发的脚手架</li>
<li>基于SpringBoot可以快速的开发单个微服务</li>
<li>约定大于配置</li>
</ul>
</li>
<li>SpringCloud<ul>
<li>基于SpringBoot实现的</li>
</ul>
</li>
</ul>
<p>多数公司在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC，承上启下！</p>
<p><strong>spring弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，容易出错，人称“配置地狱”，所以有了springboot，其更简单，更稳定健壮，功能更丰富。</strong></p>
</blockquote>
<h2 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h2><p>SpringMVC就是一个Spring内置的MVC框架。</p>
<p><strong>SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封装。</strong></p>
<blockquote>
<p>MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化等等)，而且使用简单，与Spring无缝集成。</p>
</blockquote>
<hr>
<hr>
<h2 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h2><p> MyBatis是一款优秀的持久层框架，用于简化 JDBC开发。</p>
<blockquote>
<p>JavaEE三层框架：</p>
<ul>
<li>表现层：页面展示</li>
<li>业务层：逻辑处理</li>
<li>持久层：数据持久化（将数据保存到数据库）</li>
</ul>
<p>框架：相当于一个半成品软件，是一套可重用的，通用的、软件基础代码模型。</p>
<p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。</p>
</blockquote>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707939.png" alt="image-20220224170810620"></p>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191707940.png" alt="image-20220224171023073"></p>
<h2 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h2><h2 id="SSM框架整合案例"><a href="#SSM框架整合案例" class="headerlink" title="SSM框架整合案例"></a>SSM框架整合案例</h2><p>ssm：SpringMVC+Spring+MyBatis</p>
<p>案例：Maven+SpringMVC+Spring+MyBatis+Bootstrap的组合</p>
<h2 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h2><p>非关系型数据库，即缓存数据库，读取速度快，但保存时间有限。</p>
<h2 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h2><p>Zookeeper: 是一个分布式的、开源的程序协调服务，是 hadoop(分布式计算) 项目下的一个子项目。</p>
<p>用于<strong>分布式中一致性处理的框架</strong>。</p>
<h2 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h2><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架。</p>
<p>其内部使用了 Netty、Zookeeper，保证了高性能高可用性。</p>
<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><p>消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。</p>
<p>ActiveMQ</p>
<p>中小型公司，万级，非常成熟，功能强大，在早些年业内大量的公司以及项目中都有应用，主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用。</p>
<p>RabbitMQ</p>
<p>万级，延时很低，是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</p>
<p>RocketMQ</p>
<p>大型公司，十万级，阿里，接口简单易用，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。</p>
<h2 id="SpringBoot2"><a href="#SpringBoot2" class="headerlink" title="SpringBoot2"></a>SpringBoot2</h2><h2 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/Java%E6%A1%86%E6%9E%B6&%E6%8A%80%E6%9C%AF/" data-id="cl1yneflw0002swtueuxi1qrm" data-title="java框架&amp;技术" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-javaWeb" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/javaWeb/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.200Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/javaWeb/">Java Web</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>CS ：客户端-服务器 架构模式</p>
<ul>
<li>优点：充分利用客户端机器的资源，减轻服务器的负荷<br>(一部分安全要求不高的计算任务存储任务放在客户端执行，不需要把所有的计算和存储都在服务器端执行，从而能櫛够减轻服务器的压力，也能够减轻网络负荷）</li>
<li>缺点：需要安装；升级维护成本较高；</li>
</ul>
<p>BS：浏览器-服务器 架构模式</p>
<ul>
<li>优点：客户端不需要安装；维护成本较低；</li>
<li>缺点：所有的计算和存储任务都是放在服务器端的，服务器的负荷较重；在服务端计算完成之后把结果再传输给客户端，因此客户端和服务器端会进行非常频繁的数据通信，从而网络负荷较重；</li>
</ul>
<hr>
<hr>
<blockquote>
<p>网页主要由三部分组成：</p>
<p>结构：HTML</p>
<p>表现：CSS</p>
<p>行为：JavaScript</p>
</blockquote>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><blockquote>
<p><strong>Chrome浏览器调试工具</strong>：右键点“检查”，或按F12</p>
</blockquote>
<h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>标题标签 ： &lt; h1 &gt;  ~  &lt; h6 &gt;</p>
<p>段落标签：&lt; p &gt; &lt; &#x2F;p &gt;  (两段之间会插入一定的间距)</p>
<p>换行标签：&lt; br &gt;</p>
<p>水平分割线：&lt; hr &gt;</p>
<p>文本格式化标签： </p>
<ul>
<li>加粗：&lt; strong &gt;&lt; &#x2F;strong &gt;或者 &lt; b &gt;&lt; &#x2F;b &gt;</li>
<li>倾斜：&lt; em &gt;&lt; &#x2F;em &gt; 或者 &lt; i &gt;&lt; &#x2F;i &gt;</li>
<li>删除线：&lt; del &gt;&lt; &#x2F;del &gt; 或者 &lt; s &gt;&lt; &#x2F;s &gt;</li>
<li>下划线：&lt; ins &gt;&lt; &#x2F;ins &gt; 或者 &lt; u &gt;&lt; &#x2F;u &gt;</li>
</ul>
<p>分区标签：</p>
<ul>
<li>&lt; div &gt; &lt; &#x2F;div &gt; ：一行只能放一个 &lt; div &gt; ，是大分区；</li>
<li>&lt; span &gt; &lt; &#x2F;span &gt; ：一行可以放多个 &lt; span &gt;，是小分区；</li>
</ul>
<blockquote>
<p>其他布局标签：（用于手机网页制作）</p>
<table>
<thead>
<tr>
<th>标签名</th>
<th>语义</th>
</tr>
</thead>
<tbody><tr>
<td>header</td>
<td>网页头部</td>
</tr>
<tr>
<td>nav</td>
<td>网页导航</td>
</tr>
<tr>
<td>footer</td>
<td>网页底部</td>
</tr>
<tr>
<td>aside</td>
<td>网页侧边栏</td>
</tr>
<tr>
<td>section</td>
<td>网页区块</td>
</tr>
<tr>
<td>article</td>
<td>网页文章</td>
</tr>
</tbody></table>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705816.png" alt="image-20220228195231266"></p>
</blockquote>
<p>图像标签：</p>
<ul>
<li><p>&lt; img src&#x3D;”图像URL” &#x2F; &gt; </p>
</li>
<li><p>&lt; img src&#x3D;”图像URL”  alt&#x3D;”替换的文字” title&#x3D;”图像提示文字”&#x2F; &gt;</p>
<blockquote>
<p>图像标签的属性：</p>
<p>属性之间不分先后顺序，但必须用空格分开</p>
<p>属性采用键值对的格式：key&#x3D;”value”</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>图片路径</td>
<td>必须属性</td>
</tr>
<tr>
<td>alt</td>
<td>文本</td>
<td>替换文本，图像不能显示时出现的文字</td>
</tr>
<tr>
<td>title</td>
<td>文本</td>
<td>提示文本，鼠标放到图像上会浮现的文字</td>
</tr>
<tr>
<td>width</td>
<td>像素</td>
<td>设置图像的宽度</td>
</tr>
<tr>
<td>height</td>
<td>像素</td>
<td>设置图像的高度</td>
</tr>
<tr>
<td>border</td>
<td>像素</td>
<td>设置图像的边框粗细</td>
</tr>
</tbody></table>
</blockquote>
</li>
</ul>
<p>相对路径： <strong>&#x2F;</strong> 指下一级路径， <strong>..&#x2F;</strong> 指上一级路径 </p>
<p>绝对路径：\</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意最后应该有个斜杠/，以表示是目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080/07_servlet/a/b/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>base标签：可以设置当前页面中所有路径工作时，参照哪个路径来进行跳转。</p>
<p>超链接：&lt; a &gt;  具体为：&lt; a href&#x3D;”跳转目标” target&#x3D;”目标窗口的弹出方式” &gt; 文本、图像、音频等(点击样式)  &lt; &#x2F;a&gt;</p>
<blockquote>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>href</td>
<td>用于指定链接目标的url地址（必须属性）</td>
</tr>
<tr>
<td>target</td>
<td>用于指定链接页面的打开方式，_self为默认值， _blank为在新窗口打开</td>
</tr>
</tbody></table>
<p>如：&lt; a href&#x3D;”<a target="_blank" rel="noopener" href="http://www.qq.com&quot;/">http://www.qq.com&quot;</a> target&#x3D;”_blank”&gt; 腾讯&lt; &#x2F;a &gt; </p>
<p>内部链接：则href 后可以直接写相对路径。即两者在同一文件夹。</p>
<p>空链接：href 后写个 # ，即 &lt; a href&#x3D;”#”&gt; ** &lt; &#x2F;a &gt;</p>
<p>下载链接：href后写压缩文件的路径</p>
<p>锚点链接：在href属性中，设为 #名字 的形式，如 &lt; a href&#x3D;”#ZZC”&gt; 哈哈 &lt; &#x2F;a &gt;，然后在目标处，添加一个id属性&#x3D;设定的名字，如 &lt; h4 id&#x3D;”ZZC” &gt;</p>
</blockquote>
<hr>
<p>注释： &lt; !–  注释语句 – &gt; ，快捷键 ：ctrl + &#x2F;</p>
<p>特殊字符：（只记空格符就行，所有字符后都要带个分号 ; )</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>描述</th>
<th>字符的代码</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><strong>空格符</strong></td>
<td><strong>&amp;nbsp</strong></td>
</tr>
<tr>
<td>&lt;</td>
<td>小于号</td>
<td>&amp;lt</td>
</tr>
<tr>
<td>&gt;</td>
<td>大于号</td>
<td>&amp;gt</td>
</tr>
<tr>
<td>&amp;</td>
<td>和号</td>
<td>&amp;amp</td>
</tr>
<tr>
<td>￥</td>
<td>人民币</td>
<td>&amp;yen</td>
</tr>
<tr>
<td>©</td>
<td>版权</td>
<td>&amp;copy</td>
</tr>
<tr>
<td>®</td>
<td>注册商标</td>
<td>&amp;reg</td>
</tr>
<tr>
<td>°</td>
<td>摄氏度</td>
<td>&amp;deg</td>
</tr>
<tr>
<td>±</td>
<td>正负号</td>
<td>&amp;plusmn</td>
</tr>
<tr>
<td>×</td>
<td>乘号</td>
<td>&amp;times</td>
</tr>
<tr>
<td>÷</td>
<td>除号</td>
<td>&amp;divide</td>
</tr>
<tr>
<td>²</td>
<td>平方2</td>
<td>&amp;sup2</td>
</tr>
<tr>
<td>³</td>
<td>立方3</td>
<td>&amp;sup3</td>
</tr>
</tbody></table>
<hr>
<hr>
<h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>&lt; table&gt;&lt; &#x2F;table&gt;：是用于定于表格的标签</p>
<p>&lt; tr &gt;&lt; &#x2F;tr &gt;：用于定义表格中的行，必须在&lt; table &gt;中</p>
<p>&lt; td &gt;&lt; &#x2F;td &gt;：用于单元格，必须嵌套在&lt; tr &gt;中</p>
<p>&lt; th &gt;&lt; &#x2F;th &gt;：表示表头单元格（文本内容居中加粗）</p>
<p>表格结构标签：&lt; thead &gt;指表格的头部区域，&lt; tbody &gt;指表格 的主体区域。</p>
<p>合并单元格（属性）：跨行合并——rowspan&#x3D;”合并个数“，跨列合并——colspan&#x3D;”合并个数”（也可说是占了若干个单元格）</p>
<blockquote>
<p>合并步骤：找到目标单元格，写上合并方式，如：&lt; td colspan&#x3D;”2” &gt;&lt; &#x2F;td &gt;，然后再删除多余的单元格。</p>
</blockquote>
<p>表格属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>align</td>
<td>legt，center，right</td>
<td>规定表格相对周围元素的对齐方式</td>
</tr>
<tr>
<td>border</td>
<td>1或 ” “</td>
<td>是否有边框，默认为” “，即无边框</td>
</tr>
<tr>
<td>cellpadding</td>
<td>像素值</td>
<td>规定单元边沿与内容之间的空白，默认1像素</td>
</tr>
<tr>
<td>cellspacing</td>
<td>像素值</td>
<td>规定单元格之间的空白，默认1像素</td>
</tr>
<tr>
<td>width</td>
<td>像素值或百分比</td>
<td>规定表格的宽度</td>
</tr>
</tbody></table>
<p>如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    	&lt; th&gt;表头单元格的内容<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">		&lt; td&gt;单元格中的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表：&lt; ul &gt; ，列表项：&lt; li &gt;</p>
<p>有序列表：&lt; ol &gt;</p>
<p>自定义列表：&lt; dl &gt; ，表项头&lt; dt &gt;，表项：&lt; dd &gt;</p>
<blockquote>
<p>&lt; ul &gt;和&lt; ol &gt;里只能放&lt; li &gt;， &lt; li &gt;里面可以放任意标签，&lt; dl &gt;里只能放&lt; dt &gt;和&lt; dd &gt;。</p>
</blockquote>
<hr>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单域（区域）：&lt; form &gt;</p>
<blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>表单域属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>action</td>
<td>url地址</td>
<td>指定接收该表的服务器程序的url地址</td>
</tr>
<tr>
<td>method</td>
<td>GET&#x2F;POST</td>
<td>设置表单数据的提交方式</td>
</tr>
<tr>
<td>name</td>
<td>名称</td>
<td>指定表单名称</td>
</tr>
</tbody></table>
<p>表单元素：</p>
<ul>
<li><p>输入元素：&lt; input type&#x3D;”属性值” &#x2F; &gt;</p>
<p>input属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>自定义</td>
<td>定义input元素的名称</td>
</tr>
<tr>
<td>value</td>
<td>自定义</td>
<td>规定input元素的值</td>
</tr>
<tr>
<td>checked</td>
<td>checked</td>
<td>规定此input首次加载时被选中</td>
</tr>
<tr>
<td>maxlength</td>
<td>正整数</td>
<td>规定输入字符的最大长度</td>
</tr>
</tbody></table>
<blockquote>
<p>注：name和value是每个表单元素都有的属性值，主要给后台人员使用；要求<u>单选按钮和复选框要有相同的name值</u>。</p>
</blockquote>
<p>type属性值：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>button</td>
<td>定义可点击按钮（多数情况下，用于通过 Javascript启动脚本）</td>
</tr>
<tr>
<td>checkbox</td>
<td>定义复选框。</td>
</tr>
<tr>
<td>file</td>
<td>定义输入字段和“浏览”按钮，供文件上传。和 multiple 搭配可以上传多个文件</td>
</tr>
<tr>
<td>hidden</td>
<td>定义隐藏的输入字段。</td>
</tr>
<tr>
<td>image</td>
<td>定义图像形式的提交按钮</td>
</tr>
<tr>
<td>password</td>
<td>定义密码字段。该字段中的字符被掩码。</td>
</tr>
<tr>
<td>radio</td>
<td>定义单选按钮</td>
</tr>
<tr>
<td>reset</td>
<td>定义重置按钮。重置按钮会清除表单中的所有数据</td>
</tr>
<tr>
<td>submit</td>
<td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td>
</tr>
<tr>
<td>text</td>
<td>定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。</td>
</tr>
<tr>
<td>placeholder</td>
<td>占位符，作提示，常用于需要输入的文本框</td>
</tr>
</tbody></table>
<blockquote>
<p>&lt; label &gt; ：用于绑定一个表单元素，当单击此标签内的文本时，会自动选择对应的表单元素，以增加用户体验。</p>
<p>格式：&lt; label &gt;里的for属性 应该与相关元素的 id属性相同。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zzc&quot;</span>&gt;</span> 文本<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot; &quot;</span> <span class="attr">id</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>下拉元素：&lt; select &gt; ：定义下拉列表</p>
<p>在&lt; option &gt;中添加selected&#x3D;”selected”时，为默认选中项</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span> 选项 <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文本域元素：&lt; textarea &gt;：定义多行文本输入控件</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">	文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>







<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS：层叠样式表</p>
<blockquote>
<p>CSS书写顺序：</p>
<ol>
<li>浮动 &#x2F; display</li>
<li>盒子模型：margin border padding 宽度高度背景色</li>
<li>文字样式</li>
</ol>
</blockquote>
<h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><ol>
<li><p>内联样式：在标签内使用style属性（耦合较高，较少使用）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span> HELLO CSS <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>内部样式：定义 &lt; style &gt; 标签，在标签内定义css样式；</p>
<p>（一般写在head标签里，title标签下面）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/*选择器 &#123; 样式 &#125; */</span></span></span><br><span class="line"><span class="language-css"><span class="comment">/*给谁改样式 &#123; 改什么样式 &#125; */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;		<span class="comment">/*键值对用:分开，每行用;结尾*/</span></span></span><br><span class="line"><span class="language-css">    fon-size: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>外部样式：定义link标签，引入外部的css文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;demo.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*demo.css*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>规范：</p>
<p>选择器、属性名、属性值统一小写；</p>
<p>选择器（标签）和大括号中间带空格；</p>
<p>冒号后带空格</p>
</blockquote>
<hr>
<hr>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul>
<li><p>标签选择器：元素名称{color: red;}</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>id选择器：#id属性值{color: red;}</p>
<blockquote>
<p>注意：id是唯一的，一般与js配合制作动态效果</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#name</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;name&quot;&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类选择器：.class属性值{color: red;}</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;cls&quot;&gt;helle css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通配符选择器：*{ color: red;}</p>
<p>作用：为页面的所有标签 设置样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/*去除默认的外边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<hr>
<p><strong>更多用法:</strong></p>
<ul>
<li><p>后代选择器：选择器1 选择器2 { css }</p>
<blockquote>
<p>作用：根据嵌套关系，选择父元素的 后代中满足条件的元素。</p>
<p>注：后代包括 儿子、孙子….</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;   <span class="comment">/* 选择div下的p标签 */</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>子代选择器： 选择器1 &gt; 选择器2{css}</p>
<blockquote>
<p>作用：选择父元素的子代元素。</p>
<p>注：子代只包含儿子</p>
</blockquote>
</li>
<li><p>并集选择器： 选择器1，选择器2{css}</p>
<blockquote>
<p>作用：用逗号隔开，同时选择多组标签，设置相同的样式。</p>
<p>注：一般写法是 每个选择器写一行，提高代码的可读性。</p>
</blockquote>
</li>
<li><p>交集选择器：选择器1选择器2 { css }</p>
<blockquote>
<p>作用：选中页面中同时满足多个选择器的标签</p>
<p>注：选择器连着写，且标签选择器优先写在前面。</p>
</blockquote>
</li>
<li><p>hover伪类选择器：选择器：hover {css}</p>
<blockquote>
<p>作用：在鼠标悬停在元素上时 会出现的状态样式</p>
</blockquote>
</li>
</ul>
<h3 id="字体和文本样式"><a href="#字体和文本样式" class="headerlink" title="字体和文本样式"></a>字体和文本样式</h3><h4 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h4><ul>
<li><p>字体大小：font-size</p>
<blockquote>
<p>取值：数字+px</p>
<p>谷歌浏览器默认文字大小是16px</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>粗细：font-weight</p>
<blockquote>
<p>取值：normal，bold；（指正常和加粗）</p>
<p>或取100到900的整百数，正常是400，加粗是700</p>
</blockquote>
</li>
<li><p>样式：font-style （是否倾斜）</p>
<blockquote>
<p>取值：normal，italic（正常和倾斜）</p>
</blockquote>
</li>
<li><p>类型系列：font-family</p>
<blockquote>
<p>取值：微软雅黑，黑体………等等，最后应该加sans-serif（无衬线字体）（从设置的第一种字体开始选，没有就选择下一个电脑有的字体）</p>
</blockquote>
</li>
<li><p>字体font连写：</p>
<blockquote>
<p>取值：font：style weight size family（可以省略前两个值，为默认值）</p>
<p>复合属性：一个属性后面写多个值的写法</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">66px</span> 宋体</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><ul>
<li><p>文本缩进：text-indent</p>
<blockquote>
<p>取值：数字+px   或   数字+em（1em&#x3D;当前标签的大小，推荐）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>  <span class="comment">/*缩进两字符*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>文本水平对齐方式：text-align</p>
<blockquote>
<p>属性值：left，center，right；分别是左对齐，居中，右对齐 </p>
<p>注：text-align 其实是内容对齐，不仅仅用于文本， 能用于 文本、span标签、a标签、input标签、img标签 。不过需要在以上元素的父元素设置，如<body>。</p>
</blockquote>
</li>
<li><p>文本修饰：text-decoration</p>
<blockquote>
<p>取值：underline，line-through，overline，none；分别是下划线（常用)，删除线，上划线，无装饰线（常用)。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="line-height行高"><a href="#line-height行高" class="headerlink" title="line-height行高"></a>line-height行高</h4><p>作用：控制一行的上下行间距</p>
<blockquote>
<p>取值：数字+px 或 倍数（当前标签font-size的倍数）</p>
</blockquote>
<blockquote>
<p>注意：</p>
<p>如果同时设置了行高和font连写，注意覆盖问题<br>font：style weight size&#x2F;line-height family</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>:ita1ic <span class="number">700</span> <span class="number">66px</span>/<span class="number">2</span> 宋体;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>标签水平居中： margin：0 auto</strong></p>
<blockquote>
<p> margin：0 auto 一般用于有固定宽度的盒子，如果没有宽度，会默认占满父元素的宽度。</p>
</blockquote>
<hr>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>背景色：background-color: </p>
<p>背景图：background-image: url(‘…..’)</p>
<p>背景平铺：background-repeat：</p>
<blockquote>
<table>
<thead>
<tr>
<th>取值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>repeat</td>
<td>默认，水平和垂直方向平铺</td>
</tr>
<tr>
<td>no-repeat</td>
<td>不平铺</td>
</tr>
<tr>
<td>repeat-x</td>
<td>沿水平方向平铺</td>
</tr>
<tr>
<td>repeat-y</td>
<td>沿垂直方向平铺</td>
</tr>
</tbody></table>
</blockquote>
<p>背景位置：background-position：x值 y值；</p>
<blockquote>
<p>方向名词</p>
<ul>
<li>水平：left，center，right</li>
<li>垂直：top，center，bottom</li>
</ul>
<p>数字+px（坐标）</p>
</blockquote>
<p>背景相关属性连写</p>
<blockquote>
<p>顺序无要求，推荐顺序：background：color image repeat position</p>
</blockquote>
<hr>
<h3 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h3><p>&lt; &gt;可以叫标签，标记，元素。</p>
<ul>
<li><p>块级元素</p>
<p>独占一行，宽度默认是父元素的宽度，高度由内容撑开，可以设置宽高</p>
<blockquote>
<p>如：div，p，h系列，ul，li，dl，dt，dd，form，header</p>
</blockquote>
</li>
<li><p>行内元素</p>
<p>一行可以显示多个，宽度和高度默认由内容撑开，不可以设置宽高</p>
<blockquote>
<p>如：a，apar，b，u，i，s，strong，ins，em，del</p>
</blockquote>
</li>
<li><p>行内块元素</p>
<p>一行可以显示多个，可以设置宽高</p>
<blockquote>
<p>如：image，input，textarea，button，select</p>
</blockquote>
</li>
</ul>
<p><strong>元素显示模式转换：</strong></p>
<p>作用：改变元素默认的显示特点，让元素符合布局要求</p>
<p>语法：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>display: block</td>
<td>转成块级元素</td>
</tr>
<tr>
<td>display: inline-block</td>
<td>转成行内块元素</td>
</tr>
<tr>
<td>display: inline</td>
<td>转成行内元素</td>
</tr>
</tbody></table>
<p><strong>元素的嵌套规范</strong></p>
<ul>
<li><p>块级元素一般作为大容器，可以嵌套：文本、块级元素、行内元素、行内块元素等等…</p>
<blockquote>
<p>但是：p标签中不要嵌套div、p、h等块级元素</p>
</blockquote>
</li>
<li><p>a 标签内部可以嵌套任意元素</p>
<blockquote>
<p>但是：a标签不能嵌套a标签</p>
</blockquote>
</li>
</ul>
<h3 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h3><ul>
<li><p><strong>继承性</strong>：子元素默认继承父元素的样式特点</p>
<blockquote>
<p>控制文字属性的都可以继承，如：</p>
<p>color，font- ，text- ，line-height 。。。。</p>
<p>但有例外：a标签的color有自己的蓝色，h系列的font-size有自己的字体大小，都会继承失效。</p>
</blockquote>
</li>
<li><p><strong>层叠性</strong>：覆盖，后面的覆盖前面的</p>
</li>
<li><p><strong>优先级：</strong></p>
<p>继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important</p>
<blockquote>
<p>!important可以提升选择器的优先级到最高，写在属性值的后面，分号的前面。</p>
<p>注：继承的优先级不能用 !important提高，它的优先级最低。</p>
</blockquote>
</li>
</ul>
<h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>页面中的每一个标签，都可看做是一个“盒子”，通过盒子的视角更方便的进行布局。</p>
<h4 id="盒子构成"><a href="#盒子构成" class="headerlink" title="盒子构成"></a>盒子构成</h4><ul>
<li><p><strong>内容区域 content</strong></p>
</li>
<li><p><strong>内边距区域 padding</strong></p>
<blockquote>
<p>取值：可以四个，三个，两个，一个值</p>
<p>padding: 10px 20px 30px 40px （对应上 右 下 左，即逆时针开始数）   </p>
<p>padding: 10px 20px 30px  （对应上 左右 下，也是逆时针）</p>
<p>padding：  10px 20px（对应上下 左右，也是逆时针）</p>
</blockquote>
</li>
<li><p><strong>边框区域 border</strong></p>
<blockquote>
<p>如：<strong>border：10px solid red</strong> ——&gt;10像素，直线，红色（粗细，线段样式，颜色）</p>
<p>如果只需要一边的边框线，则<strong>border-方向</strong>即可，如：border-left&#x2F; right&#x2F; top&#x2F; bottom</p>
<p>线段：直线solid，dashed虚线，dotted点线（其他的线用不着，需要的用图片）</p>
</blockquote>
<blockquote>
<p>快捷键：bd</p>
</blockquote>
</li>
<li><p><strong>外边距区域 margin</strong></p>
</li>
</ul>
<h4 id="自动内减"><a href="#自动内减" class="headerlink" title="自动内减"></a>自动内减</h4><p><strong>box-sizing：border-box</strong></p>
<blockquote>
<p>给盒子设置border或paddingl时，盒子会被撑大，需要再次设置参数，手动计算麻烦，所以有了自动内减，浏览器会自动计算，在内容中减去相应大小。</p>
</blockquote>
<h4 id="清楚默认的内外边距"><a href="#清楚默认的内外边距" class="headerlink" title="清楚默认的内外边距"></a>清楚默认的内外边距</h4><p><strong>margin：0；</strong></p>
<p><strong>padding：0；</strong></p>
<blockquote>
<p>淘宝网的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span>,<span class="selector-tag">body</span>,<span class="selector-tag">button</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">form</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,hr,<span class="selector-tag">input</span>,<span class="selector-tag">legend</span>,<span class="selector-tag">li</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">p</span>,pre,<span class="selector-tag">td</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">th</span>,<span class="selector-tag">ul</span>&#123;</span><br><span class="line">	<span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">	<span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>京东的：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">   	<span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">   	<span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ul>
<li><p>塌陷现象：</p>
<p>场景：相互嵌套的块级元素，子元素设置了margin-top，会同样作用在父元素上。致使父元素一起往下移动。</p>
<p>解决：</p>
<ul>
<li>给父元素设置border-top或者padding-top(分隔父子元素的margin-top)</li>
<li>给父元素设置 overflow: hidden</li>
<li>转换成行内块元素</li>
<li>设置浮动</li>
</ul>
</li>
</ul>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><p>根据元素在HTML的结构关系查找元素。常用于查找某父级选择器的子元素。</p>
<p>优势：减少对HTML中类的依赖，有利于保持代码的整洁。</p>
<table>
<thead>
<tr>
<th>选择器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>E:first-child{}</td>
<td>匹配父元素中第一个子元素，且是E元素</td>
</tr>
<tr>
<td>E:last-child{}</td>
<td>匹配父元素中最后一个子元素，且是E元素</td>
</tr>
<tr>
<td>E:nth-child(n){}</td>
<td>匹配父元素中第n个子元素，且是E元素</td>
</tr>
<tr>
<td>E:nth-last-child(n){}</td>
<td>匹配父元素中倒数第n个子元素，且是E元素</td>
</tr>
</tbody></table>
<blockquote>
<p>n可以写成公式，如4n+1，则会选中第5个，第9个….</p>
</blockquote>
<h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>一般在页面的非主体内容可以使用伪元素。</p>
<table>
<thead>
<tr>
<th>伪元素</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>::before</td>
<td>在父元素内容的最前添加一个伪元素</td>
</tr>
<tr>
<td>::after</td>
<td>在父元素内容的最后添加一个伪元素</td>
</tr>
</tbody></table>
<p>注：必须设置content属性才能生效，伪元素默认是行内元素</p>
<p> 例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;   </span><br><span class="line">	&lt;style&gt;</span><br><span class="line">        <span class="selector-class">.father</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">&#x27;老鼠&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.father</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">&quot;大米&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;!-- 老鼠爱大米 --&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;father&quot;&gt;爱&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="浮动特点"><a href="#浮动特点" class="headerlink" title="浮动特点"></a>浮动特点</h4><ul>
<li><p>浮动元素会脱离标准流(简称：脱标)，在标准流中不占位置</p>
<blockquote>
<p>标准流：又称文档流 ，指浏览器在渲染网页时默认采用的一套排版规则。</p>
</blockquote>
</li>
<li><p>浮动元素比标准流高半个级别，可以覆盖标准流中的元素</p>
</li>
<li><p>浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动</p>
</li>
<li><p>浮动元素有特殊的显示效果</p>
<ul>
<li>一行可以显示多个</li>
<li>可以设置宽高</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：浮动的元素不能使用text-align: center或者margin: 0 auto 设置</p>
</blockquote>
<h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>浮动带来的问题：如果子元素浮动了，此时子元素不占位置，不能撑开标准流的块级父元素。</p>
<p>解决：</p>
<ol>
<li><p>直接设置父元素的高度</p>
<p>优点：简单</p>
<p>缺点：有些布局中不能固定父元素高度</p>
</li>
<li><p>额外标签法</p>
<p>在父元素内容的最后添加一个块级元素，并对其设置 clear: both。</p>
<p>缺点：添加了额外标签，会使HTML结构变复杂</p>
</li>
<li><p>单伪元素清除法</p>
<p>用伪元素替代了额外标签。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基本写法*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;	<span class="comment">/*clearfix常用作需要清除浮动的元素的类名*/</span></span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*补充写法*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>: block;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="comment">/*补充的部分是为了在网页中看不见伪元素*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>双伪元素清除法</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">	<span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">	<span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优点：可以在项目中直接使用，直接给标签加类clearfix即可清除浮动。</p>
</li>
<li><p>设置overflow：hidden</p>
<p>直接给父元素设置overflow：hidden即可。</p>
<p>优点：方便</p>
</li>
</ol>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>可以让元素自由的摆放在网页的任意位置，一般用于盒子之间的层叠情况</p>
<p>应用：定位之后的元素层级最高，可以层叠在其他盒子上面，也可以让盒子始终固定在屏幕中的某个位置。</p>
<p>属性名：<strong>position:</strong></p>
<p>属性值：</p>
<table>
<thead>
<tr>
<th>定位方式</th>
<th>属性值</th>
</tr>
</thead>
<tbody><tr>
<td>静态定位</td>
<td>static（加不加效果一样）</td>
</tr>
<tr>
<td>相对定位</td>
<td><strong>relative</strong></td>
</tr>
<tr>
<td>绝对定位</td>
<td><strong>absolute</strong></td>
</tr>
<tr>
<td>固定定位</td>
<td><strong>fixed</strong></td>
</tr>
</tbody></table>
<p>偏移值：水平和垂直方向各选一个即可（都写的话以left和top为准）</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>属性名</th>
<th>属性值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>水平</td>
<td>left</td>
<td>数字px</td>
<td>距离左边的距离</td>
</tr>
<tr>
<td>水平</td>
<td>right</td>
<td>数字px</td>
<td>距离右边的距离</td>
</tr>
<tr>
<td>垂直</td>
<td>top</td>
<td>数字px</td>
<td>距离上边的距离</td>
</tr>
<tr>
<td>垂直</td>
<td>bottom</td>
<td>数字px</td>
<td>距离下边的距离</td>
</tr>
</tbody></table>
<blockquote>
<p>属性值 也可以用 % 来设置，这样就是以参照物来看，如 50%就是左边界在参照物的中间。</p>
</blockquote>
<ul>
<li><p><strong>相对定位——position: relative</strong></p>
<p>相对于非静态定位的父元素进行移动。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原位置仍在页面 中占位置(没有脱标)</p>
</blockquote>
</li>
<li><p><strong>绝对定位——position: absolute</strong></p>
<p>就近找已经定位的父级为参照进行定位，没有定位的父级，则默认相对于浏览器可视区域(即<body>)进行移动。（子绝父相）</p>
<blockquote>
<p>原位置在页面中不占位置(已经脱标)</p>
<p>绝对定位的盒子模式具备行内块特点</p>
</blockquote>
<blockquote>
<p>例题：让元素的位置处于浏览器或参照物正中间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">	<span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;<span class="comment">/*宽的一半*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">200px</span>;<span class="comment">/*高的一半*/</span></span><br><span class="line">    <span class="comment">/*transform:translate(-50%,-50%); 上面的margin位移也可以写成这个，位移自己的一半*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    heght: <span class="number">400px</span></span><br><span class="line">	background-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>固定定位——position: fixed</strong></p>
<blockquote>
<p>特点：</p>
<p>脱标，不占位置；</p>
<p>参照浏览器窗口改变位置；</p>
<p>具备行内块特点</p>
</blockquote>
</li>
</ul>
<h4 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h4><p>不同布局：标准流 &lt; 浮动 &lt; 定位</p>
<p>而相对，绝对，固定三种定位方式层级相同，谁写在下就覆盖其他的。</p>
<h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><blockquote>
<p>浏览器解析 行内 和 行内块 时当作文字，会根据基线对齐，所以导致常常图片或按钮之类的与文本框或背景对不齐。</p>
</blockquote>
<h4 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h4><p>属性名：<strong>vertical-align</strong></p>
<p>属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>baseline</td>
<td>默认，基线对齐</td>
</tr>
<tr>
<td>top</td>
<td>顶部对齐</td>
</tr>
<tr>
<td>middle</td>
<td>中间对齐</td>
</tr>
<tr>
<td>bottom</td>
<td>底部对齐</td>
</tr>
</tbody></table>
<h4 id="光标类型"><a href="#光标类型" class="headerlink" title="光标类型"></a>光标类型</h4><p>设置鼠标光标在元素上时显示的样式。</p>
<p>属性名：<strong>cursor</strong></p>
<p>属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>default</td>
<td>默认值，通常是箭头</td>
</tr>
<tr>
<td>pointer</td>
<td>小手，提示可以点击</td>
</tr>
<tr>
<td>text</td>
<td>工字型，提示可以选择文字</td>
</tr>
<tr>
<td>move</td>
<td>十字光标，提示可以移动</td>
</tr>
</tbody></table>
<h4 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h4><p>场景：让盒子四个角变得圆润，增加页面细节。</p>
<p>属性名：<strong>border-radius</strong></p>
<p>常见取值：数字+px、百分比（指圆角半径）</p>
<p>赋值规则：从左上角开始，顺时针赋值，没有赋值的看对角</p>
<blockquote>
<p>画一个正圆：</p>
<p>盒子为正方形，设置圆角为盒子宽高的一半，即 border-radius: 50%</p>
<p>按钮胶囊：</p>
<p>盒子为长方形，设置圆角为盒子 高度 的一半，即 border-radius: 50%</p>
</blockquote>
<h4 id="溢出部分显示"><a href="#溢出部分显示" class="headerlink" title="溢出部分显示"></a>溢出部分显示</h4><p>溢出部分：指盒子内容部分所超出盒子范围的区域。</p>
<p>overflow用于控制内容溢出部分的显示效果，如：显示&#x2F;隐藏滚动条。</p>
<p>属性名：<strong>overflow</strong></p>
<p>属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>效果</th>
</tr>
</thead>
<tbody><tr>
<td>visible</td>
<td>默认值，溢出部分可见</td>
</tr>
<tr>
<td>hidden</td>
<td>溢出部分隐藏</td>
</tr>
<tr>
<td>scroll</td>
<td>无论是否溢出，都显示滚动条</td>
</tr>
<tr>
<td>auto</td>
<td>根据是否溢出，自动显示或隐藏滚动条</td>
</tr>
</tbody></table>
<h4 id="元素本身隐藏"><a href="#元素本身隐藏" class="headerlink" title="元素本身隐藏"></a>元素本身隐藏</h4><p>让某元素本身在屏幕中不可见，如：鼠标hover之后元素隐藏，用于隐藏&#x2F;显示子菜单之类的场景</p>
<p>属性：</p>
<ul>
<li><p><strong>visibility: hidden</strong></p>
<p>占位置的隐藏效果，用的不多</p>
</li>
<li><p><strong>display: none</strong></p>
<p>脱标的隐藏效果（不占位置）</p>
<blockquote>
<p>display：black  显示元素</p>
</blockquote>
</li>
</ul>
<h4 id="元素整体透明"><a href="#元素整体透明" class="headerlink" title="元素整体透明"></a>元素整体透明</h4><p>让某元素（包括内容）一起变透明。</p>
<p>属性名：<strong>opacity</strong></p>
<p>属性值：0~1之间的数字——0为完全透明</p>
<h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote>
<p>跨平台、面向对象的脚本语言，用来控制网页行为，网页交互。</p>
</blockquote>
<h3 id="js引擎运行"><a href="#js引擎运行" class="headerlink" title="js引擎运行"></a>js引擎运行</h3><p>分两步：预解析，再代码执行</p>
<ul>
<li>预解析：js引擎会把js里面的所有var还有function提升到当前作用域的最前面；<ul>
<li>变量预解析(变量提升)：把所有的变量声明提升到当前作用域最前面，但不提升赋值操作。</li>
<li>函数预解析(函数提升)：把所有的函数声明提升到当前作用域最前面，不会调用函数。</li>
</ul>
</li>
<li>代码执行：按照代码书写顺序从上往下执行。</li>
</ul>
<h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>内部脚本：定义在HTML页面中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JS代码必须在&lt; script &gt;&lt; &#x2F;script &gt;之间，可以放置在任何地方，任意数量。一般放在&lt; body &gt;的底部，可改善显示速度，因为脚本执行会拖慢显示。</p>
</blockquote>
<p>外部脚本：作为外部JS文件引入</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;文件路径&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>外部脚本不能包含&lt; script &gt;标签，&lt; script &gt;不能自闭合</p>
</blockquote>
<hr>
<h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>与java相似，不过语句末的分号；可有可无。</p>
<h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot; ... &quot;</span>)  <span class="comment">//写入警告框</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot; ... &quot;</span>)  <span class="comment">//写入HTML输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; ... &quot;</span>)   <span class="comment">//写入浏览器控制台</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(object)  <span class="comment">//打印元素对象，查看属性,方法</span></span><br><span class="line"><span class="title function_">prompt</span>(info) <span class="comment">//弹出输入框，用户可以输入</span></span><br></pre></td></tr></table></figure>

<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>使用 <strong>var</strong> 关键字来声明变量。（variable）</p>
<blockquote>
<ul>
<li>作用域：全局变量；</li>
<li>变量可以重复声明；</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">20</span>;</span><br><span class="line">test = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JS是弱类型语言，变量可以存放不同类型的值</p>
<p>ES6新增 let 关键字来定义变量，其变量只在let所在的代码块内有效，且不允许重复声明。</p>
<p>ES6新增 const 关键字来声明一个只读的常量。</p>
</blockquote>
<blockquote>
<ul>
<li><p>全局变量 在浏览器关闭时销毁；</p>
</li>
<li><p>局部变量 在程序运行完毕后就销毁；</p>
</li>
</ul>
</blockquote>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><p>原始类型：</p>
<ul>
<li>number：数字(整数，小数，NaN(Not a Number))</li>
<li>string：字符，字符串，单双引号皆可</li>
<li>boolean：布尔类型</li>
<li>null：空</li>
<li>undefined：变量未初始化时的默认值</li>
</ul>
<blockquote>
<p>使用typeof运算符可以获取数据类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef 变量名</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>引用类型</p>
</li>
</ul>
<h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul>
<li>其他类型转为number：<ul>
<li>string：按字符的字面值转为数字，如果字面值不是数字，则转为NaN。一般使用正负号 或 parseInt 进行转化。</li>
<li>boolean：true 转为 1， false 转为 0.</li>
</ul>
</li>
<li>其他类型转为boolean：<ul>
<li>number：0和NaN转为 false，其他转为 true</li>
<li>string：空字符串转为 false，其他转为true</li>
<li>null：转为false</li>
<li>nudefined：转为fals e</li>
</ul>
</li>
</ul>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>关系运算符</p>
<ul>
<li>&#x3D;&#x3D; ：先判断类型是否一致，不一致会进行类型转换再比较两个值；</li>
<li>&#x3D;&#x3D;&#x3D; ：（全等于）如果类型不一致，会直接返回false，类型一致时才会比较两个值。</li>
</ul>
<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通过function关键字进行定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形式参数不需要类型，返回值也不需要定义类型，因为JavaScreipt是弱类型语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义方式二</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用，JS函数调用函数，可以传递任意个参数个数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">                                  </span><br><span class="line"><span class="comment">//立即执行函数,作用:立即执行，同时也独立创建了一个作用域,里面所有变量都是局部变量,避免命名冲突;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)();</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;());                               <span class="comment">//如: </span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="title function_">console</span>(a + b);</span><br><span class="line">&#125;)(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;(<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>arguments</strong></p>
<p>是当前函数的内置对象，存储了传递的所有实参。其展示形式是一个伪数组，可以遍历，有lenght属性，有索引，没有push，pop等方法。</p>
</blockquote>
<blockquote>
<p>内部函数可以访问外部函数的变量：采用链式查找的方式来决定取哪个值，即找最近的——作用域链。</p>
</blockquote>
<h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h4><p>Array用于定义数组</p>
<ul>
<li><p>创建方法：</p>
<ul>
<li>一、var 变量名 &#x3D; new Array(元素列表)；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>二、var 变量名 &#x3D; [元素列表]；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性：</p>
<p>length：数组中元素的个数</p>
<p>push：添加方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>splice：删除元素</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrs.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">//参数:从0号位开始删，删2个</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><ul>
<li><p>创建方法：</p>
<ul>
<li><p>var 变量名 &#x3D; new String(s);</p>
</li>
<li><p>var 变量名 &#x3D; s；</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>属性：</p>
<p>length：字符串的长度</p>
</li>
<li><p>方法：</p>
<p>chaAt()：返回在指定位置的字符</p>
<p>indexOf()：检索字符串</p>
<p>trim()：去除字符串前后的空格</p>
<p>concat(str1,str2….)：链接多个字符串，等效+，+更常用</p>
<p>substr(start,lenght)：从start开始，取lenght个字符</p>
</li>
</ul>
<h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><p>和Math不同，Date对象需要实例化后才能使用。</p>
<p>Date() ——（没有参数）返回系统的当前时间</p>
<blockquote>
<p>使用 .valueOf() 或 getTime() 来获得总的毫秒数(时间戳)，从1970年1月1日到现在。</p>
<p>有更常用的写法：将 <strong>+new Date()</strong> 实例化，也可获得总的毫秒数。</p>
<p>H5新增的获取方法： <strong>Date.now()</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>getFullYear()</td>
<td>获取当年</td>
</tr>
<tr>
<td>getMonth()</td>
<td>获取当月（0~11）</td>
</tr>
<tr>
<td>getDate()</td>
<td>获取当天日期</td>
</tr>
<tr>
<td>getDay()</td>
<td>获取星期几（周期0 到 周六6）</td>
</tr>
<tr>
<td>getHours()</td>
<td>当前小时</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>当前分钟</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>当前秒</td>
</tr>
</tbody></table>
<h4 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h4><p>格式：</p>
<ul>
<li><p>var 对象名 &#x3D; {属性名 : 属性值，…   函数名 : function(参数){} …. };</p>
</li>
<li><p>或者使用：var 对象名 &#x3D; new Object(); 来创造一个空的对象，再利用追加属性的方法，往里面添加数据。</p>
</li>
<li><p>使用构造函数来创建对象：</p>
<p>function 构造函数名(参数值){ this.属性 &#x3D; 值； this.方法 &#x3D; function(){} }————调用时，用“new 构造方法名” 赋值给变量。 </p>
<blockquote>
<p>注：构造函数名字首字母要大写</p>
</blockquote>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">	<span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line">	<span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line">	<span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="title function_">alert</span>(<span class="string">&quot;干饭&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,age,sex</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params">sang</span>)&#123;</span><br><span class="line">        sonsole.<span class="title function_">log</span>(sang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&#x27;刘德华&#x27;</span>，<span class="number">19</span>，<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>调用属性：<strong>对象名.属性名</strong>  或者  <strong>对象名[‘属性名’]</strong></p>
<p>调用方法：<strong>对象名.方法名</strong></p>
<p>遍历对象属性：for…in可以对数组或对象进行遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;	</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k);	<span class="comment">//k变量输出得到的是属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]); <span class="comment">//obj[k]得到的是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><p>JS是单线程的，即同一时间只能做一件事，这意味着所有任务需要排队，如果JS执行时间过长，会导致页面渲染不流畅。</p>
<p>于是，HTML5提出Web Worker标准，允许JS脚本创建多个线程。于是就有了同步和异步。</p>
<ul>
<li><p>同步</p>
<p>程序之间的执行顺序与排列顺序一致，即同步。</p>
</li>
<li><p>异步</p>
<p>执行某程序的同时可以执行另一个程序，即异步。</p>
</li>
<li><p>同步任务</p>
<p>同步任务都在主线程执行，形成一个执行栈</p>
</li>
<li><p>异步任务</p>
<p>JS的异步是通过回调函数实现的，一般而言，异步任务有三种：</p>
<ul>
<li>普通事件：如click，resize</li>
<li>资源加载：如load，error</li>
<li>定时器：如setInterval，setTimeout</li>
</ul>
<p>异步任务相关的回调函数会添加到任务队列(消息队列)中。</p>
</li>
</ul>
<p><strong>执行机制：</strong> </p>
<ol>
<li><p>先执行执行栈中的同步任务；</p>
</li>
<li><p>遇到异步任务，将其回调函数放入任务队列中；</p>
<blockquote>
<p>异步任务会先交给异步进程处理，只有异步任务的事件发生，或如click点击了，setInterval的时间到了，才会把相关的回调函数放入任务队列。</p>
</blockquote>
</li>
<li><p>等执行栈中的所有同步任务执行完毕后，系统会按次序读取任务队列中的异步任务，使其进入执行栈，开始执行。</p>
<blockquote>
<p>事件循环：主线程不断的重复获取任务，执行任务，再获取任务，反复循环。</p>
</blockquote>
</li>
</ol>
<h3 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h3><p>Browser Object Model 浏览器对象模型，JS将浏览器的各个组成部分封装成对象：Window，Navigator，Screen，History，Location。</p>
<ul>
<li><p><strong>Window对象：浏览器窗口对象</strong></p>
<ul>
<li><p>获取：直接使用window，其中window. 可以省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性：获取其他四个BOM对象</p>
</li>
<li><p>方法：</p>
<ul>
<li><strong>alert()</strong>  显示带有一段消息和一个确认的警告框</li>
<li><strong>confirm()</strong>   显示带有一段消息和确认和取消的对话框，点确定会返回ture，点取消会返回false</li>
<li><strong>setInterval()</strong>  按照指定的周期(毫秒计)来调用函数或计算表达式（定时器，循环执行）</li>
<li><strong>setTimeout()</strong>  在指定的毫秒后调用函数或计算表达式（定时器，只执行一次）</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Navigator：浏览器对象</strong></p>
<p>常用：userAgent  返回由客服端发送给服务器的user-agent头部的值。</p>
<p>使用下面代码尅判断用户在那个终端打开页面，以实现跳转：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad| pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MOOBrowser|JUC|Fennec|wosBrowser|BrowserNG|Webos|Symbian|Windows Phone)/i</span>)))&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> =<span class="string">&quot;&quot;</span>	<span class="comment">//手机</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> =<span class="string">&quot;&quot;</span>	<span class="comment">//电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Screen：屏幕对象</strong></p>
</li>
<li><p><strong>History：历史记录对象</strong></p>
<ul>
<li><p>获取：使用window.history获取，其中window. 可以省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.方法();</span><br><span class="line">history.方法();</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法：</p>
<ul>
<li><strong>back()</strong>   后退，加载history列表的前一个url</li>
<li><strong>forward()</strong>  前进，加载history列表的下一个url</li>
<li>go(参数)   参数为n，前进n个页面，参数为-n，后退n个页面</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Location：地址栏对象</strong></p>
<ul>
<li><p>获取：使用window.location获取，其中window. 可以省略。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.location.方法();</span><br><span class="line">location.方法();</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>URL</strong>:同一资源定位符 Uniform Resource Locator</p>
<p>是互联网上标准资源的地址，互联网的每个文件都有唯一的url，它包含的信息指出文件的位置，以及浏览器应该怎么处理它。</p>
<p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protocol://host[:port]/path/[?query]#fragment</span><br><span class="line">如:http:/www.baidu.cn/index.html?name=andy&amp;age=18#link</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>protocol</td>
<td>通信协议常用的http, ftp, maito 等</td>
</tr>
<tr>
<td>host</td>
<td>主机（域名）</td>
</tr>
<tr>
<td>port</td>
<td>端口号，可选，省略时使用方案的默认端口如http的默认端口为80</td>
</tr>
<tr>
<td>path</td>
<td>路径，由零或多个 ‘&#x2F;‘ 符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td>
</tr>
<tr>
<td>query</td>
<td>参数，以键值对的形式，通过&amp;符号分隔开来</td>
</tr>
<tr>
<td>fragment</td>
<td>片段，#后面内容，常见于链接、锚点</td>
</tr>
</tbody></table>
</blockquote>
</li>
<li><p>属性：</p>
<p><strong>location.href</strong>   设置或返回完整的url</p>
<p>location.host	返回主机&#x2F;域名</p>
<p>location.port	返回端口号，如果未写则返回空字符串</p>
<p>location.pathname	返回路径</p>
<p><strong>location.search</strong>	返回参数</p>
<p>location.hash	返回片段</p>
<blockquote>
<p>案例：第一页面，使用提交表单，url里的参数会携带表单的数据到另一个页面。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;index.html&quot;</span></span></span><br><span class="line"><span class="tag">      用户名<span class="attr">:</span> &lt;<span class="attr">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span>&gt;</span></span><br><span class="line">	  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个页面 url为index.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 假设表单提交的用户名输入为andy，则使用location.search得到 ?uname=andy --&gt;</span></span><br><span class="line">var arr = location.search.substr(1).split(&#x27;=&#x27;);  <span class="comment">&lt;!-- 去掉问号，再根据等于号做分割，则arr[1]就是名字andy了</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值</th>
</tr>
</thead>
<tbody><tr>
<td>location.assign(url)</td>
<td>跟href一样，可以跳转页面&#x2F;重定向页面；记录历史</td>
</tr>
<tr>
<td>location.replace(url)</td>
<td>替换当前页面，不记录历史，所以不能后退</td>
</tr>
<tr>
<td>location.reload()</td>
<td>重新加载页面，相当于刷新（部分有缓存的，从缓存获取数据）；如果参数为true，为强制刷新（从服务器重新获取数据）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h4><ul>
<li><p>onload事件是等页面内容全部加载完毕 才会开始执行。</p>
<ul>
<li><p><strong>document.addEventListener(‘load’, function(){ })</strong></p>
</li>
<li><p>window.onload &#x3D; function(){ }  &#x2F;&#x2F;传统方式只有最后一个onload生效</p>
</li>
</ul>
</li>
<li><p>DOMContentLoaded 是只需DOM加载完毕，不包括flash， css等 就可以执行，速度比load快一些。</p>
<ul>
<li><strong>document.addEventListener(‘DOMContentLoaded’, function(){})</strong></li>
</ul>
</li>
</ul>
<h4 id="窗口大小调整"><a href="#窗口大小调整" class="headerlink" title="窗口大小调整"></a>窗口大小调整</h4><ul>
<li><p><strong>window.addEventListener(“resize”, function(){})</strong></p>
</li>
<li><p>window.onreasize &#x3D; function(){ }</p>
</li>
</ul>
<p>常用于响应式布局</p>
<h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul>
<li><p><strong>setTimeout（函数，延迟时间）</strong> </p>
<p>延迟设定的时候后调用函数。</p>
<p>时间单位：毫秒，省略时默认为0毫秒；</p>
<p>浏览器中经常需要多个定时器，为了区分，一般把定时器赋值给一个变量，以起一个名字。</p>
<blockquote>
<p>setTimeout也称为回调函数callback。想click点击事件里的函数也叫回调函数。</p>
</blockquote>
<ul>
<li>清除定时器：clearTimeout (定时器)</li>
</ul>
</li>
<li><p><strong>setInterval（函数，间隔时间）</strong></p>
<p> 每隔设定的时间调用以此函数。</p>
<ul>
<li>clearInterval（定时器）</li>
</ul>
</li>
</ul>
<h3 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h3><p>Document Object Model，文档对象模型，JS将标记语言的各个组成部分封装为对象，分别有：Document，Element，Attribute，Text，Comment。</p>
<p>JS通过DOM，能对HTML进行操作：改变内容、样式，对事件做出反应，添加和删除元素。</p>
<ul>
<li><p><strong>Document：整个文档对象</strong></p>
</li>
<li><p><strong>Element：元素对象</strong></p>
<ul>
<li><p>获取：使用document对象的方法获取（document.方法 或者 document对象.方法）</p>
<ul>
<li><p>getElementByld</p>
<p>根据id属性值取，返回一个Element对象</p>
</li>
<li><p>getElementsByTagName</p>
<p>根据标签名称获取，返回Element对象数组</p>
</li>
<li><p>getElementsByName</p>
<p>根据name属性值获取，返回Element对象数组</p>
</li>
<li><p>getElementsByClassName</p>
<p>根据class属性值获取，返回Element对象数组</p>
</li>
<li><p><strong>querySelector(选择器)</strong></p>
<p>返回指定选择器的<strong>第一个元素对象</strong>，选择器需要<strong>加符号以区分： .类名    #id    标签名</strong></p>
</li>
<li><p><strong>querySelectorAll (选择器)</strong></p>
<p>返回指定选择器的<strong>所有元素对象集合</strong>，选择器需要加符号以区分 </p>
</li>
<li><p>获取特殊元素：bod y，html</p>
<p><strong>document.body</strong> ：返回body元素对象</p>
<p><strong>document.documentElement</strong>：返回html元素对象</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Attribute：属性对象</strong></p>
</li>
<li><p><strong>Text：文本对象</strong></p>
</li>
<li><p><strong>Comment：注释对象</strong></p>
</li>
</ul>
<hr>
<h4 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h4><ul>
<li><p>普通盒子修改，如div标签：</p>
<ul>
<li><p>对象.<strong>innerHTML</strong></p>
<p>可以识别html标签，保留空格和换行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="comment">//修改后的内容或对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对象.<strong>innerText</strong></p>
<p>不识别html标签，去除空格和换行</p>
</li>
</ul>
</li>
<li><p>表单内容修改：</p>
<p>对象**.value** &#x3D;  修改内容</p>
</li>
<li><p>修改样式：</p>
<ul>
<li><p>行内样式操作（适合样式较少的情况）：</p>
<p>对象.<strong>style.样式&#x2F;属性</strong> &#x3D;  修改内容</p>
</li>
<li><p>类名样式操作（适合样式复杂的情况）：</p>
<p>对象.<strong>className</strong> &#x3D; 新类名（修改内容放在新类名里）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.change</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    对象.<span class="property">className</span> = <span class="string">&#x27;change&#x27;</span>;<span class="comment">//覆盖原先的类名</span></span></span><br><span class="line"><span class="language-javascript">    对象.<span class="property">className</span> = <span class="string">&#x27;原类名 新类名&#x27;</span>;<span class="comment">//不会覆盖原先的类名，存在多类名</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>禁用元素：   </p>
<p>对象.<strong>disabled</strong> &#x3D;  true；</p>
</li>
</ul>
<hr>
<h4 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h4><p><strong>获取属性值</strong>:</p>
<ul>
<li><strong>element.属性</strong> —— 获取内置属性值</li>
<li><strong>element.getAttribute(‘属性’)</strong> ——  主要获取自定义的属性</li>
</ul>
<p><strong>设置属性值</strong>： </p>
<ul>
<li><strong>element.属性 &#x3D; ‘值’</strong> —— 设置内置属性</li>
<li><strong>element.setAttribute(‘属性’，’值’)</strong> —— 主要设置自定义属性</li>
</ul>
<p><strong>移除属性</strong>：</p>
<ul>
<li><strong>element.removeAttribute(‘属性’)</strong></li>
</ul>
<blockquote>
<p>H5规定：</p>
<p>设置自定义属性要以 <strong>data-</strong> 开头，并且赋值。如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-index</span> = <span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-index&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>H5新增的获取自定义属性的方法（ie11后支持）：</p>
<p>使用dataset存放所有以data开头的自定义属性，通过dataset时属性名不用加 data- 前缀。</p>
<ul>
<li>element.dataset.属性名</li>
<li>element.dataset[‘属性名’]</li>
</ul>
<p>如果自定义属性中由多个 -链接的单词，获取时使用驼峰命名法，去掉 - </p>
</blockquote>
<p>阻止链接跳转：添加 <strong>javascript：；</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:;&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><p>节点：网页中所有内容都是节点 (标签，属性，文本，注释)，在DOM中，节点用node表示。</p>
<p><strong>基本属性：</strong></p>
<ul>
<li><p><strong>nodeType</strong>（节点类型）</p>
<ul>
<li>元素节点 nodeType为1</li>
<li>属性节点 nodeType为2</li>
<li>文本节点 nodeType为3（文本节点包括文字，空格，换行等）</li>
</ul>
<blockquote>
<p>实际主要操作的是元素节点</p>
</blockquote>
</li>
<li><p><strong>nodeName</strong>（节点名称）</p>
</li>
<li><p><strong>nodeValue</strong>（节点值）</p>
</li>
</ul>
<p><strong>节点层级：</strong></p>
<ul>
<li><p>父节点： <strong>节点 .parenNode</strong></p>
<blockquote>
<p>返回指定节点的最近的父 节点，如果没有父节点则返回null</p>
</blockquote>
</li>
<li><p>子节点：节点 .childNodes</p>
<blockquote>
<p> 返回指定节点的子节点的集合，包括元素节点，文本节点等，需要再处理后才能得到元素节点，较麻烦，一般不使用。</p>
<p>可以使用 <strong>节点 .children</strong> 来获取子元素节点，虽然不是标准规定，但各浏览器2都支持。</p>
</blockquote>
<p>首个字节点和最后一个子节点： </p>
<ul>
<li>节点 .children[0] ——首个</li>
<li>节点.children[节点.children.lenght - 1] ——最后一个</li>
</ul>
</li>
<li><p>下一个兄弟元素节点： <strong>节点. nextElementSibling</strong></p>
<p>上一个兄弟元素节点： <strong>节点. previousElementSibling</strong></p>
</li>
</ul>
<p><strong>创建节点：</strong> <strong>document.createElement(‘新节点名’)</strong></p>
<p><strong>添加节点：</strong></p>
<ul>
<li><strong>父节点.appendChild(新建的节点)</strong> —— 添加到父节点的子节点列表的末尾</li>
<li><strong>父节点 .insertBefore(‘新建的节点’，指定节点)</strong> ——添加到指定子节点的前面</li>
</ul>
<p><strong>删除节点：</strong>  <strong>父节点.removeChild(要删除的子节点)</strong></p>
<p><strong>复制节点：</strong> <strong>节点.cloneNode()</strong> ——如果括号里参数为空 或者为 false，则为浅拷贝，即只复制节点本身，不复制里面的内容；括号里为true，则为深拷贝，复制标签和里面的子节点。 </p>
<hr>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件：HTML事件是发生在HTML元素上的”事情”。比如：按钮被点击，鼠标移动到元素之上，按下键盘按键。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象.事件 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    事件处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul>
<li><strong>事件源：</strong>事件被触发的对象</li>
<li><strong>事件类型：</strong>如何触发&#x2F;发生了什么事件</li>
<li><strong>事件处理程序：</strong>通过函数赋值的方式进行</li>
</ul>
<p>事件监听：JavaScript可以在事件被侦测到时执行代码。</p>
<h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>新方式——事件监听方式：</p>
<p><strong>对象. addEventListener(事件类型，处理函数，flag）</strong></p>
<blockquote>
<p>事件监听方式：</p>
<p>事件类型 为字符串形式，如：click，mouseover，注意不再带on</p>
<p>第三个参数flag，如果为false或省略，那么事件流处于冒泡阶段，如果为true，则为捕获阶段。实际开发中，很少使用事件捕获，不过有些事件没有冒泡，如：onblur，onfocus，onmouseenter，onmouseleave</p>
</blockquote>
<p>传统方式：</p>
<ul>
<li><p>方法一：通过HTML标签中的事件属性进行绑定（耦合）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">&quot;button&quot;</span> onclick=<span class="string">&#x27;on()&#x27;</span> &gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title function_">alet</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
</li>
<li><p>方法二：通过DOM元素属性绑定（推荐）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">&quot;button&quot;</span> id = <span class="string">&quot;btn&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementByld</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	<span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h4><p>事件监听方式：对象. removeEventListener(事件类型，处理函数) </p>
<p>传统方式：对象. 事件类型 &#x3D; null</p>
<h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>分为3个阶段：</p>
<ol>
<li>捕获阶段：由最顶层节点开始，然后逐级向下传播到最具体(最小)的元素。</li>
<li>当前目标阶段</li>
<li>冒泡阶段：事件开始由最具体(最小)的元素接收，然后逐级传播到最顶层阶段。</li>
</ol>
<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705818.png" alt="image-20220312204641336"></p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>event 是一个事件对象，写在监听函数的小括号里当形参，事件对象只有事件发生了才会存在，是系统自动创建的，不需要传递实参进去。</p>
<p>事件对象：是事件的一系列相关数据的集合，跟事件相关的，如鼠标点击里就包含了鼠标坐标之类的信息。</p>
<blockquote>
<p>事件对象可以自己命名，如event，evt，e </p>
</blockquote>
<p><strong>属性方法</strong></p>
<table>
<thead>
<tr>
<th>属性&#x2F;方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>e.target</td>
<td>返回触发事件的对象</td>
</tr>
<tr>
<td>e.type</td>
<td>返回事件的类型</td>
</tr>
<tr>
<td>e.preventDefault()</td>
<td>阻止事件的默认行为，如阻止链接跳转</td>
</tr>
<tr>
<td>e.stopPropagation()</td>
<td>阻止冒泡</td>
</tr>
</tbody></table>
<blockquote>
<p>在监听函数中，e.target指触发事件的对象，this指绑定该事件的对象。</p>
</blockquote>
<h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p>事件对象.stopPropagation()</p>
<blockquote>
<p>低版本浏览器：window.event.cancelBubble &#x3D; true;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e &amp;&amp; e.<span class="property">stopPropagation</span>)&#123;<span class="comment">//浏览器是否认识新特性</span></span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>阻止默认行为： event.preventDefault() </p>
</blockquote>
<h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>对于子节点要设置相同的事件监听，可以不用在子节点上单独设置，而是设置在其父节点上，然后利用冒泡原理影响设置的每个子节点。</p>
<p>作用：只操作了以此DOM，提供了程序的性能。</p>
<blockquote>
<p>如果只想操作触发事件的那个子节点，可以利用e.target 得到触发事件的那个子节点</p>
</blockquote>
<h4 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h4><blockquote>
<p>使用传统方式window. 时，事件前要加on，如onclick，onfocus</p>
</blockquote>
<p>click：对象被点击</p>
<p> focus：鼠标获得焦点</p>
<p>blur：鼠标失去焦点</p>
<p>mouseover：鼠标经过 </p>
<p>mouseout：鼠标离开</p>
<p>mousemove：鼠标移动触发</p>
<p>mouseup：鼠标弹起触发</p>
<p>mousedown：鼠标按下触发</p>
<p>submit：确认按钮被点击（常用于v 表单提交）</p>
<p>change：域的内容被改变</p>
<p>keydown：某个按键被按下</p>
<p>keyup：某个按键被松开</p>
<p>keypress：某个按键被按下，但不识别ctrl shift等功能键</p>
<blockquote>
<p>mouseover 和 mouseenter 区别：</p>
<p>mouseover 经过自身盒子会触发，经过子盒子还会触发；</p>
<p>mouseenter 只会经过自身盒子触发</p>
</blockquote>
<hr>
<p><strong>鼠标事件对象</strong></p>
<p>属性：</p>
<p>e.clientX &#x2F; e.clientY —— 鼠标相对于浏览器窗口的X&#x2F;Y坐标</p>
<p>e.pageX &#x2F; e.pageY —— 鼠标相对于文档页面的X&#x2F;Y坐标</p>
<p>e.screenX &#x2F; e.screenY —— 鼠标相对于电脑屏幕的X&#x2F;Y坐标</p>
<blockquote>
<p>禁止鼠标右键菜单</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;contextmenu&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>禁止鼠标选中</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;selectstart&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>键盘事件对象</strong></p>
<p>属性：</p>
<p>keyCode：识别按下的是哪个键</p>
<blockquote>
<p>事件keyup和keydown不区分字母大小写，keypress区分大小写</p>
</blockquote>
<blockquote>
<p>例子：按s键，使搜索框获得焦点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="variable language_">document</span>.<span class="title function_">queryAelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">	<span class="keyword">if</span>(e.<span class="property">keyCode</span> === <span class="number">83</span>)&#123;</span><br><span class="line">        search.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="网页特效"><a href="#网页特效" class="headerlink" title="网页特效"></a>网页特效</h3><h4 id="元素偏移量-offset"><a href="#元素偏移量-offset" class="headerlink" title="元素偏移量 offset"></a>元素偏移量 offset</h4><ul>
<li><p>获得元素距离带有定位父元素的位置</p>
</li>
<li><p>获得元素自身的大小（宽度高度）</p>
<blockquote>
<p>注意：返回的数值都不带单位</p>
</blockquote>
</li>
</ul>
<p>常用属性：</p>
<table>
<thead>
<tr>
<th>offset系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.offsetParent</td>
<td>返回该元素带有定位的父元素，如果父级都无定位则返回body</td>
</tr>
<tr>
<td>element.offsetTop</td>
<td>返回元素相对带有定位父元素上方的偏移</td>
</tr>
<tr>
<td>element.offsetLeft</td>
<td>返回元素相对带有定位父元素左边框的偏移</td>
</tr>
<tr>
<td>element.offsetWidth</td>
<td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td>
</tr>
<tr>
<td>element.offsetHeight</td>
<td>返回自身包括padding、边框、内容区的高度，返回数值不带 单位</td>
</tr>
</tbody></table>
<p>offset与style的区别：</p>
<table>
<thead>
<tr>
<th>offset</th>
<th>style</th>
</tr>
</thead>
<tbody><tr>
<td>offset可以得到任意样式表中的样式值</td>
<td>style只能得到行内样式表中的样式值</td>
</tr>
<tr>
<td>offset系列获得的数值是没有单位的</td>
<td>style.width获得的是带有单位的字符串</td>
</tr>
<tr>
<td>offsetWidth包含padding+border+width</td>
<td>style.width获得不包含padding和border的值</td>
</tr>
<tr>
<td>offsetWidth等属性是只读属性，只能获取不能赋值</td>
<td>style.width是可读写属性，可以获取也可以赋值</td>
</tr>
</tbody></table>
<p>所以，想要获取元素大小位置，用offset更合适；想要给元素更改值，则需要用stye改变</p>
<h4 id="元素可视区-client"><a href="#元素可视区-client" class="headerlink" title="元素可视区 client"></a>元素可视区 client</h4><p>client翻译：客户端。可以动态获取元素可视区的相关信息</p>
<table>
<thead>
<tr>
<th>client系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.clientTop</td>
<td>返回元素上边框的大小</td>
</tr>
<tr>
<td>element.clientLeft</td>
<td>返回元素左边框的大小</td>
</tr>
<tr>
<td>element.clientWidth</td>
<td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.clientHeight</td>
<td>返回自身包括padding、内容区的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<h4 id="元素滚动-scroll"><a href="#元素滚动-scroll" class="headerlink" title="元素滚动 scroll"></a>元素滚动 scroll</h4><p>scroll翻译：滚动。可以动态的得到该元素的大小，滚动距离等</p>
<table>
<thead>
<tr>
<th>scroll系列属性</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>element.scrollTop</td>
<td>返回被卷去的上侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollLeft</td>
<td>返回被卷去的左侧距离，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollWidth</td>
<td>返回自身<strong>实际</strong>的宽度，不含边框，返回数值不带单位</td>
</tr>
<tr>
<td>element.scrollHeight</td>
<td>返回自身实际的高度，不含边框，返回数值不带单位</td>
</tr>
</tbody></table>
<p>常用方法：window.scroll(x, y) 滚动窗口至文档的特定位置</p>
<blockquote>
<p>offset系列经常用于获得元素位置 offsetLeft  offsetTop</p>
<p>client 经常用于获取元素大小 clientWidth  clientHeight</p>
<p>scroll 经常用于获取滚动距离 scrallTop  scrollLeft</p>
<p>注意：页面滚动的距离通过 window.pagexoffset 获得</p>
</blockquote>
<h4 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h4><p>动画实现原理：通过定时器setInterval() 不断移动盒子位置。</p>
<blockquote>
<p>步骤：</p>
<ol>
<li>获取盒子当前位置</li>
<li>让盒子在当前位置加上一个移动距离</li>
<li>利用定时器不断重复操作，并加一个结束的条件</li>
</ol>
<p>注意 此元素需要<strong>添加定位</strong>，才能使用element.style.left</p>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将移动效果封装成函数，调用即可</span></span><br><span class="line"><span class="comment">//obj是传入的对象，target是要移动的距离，callback为传入的其他函数，用于实现额外的效果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">obj, target，callback</span>)&#123;</span><br><span class="line">    <span class="comment">//防止同一对象同时开启多个定时器(只保留当前一个定时器执行)</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(obj.<span class="property">timer</span>); 	</span><br><span class="line">    <span class="comment">//将timer作为传入对象obj的属性，可以避免开辟过多空间</span></span><br><span class="line">    obj.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> step = (target - obj.<span class="property">offsetLeft</span>) / <span class="number">10</span>;	<span class="comment">//实现缓动效果，速度从快到慢</span></span><br><span class="line">        step = step &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(step) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(step); <span class="comment">//去掉小数点</span></span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="property">offsetLeft</span> &gt;= target)&#123;</span><br><span class="line">        <span class="title function_">cleatInterval</span>(obj.<span class="property">timer</span>); 	<span class="comment">//停止定时器</span></span><br><span class="line">        callback &amp;&amp; callback;	<span class="comment">//如果回调函数存在就执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//步长值变化</span></span><br><span class="line">    obj.<span class="property">style</span>.<span class="property">left</span> = obj.<span class="property">offsetLeft</span> + s + <span class="string">&#x27;px&#x27;</span>;&#125;,<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="title function_">animate</span>(div, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>

</blockquote>
<p>因为动画函数经常被使用，所以可以将其单独封装到一个JS文件里面，使用的时候应用这个JS文件即可。</p>
<h4 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h4><p>作用：当上一个函数动画内容执行完毕，再取执行下一个函数动画，让事件不会连续过快触发。</p>
<p>思想：利用回调函数，添加一个变量来控制，所著函数和解锁函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    ......   <span class="comment">//动画安徽念书</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>本地存储特性：</p>
<ul>
<li>数据存储在用户浏览器中</li>
<li>设置、读取方便、甚至页面刷新不丢失数据</li>
<li>容量较大，sessionStorage约5M、localStorage约20M</li>
<li>只能存储字符串，可以将对象SON.stringify0编码后存储</li>
</ul>
<hr>
<p><strong>sessionStorage</strong></p>
<p>特点：</p>
<ul>
<li>生命周期为关闭浏览器窗口</li>
<li>在同一个窗口页面下数据可以共享</li>
<li>以键值对的形式存储使用</li>
</ul>
<p>方法：</p>
<ul>
<li><p>存储数据：</p>
<p>sessionStorage.setItem（key, value）</p>
</li>
<li><p>获取数据：</p>
<p>sessionStorage.getItem（key）</p>
</li>
<li><p>删除数据：</p>
<p>sessionStorage.removeItem（key）</p>
</li>
<li><p>删除所有数据</p>
<p>sessionStorage.clear()</p>
</li>
</ul>
<hr>
<p><strong>localStorage</strong></p>
<p>特点：</p>
<ul>
<li>生命周期永久生效，除非手动删除否则关闭页面也会存在</li>
<li>可以多窗口（页面）共享（同一浏览器可以共享）</li>
<li>以键值对的形式存储使用</li>
</ul>
<p>方法：</p>
<ul>
<li><p>存储数据：</p>
<p>localStorage.setItem（key, value）</p>
</li>
<li><p>获取数据：</p>
<p>localStorage.getItem（key）</p>
</li>
<li><p>删除数据：</p>
<p>localStorage.removeItem（key）</p>
</li>
<li><p>删除所有数据</p>
<p>localStorage.clear()</p>
</li>
</ul>
<h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery是JavaScript库，封装了JS中的DOM操作。</p>
<blockquote>
<p>j 指 JavaScript，query 查询</p>
</blockquote>
<p>优点：</p>
<ul>
<li>轻量级。核心文件才几十kb,不会影响页面加截速度</li>
<li>跨浏览器兼容。基本兼容了现在主流的浏览器</li>
<li>链式编程、隐式迭代</li>
<li>对事件、样式、动画支持，大大简化了DOM操作</li>
<li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等</li>
<li>免费、开源</li>
</ul>
<p><strong>入口函数</strong></p>
<p>等DOM接口渲染完毕即可执行内部代码，相当于原生js中的DOMContentLoaded</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">	....  <span class="comment">//此处是页面DOM加载完成的入口</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>



<h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>顶级对象 $</strong></p>
<p>$是jQuery的别称，在代码中也可以使用jQuery代替$。</p>
<p>$是jQuery的顶级对象，相当于原生JS中的window。把元素利用$包装成jQuery对象，就可以调用jQuery的方法。</p>
<p><strong>jQuery对象 和 DOM对象</strong></p>
<p>用原生JS获取过来的对象就是DOM对象。</p>
<p>用 jQuery 方式获取过来的对象是jQuery)对象。本质：通过$把DOM元素进行了包装</p>
<blockquote>
<p>DOM对象只能使用原生的 JS 属性和方法</p>
<p>jQuery对象只能使用 jQuery 方法</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelect</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">//jQuery对象</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>jQuery对象 和 DOM对象 相互转换：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM对象转换为jQuery对象</span></span><br><span class="line">$(<span class="variable constant_">DOM</span>对象)</span><br><span class="line"><span class="comment">//jQuery对象转换为DOM对象</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>)[index]</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">get</span>(index)</span><br></pre></td></tr></table></figure>



<h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><h5 id="选择器操作"><a href="#选择器操作" class="headerlink" title="选择器操作"></a>选择器操作</h5><p><strong>选择器： $(“选择器”)</strong></p>
<p>**筛选选择器： **</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>用法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>:first</td>
<td>$(“li:first”)</td>
<td>获取第一个li元素</td>
</tr>
<tr>
<td>:last</td>
<td>$(“li:last”)</td>
<td>获取最后一个li元素</td>
</tr>
<tr>
<td>:eq(index)</td>
<td>$(“li:eq(2)”)</td>
<td>获取的li元素中，选择下标为2的元素</td>
</tr>
<tr>
<td>:odd</td>
<td>$(“li:odd”)</td>
<td>获取的li元素中，选择下标为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$(“li:even”)</td>
<td>获取的li元素中，选择下标为偶数的元素</td>
</tr>
</tbody></table>
<p><strong>筛选方法：</strong></p>
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>用法</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>parent()</strong></td>
<td>$(“li”).parent()</td>
<td>查找父级</td>
</tr>
<tr>
<td><strong>children(selector)</strong></td>
<td>$(“ul”).children(“li”)</td>
<td>相当于$(“u1&gt;li”),最近一级（亲儿子）</td>
</tr>
<tr>
<td><strong>find(selector)</strong></td>
<td>$(“ul”).find(“li”);</td>
<td>相当于$(“ul li”), 后代选择器</td>
</tr>
<tr>
<td><strong>siblings(selector)</strong></td>
<td>$(“.first”).siblings(“li”);</td>
<td>查找兄弟节点，不包括自己本身</td>
</tr>
<tr>
<td>nextAll ([expr])</td>
<td>$(“.first”).nextAll ()</td>
<td>查找当前元素之后所有的同辈元素</td>
</tr>
<tr>
<td>prevAll (class)</td>
<td>$(“.last”).prevAll ()</td>
<td>查找当前元素之前所有的同辈元素</td>
</tr>
<tr>
<td>hasClass (class)</td>
<td>$(‘div’).hasclass(“protected”)</td>
<td>检查当前的元素是否含有某个特定的类，如果有，则返回true</td>
</tr>
<tr>
<td><strong>eq (index)</strong></td>
<td>$(“li”).eq(2);</td>
<td>相当于$(“1i:eq(2)”), index从0开始</td>
</tr>
</tbody></table>
<p><strong>jQuery使用排他思想：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：思想点击 背景颜色跟随</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//隐式迭代，给所有按钮绑定点击事件</span></span><br><span class="line">    $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//当前元素设置背景颜色</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        <span class="comment">//其余兄弟去掉背景颜色</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">siblings</span>(<span class="string">&quot;button&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>链式编程：</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来写法</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">siblings</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//链式编程写法，节省代码量，比较简洁</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>).<span class="title function_">siblings</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h5><p><strong>设置样式：</strong></p>
<ul>
<li><p><strong>$(“选择器”).css(“属性”)</strong> —— 只写属性，则返回属性值</p>
</li>
<li><p><strong>$(“选择器”).css(“属性”,”值”)</strong> ——设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号</p>
</li>
<li><p><strong>$(“选择器”).css( {color: “red”, font-size: 20});</strong> ——参数是对象形式，可以设置多组样式，属性和值用冒号隔开，属性可以不加引号</p>
</li>
</ul>
<blockquote>
<p>DOM元素设置样式需要显式迭代，而jQuery对象是以伪数组形式存储，它在设置样式时会自动遍历内部DOM元素，即隐式迭代。</p>
</blockquote>
<p><strong>类操作：</strong></p>
<ul>
<li>添加类：**$(“div”).addClass(“类名”)**</li>
<li>删除类：**$(“div”).removeClass(“类名”)**</li>
<li>切换类：**$(“div”).toggleClass(“类名”)**</li>
</ul>
<blockquote>
<p>可以先为某个类设置样式，需要时再通过类操作来修改样式。</p>
</blockquote>
<hr>
<h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>显示隐藏</p>
<ul>
<li><p>**show **( [speed], [easing], [fn] ) —— 显示</p>
<blockquote>
<p>参数都可以省略，则无动画直接显示</p>
<p>speed：预定字符串(“slow”,”normal”,”fast”)或动画时长的毫秒值；</p>
<p>easing：用来指定切换效果，默认”swing“，可选参数“linear”；</p>
<p>fn：回调函数，在动画完成时执行，每个元素执行一次。</p>
<p>（一般都是不加参数直接显示隐藏的）</p>
</blockquote>
</li>
<li><p>**hide **( [speed, [easing], [fn]] ) —— 隐藏</p>
</li>
<li><p><strong>toggle</strong> ( [speed, [easing], [fn]] ) —— 切换显示和隐藏</p>
</li>
</ul>
<p>滑动</p>
<ul>
<li><strong>slideDown</strong> ( [speed, [easing], [fn]] ) —— 下拉</li>
<li><strong>slideUp</strong> ( [speed, [easing], [fn]] ) —— 上拉</li>
<li><strong>slideToggle</strong> ( [speed, [easing], [fn]] ) ——切换上下拉动</li>
</ul>
<p>淡入淡出</p>
<ul>
<li><p><strong>fadeIn</strong> ( [speed, [easing], [fn]] ) —— 淡入</p>
</li>
<li><p><strong>fadeOut</strong> ( [speed, [easing], [fn]] ) —— 淡出</p>
</li>
<li><p><strong>fadeToggle</strong> ( [speed, [easing], [fn]] ) —— 切换淡入淡出</p>
</li>
<li><p><strong>fadeTo</strong> ( [speed, opacity, [easing], [fn]] ) —— 修改透明度</p>
<blockquote>
<p>speed速度为动画时长，必须写，</p>
<p>opacity透明度必须写，</p>
</blockquote>
</li>
<li><p><strong>animate</strong> ( params, [speed], [easing], [fn] ) —— 自定义动画</p>
<blockquote>
<p>params： 样式选择，以对象形式传递，必须写</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">	&#123;$(<span class="string">&quot;button&quot;</span>).click(<span class="keyword">function</span>(&#123;</span></span><br><span class="line"><span class="params">  		$(<span class="string">&quot;div&quot;</span>).antimate(&#123;</span></span><br><span class="line"><span class="params">        	legt:<span class="number">200</span></span></span><br><span class="line"><span class="params">   		&#125;);</span></span><br><span class="line"><span class="params">	&#125;)</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h5><p>hover 是鼠标经过和离开的复合写法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数分别是鼠标经过和鼠标离开时分别调用的函数</span></span><br><span class="line">$(<span class="string">&quot;.nav&gt;li&quot;</span>).<span class="title function_">hover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="comment">//只写一个函数，则鼠标经过和离开都会调用这个函数</span></span><br><span class="line">$(<span class="string">&quot;.nav&gt;li&quot;</span>).<span class="title function_">hover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">children</span>(<span class="string">&quot;ul&quot;</span>).<span class="title function_">slideToggle</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h5 id="停止排队"><a href="#停止排队" class="headerlink" title="停止排队"></a>停止排队</h5><p>动画效果一旦触发就会执行，如果多次触发，就会使多个动画同时执行。</p>
<p>停止排队：<strong>stop()</strong> —— 用于停止动画效果。可以写到动画的前面，相当于停止上一次的动画。</p>
<hr>
<h5 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h5><p>获取元素固有属性的值：prop(“属性名”)</p>
<p>设置固有属性值： prop(“属性”，”属性值”)</p>
<blockquote>
<p>元素固有属性就是元素本身自带的属性，如&lt; a &gt;里的href，&lt; input &gt; 里的type。</p>
</blockquote>
<p>获取元素自定义属性的值：attr(“属性”)</p>
<p>设置元素自定义属性的值：attr(“属性”，“属性值”)</p>
<blockquote>
<p>类似原生的getAttribute()和setAttribute()</p>
</blockquote>
<p>数据缓存data()：可以在指定的元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都将被移除。</p>
<p>获取：data(“属性”) ；设置：data(“属性”,”值”)</p>
<hr>
<h5 id="内容文本值"><a href="#内容文本值" class="headerlink" title="内容文本值"></a>内容文本值</h5><p>**普通元素内容：html()**，相当于原生innerHTML。</p>
<blockquote>
<p>获取：html()</p>
<p>设置：html(“内容”)</p>
</blockquote>
<p>**普通元素文本内容：text()**，相当于原生innerText。</p>
<blockquote>
<p>获取：text()</p>
<p>设置：text(“内容”)</p>
</blockquote>
<p><strong>表单的值 val()</strong> ，相当于原生value</p>
<blockquote>
<p>获取：val()</p>
<p>设置：val(“内容”)</p>
</blockquote>
<hr>
<h5 id="元素操作-1"><a href="#元素操作-1" class="headerlink" title="元素操作"></a>元素操作</h5><p>jQuery隐式迭代是对同一类元素做同样的操作，如果想要给同一元素做不同操作，仍需要遍历。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">index,domEle</span>)&#123;...&#125;))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>index是每个元素的索引号，domEle是每个DOM元素对象，注意不是jquery对象，要用jquery方法，需要进行对象转化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">each</span>(object, <span class="keyword">function</span>(<span class="params">index, element</span>)&#123;&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>object可以是任何对象，所以$each主要用于数据处理，如数组，对象；</p>
</blockquote>
<h5 id="尺寸、位置操作"><a href="#尺寸、位置操作" class="headerlink" title="尺寸、位置操作"></a>尺寸、位置操作</h5><p>尺寸：</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>width() &#x2F; height()</td>
<td>只算width &#x2F; height</td>
</tr>
<tr>
<td>innerWidth() &#x2F; innerHeight()</td>
<td>包含padding</td>
</tr>
<tr>
<td>outerWidth() &#x2F; outerHeight()</td>
<td>包含padding、border</td>
</tr>
<tr>
<td>outerWidth(true) &#x2F; outerHeight(true)</td>
<td>包含padding、borde、margin</td>
</tr>
</tbody></table>
<p>位置：</p>
<p>offset()</p>
<p>设置或返回距离文档的位置(偏移)，跟父级没有关系。offset().left 获取距离文档左侧的距离， offset().top 获取距离文档顶部的距离</p>
<ul>
<li>scrollTop()</li>
</ul>
<p>设置或返回被卷去的头部。</p>
<p>同样有 scrollTop().left 和 scrollTop().top 两个属性。</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><h5 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.事件(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="comment">//例:</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p><strong>on() 绑定事件</strong>：匹配元素上绑定一个或多个事件的处理函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">on</span>(events, [selector], fn)</span><br></pre></td></tr></table></figure>

<p>events：一个或多个用空格分割的事件类型；</p>
<p>selector：元素的子元素选择器；</p>
<p>fn：回调函数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定多个事件，多个处理程序</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">on</span>(&#123;</span><br><span class="line">    <span class="attr">mouseenter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;skyblue&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">click</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;purple&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果绑定事件的处理程序相同:</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">in</span>(<span class="string">&quot;mouseover mouseout&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">toggleClass</span>(<span class="string">&quot;current&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以实现事件委派，把原来加给子元素的事件绑定到父元素上。</span></span><br><span class="line"><span class="comment">//点击事件绑定在ul上，但触发对象是li</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//on()可以给动态生成的元素绑定事件,而原来的 $(&quot;&quot;).事件(fn)不能给动态创建的元素绑定事件</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> li = $(<span class="string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">append</span>(li);</span><br></pre></td></tr></table></figure>

<p><strong>one() 绑定事件，只触发一次</strong> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">one</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>off() 解绑事件</strong> ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">off</span>();  <span class="comment">//移除div身上的所有事件</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>);   <span class="comment">//移除div身上的点击事件</span></span><br><span class="line">(<span class="string">&quot;ul&quot;</span>).<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>);	<span class="comment">//接触li的事件委托</span></span><br></pre></td></tr></table></figure>

<p>**trigger() 自动触发事件 ** ：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">trigger</span>(<span class="string">&quot;type&quot;</span>);</span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">....    </span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>); <span class="comment">//此时自动触发事件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发事件，但不触发元素的默认行为</span></span><br><span class="line">element.<span class="title function_">triggerHandler</span>(<span class="string">&quot;type&quot;</span>);</span><br></pre></td></tr></table></figure>



<h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>ECharts是一个使用JavaScript实现的开源可视化库，兼容大部分浏览器，底层依赖矢量图形库ZRender。</p>
<h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>xml 是可扩展的标记性语言。</p>
<p>作用：</p>
<ul>
<li>主要用于存储数据，这些数据具有自我描述性；</li>
<li>作为项目或者模块的配置文件；</li>
<li>作为网络传输数据的格式（现在改为使用 JSON 为主了）。</li>
</ul>
<p>语法</p>
<ul>
<li><p>文档声明</p>
<p>xml声明：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>version 是版本的意思， </li>
<li>encoding 是编码，</li>
<li>standalone&#x3D;”yes&#x2F;no” 表示这个 xml 文件是否是独立的 xml文件</li>
</ul>
</li>
<li><p>元素（标签） </p>
<p>元素是指从开始标签到结束标签的内容。（与html一样）</p>
<p>注意<strong>大小写敏感</strong>，元素都必须<strong>闭合</strong>，必须<strong>有根元素</strong></p>
<p>命名规则：</p>
<ul>
<li>可以包含字母，数字，其他字符（包括中文）；</li>
<li>不能以数字或标点符号开头；</li>
<li>不能包含空格；</li>
</ul>
<p>元素(标签) 分 单双标签：</p>
<ul>
<li>单标签： &lt; 标签名 属性&#x3D;”值“ 属性&#x3D;”值“ …. &#x2F;&gt;</li>
<li>双标签：&lt; 标签名 属性&#x3D;”值“ …&gt; 文本或子标签 &lt;&#x2F;标签名&gt;</li>
</ul>
</li>
<li><p>xml 属性 </p>
<p>与html非常类似，注意属性的值要用 引号” “ 包起来。</p>
</li>
<li><p>文本区域（CDATA 区）</p>
<p>说明此区域是纯文本内容，不需要xml语法解析</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">	文本内容，不会被xml解析</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h3><p>dom4j 解析技术是第三方公司的技术，需要到其官网上下载dom4j的jar包，导入到idea的库中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要分四步操作:</span></span><br><span class="line"><span class="comment">// 第一步，通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象</span></span><br><span class="line"><span class="comment">// 第二步，通过 Document 对象。拿到 XML 的根元素对象</span></span><br><span class="line"><span class="comment">// 第三步，通过根元素对象。获取所有的 book 标签对象</span></span><br><span class="line"><span class="comment">// 第四小，遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readXML</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException &#123;</span><br><span class="line">	<span class="comment">// 第一步，通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象</span></span><br><span class="line">	<span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line">	<span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(<span class="string">&quot;src/books.xml&quot;</span>);</span><br><span class="line">	<span class="comment">// 第二步，通过 Document 对象。拿到 XML 的根元素对象</span></span><br><span class="line">	<span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line">	<span class="comment">// 打印测试</span></span><br><span class="line">	<span class="comment">// Element.asXML() 它将当前元素转换成为 String 对象</span></span><br><span class="line">	<span class="comment">// System.out.println( root.asXML() );</span></span><br><span class="line">	<span class="comment">// 第三步，通过根元素对象。获取所有的 book 标签对象</span></span><br><span class="line">	<span class="comment">// Element.elements(标签名)它可以拿到当前元素下的指定的子元素的集合</span></span><br><span class="line">	List&lt;Element&gt; books = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line">	<span class="comment">// 第四小，遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，</span></span><br><span class="line">	<span class="keyword">for</span> (Element book : books) &#123;</span><br><span class="line">	<span class="comment">// 测试</span></span><br><span class="line">	<span class="comment">// System.out.println(book.asXML());</span></span><br><span class="line">	<span class="comment">// 拿到 book 下面的 name 元素对象</span></span><br><span class="line">	<span class="type">Element</span> <span class="variable">nameElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">	<span class="comment">// 拿到 book 下面的 price 元素对象</span></span><br><span class="line">	<span class="type">Element</span> <span class="variable">priceElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;price&quot;</span>);</span><br><span class="line">	<span class="comment">// 拿到 book 下面的 author 元素对象</span></span><br><span class="line">	<span class="type">Element</span> <span class="variable">authorElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;author&quot;</span>);</span><br><span class="line">	<span class="comment">// 再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line">	System.out.println(<span class="string">&quot;书名&quot;</span> + nameElement.getText() + <span class="string">&quot; , 价格:&quot;</span> + priceElement.getText() + <span class="string">&quot;, 作者：&quot;</span> + authorElement.getText());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON ( JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p>
<p>JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 使得 JSON 成为理想的数据交换格式。</p>
<ul>
<li>其语法格式简单，层次结构鲜明，现多用于作为 数据载体，在网络中进行数据传输。</li>
</ul>
<blockquote>
<p>轻量级是相较xml而言；</p>
<p>数据交换指的是客户端和服务器之间业务数据的传递格式</p>
</blockquote>
<p><strong>定义：</strong></p>
<ul>
<li>json由键值对组成，用大括号包围；</li>
<li>每个键都用双引号包起来；</li>
<li>键与值之间用冒号分割。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:<span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:<span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;key4&quot;</span>:[<span class="number">11</span>,<span class="string">&quot;arr&quot;</span>,<span class="literal">false</span>],</span><br><span class="line">    <span class="string">&quot;key5&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;key5_1&quot;</span> : <span class="number">551</span>,</span><br><span class="line">        <span class="string">&quot;key5_2&quot;</span> : <span class="string">&quot;key5_2_value&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;key6&quot;</span>:[&#123;</span><br><span class="line">            <span class="string">&quot;key6_1_1&quot;</span>:<span class="number">6611</span>,</span><br><span class="line">            <span class="string">&quot;key6_1_2&quot;</span>:<span class="string">&quot;key6_1_2_value&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="string">&quot;key6_2_1&quot;</span>:<span class="number">6621</span>,</span><br><span class="line">            <span class="string">&quot;key6_2_2&quot;</span>:<span class="string">&quot;key6_2_2_value&quot;</span></span><br><span class="line">        &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>访问：</strong></p>
<p>json本身是一个对象，访问： json对象.key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof(jsonObj));<span class="comment">// object json 就是一个对象</span></span><br><span class="line">alert(jsonObj.key1); <span class="comment">//12</span></span><br><span class="line">alert(jsonObj.key2); <span class="comment">// abc</span></span><br><span class="line">alert(jsonObj.key3); <span class="comment">// true</span></span><br><span class="line">alert(jsonObj.key4);<span class="comment">// 得到数[11,&quot;arr&quot;,false]</span></span><br><span class="line"><span class="comment">// json 中 数组值的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; jsonObj.key4.length; i++)&#123;</span><br><span class="line">	alert(jsonObj.key4[i]);</span><br><span class="line">&#125;</span><br><span class="line">alert(jsonObj.key5.key5_1);<span class="comment">//551</span></span><br><span class="line">alert(jsonObj.key5.key5_2);<span class="comment">//key5_2_value</span></span><br><span class="line">alert( jsonObj.key6 );<span class="comment">// 得到 json 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出来每一个元素都是 json 对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">jsonItem</span> <span class="operator">=</span> jsonObj.key6[<span class="number">0</span>];</span><br><span class="line">alert( jsonItem.key6_1_1 ); <span class="comment">//6611</span></span><br><span class="line">alert( jsonItem.key6_1_2 ); <span class="comment">//key6_1_2_value</span></span><br></pre></td></tr></table></figure>

<p><strong>方法：</strong></p>
<p>json有两种存在形式：</p>
<ul>
<li>json对象：用于操作json中的数据；</li>
<li>json字符串：用于客户端和服务器之间数据交换时；</li>
</ul>
<p>转换方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.stringify()   <span class="comment">//json对象 转换为 json字符串</span></span><br><span class="line">json.parse()	<span class="comment">//json字符串 转换为 json对象</span></span><br></pre></td></tr></table></figure>

<p><strong>解析转换：</strong></p>
<blockquote>
<p>jackson：</p>
<p>Spring MVC 默认采用Jackson解析Json，尽管还有一些其它同样优秀的json解析工具，例如Fast Json、GSON，但是出于最小依赖的考虑，也许Json解析第一选择就应该是Jackson。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
<p>Fastjson：</p>
<p>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的SON库，是目前ava语言中最快的 JSON库，可以实现Java对象和 JSON字符串的相互转换。但拓展性不高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java对象 转 json字符串</span></span><br><span class="line">String java对象 = JSON.toJSONString(对象);</span><br><span class="line"><span class="comment">//json字符串 转 java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr,User.class); <span class="comment">//User为某一个类</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p>gson的一些使用（还是建议使用jackson）：</p>
<p><strong>javaBean和json互转：</strong></p>
<p>使用GSON，它是Google提供的用来在Java对象和 JSON数据之间进行映射的Java类库。</p>
<ul>
<li>创建gosn对象</li>
<li>gosn.toJson（json对象)  </li>
<li>gson.fromJson（json字符串，javaBean类名.class)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1</span>,<span class="string">&quot;zzc&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 Gson 对象实例</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="comment">// toJson 方法可以把 java 对象转换成为 json 字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">personJsonString</span> <span class="operator">=</span> gson.toJson(person);</span><br><span class="line">    System.out.println(personJsonString);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个参数是 json 字符串</span></span><br><span class="line">    <span class="comment">// 第二个参数是转换回去的 Java 对象类型</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> gson.fromJson(personJsonString, Person.class);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>list和json互转：</strong></p>
<ul>
<li>创建gosn对象</li>
<li>gosn.toJson（list)  </li>
<li>gson.fromJson（json字符串，list.getclass())</li>
</ul>
<p><strong>map和json互转：</strong></p>
<ul>
<li>创建gosn对象</li>
<li>gosn.toJson（map)  </li>
<li>gson.fromJson（json字符串， new TypeToken&lt;HashMap&lt;对应类，对应类&gt;&gt;(){}.getType() );</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><strong>Vue</strong></h2><p><strong>Vue是一套前端框架，免除原生JavaScripte中的DOM操作，简化书写。</strong></p>
<blockquote>
<p><strong>基于MWM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。</strong></p>
<p><strong>其中 ViewModel 有Vue提供。</strong></p>
</blockquote>
<p>使用：</p>
<p>1.声明</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/pro03-vue/script/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>



























<h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h2><blockquote>
<p><strong>Web服务器：是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是 “提供网上信息浏览服务”。</strong></p>
</blockquote>
<p><strong>Tomcat ：是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet &#x2F; JSP 和少量JavaEE规范。</strong></p>
<ul>
<li><p>启动Tomcat服务器：</p>
<p>到bin目录下，双击startup.bat启动，双击shutdown.bat关闭</p>
</li>
<li><p>修改Tomcat的端口号：</p>
<p>mysql默认的端口号是3306，Tomcat默认的端口号是8080，HTTP协议默认的端口号是80；</p>
<p>修改：到conf目录下，修改server.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在69行附近 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改其中的port=&quot;8080&quot;即可 --&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p><strong>Tomcat 部署项目：将项目放置到webapps目录下，即部署完成。</strong></p>
<ul>
<li><strong>一般JavaWeb项目会被打成war包，然后将war包放到webapps目录下，Tomcat会自动解压缩war文件</strong></li>
</ul>
<p>第二种部署方式：</p>
<p>项目不需要放在webapps下，可以放在任何地方；</p>
<p>找到 Tomcat 下的 conf 目录\Catalina\localhost\ 下,创建配置文件，如abc.xml，配置文件内容如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Context 表示一个工程上下文 </span></span><br><span class="line"><span class="comment">	path 表示工程的访问路径:/abc</span></span><br><span class="line"><span class="comment">	docBase 表示你的工程目录在哪里</span></span><br><span class="line"><span class="comment">	即url中输入path，也就是/abc,路径就会到docBase那里</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot; &quot;</span> /</span></span><br></pre></td></tr></table></figure>
</blockquote>
<ul>
<li>当浏览器地址栏输入访问地址为： http :&#x2F;&#x2F;ip:port&#x2F; 时，也就是没有工程名时，默认访问webapps下的ROOT工程；</li>
<li>当浏览器地址栏输入访问地址为： http :&#x2F;&#x2F;ip:port&#x2F; 工程名&#x2F; 时，也就是没有资源名时，默认访问工程下的index.html页面；</li>
</ul>
<hr>
<p><strong>在IDEA中创建Maven Web项目：</strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705819.jfif" alt="image-20220224192255613"></strong></p>
<ul>
<li><strong>编译后的 java字节码文件和resources的资源文件，放到WEB-INF 下的 classes目录下；</strong></li>
<li><strong>pom.xml中依赖坐标对应的jar包，放入WEB-INF下的Iib目录下；</strong><ul>
<li>WEB-INF是一个受服务器保护的目录，浏览器无法直接访问此目录的内容；</li>
</ul>
</li>
</ul>
<p><strong>创建方式：</strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705820.png" alt="image-20220224192858734"></strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705821.png" alt="image-20220224193548166"></strong></p>
<blockquote>
<p><strong>WEB-INF放到webapp目录下</strong></p>
</blockquote>
<hr>
<p><strong>在IDEA中使用Tomcat：</strong></p>
<ul>
<li><strong>方法一：集成本地Tomcat</strong></li>
</ul>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705822.png" alt="image-20220224194330615"></strong></p>
<ul>
<li><strong>方法二：Tomcat Maven插件</strong></li>
</ul>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705823.png" alt="image-20220224194749638"></strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Tomcat插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!--默认是8080--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>













<hr>
<hr>
<h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h2><blockquote>
<p>JavaWeb三大组件：Servlet、.Filter、Listener；</p>
</blockquote>
<p><strong>Servlet是 Java提供的一门 动态web资源开发技术。</strong></p>
<p><strong>Servlet是javaEE规范之一，也就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet。</strong></p>
<p>Servlet可以接收客户端发过来的请求，并响应数据给客户端；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用servlet："><a href="#使用servlet：" class="headerlink" title="使用servlet："></a>使用servlet：</h3><ol>
<li><strong>创建Web项目，导入Servlet依赖坐标</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">	&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">         &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">         &lt;artifactId&gt;javax.servlet-api &lt;/artifactId&gt;</span><br><span class="line">         &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">     	&lt;scope&gt;provided&lt;/scope&gt;		<span class="comment">//Tomcat有servlet的jar包，所以这里的servlet不要带到运行环境去，因此使用provided;</span></span><br><span class="line">     &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p><strong>创建：定义一个类，实现Servlet接口，并重写接口中所有方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置：在类上使用@WebServlet注解，配置该Servlet的访问路径</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>访问：启动Tomcat,浏览器输入URL访问该Servlet</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>执行流程</strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705824.png" alt="image-20220228110919940"></strong></p>
<hr>
<p><strong>生命周期</strong></p>
<p><strong>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</strong></p>
<ol>
<li><p><strong>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</strong></p>
</li>
<li><p><strong>初始化：在Servlet实例化之后，容器将调用Servlet的 init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</strong></p>
<blockquote>
<p><strong>可以在注解中修改init()调用的时机：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&quot;/demo&quot;,loadOnStartup=1)</span></span><br><span class="line"><span class="comment">//负整数：第一次被访问时创建 Servlet对象</span></span><br><span class="line"><span class="comment">//0或正整数：服务器启动时创建Servlet对象，数字越小优先级越高</span></span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p><strong>请求处理&#x2F;服务：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</strong></p>
</li>
<li><p><strong>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</strong></p>
</li>
</ol>
<hr>
<p><strong>Servlet体系结构</strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705825.png" alt="image-20220228113253739"></strong></p>
<p><strong>开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以自定义的Servlet都是继承HttpServlet。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">((HttpServletRequest req,HttpServletResponse resp)</span>&#123;</span><br><span class="line">		<span class="comment">//TOOD Get 请求方式处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@override</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req,HttpservletResponse resp)</span>&#123;</span><br><span class="line">	<span class="comment">//TOOD Post 清求方式处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h3><p>ServletConfig类是Servlet程序的配置信息类。</p>
<ul>
<li>Servlet程序和ServletConfig对象都是由Tomcat负责创建；</li>
<li>Servlet程序默认第一次访问时创建，而每个Servlet程序创建时都会创建一个对应的ServletConfig对象。</li>
</ul>
<p>方法：</p>
<ul>
<li>getServletName() —— 获取Servlet程序的别名 servlet-name 的值</li>
<li>getInitParameter(“ “) —— 获取初始化参数 init-param （括号里写param-name的值，得到param-value值）</li>
<li>getServletContext() —— 获取ServletContext对象</li>
</ul>
<hr>
<blockquote>
<p>注： 如果<strong>重写了HttpServlet类的init方法</strong>，一定要**调用父类的init(ServletConfig)**，因为HttpServlet类的init方法里，保存了ServletConfig对象，不然的话，调用getInitParameter(“ “)方法会报错。</p>
</blockquote>
<p><strong>web.xml配置</strong>：设置servlet程序的别名，访问路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">	url-pattern 标签配置访问地址 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">		/ 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">		/hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><ul>
<li>ServletContext是一个接口，它<strong>表示Servlet上下文对象</strong>；</li>
<li>一个 web工程中<strong>只有一个 ServletContext 对象实例</strong>；</li>
<li>ServletContext 对象是一个<strong>域对象</strong>；</li>
<li>ServletContext 是在 web工程部署启动的时候创建。在 web工程停止的时候销毁；</li>
</ul>
<blockquote>
<p>域对象： 是可以像Map一样存取数据的对象，这里的域指存取数据的操作范围，即整个web工程；</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ServletContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletConfig().getServletContext();</span><br><span class="line"><span class="comment">//直接get也可以，本质上也是调用getServletConfig().getServletContext();</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<ul>
<li><p>getInitParameter(“…”) —— 获取 web.xml 中配置的上下文参数 context-param （括号里写param-name值，得到param-value值）</p>
</li>
<li><p>getContextPath() —— 获取当前的工程路径，格式: &#x2F;工程路径 </p>
</li>
<li><p>getRealPath(“&#x2F;“) —— 获取工程部署后在服务器硬盘上的绝对路径 </p>
<blockquote>
<p>getRealPath(“&#x2F;“) —— 工程部署的路径</p>
<p>getRealPath(“&#x2F;css”) —— 工程下 css 目录的绝对路径</p>
</blockquote>
</li>
<li><p>像 Map 一样存取数</p>
<table>
<thead>
<tr>
<th></th>
<th>存数据</th>
<th>取数据</th>
<th>删除数据</th>
</tr>
</thead>
<tbody><tr>
<td>Map</td>
<td>put()</td>
<td>get()</td>
<td>remove()</td>
</tr>
<tr>
<td>域对象</td>
<td>setAttribute()</td>
<td>getAttribute()</td>
<td>removeAttribute()</td>
</tr>
</tbody></table>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml中相关配置信息  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>





<h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议是 客户端和服务器之间通信时要发送的数据，需要遵守的规则； HTTP 协议中的数据又叫报文。</p>
<ul>
<li>请求 Request：客户端给服务器发送数据。<ul>
<li>GET请求</li>
<li>POST请求</li>
</ul>
</li>
<li>响应 Response：服务器给客户端回传数据。</li>
</ul>
<hr>
<p><strong>GET请求的组成：</strong></p>
<ul>
<li><p>请求行： 请求方式  请求的资源路径  请求的协议版本号</p>
<p>如： GET  &#x2F;servlet_1&#x2F;a.html  HTTP&#x2F;1.1</p>
</li>
<li><p>请求头：以键值对的形式组成</p>
<ul>
<li>Accept： 告诉服务器，客户端可以接收的数据类型；</li>
<li>Accept-Language：告诉服务器，客户端可以接收的语言类型，如：zh_CN指中文中国，en_US指英文美国；</li>
<li>User-Agent：就是浏览器的信息；</li>
<li>Accept-Encoding：告诉服务器，客户端可以接收的数据编码（压缩）格式</li>
<li>Host：表示请求的股务器ip和端口号</li>
<li>Connection:告诉服务器诗求连接如何处理<ul>
<li>Keep-Alive ：告诉服务器回传数据不要马上关闭，保持一小段时间的连接；</li>
<li>Closed：马上关闭</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>POST请求的组成：</strong></p>
<ul>
<li><p>请求行： 请求方式  请求的资源路径  请求的协议版本号</p>
</li>
<li><p>请求头：</p>
<ul>
<li><p>Accept：表示客户端可以接收的数据类型；</p>
</li>
<li><p>Accept-Language：表示客户端可以接收的语言类型；</p>
</li>
<li><p>Referer：表示请求发起时，浏览器地址栏中的地址（从哪来）</p>
</li>
<li><p>User-Agent：表示浏览器的信息</p>
</li>
<li><p>Content-Type：表示发送的数据的类型</p>
<blockquote>
<p>如：application&#x2F;x-www-form-ur lencoded ： 表示提交的数据格式是 name&#x3D;value&amp;name&#x3D;value,然后对其进行urI编码，使非英文内容转换为：%xx%xx</p>
<p>multipart&#x2F;form-data  ：表示以多段的形式提交数据给服务器 (以流的形式提交，用于上传)</p>
</blockquote>
</li>
<li><p>Content-Lnegth：表示发送的数据的长度</p>
</li>
<li><p>Cache-Control：表示如何控制缓存， no-cache 指不缓存</p>
</li>
</ul>
</li>
<li><p>空行 （请求头和请求体之间隔一空行）</p>
</li>
<li><p>请求体：发给服务器的数据</p>
</li>
</ul>
<blockquote>
<p><strong>区分</strong>GET请求和POST请求：</p>
<p>POST请求有：</p>
<ul>
<li>form 标签中 method&#x3D;post</li>
</ul>
<p>GET请求有：</p>
<ul>
<li>form 标签 method&#x3D;get</li>
<li>a标签</li>
<li>link标签引入css</li>
<li>Script标签引入js文件</li>
<li>img标签引入图片</li>
<li>iframe 引入html页面</li>
<li>在浏览器地址栏中输入地址后敲回车</li>
</ul>
</blockquote>
<hr>
<p><strong>响应 的组成：</strong></p>
<ul>
<li>响应行：响应的协议和版本号  状态码  状态描述符</li>
<li>响应头：以键值对形式组成<ul>
<li>Server：表示服务器的信息；</li>
<li>Content-Type：表示响应体的数据类型；</li>
<li>Content-Length：响应体的长度；</li>
<li>Date：请求响应的时间（格林时间）；</li>
</ul>
</li>
<li>空行</li>
<li>响应体：（就是回传给客户端的数据）</li>
</ul>
<p><strong>常用响应码：</strong></p>
<ul>
<li>200 —— 请求成功</li>
<li>302 —— 请求重定向</li>
<li>404 —— 表示请求服务器已收到，但所要的数据不存在&#x2F;请求地址错误</li>
<li>500 —— 表示服务器已经收到请求，但服务器内部错误（错误代码）</li>
</ul>
<hr>
<p><strong>MIME类型</strong></p>
<p>MIME类型 指的是HTTP协议中的数据类型 —— Multipurpose Internet Mail Extensions 多功能Internet邮件扩充服务。</p>
<p>格式：大类型&#x2F;小类型</p>
<p>常见的MIME类型：</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>后缀</th>
<th>MIME类型</th>
</tr>
</thead>
<tbody><tr>
<td>超文本标记语言文本</td>
<td>.html   .htm</td>
<td>text&#x2F;html</td>
</tr>
<tr>
<td>普通文本</td>
<td>.txt</td>
<td>text&#x2F;plain</td>
</tr>
<tr>
<td>RTF文本</td>
<td>.rtf</td>
<td>application&#x2F;rtf</td>
</tr>
<tr>
<td>GIF图形</td>
<td>.gif</td>
<td>image&#x2F;gif</td>
</tr>
<tr>
<td>JPEG图形</td>
<td>.jpeg   .jpg</td>
<td>image&#x2F;jpeg</td>
</tr>
<tr>
<td>au声音文件</td>
<td>.au</td>
<td>audio&#x2F;basic</td>
</tr>
<tr>
<td>MIDI音乐文件</td>
<td>.mid   .midi</td>
<td>audio&#x2F;midi,  audio&#x2F;x-midi</td>
</tr>
<tr>
<td>RealAudio音乐文件</td>
<td>.ra    .ram</td>
<td>audio&#x2F;x-pn-realaudio</td>
</tr>
<tr>
<td>AVI文件</td>
<td>.avi</td>
<td>vidio&#x2F;mpeg</td>
</tr>
<tr>
<td>GZIP文件</td>
<td>.gz</td>
<td>video&#x2F;x-msvideo</td>
</tr>
<tr>
<td>TAR文件</td>
<td>.tar</td>
<td>application&#x2F;x-gzip</td>
</tr>
<tr>
<td>MPEG文件</td>
<td>v</td>
<td>application&#x2F;x-tar</td>
</tr>
</tbody></table>
<hr>
<h3 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h3><p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。</p>
<p>而通过 HttpServletRequest 对象，可以获取到所有 请求 的信息。</p>
<p>方法：</p>
<ul>
<li>getRequestURI（） 获取请求的资源路径</li>
<li>getRequestURL（） 获取请求的统一资源定位符（绝对路径）</li>
<li>getRemoteHost（） 获取客户端的ip地址</li>
<li>getHeader（） 获取请求头</li>
<li>getParameter（） 获取请求的参数</li>
<li>getParameterValues（） 获取请求的参数（多个值的时候使用）</li>
<li>getMethod（）  获取请求的方式GET或POST</li>
<li>setAttribute(key,value)    设置域数据</li>
<li>getAttribute(key)   获取域数据</li>
<li>getRequestDispatcher（）  获取请求转发对象</li>
</ul>
<blockquote>
<p>如果doPost中获取数据出现中文乱码，可以设置请求体的字符集为UTF-8：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">	req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);	<span class="comment">//设置字符集要写在获取请求参数之前，否则不生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h3><p>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。</p>
<p>HttpServletRequest表示请求过来的信息，HttpServletResponse 表示所有响应的信息，；我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse对象来进行设置。</p>
<p><strong>两个输出流：</strong></p>
<ul>
<li>字节流 getOutputStream()  ——  常用于下载（传递二进制数据）</li>
<li>字符流  getWriter()  —— 常用于回传字符串（常用）</li>
</ul>
<blockquote>
<p>两个流同时只能使用一个。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseIOServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//resp.setContentType(&quot;text/html; charset=UTF-8&quot;);  用于解决响应中文乱码：它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头；注：要在获取流对象之前使用才有效；    </span></span><br><span class="line">    <span class="comment">// 要求: 往客户端回传 字符串 数据。</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    writer.write(<span class="string">&quot;response&#x27;s content!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问，叫请求 重定向。（因为之前的地址可能已经被废弃）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;新地址&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>请求转发&#x2F;内部转发：</strong></p>
<p>意思是：服务器收到请求后，从一个资源跳转到另一个资源。即<strong>服务器内部转发</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;demo07&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203311638672.png" alt="image-20220329114857941"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//办事处1 —— Servlet1程序</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">	<span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看</span></span><br><span class="line">	req.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;柜台 1 的章&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问路：Servlet2（柜台 2）怎么走</span></span><br><span class="line">    <span class="comment">// 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录</span></span><br><span class="line">    <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line">    <span class="comment">// RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.baidu.com&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走向 Sevlet2（柜台 2）</span></span><br><span class="line">    requestDispatcher.forward(req,resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//办事处2 —— Servlet2程序</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">    <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看 柜台 1 是否有盖章</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">key1</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;柜台 1 是否有章：&quot;</span> + key1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理自己的业务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Servlet2 处理自己的业务 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="保存作用域"><a href="#保存作用域" class="headerlink" title="保存作用域"></a>保存作用域</h3><p>作用域一般有四个：</p>
<ul>
<li><p>page（页面级别，现在几乎不用)</p>
</li>
<li><p>request（一次请求响应范围） </p>
<blockquote>
<p>重定向中，客户端实际发起了两次请求；所以在第一次请求中在request的作用域中保存数据，数据不会保存到第二次请求。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line">req.getSession().setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line">System.out.println(req.getAttribute(<span class="string">&quot;key&quot;</span>));	<span class="comment">//打印null，不能得到结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>session（一次会话范围）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line">req.getSession().setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line">System.out.println(req.getAttribute(<span class="string">&quot;key&quot;</span>));	<span class="comment">//能得到结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>application（整个应用程序范围）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里假设/Servlet_1和/Servlet_2是两个不同的用户</span></span><br><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">System.out.println(application.getAttribute(<span class="string">&quot;key&quot;</span>));	<span class="comment">//能得到结果</span></span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p><strong>文件上传：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 如果要设置上传文件，需要加上 enctype=&quot;multipart/form-data&quot; ,然后在 input的属性type值为&quot;file&quot; --&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>multipart&#x2F;form-data表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器<br>查看http协议内容时，context-type部分有属性boundary：表示每段数据的分隔符，分隔符是由浏览器每次都随机生成，它就是每段上传数据的分界符。 </p>
</blockquote>
<p><strong>文件接收：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上传文件的表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span> &gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileupload类库的适用:</span></span><br><span class="line"><span class="comment">//需要导入两个jar包:commons-fileupload.jar 和 commons-io.jar</span></span><br><span class="line"><span class="comment">//解析上传的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">        <span class="comment">//1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）</span></span><br><span class="line">        <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(req)) &#123;</span><br><span class="line">        <span class="comment">// 创建 FileItemFactory 工厂实现类</span></span><br><span class="line">        <span class="type">FileItemFactory</span> <span class="variable">fileItemFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line">        <span class="comment">// 创建用于解析上传数据的工具类 ServletFileUpload 类</span></span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">servletFileUpload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(fileItemFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析上传的数据，得到每一个表单项 FileItem</span></span><br><span class="line">            List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);</span><br><span class="line">            <span class="comment">// 循环判断，每一个表单项，是普通类型，还是上传的文件</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">                    <span class="comment">// 普通表单项</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 name 属性值：&quot;</span> + fileItem.getFieldName());</span><br><span class="line">                    <span class="comment">// 参数 UTF-8.解决乱码问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 value 属性值：&quot;</span> + fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上传的文件</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 name 属性值：&quot;</span> + fileItem.getFieldName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;上传的文件名：&quot;</span> + fileItem.getName());</span><br><span class="line">                    fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span> + fileItem.getName()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文件下载：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">downloadFileName</span> <span class="operator">=</span> <span class="string">&quot;2.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 获取要下载的文件内容（通过ServletContext对象可以获取）</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">//获取要下载的文件类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> servletContext.getMimeType(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//4.在回传前，通过响应头告诉客户端返回的数据类型</span></span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line">        <span class="comment">//5.告诉客户端收到的数据是用于下载的，还是适用响应头的</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=文件名&quot;</span>);</span><br><span class="line">        <span class="comment">//输入流获取文件内容</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> servletContext.getResourceAsStream(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//获取响应的输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//读取输入流中全部数据，复制给输出流，输出给客户端</span></span><br><span class="line">        IOUtils.copy(resourceAsStream, outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>















<h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter表示过滤器，可以把对资源的请求拦截下来；</p>
<p>通常用过滤器完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等…</p>
<blockquote>
<p>JavaWeb三大组件：Servlet、.Filter、Listener；</p>
</blockquote>
<p>使用：实现Filter接口 ，并重写三个方法；注意是javax.servlet. 下的Filter接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span>       <span class="comment">//设置拦截路径, “/*” 指拦截全部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter_1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">         <span class="comment">// 放行前逻辑(已被拦截)</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);     <span class="comment">//放行</span></span><br><span class="line">        <span class="comment">// 放行后逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Filter执行流程：</strong></p>
<p>执行放行前逻辑——放行——访问资源——执行放行后逻辑</p>
<hr>
<p><strong>Filter拦截路径配置</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;...&quot;)</span>   <span class="comment">//括号中设置拦截路径</span></span><br></pre></td></tr></table></figure>

<ul>
<li>拦截具体的资源： &#x2F;index.jsp   只有访问index.jsp时才会被拦截；</li>
<li>目录拦截：&#x2F;user&#x2F;*  访问&#x2F;user下的所有资源都会被拦截；</li>
<li>后缀名拦截： *.jsp    访问后缀名为jsp的资源都会被拦截；</li>
<li>拦截所有： &#x2F;*</li>
</ul>
<blockquote>
<p>如果要拦截多个页面或分散文件，要在括号例写urlPatterns属性，然后在里面写属性的值，逗号分割；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &#123;&quot;...&quot;,&quot;...&quot;,&quot;...&quot;&#125;)</span>  </span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<p><strong>过滤器链</strong></p>
<p>一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p>
<p>例如：对同一应用，如果执行了2个过滤器，执行顺序为：Filter1的放行前逻辑，Filter1放行，Filter2放行前逻辑，Filter2放行，Filter2放行后逻辑，Filter1放行后逻辑。（类似递归）</p>
<blockquote>
<p>过滤器的执行顺序按 过滤器的类名的字典序排序；</p>
</blockquote>
<p><strong>FilterConfig类</strong></p>
<p>Filter过滤器的配置文件类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filterConfig.getFilterName()  <span class="comment">//获取过滤器的名称</span></span><br><span class="line">filterConfig.getInitParameter(<span class="string">&quot;&quot;</span>)   <span class="comment">//获取过滤器中配置的初始化参数 </span></span><br></pre></td></tr></table></figure>







<h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>监听器，是在application，session，request三个对象创建、销毁或者往其中添加修改删属性时自动执行代码的功能组件。</p>
<p>Listener分类：JavaWeb中提供了8个监听器</p>
<table>
<thead>
<tr>
<th>监听器分类</th>
<th>监听器名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ServletContext监听</td>
<td>ServletContextListener</td>
<td>用于对ServletContext对象进行监听(仓创建、销毁)</td>
</tr>
<tr>
<td></td>
<td>ServletContextAttributeListener</td>
<td>对ServletContext对象中属性的监听（增别改属性）</td>
</tr>
<tr>
<td>Session监听</td>
<td>HttpSessionListener</td>
<td>对Session对象的整体状态的监听(创建、销毁)</td>
</tr>
<tr>
<td></td>
<td>HttpSessionAttributeListener</td>
<td>对Session?对象中的属性监听（增删改属性）</td>
</tr>
<tr>
<td></td>
<td>HttpSessionBindingListener</td>
<td>监听对象于Sessionl的绑定和解除</td>
</tr>
<tr>
<td></td>
<td>HttpSessionActivationListener</td>
<td>对Session数据的钝化和活化的监听</td>
</tr>
<tr>
<td>Request监听</td>
<td>ServletRequestListener</td>
<td>对Requestx对象进行监听(创建、销毁)</td>
</tr>
<tr>
<td></td>
<td>ServletRequestAttributeListener</td>
<td>对Reque5t对象中属性的监听（增别改属性）</td>
</tr>
</tbody></table>
<p>使用</p>
<p>实现ServletContextListener接口，并重写两个方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">      <span class="comment">//加载资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p><strong>会话</strong>：用户打开浏览器，访问wb服务器的资源，会话建立，直到有一方断开连接， 会话结束（浏览器关闭）。在一次会话中可以包含多次请求和响应</p>
<p><strong>会话跟踪</strong>：服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<u>共享数据</u>。</p>
<blockquote>
<p>由于HTTP协议是无状态的，每次浏览器发出请求，服务器都会将请求视为新的请求，所以需要会话跟踪技术。</p>
</blockquote>
<ul>
<li>客户端会话跟踪技术：Cookie</li>
<li>服务端会话跟踪技术：Session</li>
</ul>
<h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>客户端会话技术，将数据保存到客户端，以后客户端每次请求都携带Cookie数据进行访问。</p>
<blockquote>
<p>客户端第一次向服务端发送请求，服务器会生成一个cookie对象，和响应一起发给客户端；客户端之后向服务端发送请求时，会携带cookie一起发送，服务端识别cookie就会知道客户端的身份。</p>
</blockquote>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送:</span></span><br><span class="line"><span class="comment">//创建Cookie对象，设置数据</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送Cookie到客户端，使用response对象</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取:</span></span><br><span class="line"><span class="comment">//获取客户端所有Cookie，使用request对象</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//遍历数组，获取每一个Cookie对象</span></span><br><span class="line"><span class="comment">//使用Cookie对象方法获取数据</span></span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies)&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line">	<span class="keyword">if</span>(<span class="string">&quot;key&quot;</span>.equals(name))&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改Cookie的值</span></span><br><span class="line"><span class="comment">//方法一：创建一个同名的Cookie对象，直接覆盖</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;newValue&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line"><span class="comment">//方法二：找到对应的Cookie对象，用setValue()修改</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> CookieUtils.findCookie(<span class="string">&quot;key2&quot;</span>, req.getCookies());</span><br><span class="line"><span class="keyword">if</span> (cookie != <span class="literal">null</span>) &#123;</span><br><span class="line">    cookie.setValue(<span class="string">&quot;newValue2&quot;</span>);</span><br><span class="line">    resp.addCookie(cookie);	<span class="comment">//修改后还要通知客户端保存修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 原理：</p>
<p>Cookie的实现是基于HTTP协议的；<br>响应头：set-cookie<br>请求头：cookie</p>
<blockquote>
<p> 注：</p>
<p> Cookie存活时间：</p>
<ul>
<li><p>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁。</p>
</li>
<li><p>setMaxAge(int seconds) ：设置Cookie存活时间</p>
<ul>
<li><p>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储；到时间自动删除。</p>
</li>
<li><p>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁；</p>
</li>
<li><p>零：删除对应Cookie；</p>
</li>
</ul>
</li>
</ul>
<p> Cookie存储中文：</p>
<ul>
<li>默认情况不能存储中文；如果要存中文，则需要进行转码：可用URL编码</li>
</ul>
</blockquote>
<h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>服务端会话跟踪技术：将数据保存到服务端；</p>
<p>JavaEE提供HttpSession接口，来实现一次会话的多次请求之间的 数据共享功能。</p>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Session对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">//Session对象功能：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object o)</span> <span class="comment">//存储数据到session域中</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span> <span class="comment">//根据key,获取值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span> <span class="comment">//根据key,删除该键值对</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isNew</span><span class="params">()</span> <span class="comment">//判断是不是刚创建的</span></span><br></pre></td></tr></table></figure>

<p>原理：</p>
<p> Session技术，底层是基于Cookie技术实现的。</p>
<p>如果客户端发送的请求没有携带cookie，则服务端会新创建一个session和cookie，cookie的key值session的id值相同，然后session保存在服务端，cookie返回给客户端。</p>
<p>如果客户端发送的请求携带了cookie，则服务端会通过cookie的key值找到对应保存的session，然后返回相应的cookie。</p>
<blockquote>
<p>注意事项</p>
<p>Session 钝化、活化：</p>
<ul>
<li>钝化：在服务器正常关闭后，Tomcats会自动将Session数据写入硬盘的文件中；</li>
<li>活化：再次启动服务器后，从文件中加载数据到Session中；</li>
</ul>
<p>Session销毁：</p>
<ul>
<li><p>默认30分钟无操作，销毁；</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中配置所有session的超时时长 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用session的方法设置单个</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaxInactiveInterval</span><span class="params">(<span class="type">int</span> interval)</span> <span class="comment">//设置session的超时时间，单位为秒，设置负数表示永不超时</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMaxInactiveInterval</span><span class="params">()</span>  <span class="comment">//获取超时间</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invalidate</span><span class="params">()</span>	<span class="comment">//立即超时，销毁</span></span><br></pre></td></tr></table></figure></li>
</ul>
</blockquote>
<p><strong>Cookie和Session异同点：</strong></p>
<p>Cookie和Session都是来完成一次会话内多次请求间数据共享的；<br>区别：</p>
<ul>
<li>存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端；</li>
<li>安全性：Cookie不安全，Session安全；</li>
<li>数据大小：Cookie最大KB，Session无大小限制；</li>
<li>存储时间：Cookie可以长期存储，Session默认30分钟；</li>
<li>服务器性能：Cookie不占服务器资源，Session占用服务器资源；</li>
</ul>
<h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ul>
<li><p><strong>概念：Java Server Pages —— Java服务端页面</strong></p>
</li>
<li><p><strong>一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容；</strong></p>
<p>主要用于代替Servlet程序回传html页面的数据，因为Servlet程序回传html页面非常繁琐，开发维护成本都较高。</p>
<p>JSP本质上就是一个Servlet程序，JSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet)，再编译，最终对外提供服务的其实就是字节码文件</p>
</li>
<li><p><strong>JSP &#x3D; HTML + Java</strong></p>
</li>
</ul>
<blockquote>
<p>JSP有很多缺点：</p>
<p>书写麻烦：特别是复杂的页面；<br>阅读麻烦；<br>复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE；<br>占内存和磁盘：JSP会自动生成java和 .class文件占磁盘，运行的是 .class文件占内存；<br>调试困难：出错后，需要找到自动生成的，java文件进行调试；<br>不利于团队协作：前端人员不会java,后端人员不精HTML；</p>
<p>….</p>
<p>后续逐渐被ajax+html替代</p>
</blockquote>
<hr>
<p>步骤：</p>
<p>导入JSP坐标——创建jsp文件——编写html标签和java代码</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span>		<span class="comment">&lt;!-- tomcat有，注意要写成provided --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>page指令：</strong></p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>language ——  表示 jsp 翻译后是什么语言文件。只支持 java。</li>
<li>contentType —— 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值</li>
<li>pageEncoding —— 表示当前 jsp 页面文件本身的字符集。 </li>
<li>import —— 跟 java 源代码中一样。用于导包，导类。 </li>
<li>给out输出流使用的两个属性（不建议改）：<ul>
<li>autoFlush —— 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。</li>
<li>buffer —— 设置 out 缓冲区的大小。默认是 8kb。</li>
</ul>
</li>
<li>errorPage —— 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。路径一般以斜杠开头，表示请求地址为 “http :&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F; ”  映射到代码的Web目录</li>
<li>isErrorPage —— 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。 </li>
<li>session ——  设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。 </li>
<li>extends —— 设置 jsp 翻译出来的 java类继承谁</li>
</ul>
<p><strong>脚本：</strong></p>
<p>JSP脚本：用于在JSP页面内定义Java代码</p>
<p>分为：</p>
<ul>
<li><p><strong>代码脚本 &lt;% … %&gt;</strong> </p>
<p>用于编写需要的功能。内容会直接放到 jspService()方法之中。</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--<span class="number">2.</span>代码脚本----<span class="keyword">for</span> 循环语句--%&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;第 &lt;%=j + <span class="number">1</span>%&gt;行&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    	&#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>表达脚本 &lt;%&#x3D; … %&gt;</strong></p>
<p>用于在jsp页面上输出数据。内容会放到out.print()中，作为out.print0的参数</p>
<blockquote>
<p>注：表达脚本中的表达式不能以分号结束。</p>
</blockquote>
</li>
<li><p>声明脚本 &lt;%! … %&gt;</p>
<p>可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块，内部类等。</p>
<p>内容会放到 _jspService()方法之外，被类直接包含。</p>
<blockquote>
<p>注：声明脚本很少使用</p>
</blockquote>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line">	<span class="keyword">private</span> Integer id;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; map;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>输出</strong></p>
<p>response.getWriter输出 和 out输出 都用于设置返回给客户端的内容。由于jsp翻译后，底层源码都是用out来输出的，所以一般统一用out来进行输出。</p>
<p><strong>注释：</strong></p>
<p>html注释： &lt; !–    – &gt;</p>
<p>java注释：&lt;% &#x2F;&#x2F; 单行 java 注释    &#x2F;* 多行 java 注释 *&#x2F; %&gt;</p>
<p>jsp注释： &lt;%–   –%&gt; </p>
<p>其中html注释和java注释会被翻译到java源代码中，jsp注释不会。</p>
<hr>
<h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><p><strong>jsp的内置对象</strong>：是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象。</p>
<p>request —— 请求对象<br>response —— 响应对象<br>pageContext —— jsp的上下文对象<br>session —— 会话对象<br>application —— ServletContext.对象<br>config —— ServletConfig对象<br>out —— jsp输出流对象<br>page —— 指向当前jsp的对象<br>exception —— 异常对象</p>
<hr>
<p><strong>jsp四大域对象：</strong></p>
<p>pageContext —— request —— session —— application</p>
<p>域对象可以像Map一样存取数据，其范围和Servlet的四个作用域相同。</p>
<hr>
<h3 id="常用标签-1"><a href="#常用标签-1" class="headerlink" title="常用标签"></a>常用标签</h3><p><strong>静态包含</strong>（常用）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">&quot;&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 例如  --&gt; </span><br><span class="line">&lt;%@ include file=<span class="string">&quot;/include/footer.jsp&quot;</span>%&gt;</span><br></pre></td></tr></table></figure>

<p>file属性指定要包含的jsp页面的路径，地址的第一个斜杠为 “ http :&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F; ” 映射到web目录。</p>
<blockquote>
<p>注：静态包含不会翻译被包含的jsp页面，而是直接把页面拷贝到包含的位置执行输出。</p>
</blockquote>
<p><strong>动态包含</strong>（少用）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;&quot;</span>&gt; &lt;/jsp:include&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 例如  --&gt; </span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;/include/footer.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;bbj&quot;</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>

<p>page属性是指定要包含的 jsp页面的路径。</p>
<blockquote>
<p>注：动态包含会 直接翻译被包含的jsp页面，同时还可以传递参数。</p>
</blockquote>
<p><strong>转发标签</strong>（常用）</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;&quot;</span>&gt; &lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>

<p>page属性设置请求转发的路径</p>
<p>相当于：request.getRequestDispatcher(“&#x2F;xxxx.jsp”).forward(request,reponse);</p>
<h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><p>Expression Language ，即表达式语言，用于简化 JSP页面内的java代码。</p>
<p>主要功能：获取数据；</p>
<p>语法：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaWeb中的四大域对象：</p>
<ul>
<li>page：当前页面有效；</li>
<li>request：当前请求有效；</li>
<li>session：当前会话有效；</li>
<li>application：当前应用有效；</li>
</ul>
<p>——EL表达式获取数据，会依次从4个域中寻找，直到找到为止。（四个域的范围逐渐增大，即page范围最小，application最大）</p>
</blockquote>
<ul>
<li><p>empty运算</p>
<p>判断一个数据是否为空，如果为空则输出true。</p>
<blockquote>
<p>值为null，空串时，Object类型数组长度为0时，list集合中元素个数为0，map集合元素个数为0，这些情况均视为空。</p>
</blockquote>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">	request.setAttribute(<span class="string">&quot;obj&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">%&gt;</span><br><span class="line">$&#123;empty obj&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关系运算： &#x3D;&#x3D; !&#x3D;  &lt; &gt; &lt;&#x3D;  &gt;&#x3D;</p>
</li>
<li><p>逻辑运算：&amp;&amp; || ！</p>
</li>
<li><p>算数运算： + - * &#x2F; %</p>
</li>
<li><p>三元运算</p>
</li>
<li><p>点运算 中括号运算：</p>
<p>点运算 输出Bean对象中某个属性的值；</p>
<p>中括号运算 输出有序集合中某个元素的值；</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a.a.a&quot;</span>, <span class="string">&quot;aaaValue&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b+b+b&quot;</span>, <span class="string">&quot;bbbValue&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c-c-c&quot;</span>, <span class="string">&quot;cccValue&quot;</span>);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; map[<span class="string">&#x27;a.a.a&#x27;</span>] &#125; &lt;br&gt;</span><br><span class="line">    $&#123; map[<span class="string">&quot;b+b+b&quot;</span>] &#125; &lt;br&gt;</span><br><span class="line">    $&#123; map[<span class="string">&#x27;c-c-c&#x27;</span>] &#125; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>11个隐含对象：</strong></p>
<table>
<thead>
<tr>
<th>变量</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>pageContext</td>
<td>PageContextImpl</td>
<td>获取jsp九大内置对象</td>
</tr>
<tr>
<td>pageScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>获取pageContext域中的数据</td>
</tr>
<tr>
<td>requestScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>获取Request域的数据</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>获取Session域的数据</td>
</tr>
<tr>
<td>applicationScope</td>
<td>Map&lt;String,Object&gt;</td>
<td>获取ServletContext域的数据</td>
</tr>
<tr>
<td>param</td>
<td>Map&lt;String,String&gt;</td>
<td>获取请求参数的值</td>
</tr>
<tr>
<td>paramValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>获取多个请求参数的值</td>
</tr>
<tr>
<td>header</td>
<td>Map&lt;String,String&gt;</td>
<td>获取请求头的信息</td>
</tr>
<tr>
<td>headerValues</td>
<td>Map&lt;String,String[]&gt;</td>
<td>获取多个请求头的信息</td>
</tr>
<tr>
<td>cookie</td>
<td>Map&lt;String,Cookie&gt;</td>
<td>获取当前请求的Cookie信息</td>
</tr>
</tbody></table>
<p><strong>获取4个特定域的属性：</strong></p>
<table>
<thead>
<tr>
<th>pageScope</th>
<th>pageContext域</th>
</tr>
</thead>
<tbody><tr>
<td>requestScope</td>
<td>Request域</td>
</tr>
<tr>
<td>sessionScope</td>
<td>Session域</td>
</tr>
<tr>
<td>applicationScope</td>
<td>ServletContext域</td>
</tr>
</tbody></table>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        application.setAttribute(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;application&quot;</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">	$&#123; applicationScope.key2 &#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>pageContext的使用</strong>：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    request.getScheme() 它可以获取请求的协议</span><br><span class="line">    request.getServerName() 获取请求的服务器 ip 或域名</span><br><span class="line">    request.getServerPort() 获取请求的服务器端口号</span><br><span class="line">    getContextPath() 获取当前工程路径</span><br><span class="line">    request.getMethod() 获取请求的方式（GET 或 POST）</span><br><span class="line">    request.getRemoteHost() 获取客户端的 ip 地址</span><br><span class="line">    session.getId() 获取会话的唯一标识</span><br><span class="line">    --&gt;</span><br><span class="line">	&lt;%</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;req&quot;</span>, request);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%= request.getScheme() %&gt; &lt;br&gt;</span><br><span class="line">    <span class="number">1.</span>协议： $&#123; req.scheme &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">2.</span>服务器 ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">3.</span>服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">4.</span>获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">5.</span>获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">6.</span>获取客户端 ip 地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">7.</span>获取会话的 id 编号：$&#123; pageContext.session.id &#125;&lt;br</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>





<h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><p>JSTL标准标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码。</p>
<p>步骤：</p>
<p>1.导入坐标：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在JSP页面上引入JSTL标签库：</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com /jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure>

<p>JSTL有五个功能不同的标签库：</p>
<table>
<thead>
<tr>
<th>功能范围</th>
<th>URI</th>
<th>前缀</th>
</tr>
</thead>
<tbody><tr>
<td>核心标签库（常用）</td>
<td>http :&#x2F;&#x2F;java.sun.com &#x2F;jsp&#x2F;jstl&#x2F;core</td>
<td>c</td>
</tr>
<tr>
<td>格式化</td>
<td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;fmt</td>
<td>fmt</td>
</tr>
<tr>
<td>函数</td>
<td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;functions</td>
<td>fn</td>
</tr>
<tr>
<td>数据库（不适用）</td>
<td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;sql</td>
<td>sql</td>
</tr>
<tr>
<td>XML（不适用）</td>
<td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;xml</td>
<td>x</td>
</tr>
</tbody></table>
<p>标签：</p>
<p>if</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;true或false&quot;</span>&gt;</span><br><span class="line">    ....</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status==0&#125;&quot;</span>&gt;</span><br><span class="line">    hello world!</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure>

<p>forEach</p>
<figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- items是被遍历的容器 <span class="keyword">var</span>是遍历生产的临时变量 --&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;xx&quot;</span>&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;$(xx.index)&lt;/td&gt;  &lt;!-- varStatus表示下标序号，xx.index表示从<span class="number">0</span>开始，xx.count表示从<span class="number">1</span>开始 --&gt;</span><br><span class="line">        &lt;td&gt;$(brand.brandName)&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;S(brand.companyName)&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$(brand.description)&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 相当于.. --&gt;</span><br><span class="line"><span class="keyword">for</span>(Brand brand : brands)&#123;</span><br><span class="line">	<span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> brand.getld();</span><br><span class="line">	<span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> brand.getlmgUrl();</span><br><span class="line">	<span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> brand.getBrandName();</span><br><span class="line">	<span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> brand.getCompanyName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- begin是开始数，end是结束数，step是步长 --&gt;</span><br><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&#x27;i&#x27;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 相当于.. --&gt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">	System.out.println(i);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h2><p><strong>MVC是一种分层开发的模式，其中：</strong></p>
<ul>
<li><strong>M：Model，业务模型，处理业务</strong></li>
<li><strong>V：View，视图，界面展示</strong></li>
<li><strong>C：Controller，控制器，处理请求，调用模型和视图</strong></li>
</ul>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705826.png" alt="image-20220228114916749"></strong></p>
<blockquote>
<p><strong>MVC只能实现模型到视图的单向展示</strong></p>
</blockquote>
<p><strong>三层架构</strong></p>
<p><strong>表现层：接收请求，封装数据，调用业务逻辑层，响应数据</strong></p>
<p><strong>业务逻辑层：对业务逻辑进行封装，组合数据访问层的基本功能，形成复杂的业务逻辑功能</strong></p>
<p><strong>数据访问层(持久层)：对数据库的CRUD基本操作</strong></p>
<p><strong><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191705827.png" alt="image-20220228115248548"></strong></p>
<h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><strong>AJAX</strong></h2><p><strong>概念：AJAX（Asynchronous JavaScript And XML）：异步的 javaScript 和 XML</strong></p>
<p><strong>AJAX作用</strong></p>
<ol>
<li><p><strong>与服务器进行数据交换： 通过AJAX可以给服务器发送请求，并获取服务器响应的数据。</strong></p>
<blockquote>
<p><strong>使用了AJAX和服务器进行通信，就可以使用 HTML+AJAX 来替换 JSP 页面了。</strong></p>
</blockquote>
</li>
<li><p><strong>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验，等等…</strong></p>
<p>Ajax 请求的局部更新，浏览器地址栏不会发生变化， 局部更新不会舍弃原来页面的内容。</p>
</li>
</ol>
<blockquote>
<p><strong>同步：浏览器请求服务器 ，需要等待服务器处理并响应后，才能继续操作。</strong></p>
<p><strong>异步：浏览器请求服务器，服务器在处理时，浏览器可以做其他操作。</strong></p>
</blockquote>
<hr>
<h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>服务端：Servlet程序</p>
<p>客户端：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">        xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><p><strong>方法：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>abort()</td>
<td>取消当前请求</td>
</tr>
<tr>
<td>getAllResponseHeaders()</td>
<td>返回头部信息</td>
</tr>
<tr>
<td>getResponseHeader()</td>
<td>返回特定的头部信息</td>
</tr>
<tr>
<td>open(method, url, async, user, psw)</td>
<td>发送请求 —— method：请求类型 GET 或 POST；    url：文件位置；     async：true（异步）或 false（同步）；     user：可选的用户名称；     psw：可选的密码</td>
</tr>
<tr>
<td>send()</td>
<td>将请求发送到服务器，用于GET请求</td>
</tr>
<tr>
<td>send(string)</td>
<td>将请求发送到服务器，用于POST请求</td>
</tr>
<tr>
<td>setRequestHeader()</td>
<td>向要发送的报头添加标签&#x2F;值对</td>
</tr>
</tbody></table>
<p><strong>XMLHttpRequest属性：</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>onreadystatechange</td>
<td>定义当 readyState 属性发生变化时被调用的函数</td>
</tr>
<tr>
<td>readyState</td>
<td>保存XMLHttpRequest的状态</td>
</tr>
<tr>
<td>responseXML</td>
<td>以字符串返回响应数据</td>
</tr>
<tr>
<td>status</td>
<td>返回请求的状态号</td>
</tr>
<tr>
<td>statusText</td>
<td>返回状态文本（如 “OK” 或 “Not Found”）</td>
</tr>
</tbody></table>
<blockquote>
<p>readyState中的XMLHttpRequest的状态 ：</p>
<ul>
<li>0：请求未初始化</li>
<li>1：服务器连接已建立</li>
<li>2：请求已收到</li>
<li>3：正在处理请求</li>
<li>4：请求已完成且响应已就绪</li>
</ul>
<p>status中常见的 返回请求的状态：</p>
<ul>
<li>200: “OK”</li>
<li>403: “Forbidden”</li>
<li>404: “Not Found”</li>
</ul>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在</p>
<ul>
<li><strong>前端完成的逻辑</strong><ol>
<li>给用户名输入框绑定光标失去焦点事件 <code>onblur</code></li>
<li>发送 ajax请求，携带username参数</li>
<li>处理响应：是否显示提示信息</li>
</ol>
</li>
<li><strong>后端完成的逻辑</strong><ol>
<li>接收用户名</li>
<li>调用service 查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理</li>
<li>返回标记</li>
</ol>
</li>
</ul>
<p>后端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectUserServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectUserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 接收用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//3. 响应标记</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前端：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 给用户名输入框绑定 失去焦点事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//2. 发送ajax请求</span></span><br><span class="line">    <span class="comment">// 获取用户名的值 </span></span><br><span class="line">    <span class="keyword">var</span> username = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1. 创建核心对象</span></span><br><span class="line">    <span class="keyword">var</span> xhttp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// code for IE6, IE5</span></span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2. 发送请求</span></span><br><span class="line">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/ajax-demo/selectUserServlet?username=&quot;</span>+username);</span><br><span class="line">    xhttp.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3. 获取响应</span></span><br><span class="line">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">responseText</span> == <span class="string">&quot;true&quot;</span>)&#123;</span><br><span class="line">                <span class="comment">//用户名存在，显示提示信息</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户名不存在 ，q提示信息</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送get、post请求。</p>
<p>Axios对原生的AJAX进行封装，简化书写。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>axios 使用是比较简单的，分为以下两步：</p>
<ul>
<li><p>引入 axios 的 js 文件</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用axios 发送请求，并获取响应结果</p>
<ul>
<li><p>发送 get 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送 post 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><code>axios()</code> 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：</p>
<ul>
<li><code>method</code> 属性：用来设置请求方式的。取值为 <code>get</code> 或者 <code>post</code>。</li>
<li><code>url</code> 属性：用来书写请求的资源路径。如果是 <code>get</code> 请求，需要将请求参数拼接到路径的后面，格式为： <code>url?参数名=参数值&amp;参数名2=参数值2</code>。</li>
<li><code>data</code> 属性：作为请求体被发送的数据。也就是说如果是 <code>post</code> 请求的话，数据需要作为 <code>data</code> 属性的值。</li>
</ul>
<p><code>then()</code> 需要传递一个匿名函数。我们将 <code>then()</code> 中传递的匿名函数称为 &#x3D;&#x3D;回调函数&#x3D;&#x3D;，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 <code>resp</code> 参数是对响应的数据进行封装的对象，通过 <code>resp.data</code> 可以获取到响应的数据。</p>
<hr>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>1.后端实现</strong></p>
<p>定义一个用于接收请求的servlet，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/axiosServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AxiosServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 接收请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//2. 响应数据</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello Axios~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2.前端实现</strong></p>
<ul>
<li><p>引入 js 文件</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送 ajax 请求</p>
<ul>
<li><p>get 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>post 请求</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>整体页面代码如下：</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. get</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/* axios(&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        method:&quot;get&quot;,</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;).then(function (resp) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        alert(resp.data);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;)*/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：</p>
<ul>
<li><p><code>get</code> 请求 ： <code>axios.get(url[,config])</code></p>
</li>
<li><p><code>delete</code> 请求 ： <code>axios.delete(url[,config])</code></p>
</li>
<li><p><code>head</code> 请求 ： <code>axios.head(url[,config])</code></p>
</li>
<li><p><code>options</code> 请求 ： <code>axios.option(url[,config])</code></p>
</li>
<li><p><code>post</code> 请求：<code>axios.post(url[,data[,config])</code></p>
</li>
<li><p><code>put</code> 请求：<code>axios.put(url[,data[,config])</code></p>
</li>
<li><p><code>patch</code> 请求：<code>axios.patch(url[,data[,config])</code></p>
</li>
</ul>
<p>而我们只关注 <code>get</code> 请求和 <code>post</code> 请求。</p>
<p>入门案例中的 <code>get</code> 请求代码可以改为如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>入门案例中的 <code>post</code> 请求代码可以改为如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,<span class="string">&quot;username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>



<h3 id="携带JSON数据"><a href="#携带JSON数据" class="headerlink" title="携带JSON数据"></a>携带JSON数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:jsObject  	<span class="comment">//这里 axios 会将该js对象转换为 json 串的</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：</p>
<ul>
<li>发送异步请求时，如果请求参数是 <code>JSON</code> 格式，那请求方式必须是 <code>POST</code>。因为 <code>JSON</code> 串需要放在请求体中。</li>
<li>axios将js对象转为json字符串，用了 js提供的 JSON对象，即 JSON.stringify (jsObject)。（了解即可）</li>
</ul>
</blockquote>
<h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf 是（服务器端)视图模板技术,</p>
<p>优势：和springBoot完美契合。不经过服务器运算仍可以直接查看原始值，对前端友好。</p>
<hr>
<p><strong>物理视图：</strong></p>
<p>在Servlet中，将请求转发到一个HTML页面文件时，使用的<strong>完整的转发路径就是 物理视图</strong>。如：&#x2F;pages&#x2F;user&#x2F;login_success.html</p>
<p>由于html页面放在统一的目录下，所以转发地址会有相同的前缀 和 后缀，称为<strong>视图前缀，视图后缀</strong>。</p>
<p><strong>逻辑视图：</strong></p>
<p>物理视图 &#x3D; 视图前缀 + 逻辑视图 + 视图后缀</p>
<p>也就是说，逻辑视图 就是指转发路径中间不一样的部分（html页面名）。</p>
<hr>
<p>使用步骤：</p>
<ul>
<li><p>添加jar包（maven可直接添加依赖）；</p>
</li>
<li><p>配置两个 &lt; context-param &gt;: view-prefix,view-suffix</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在上下文参数中配置 视图前缀和视图后缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/view/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>新建viewBaseServlet（有两个方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, getServletContext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>……</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/javaWeb/" data-id="cl1ynefm00005swtufcyd17s7" data-title="Java Web" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Git" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/Git/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.183Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/Git/">git</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>git 是一个<strong>分布式版本控制</strong>系统，</p>
<blockquote>
<p>版本控制 是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p>
</blockquote>
<blockquote>
<p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p>
<ol>
<li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li>
<li>每个客户端保存的也都是整个完整的项目 (包含历史记录，更加安全)</li>
</ol>
</blockquote>
<h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><strong>工作区——git add——&gt; 暂存区——git commit——&gt; 本地库</strong></p>
<blockquote>
<p>工作区：写代码； </p>
<p>暂存区：临时存储；</p>
<p>本地库：历史版本；</p>
</blockquote>
<p><strong>代码托管中心</strong></p>
<p>代码托管中心是基于网络服务器的远程代码仓库，一般称为 <strong>远程库</strong>。</p>
<blockquote>
<p>局域网：GitLab</p>
<p>互联网：GitHub，Gitee码云</p>
</blockquote>
<h3 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h3><p>查看本地库状态：<strong>git status</strong></p>
<p>添加暂存区：<strong>git add 文件名</strong> （<strong>git add .</strong>  &#x2F;&#x2F;将所有修改加入暂存区）</p>
<p>提交本地库：<strong>git commit -m “日志信息” 文件名</strong></p>
<blockquote>
<p>工作区的文件是git对象，不能看作是项目，要添加到暂存区，才能形成一个项目。</p>
</blockquote>
<p>查看简易版本信息：<strong>git reflog</strong>  (参看详细版本信息：<strong>git log</strong>)</p>
<p>版本穿梭：<strong>git reset –hard 版本号</strong></p>
<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在版本控制中，要同时推进多个任务，对每个任务就可以单独创建一个分支。</p>
<p>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己的分支时不会影响主线分支的运行。（分支底层是指针的引用）</p>
<p><strong>分支操作：</strong></p>
<p>创建分支：<strong>git branch 分支名</strong></p>
<p>查看分支：<strong>git branch -v</strong></p>
<p>切换分支：<strong>git checkout 分支名</strong></p>
<p>将指定分支合并到当前分支上：<strong>git merge 分支名</strong></p>
<blockquote>
<p>指定分支要提交本地库，合并后，当前分支才会修改。</p>
<p>合并冲突： </p>
<p>当两个分支修改了同一个文件，并都提交到本地库，那么合并时，系统发现一个文件出现两个版本，不知道应该选择哪一个，就是发生了冲突。需要手动修改，选择。</p>
</blockquote>
<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p><strong>git remote -v</strong> ：查看当前所有远程地址别名</p>
<p><strong>git remote add 别名 远程地址</strong>  ：添加远程库地址和别名</p>
<p>推送本地分支到远程仓库 ：<strong>git push 别名 分支</strong></p>
<p>拉取远程库到本地库 ： <strong>git pull 别名 分支</strong> （自动提交到本地库）</p>
<p>克隆远程库到本地库：<strong>git clone 远程地址</strong></p>
<blockquote>
<p>克隆结果：初始化本地仓库，创建别名</p>
</blockquote>
<h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p>远程仓库的所有人需要在仓库的设置-成员设置中邀请其他团队成员加入，其他成员才能将本地分支推送到远程库</p>
<p>跨团队协作</p>
<p>团队外的人要先用fork获取远程库，修改后在界面的pull requests发送拉取请求。</p>
<blockquote>
<p>SSH免密登录</p>
<p>生成 .ssh密钥目录： <strong>ssh-keygen -t rsa -C 账号邮箱</strong></p>
<p>在.ssh目录下会有私钥id_rsa，公钥id_rsa.pub，将公钥添加到github上即可。</p>
</blockquote>
<h3 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h3><p>环境准备：</p>
<p>先配置忽略文件 git.ignore，避免提交无用的文件，避免开发环境差异。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//内容如下</span><br><span class="line"># Compoled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line">#Blue files</span><br><span class="line">*.ctxt</span><br><span class="line">a</span><br><span class="line">#Mobile Tools for Java(J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure>

<p>然后在 .gitconfig 中添加 ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">	excludesfile = C:/Users/123/git.ignore</span><br></pre></td></tr></table></figure>

<p>之后再idea设置的版本控制中设置git.exe路径。</p>
<p>初始化：</p>
<p>在工具栏的vcs中选择创建git仓库即可。</p>
<h3 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h3><p>前置操作已完成，现在 —— 初始化及部署博客：</p>
<p>新建文件夹 blog， 在blog 中使用git命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init   //初始化本地博客</span><br><span class="line">hexo clean  //清理编译文件</span><br><span class="line">hexo g   //生成对应的html文件</span><br><span class="line">hexo s	//本地预览运行</span><br></pre></td></tr></table></figure>

<p>修改 _config.yml 文件，在文件最后，修改为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 仓库ssh地址</span><br><span class="line">  branch: master</span><br><span class="line">  </span><br><span class="line">  //在17行左右，url下面，添加：</span><br><span class="line">  root: /仓库名</span><br></pre></td></tr></table></figure>

<p>上传：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>



<p>每次上传：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>





<p>常用hexo命令</p>
<p>常见命令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure>

<p>缩写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure>

<p>组合命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/Git/" data-id="cl1yneflt0001swtudewleb1q" data-title="git" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C语言学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:55:35.169Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">C语言</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C语言学习"><a href="#C语言学习" class="headerlink" title="C语言学习"></a>C语言学习</h1><h2 id="1章-概述"><a href="#1章-概述" class="headerlink" title="1章 概述"></a>1章 概述</h2><p>注意点：</p>
<ol>
<li>一个函数的函数体可以没有变量定义和执行部分，函数可以是空函数。</li>
<li>一个C程序至少包含一个<u>主函数</u>，即<u>main函数</u>。</li>
<li>一个函数由两部分组成，分别是<u>函数的说明部分</u>和<u>函数体</u>。</li>
<li>C语言通过输入和输出函数 来进行输入输出。</li>
<li>主函数后的圆括号内可为空，但这个圆括号不能省略。</li>
</ol>
<h2 id="2章-数据类型、运算符、表达式"><a href="#2章-数据类型、运算符、表达式" class="headerlink" title="2章 数据类型、运算符、表达式"></a>2章 数据类型、运算符、表达式</h2><p>注意点：</p>
<ol>
<li>C语言中，数据基本类型有<u>整型，浮点型，字符型</u>；</li>
<li>能表示整型常量的进制有八、十、十六进制（二进制不行）；</li>
<li>ASCII码表：数值0——48；字母A——65；字母a——97；</li>
<li>所有变量，遵循<u>先定义后使用</u>的原则；</li>
<li>强制类型转换——将一个表达式转换成指定的类型；</li>
</ol>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4字节</td>
<td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-32 768 ~ 32 767</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>-128 ~ 127</td>
</tr>
</tbody></table>
<p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p>
<hr>
<p><strong>浮点型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td>
</tr>
</tbody></table>
<p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p>
<ul>
<li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p>
<p>1.正无穷大：Double.POSITIVE_INFINITY</p>
<p>2.负无穷大：Double.NEGATIVE_INFINITY</p>
<p>3.NaN(不是一个数字)：Double.NaN</p>
<ul>
<li><p>检测一个特定值是否等于Double.NaN：</p>
</li>
<li><p>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</p>
</li>
</ul>
</li>
<li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p>
</li>
</ul>
<hr>
<p><strong>char</strong>类型</p>
<p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p>
<ul>
<li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p>
<p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p>
<p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p>
</li>
</ul>
<hr>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型也是算术类型，被用来定义在程序中只能赋予其一定的整数值的变量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br><span class="line"><span class="comment">//上面的宏定义可用枚举来表示</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li><p>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p>
</li>
<li><p>可以在定义枚举类型时改变枚举元素的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure>

<p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p>
</li>
</ul>
<p><strong>关于枚举的遍历：</strong></p>
<p>在C 中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 规范是没有办法遍历枚举类型的。不过有特殊情况，即在枚举类型中的值是连续时 可以遍历，否则不能；</p>
<hr>
<h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>类型与描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>函数返回为空</strong> ：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td>
</tr>
<tr>
<td>2</td>
<td><strong>函数参数为空</strong>： C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td>
</tr>
<tr>
<td>3</td>
<td><strong>指针指向 void</strong> ：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td>
</tr>
</tbody></table>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>逻辑运算符</strong></p>
<p>假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>||</td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td>(A || B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
<p><strong>位运算符</strong></p>
<p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p>
<table>
<thead>
<tr>
<th>p</th>
<th>q</th>
<th>p &amp; q</th>
<th>p | q</th>
<th>p ^ q</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p>
<blockquote>
<p>A &#x3D; 0011 1100</p>
<p>B &#x3D; 0000 1101</p>
<p>-—————-</p>
<p>A&amp;B &#x3D; 0000 1100</p>
<p>A|B &#x3D; 0011 1101</p>
<p>A^B &#x3D; 0011 0001</p>
<p>~A &#x3D; 1100 0011</p>
</blockquote>
<p><strong>赋值运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与且赋值运算符</td>
<td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或且赋值运算符</td>
<td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或且赋值运算符</td>
<td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td>
</tr>
</tbody></table>
<p><strong>杂项运算符</strong></p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>sizeof()</td>
<td>返回变量的大小。</td>
<td>sizeof(a) 将返回 4，其中 a 是整数。</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量的地址。</td>
<td>&amp;a; 将给出变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>指向一个变量。</td>
<td>*a; 将指向一个变量。</td>
</tr>
<tr>
<td>? :</td>
<td>条件表达式（三元运算符）</td>
<td>如果条件为真 ? 则值为 X : 否则值为 Y</td>
</tr>
</tbody></table>
<h2 id="3章-顺序结构"><a href="#3章-顺序结构" class="headerlink" title="3章 顺序结构"></a>3章 顺序结构</h2><ol>
<li><p>printf函数包括“格式控制”和“输出列表”，其中“格式控制”包括：<u>格式说明、普通字符</u>；。</p>
<p>scanf函数包括“格式控制”和“地址列表”。</p>
</li>
<li><p>#define宏都是直接替换的，不会计算后再替换。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  P  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  S(a)   P*a*a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span>  ar;</span><br><span class="line">	ar=S(<span class="number">3</span>+<span class="number">5</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,ar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为29</span></span><br><span class="line"><span class="comment">//s(3+5) = p*3+5*3+5 = 9+15+5 =29</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>真  等价于  非0的数</p>
</li>
<li><p>数组中的元素具有相同的类型（数据类型，储存类型）</p>
</li>
<li><p>实型常量–指数形式：e&#x2F;E之前必须有数字，且e&#x2F;E后面必须为整数；如不能有e4，12e2.5</p>
</li>
<li><pre><code>\a:警告，蜂鸣声
\b：退格，后退一个字符
\f：换页
\n：换行
\r：回车，当前位置移到本行开头
\t：水平制表符，当前位置移到下一个tab位置
\v：垂直制表符，当前位置移到下一个垂直对齐点
\加数字：数字为八进制，表示为数字对于的ASCII字符
\x加数字：数字为十六进制，表示为数字对于的ASCII字符
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 4章 选择结构</span><br><span class="line"></span><br><span class="line">1. switch括号内的表达式应为整数类型，即可以是int类型、char类型、枚举类型；</span><br><span class="line"></span><br><span class="line">2. 运算符优先级：</span><br><span class="line"></span><br><span class="line">   !(逻辑非) &gt; 算数运算 &gt; 关系运算 &gt; &amp;&amp;(逻辑与) &gt; ||(逻辑或) &gt; 赋值运算</span><br><span class="line"></span><br><span class="line">3. else与它前面最近的一个未配对的if 配对</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5章 循环结构</span><br><span class="line"></span><br><span class="line">1. ```c</span><br><span class="line">   int k = 0; </span><br><span class="line">   while(k++ &lt;= 2)&#123;</span><br><span class="line">   	printf(&quot;%d &quot;,k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

执行结果为：

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>for( 表达式1；表达式2；表达式3) 中表达式2不成立后，依旧会执行完表达式3.</p>
</li>
</ol>
<h2 id="6章-数组"><a href="#6章-数组" class="headerlink" title="6章.数组"></a>6章.数组</h2><ol>
<li>全局或静态数组：未初始化的部分默认为0；<br>局部数组：如果有部分初始化，则剩下未初始化的部分为0；如完全没有初始化，则所有值均不确定。</li>
<li>“类型  数组名  [常量表达式]”  中常量表达式 可以包括 常量和符号常量。</li>
<li>二维数组中元素排列顺序为  ： 按行存放，即在内存中先存放第一行的元素，再存放第二行的元素。</li>
</ol>
<h4 id="输出“魔方阵”。"><a href="#输出“魔方阵”。" class="headerlink" title="输出“魔方阵”。"></a><strong>输出“魔方阵”。</strong></h4><p>所谓魔方阵是指这样的方阵，它的每一行、每一列和对角线之和均相等。例如，三阶魔方阵为</p>
<p>8	1	6</p>
<p>3	5	7<br>4	9	2<br>要求输出1～pow（n，2）的自然数构成的魔方阵。<br>解:魔方阵中各数的排列规律如下:<br>（1）将1放在第1行中间一列。<br>（2）从2开始直到n×n止各数依次按下列规则存放:每一个数存放的行比前一个数的<br>行数减1，列数加1（例如上面的三阶魔方阵，5在4的上一行后一列）。<br>（3）如果上一数的行数为1，则下一个数的行数为n（指最下一行）。例如，1在第1行，<br>则2应放在最下一行，列数同样加1。<br>（4）当上一个数的列数为n时，下一个数的列数应为1，行数减1。例如，2在第3行最<br>后一列，则3应放在第2行第1列。<br>（5）如果按上面规则确定的位置上已有数，或上一个数是第1行第n列时，则把下一个<br>数放在上一个数的下面。例如，按上面的规定，4应该放在第1行第2列，但该位置已被1<br>占据，所以4就放在3的下面。由于6是第1行第3列（即最后一列），故7放在6下面。</p>
<p>按此方法可以得到任何阶的魔方阵。注：魔方阵的阶数应为奇数。</p>
<h2 id="7章-函数"><a href="#7章-函数" class="headerlink" title="7章.函数"></a>7章.函数</h2><ol>
<li><p>变量作为实参向形参的数据传递方式是：单向值传递</p>
</li>
<li><p>函数的定义不可以嵌套，但调用可以嵌套</p>
</li>
<li><p>形参可以是常量，变量或表达式；</p>
</li>
<li><p>实参与对应的形参各占用独立的存储单元；</p>
</li>
</ol>
<p>函数定义的一般形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p>
<ul>
<li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li>
<li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li>
<li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li>
<li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li>
</ul>
<hr>
<p><strong>调用函数：</strong></p>
<ul>
<li><p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p>
</li>
<li><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p>
</li>
</ul>
<h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>用牛顿迭代法求根。方程为ax3＋b2＋cx＋d＝0，系数a，b，c，d的值依次为1，2，<br>3，4，由主函数输入。求x在1附近的一个实根。求出根后由主函数输出。</p>
<p><strong>牛顿迭代公式：x &#x3D; x0 - f(x0) &#x2F; f ‘(x0)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">function</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c, <span class="type">float</span> d)</span> &#123;</span><br><span class="line">    <span class="type">float</span> x1 = <span class="number">1</span>, x0, f1, f2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        f1 = ((a * x0 + b) * x0 + c) * x0 + d;  <span class="comment">//将原公式化简，可减少计算时间</span></span><br><span class="line">        f2 = (<span class="number">3</span> * a * x0 + <span class="number">2</span> * b) * x0 + c;</span><br><span class="line">        x1 = x0 - f1 / f2;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x0) &gt;= <span class="number">1e-3</span>);</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f %f&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %10.7f&quot;</span>, function(a, b, c, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="8章-指针运用"><a href="#8章-指针运用" class="headerlink" title="8章.指针运用"></a><strong>8章.指针运用</strong></h2><ol>
<li>&#96;&#96;&#96;<br>int a[5];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   则数组a中首元素的地址可表示为：a  </span><br><span class="line"></span><br><span class="line">2. C中，指针变量能够赋&lt;u&gt;地址值&lt;/u&gt;或&lt;u&gt;NULL&lt;/u&gt;&lt;u&gt;值&lt;/u&gt;（或&#x27;\0&#x27;，或0，或空值）；</span><br><span class="line"></span><br><span class="line">3. 指针 p++ 指 p = p + 1，因为++有赋值操作，p的值（存放的地址）会改变；</span><br><span class="line"></span><br><span class="line">   指针 p + 1 指访问下一个地址；p本身不变。</span><br><span class="line"></span><br><span class="line">4. * int  * p[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与[]结合,因为其优先级比 * 高,所以P 是一个数组,然后再与 * 结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以**P 是一个由返回整型数据的指针所组成的数组** </span><br><span class="line"></span><br><span class="line">   * int  ( *p)[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以**P 是一个指向由整型数据组成的数组的指针** </span><br><span class="line"></span><br><span class="line">   * int * * p; </span><br><span class="line"></span><br><span class="line">     //首先从P 开始,先与* 结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.</span><br><span class="line">   </span><br><span class="line">   * int p(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </span><br><span class="line">   </span><br><span class="line">   * Int ( *p)(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以**P 是一个指向有一个整型参数且返回类型为整型的函数的指针** </span><br><span class="line">   </span><br><span class="line">   * int * (* p(**int**))[3]; </span><br><span class="line">   </span><br><span class="line">     从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的 * 结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以**P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.** </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一些题解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 求素数</span><br><span class="line"></span><br><span class="line">令变量 i 从**2**开始，看是否能被N%后等于0，i  一直到**sqrt（N）**即可。</span><br><span class="line"></span><br><span class="line">#### 将ASCII码转为字符：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">char c1;</span><br><span class="line">c1 = 33;    //对应字符ASCII码的十进制数，不需加引号；</span><br><span class="line">printf(&quot;%c&quot;,c1);</span><br><span class="line">//32以前的字符无法正常输出；</span><br></pre></td></tr></table></figure></li>
</ol>
<p>将字符转为对应ASCII码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c 的 ASCII 为 %d&quot;</span>, c, c);</span><br><span class="line"><span class="comment">//%d显示整数，%c显示对应字符</span></span><br></pre></td></tr></table></figure>

<h4 id="一元二次方程"><a href="#一元二次方程" class="headerlink" title="一元二次方程"></a>一元二次方程</h4><p>求<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708726.png" alt="image-20210409140501637" style="zoom: 50%;" />的根：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,c,x1,x2,d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入方程的三个系数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        d=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*c);</span><br><span class="line">        x1=(-b+d)/(<span class="number">2</span>*a);</span><br><span class="line">        x2=(-b-d)/(<span class="number">2</span>*a);</span><br><span class="line">        <span class="keyword">if</span>(x1&lt;x2) </span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x2,x1); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x1,x2);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="求两数的最大公约数："><a href="#求两数的最大公约数：" class="headerlink" title="求两数的最大公约数："></a>求两数的最大公约数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2, i, gcd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;输入两个正整数，以空格分隔: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt;= n1 &amp;&amp; i &lt;= n2; ++i)&#123;</span><br><span class="line">        <span class="comment">// 判断 i 是否为最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(n1%i==<span class="number">0</span> &amp;&amp; n2%i==<span class="number">0</span>)</span><br><span class="line">            gcd = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最大公约数是 %d&quot;</span>, n1, n2, gcd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="type">int</span> rem;	<span class="comment">//余数，当余数为0的时候，最后的m即为最大公约数</span></span><br><span class="line">	<span class="comment">//先用较小的数对较大的数取余，再用余数对较小的数求余，直到余数为零 </span></span><br><span class="line">	<span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		rem = m % n;</span><br><span class="line">		m = n;</span><br><span class="line">		n = rem;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m;			<span class="comment">//将结果返回			</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line">	<span class="keyword">return</span> fun(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>求两数最小公倍数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minMultiple;</span><br><span class="line">    minMultiple = (n1&gt;n2) ? n1 : n2;	<span class="comment">// 判断两数较大的值，并赋值给 minMultiple</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( minMultiple%n1==<span class="number">0</span> &amp;&amp; minMultiple%n2==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最小公倍数为 %d&quot;</span>, n1, n2,minMultiple);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++minMultiple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：先记n1和n2的积为p，再求最大公约数x，则最小公倍数为p/x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = n1 * n2;</span><br><span class="line">    <span class="type">int</span> rem;	</span><br><span class="line">	<span class="keyword">while</span>(n2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		rem = n1 % n2;</span><br><span class="line">		n1 = n2;</span><br><span class="line">		n2 = rem;</span><br><span class="line">	&#125;<span class="comment">//最后n1为最大公约数</span></span><br><span class="line">    <span class="type">int</span> minMultiple = p / n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><p>有三根柱子，有若干圆盘从下面开始按大到小顺序摆在第一根柱子上，将这些圆盘原封不动移到另一根（第三根）柱子上。<br>并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p>
<p><strong>总体思想</strong><br>1.将 n-1个盘子先放到B座位上<br>2.将A座上地剩下的一个盘移动到C盘上<br>3.将n-1个盘从B座移动到C座上<br><strong>或者</strong><br>在1盘的基础上操作2盘，在2盘的基础上操作3盘………在n-1盘的基础上操作n盘</p>
<p>（1）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hannuo</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> one ,<span class="type">char</span> two,<span class="type">char</span> three)</span> <span class="comment">//将n个盘从one座借助two转移到three</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        move(one, three);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hannuo(n<span class="number">-1</span>,one ,three,two);<span class="comment">//将 n-1个盘子从A借助c放到B座位上</span></span><br><span class="line">        move(one,three);<span class="comment">//将A座上地剩下的一个盘移动到C盘上</span></span><br><span class="line">        hannuo(n<span class="number">-1</span>,two,one,three);<span class="comment">//将n-1个盘借助A从B座移动到C座上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">char</span> y)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c---&gt;%c\n&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your number&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    hannuo(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）（上下两段代码一样)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">int</span> i,<span class="type">char</span> y)</span></span><br><span class="line">    <span class="title function_">printf</span><span class="params">(<span class="string">&quot;move disk %d:%c-&gt;%c\n&quot;</span>,i,x,y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> a,<span class="type">char</span> b, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">     move(a,<span class="number">1</span>,c);      <span class="comment">//将n个盘子从A移动到c</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">       hanoi(n<span class="number">-1</span>,a, c,b);<span class="comment">//将n-1个盘子从A借助C移动到B</span></span><br><span class="line">       move(a, n, c) ;<span class="comment">//将n个盘子从A移动到C</span></span><br><span class="line">       hanoi(n<span class="number">-1</span>,b, a,c) ;<span class="comment">//将n-1个盘子从B借助A移动到C</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3个字符串排序"><a href="#3个字符串排序" class="headerlink" title="3个字符串排序"></a>3个字符串排序</h4><p>输入3个字符串，按由小到大的顺序输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, a);</span><br><span class="line">    <span class="built_in">strcpy</span>(a,b);</span><br><span class="line">    <span class="built_in">strcpy</span>(b,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> n1[<span class="number">20</span>], n2[<span class="number">20</span>], n3[<span class="number">20</span>];</span><br><span class="line">    gets(n1);</span><br><span class="line">    gets(n2);</span><br><span class="line">    gets(n3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n2) &gt; <span class="number">0</span>) swap(n1, n2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n3) &gt; <span class="number">0</span>) swap(n1, n3);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n2, n3) &gt; <span class="number">0</span>) swap(n2, n3);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt; %s &lt; %s&quot;</span>,n1, n2, n3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h1 id="C一些用法"><a href="#C一些用法" class="headerlink" title="C一些用法"></a>C一些用法</h1><ol>
<li><pre><code class="c">int *p[3];
//定义了一个指针数组p，该数组含有三个元素;
//每个元素都是基类型为int的指针
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">   char *s=&quot;\ta\017bc&quot;;</span><br><span class="line">   //则指针变量s指向的字符串所占的字节数是?</span><br><span class="line">   //6个，(包括结束符)</span><br><span class="line">   //\t  a  \017  b  c  \0</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>同类型的两个指针之间可以减运算，但不能加运算；</p>
<ul>
<li>两个相同指针变量相减可以获得在其之间相隔的同类型元素个数（可在某类型的数组中应用）；</li>
</ul>
</li>
<li><pre><code class="c">(j = 3, j++)
//表达式的值为3，j为4；
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```c</span><br><span class="line">   #define S(a,b) t=a;a=b;b=t</span><br><span class="line">   //宏就是符号定义，宏扩展时只是字符串替换，</span><br><span class="line">   //虽然变量t没定义，但此宏定义是正确的</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准</p>
</li>
<li><p>内外函数的两种理解.</p>
</li>
</ol>
<p>   (1)库函数是C语言的内部函数或自带函数,外部函数即程序员自定函数. </p>
<p>   (2)凡加写了extern 的函数是外部函数；一个函数声明为static或声明在另外一个函数内部，那么这个函数就是内部函数，它的声明在其他文件中不可见。</p>
<ol start="8">
<li><strong>位运算符</strong>的操作数必须为<strong>整数类型</strong>；</li>
</ol>
<p>   （位运算符优先级比算数运算符低）</p>
<table>
<thead>
<tr>
<th>&amp;</th>
<th>（按位与）都为1，则得到1；有一个0，则得到0</th>
</tr>
</thead>
<tbody><tr>
<td>|</td>
<td>（按位或）有一个1，则得到1；都为0，则得到0</td>
</tr>
<tr>
<td>^</td>
<td>（按位异或）两着值不同，则得到1；值相同，则为0</td>
</tr>
<tr>
<td>~</td>
<td>（取反）~x：取反（得到x的补码）</td>
</tr>
</tbody></table>
<p>9. </p>
   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0177</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %3d, x = %6d, x = %6o, x = %6x, x = %6u\n&quot;</span>, x, x, x, x, x);</span><br><span class="line"><span class="comment">//输出结果为:(0117以0开头，表示八进制数，即十进制的127，十六进制的7f)</span></span><br><span class="line"><span class="comment">//x = 127, x =    127, x =    177, x =     7f, x =    127</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li><pre><code class="c">double a = 513.789215;
printf(“a = %8.2f, a = %14.8f, a = %14.8lf\n”, a, a, a);
//输出结果：a = 513.79，a = 513.78921500，a = 513.78921500
//小数部分不够则补0
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. ```c</span><br><span class="line">    int a = 0;</span><br><span class="line">    a += (a = 8);</span><br><span class="line">    //运算后a = 16</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;c<br>int a[4],*p &#x3D; a;<br>*p++;<br>*(–p);<br>&#x2F;&#x2F;上述两者都是指针p地址值的改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### C运算符的优先级</span><br><span class="line"></span><br><span class="line">![img](https://pic4.zhimg.com/v2-de212d1860ead5971c56d91194f94fa1_r.jpg?source=1940ef5c)</span><br><span class="line"></span><br><span class="line">#### 四舍五入</span><br><span class="line"></span><br><span class="line">例：对小数点后四舍五入：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//a是x四舍五入后的结果</span><br><span class="line">a = (int)(x+0.5)&gt;(int)x?(int)x+1:(int)x;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line">	<span class="type">int</span> count1 = <span class="keyword">sizeof</span>(str);</span><br><span class="line">	<span class="type">int</span> count2 = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count1);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count2);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">//sizeof会将\0一起计算，strlen只计算字符串本身长度</span></span><br></pre></td></tr></table></figure>



<h4 id="1-为类型起别名"><a href="#1-为类型起别名" class="headerlink" title="1.为类型起别名"></a>1.为类型起别名</h4><p>为常用的数据类型起一个别名，这样就实现简单的多态，如需要将int类型改为char时，只需修改定义的别名中的类型即可。</p>
<h4 id="2-求数中的一个数字"><a href="#2-求数中的一个数字" class="headerlink" title="2.求数中的一个数字"></a>2.求数中的一个数字</h4><p>要求一个数中的个位数字，可使用求模运算，如，149 % 10 &#x3D;  9；</p>
<h4 id="3-迭代自增用-i"><a href="#3-迭代自增用-i" class="headerlink" title="3.迭代自增用++i"></a>3.迭代自增用++i</h4><p>一般情况下，迭代自增请使用++ i （以减少不必要开销）；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>; 语句<span class="number">2</span>; 语句<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  被执行的代码块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>语句 1 在循环（代码块）开始前执行；</p>
<p>语句 2 定义运行循环（代码块）的条件；</p>
<p>语句 3 在循环（代码块）已被执行之后执行。</p>
<ul>
<li>循环里的 ++i 和 i++的结果是一样的，<strong>都要等代码块执行完毕才能执行</strong>，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因。</li>
</ul>
<h4 id="4-uthash"><a href="#4-uthash" class="headerlink" title="4.uthash"></a>4.uthash</h4><p>开源文件&lt;uthash.h&gt;    :    uthash 是C的比较优秀的开源代码，它实现了常见的hash操作函数，例如查找、插入、删除等待。该套开源代码采用宏的方式实现hash函数的相关功能，支持C语言的任意数据结构为key值，甚至可以采用多个值作为key，</p>
<h4 id="5-qsort"><a href="#5-qsort" class="headerlink" title="5.qsort"></a>5.qsort</h4><p>头文件&lt;stdlib.h&gt;  包含有    <strong>qsort</strong>    函数（即快速排序），用法：</p>
<p><strong>对int类型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *) a - *(<span class="type">int</span> *) b;  </span><br><span class="line">    <span class="comment">//输入a，b：*(int *) a - *(int *) b为顺序排序，即从小到大排，b - a 则为逆序排序，即从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    qsort (arr, n , <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对char类型：（同上）</p>
<p>对double类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *a , <span class="type">const</span> <span class="type">void</span> *b )</span> </span><br><span class="line">&#123; </span><br><span class="line"> 	<span class="keyword">return</span> *(<span class="type">double</span>*)a &gt; *(<span class="type">double</span>*)b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p><strong>对结构体类型以及字符串类型：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp1</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b-&gt;num - a-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp2</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;word, b-&gt;word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>qsort  ( )  包含：</p>
<ul>
<li>arr  :  指向要排序的数组的第一个元素的指针；</li>
<li>n : 对应数组中元素的个数；</li>
<li>sizeof ( int ) : 数组中每个的元素的大小，以字节为单位；</li>
<li>cmp：用来比较两个元素的函数</li>
</ul>
<h4 id="6-布尔类型"><a href="#6-布尔类型" class="headerlink" title="6.布尔类型"></a>6.布尔类型</h4><p>C语言中没有布尔类型，要使用true和false，需要导入头文件&lt;stdbool.h&gt;,或使用宏定义或枚举类来设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用宏定义布尔类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="comment">//定义一个布尔变量</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以用过枚举来定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    <span class="literal">true</span> = <span class="number">1</span>, falsse = <span class="number">0</span></span><br><span class="line">&#125;<span class="type">bool</span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-字符串操作"><a href="#7-字符串操作" class="headerlink" title="7.字符串操作"></a>7.字符串操作</h4><p>C中的有关字符串操作的函数：</p>
<ul>
<li>需要头文件&lt;string.h&gt;</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">函数 &amp; 目的</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td>
</tr>
</tbody></table>
<h4 id="8-动态分配"><a href="#8-动态分配" class="headerlink" title="8.动态分配"></a>8.动态分配</h4><ul>
<li>malloc用法，如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>calloc用法，如：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;  关于效率问题，calloc函数由于给每一个空间都要初始化值，那必然效率较malloc要低，并且现实世界，很多情况的空间申请是不需要初始值的，这也就是为什么许多初学者更多的接触malloc函数的原因。</p>
<ul>
<li>realloc用于对动态内存进行扩容（即已申请的动态空间不够用，需进行空间扩容操作），如:</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> *pp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure>

<p>（逗号前的p是指向原来空间的指针，逗号后是需要扩容的大小）</p>
<h4 id="9-amp-amp-和switch注意"><a href="#9-amp-amp-和switch注意" class="headerlink" title="9.&amp;&amp;和switch注意"></a>9.&amp;&amp;和switch注意</h4><ul>
<li><p>（…)&amp;&amp;(…)     如果前面的语句为0，则后面的语句不执行</p>
</li>
<li><p>switch中的case后不带break的话，会一直往后执行，直到遇到break；default写在中间，也会一直往后执行语句，直到遇到break或switch结束。</p>
</li>
</ul>
<h4 id="10-斐波那契数通项公式："><a href="#10-斐波那契数通项公式：" class="headerlink" title="10.斐波那契数通项公式："></a>10.斐波那契数通项公式：</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708728.png" alt="image-20210407141717675"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-math-h"><a href="#11-math-h" class="headerlink" title="11.math.h"></a>11.math.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span>	</span><br><span class="line">    <span class="comment">//返回x的自然对数（基数为e的对数）</span></span><br><span class="line">如：<span class="title function_">log</span><span class="params">(<span class="number">2.700000</span>)</span> = <span class="number">0.993252</span>    </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span>	</span><br><span class="line">    <span class="comment">//返回x的常用对数（基数为10的对数）</span></span><br><span class="line">如：<span class="title function_">log10</span><span class="params">(<span class="number">10000.000000</span>)</span> = <span class="number">4.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> *integer)</span>	</span><br><span class="line">    <span class="comment">//返回值为小数部分，并设置interger为整数部分</span></span><br><span class="line">如：x = <span class="number">8.123456</span>;</span><br><span class="line">   fractpart = <span class="built_in">modf</span>(x, &amp;intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;整数部分 = %lf\n&quot;</span>, intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;小数部分 = %lf \n&quot;</span>, fractpart);</span><br><span class="line">结果为：整数部分 = <span class="number">8.000000</span></span><br><span class="line">	   小数部分 = <span class="number">0.123456</span> </span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">pow</span>(<span class="type">double</span> x,<span class="type">double</span> y)	</span><br><span class="line">    <span class="comment">//返回x的y次幂</span></span><br><span class="line">如：<span class="built_in">pow</span>(<span class="number">8.0</span>, <span class="number">3</span>) </span><br><span class="line">   值 <span class="number">8.0</span> ^ <span class="number">3</span> = <span class="number">512.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的平方根</span></span><br><span class="line">如：<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br><span class="line">    值<span class="number">4.000000</span> 的平方根是 <span class="number">2.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">fabs</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的绝对值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">ceil</span>(<span class="type">double</span> x)    </span><br><span class="line">    <span class="comment">//返回大于或等于x的最小整数值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">floor</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回小于或等于x的最大整数值</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="built_in">fmod</span>(<span class="type">double</span> x,<span class="type">double</span> y)</span><br><span class="line">    <span class="comment">//返回x除以y的余数</span></span><br></pre></td></tr></table></figure>

<h4 id="12-负数补码，二-x2F-十-x2F-八进制转化"><a href="#12-负数补码，二-x2F-十-x2F-八进制转化" class="headerlink" title="12.负数补码，二&#x2F;十&#x2F;八进制转化"></a>12.负数补码，二&#x2F;十&#x2F;八进制转化</h4><p>补码来表示和存储。反码多应用于系统环境设置。</p>
<p>1、补码：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p>
<p>2、反码：反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数。</p>
<p>比如（7）+（-7）&#x3D;0</p>
<p>7 -&gt; 0000 0111（7的补码）</p>
<p>-7 -&gt; 1111 1001（-7的补码）</p>
<p>所以相加为1 0000 0000（超出的最高位默认去掉）</p>
<p>比如（2）+（-3）&#x3D;（-1）</p>
<p>2  -&gt; 0000 0010 （2的补码）</p>
<p>-3 -&gt; 1111 1101 （-3的补码）</p>
<p>相加为 1111 1111（-1的补码）</p>
<ul>
<li><p>1.<strong>负数的补码是在原码的基础上除符号位外其余位取反后+1</strong></p>
<p>例如：-8的原码为 1000 1000，通过原码求出它的反码，负数的反码就是 除符号为以外，其余的全部求反，-8 的反码为 1111 0111，其反码码 +1，就是它的补码， -8 的补码为 1111 1000</p>
<p><strong>或者</strong>：</p>
<p>2.<strong>先求出负数的绝对值的二进制，然后从右到左遍历，遇到第一个1时，将其左侧全部取反，右侧和它本身不变。</strong></p>
<p><strong>例如01100100 -&gt; 10011100</strong></p>
</li>
<li><p>十进制转二进制，如果十进制数是负数则取其反码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">15</span>], flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) flag = <span class="number">1</span>, x = -x;    <span class="comment">//这里使用了上述第二种取补码方式   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        arr[i] = x % <span class="number">2</span>;		<span class="comment">//这里数组存储二进制数的1和0的顺序与其本身相反</span></span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="comment">// 负数 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)        </span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">1</span> &amp;&amp; i &lt; <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">7</span>; ++j)</span><br><span class="line">                    arr[j] = <span class="number">1</span> - arr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">convertDecimalToBinary</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> binaryNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> remainder, i = <span class="number">1</span>, step = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Step %d: %d/2, 余数 = %d, 商 = %d\n&quot;</span>, step++, n, remainder, n/<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        binaryNumber += remainder*i;</span><br><span class="line">        i *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>二进制转十进制</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的n由1和0构成，以表示二进制数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">convertBinaryToDecimal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> decimalNumber = <span class="number">0</span>, i = <span class="number">0</span>, remainder;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        decimalNumber += remainder*<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decimalNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="输入常见问题"><a href="#输入常见问题" class="headerlink" title="输入常见问题"></a>输入常见问题</h4><h6 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h6><p>1、scanf的返回值</p>
<p>scanf通常返回的是成功赋值(从标准输入设备赋值到参数列表所指定的内存区域)的数据项数，如果出错或是遇到end of file，则返回EOF，比如：</p>
<p>scanf(“%d%d”, &amp;x, &amp;y);</p>
<p> scanf函数仅在每一个数据域均有数据，并按回车后结束</p>
<p>如果x和y都被成功读入，那么scanf的返回值就是2;<br>如果只有x被成功读入，返回值为1;<br>如果x和y都未被成功读入，返回值为0;<br>如果遇到错误或遇到end of file，返回值为EOF</p>
<p>2、scanf的处理机制</p>
<p>scanf以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf需要读取一个数据项，发现缓冲区当前是空的，那么程序就会在scanf代码处阻塞，等待用户输入，scanf函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf函数返回，程序继续执行。</p>
<p>3、scanf对不同类型输入的处理方式</p>
<p>首先，要明确一个概念：空白字符(white space)。一般，程序中所指的空白字符是指空格(space)，回车(enter)和指标符(table)。</p>
<p>3.1 整数%d</p>
<p>对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(“%d%d”,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。</p>
<p>3.2 字符串%s<br>scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\0’。</p>
<p>因此，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p>
<p>3.3 字符%c</p>
<p>scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。对此可以使用 getchar(char类型变量) ，来只读取一个字符。</p>
<p>1 2 4 8 16 32 64 128 256</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="cl1yneflg0000swtugk1q9lrr" data-title="C语言" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/Notes/2022/04/14/hello-world/" class="article-date">
  <time class="dt-published" datetime="2022-04-14T06:48:37.433Z" itemprop="datePublished">2022-04-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/Notes/2022/04/14/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/04/14/hello-world/" data-id="cl1yn5ycv0000fotu3kgebnue" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/Notes/">&laquo; Prev</a><a class="page-number" href="/Notes/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/Notes/archives/2022/04/">April 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/">算法</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/">快捷键</a>
          </li>
        
          <li>
            <a href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E7%9B%B8%E5%85%B3/">面试相关</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/Notes/" class="mobile-nav-link">Home</a>
  
    <a href="/Notes/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/Notes/js/jquery-3.4.1.min.js"></script>



  
<script src="/Notes/fancybox/jquery.fancybox.min.js"></script>




<script src="/Notes/js/script.js"></script>





  </div>
</body>
</html>