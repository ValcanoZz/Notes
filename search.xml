<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java—SpringBoot&amp;MybatisPlus</title>
      <link href="/Notes/2022/05/13/Java%E2%80%94SpringBoot-MybatisPlus/"/>
      <url>/Notes/2022/05/13/Java%E2%80%94SpringBoot-MybatisPlus/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot&amp;MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络2.0</title>
      <link href="/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/"/>
      <url>/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/</url>
      
        <content type="html"><![CDATA[<h3 id="缩写简称"><a href="#缩写简称" class="headerlink" title="缩写简称"></a>缩写简称</h3><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p></li><li><p>HTTP —— 超文本传输协议， HyperText Transfer Protocol</p></li><li><p>ARP协议 —— 地址解析协议 （Address Resolution Protocol）</p></li><li><p>MSS  —— TCP最大报文段长度</p></li><li><p>QUIC —— 快速UDP互联网连接（Quick UDP Internet Connection）</p></li><li><p>SSL&#x2F;TLS —— </p><blockquote><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p></blockquote></li><li><p>RTT —— 往返时间 （Round-Trip Time）</p></li></ul><h1 id="TCP-x2F-IP网络模型"><a href="#TCP-x2F-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户直接接触到的就是应⽤层（Application Layer），当两个不同设备的应⽤需要通信的时候，应用就把应用数据传给下⼀层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><blockquote><p>应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。</p></blockquote><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层（Transport Layer）是为应用层提供网络支持的。</p><p>传输层有两个重要协议：TCP和UDP</p><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p><p>大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证 数据包能可靠地传输给对方。</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p><p>UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率 也高。</p></li></ul><p>MSS —— TCP最大报文段长度</p><p>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP段（TCP Segment）。</p><p>端口：</p><p>⼀台设备上可能会有很多应用在接收或者传输数 据，因此需要用一个编号将应用区分开来，这个编号就是端口。</p><p>传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>公认的默认端口：</p><p>0 ~ 1023 是系统端口号，即已经公认定义或为将要公认定义的软件保留的，1024-49151用户端口号 ，49152-65535 是动态端口号 或称私有端口，不能被正式注册占用。</p><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>20 &#x2F;TCP,UDP</td><td>FTP [Default Data]</td><td>文件传输协议 - 默认数据端口</td></tr><tr><td>21 &#x2F;TCP,UDP</td><td>FTP [Control]</td><td>文件传输协议 - 控制端口</td></tr><tr><td>22 &#x2F;TCP,UDP</td><td>SSH</td><td>SSH（Secure Shell） - 远程登录协议，用于安全登录文件传输（SCP，SFTP）及端口重新定向</td></tr><tr><td>23 &#x2F;TCP,UDP</td><td>Telnet</td><td>Telnet终端仿真协议 - 未加密文本通信</td></tr><tr><td>25 &#x2F;TCP,UDP</td><td>SMTP</td><td>SMTP（简单邮件传输协议） - 用于邮件服务器间的电子邮件传递</td></tr><tr><td>43 &#x2F;TCP</td><td>WHOIS</td><td>WHOIS协议（who is ，查询域名的相关信息）</td></tr><tr><td>53 &#x2F;TCP,UDP</td><td>DNS</td><td>DNS（域名服务系统）</td></tr><tr><td>67 &#x2F;UDP</td><td>BOOTPs</td><td>BOOTP服务；同时用于动态主机设置协议 （BootStrap协议，引导程序协议，是DHCP的前身）</td></tr><tr><td>68 &#x2F;UDP</td><td>BOOTPc</td><td>BOOTP客户端；同时用于动态主机设定协议</td></tr><tr><td>69 &#x2F;UDP</td><td>TFTP</td><td>小型文件传输协议（小型文件传输协议）</td></tr><tr><td>80 &#x2F;TCP</td><td>Http</td><td>超文本传输协议（超文本传输协议）- 用于传输网页</td></tr><tr><td>110 &#x2F;TCP</td><td>POP3</td><td>邮局协议，“邮局协议”，第3版 - 用于接收电子邮件</td></tr><tr><td>113 &#x2F;TCP</td><td>Windows验证服务</td><td>Ident - 旧的服务器身份识别系统，仍然被IRC服务器用来认证它的用户</td></tr><tr><td>123 &#x2F;UDP</td><td>NTP</td><td>NTP（Network Time Protocol） - 用于网络时间同步</td></tr><tr><td>137 &#x2F;TCP,UDP</td><td>NetBIOS Name Service</td><td>NetBIOS（网上基本输入输出系统）， NetBIOS 名称服务</td></tr><tr><td>138 &#x2F;TCP,UDP</td><td>NetBIOS Datagram Service</td><td>NetBIOS NetBIOS 数据报文服务</td></tr><tr><td>139 &#x2F;TCP,UDP</td><td>NetBIOS Session Service</td><td>NetBIOS NetBIOS 会话服务</td></tr><tr><td>143 &#x2F;TCP,UDP</td><td>IMAP</td><td>因特网信息访问协议（Internet Message Access Protocol） - 用于检索 电子邮件</td></tr><tr><td>161 &#x2F;TCP,UDP</td><td>SNMP</td><td>简单网络管理协议</td></tr><tr><td>179 &#x2F;TCP</td><td>Bgp</td><td>边界网关协议 (Border Gateway Protocol)</td></tr><tr><td>194 &#x2F;TCP</td><td>IRC</td><td>互联网中继聊天（Internet Relay Chat）</td></tr><tr><td>220 &#x2F;TCP,UDP</td><td>IMAP3</td><td>因特网信息访问协议，交互邮件访问协议第3版</td></tr><tr><td>389 &#x2F;TCP,UDP</td><td>LDAP</td><td>轻型目录访问协议（Lightweight Directory Access Protocol）</td></tr><tr><td>443 &#x2F;TCP</td><td>Https</td><td>超文本传输安全协议 - 超文本传输协议 over TLS&#x2F;SSL（加密传输）</td></tr><tr><td>546 &#x2F;TCP,UDP</td><td>DHCPv6 client</td><td>DHCPv6客户端（动态主机配置协议，Dynamic Host Configuration Protocol）</td></tr><tr><td>547 &#x2F;TCP,UDP</td><td>DHCPv6 server</td><td>DHCPv6服务器</td></tr><tr><td>631 &#x2F;TCP,UDP</td><td>CUPS</td><td>通用Unix打印系统</td></tr><tr><td>636 &#x2F;TCP,UDP</td><td>LDAPS</td><td>LDAP over SSL（加密传输，也被称为LDAPS）</td></tr><tr><td>991 &#x2F;TCP,UDP</td><td>NAS</td><td>NAS (Netnews Admin System， 网络新闻管理系统 )</td></tr><tr><td>1080 &#x2F;tcp</td><td>SOCKS</td><td>SOCKS代理</td></tr><tr><td>1194 &#x2F;udp</td><td>OpenVPN</td><td>OpenVPN</td></tr><tr><td>1433 &#x2F;tcp,udp</td><td>SQL Server</td><td>Microsoft SQL 数据库系统</td></tr><tr><td>1434 &#x2F;tcp,udp</td><td>SQL Server monitor</td><td>Microsoft SQL 活动监视器</td></tr><tr><td>1521 &#x2F;tcp</td><td>Oracle</td><td>Oracle数据库 default listener, in future releases official port 2483</td></tr><tr><td>3306 &#x2F;tcp,udp</td><td>MySQL</td><td>MySQL数据库系统</td></tr><tr><td>3389 &#x2F;tcp</td><td>RDP</td><td>远程桌面协议（RDP）</td></tr><tr><td>5432 &#x2F;tcp</td><td>PostgreSQL</td><td>PostgreSQL database system</td></tr></tbody></table></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层负责 实际的数据传输功能；</p><blockquote><p>⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，所以这些功能交由网络层实现。</p></blockquote><p>主要协议： IP</p><p>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装 成 IP 报文，如果 IP 报文大小超过 MTU（最大传输但与，以太网中⼀般为 1500 字节）就会再次进行分片，得到⼀个即将发送到网络的 IP 报文。</p><p>IP地址分为两种意义 ：</p><ul><li>网络号：负责标识该 IP 地址是属于哪个子网的</li><li>主机号：负责标识同⼀子网下的不同主机</li></ul><p>通过子网掩码算出，先匹配到相同的网络号，再去找对应的主机。</p><p>路由：通过算法决定下一步走哪一条路径。</p><blockquote><p>IP 协议的寻址作用是告诉我们去往下⼀个目的地该朝哪个⽅向走，路由则是根据「下⼀个目的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘。</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层 标识网络中的设备，为网络层提供链路级别传输的服务。</p><blockquote><p>每⼀台设备的网卡都会有⼀个 MAC 地址，它就是用来唯⼀标识设备的。路由器计算出了下⼀个目的地 IP 地址，再通过 ARP 协议找到该目的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p></blockquote><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层 （Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>HTTP，是超文本传输协议，HyperText Transfer Protocol</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>HTTP五大类状态码：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1**</td><td>提示信息，表示目前是协议处理的中间状态，还需要后续操作</td></tr><tr><td>2**</td><td>成功，报文已经收到并正确处理</td></tr><tr><td>3**</td><td>重定向，资源位置发生变动，需要客户端重新发送请求</td></tr><tr><td>4**</td><td>客户端错误，请求报文有误，服务器无法处理</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求时内部发生错误</td></tr></tbody></table><p>1xx —— 属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。 </p><p>2xx —— 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 </p><ul><li>「200 OK」：是最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 </li><li>「204 No Content」：也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「206 Partial Content」：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的⼀部分，也是服务器处理成功的状态。</li></ul><p>3xx —— 表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 </p><ul><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。 </p></li><li><p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。 </p><blockquote><p>301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 </p></blockquote></li><li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，᯿定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓 存控制。</p></li></ul><p>4xx —— 表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 </p><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 </li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 </li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p>5xx —— 表示客户端请求报文正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。 </p><ul><li>「500 Internal Server Error」与 400 类型一样，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 </li><li>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。 </li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器 发生了错误。 </li><li>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“网络服务正忙，请稍后再试”的意思。</li></ul><h3 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h3><ul><li><p>Host 字段 —— 客户端发送请求时，用来指定服务器的域名。</p><blockquote><p>例： Host: www. baidu.com ，有了Host字段，就可以将请求发往「同⼀台」服务器上的不同网站。</p></blockquote></li><li><p>Content-Length 字段 —— 服务器本次回应返回的数据长度。</p></li><li><p>Connection 字段 —— 用于客户端要求服务器使用TCP 持久连接，以便其他请求复用。</p><blockquote><p>Connection：Keep-Alive</p><p>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive.</p><p>⼀个可以复用的 TCP 连接会持续到 客户端或服务器主动关闭连接。</p></blockquote></li><li><p>Content-Type —— 用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Accept —— 客户端声明自己可以接收哪些数据格式</p><blockquote><p>客户端    Accept:  *&#x2F;*    （表示能接收所有数据格式</p><p>服务器   Content-Type:  text&#x2F;html; charset&#x3D;utf-8</p></blockquote></li><li><p>Content-Encoding  ——  说明数据的压缩方法，即服务器返回的数据用了什么压缩格式</p><p>Accept-Encoding  —— 客户端能接受的压缩方式。</p></li></ul><h2 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h2><p>GET —— 请求从服务器获取资源；</p><p>POST —— 向 url 指定的资源提交数据，数据就放在报文的 body 里；</p><blockquote><p>安全：在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。</p><p>幂等：是指多次执⾏相同的操作，结果都是「相同」的。</p><p>对此 —— </p><ul><li>GET方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全 的，且每次的结果都是相同的；</li><li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的。</li></ul></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>优点：简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li><p>简单： HTTP 基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式，易于理解。</p></li><li><p>灵活和易于扩展：：HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许自定义和扩充。</p><p>同时HTTP是工作再应用层的，它的下层可以随意变化，比如：HTTPS就是在HTTP和TCP之间增加了SSL&#x2F;TLS安全传输层，HTTP3还把TCP换成了基于UDP的QUIC。</p></li></ul><p>缺点：无状态，明文传输，不安全</p><ul><li><p>无状态</p><p>好处在于服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的 负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>坏处是在完成有关联性的操作时会非常麻烦，需要每次都询问身份信息。</p><blockquote><p>最简单的解决方式：使用 Cookie 技术</p></blockquote></li><li><p>明文传输</p><p>好处在于方便阅读，通过浏览器控制台或抓包都可以直接查看，便于调试。</p><p>坏处是 信息裸奔了，很容易被窃取信息。</p></li><li><p>不安全</p><ul><li>窃听风险：通信使用明文；</li><li>冒充风险：不验证通信方的身份，可能遭遇伪装；</li><li>篡改风险：无法证明报文的完整性，可能数据遭到篡改</li></ul><blockquote><p>解决：可以用HTTPS，也就是引入 SSL&#x2F;TLS 层</p></blockquote></li></ul><p>HTTP&#x2F;1.1性能</p><ul><li><p>长连接</p><p>HTTP&#x2F;1.0每次发起请求，都要新建一次TCP连接，而且是串行请求，做了无所谓的TCP建立连接和断开。</p><p>HTTP&#x2F;1.1提出了 长连接，也就是持久连接，只要任意一端没有明确提出断开连接，则会保持TCP连接状态。</p><blockquote><p>长连接使得 管道网络传输 成为可能，即在同⼀个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>但是服务器还是得按顺序处理请求，可能发生 队头阻塞。</p></blockquote></li><li><p>队头阻塞</p><p>「请求 - 应答」的模式会发送队头阻塞，影响性能；</p><p>因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了上述的风险： </p><ul><li><p>信息加密：交互信息无法被窃取；</p><p>使用<strong>混合加密</strong>的方式实现信息的机密性。</p><blockquote><p>混合加密： 对称加密 + 非对称加密 </p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 </li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul><p>之所以使用混合加密是因为：</p><ul><li>对称加密 只使用⼀个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密 使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></blockquote></li><li><p>校验机制：无法篡改通信内容，篡改了就不能正常显示； </p><p>使用 <strong>摘要算法</strong> 来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决 了篡改的风险。</p><blockquote><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」⼀同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出 的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p></blockquote></li><li><p>身份证书：证明网站合法性；</p><p>将服务器<strong>公钥放入到数字证书</strong>中，解决了冒充的风险。</p><blockquote><p>公钥的可信度：将公钥放在CA（数字证书认证机构）颁发的数字证书中，只要证书可信，公钥就可信；</p><ol><li>服务器把自己的公钥注册到CA;</li><li>CA用自己的私钥将服务器的公钥 数字签名，并颁发数字证书；</li><li>客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性；</li><li>从数字证书获取服务器的公钥后，使用公钥对报文加密后发送；</li><li>服务器使用是要对报文解密；</li></ol></blockquote></li></ul><h3 id="HTTPS建立连接"><a href="#HTTPS建立连接" class="headerlink" title="HTTPS建立连接"></a>HTTPS建立连接</h3><p>SSL&#x2F;TLS 协议基本流程： </p><ol><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。 </li><li>双方采用「会话秘钥」进行加密通信。</li></ol><p>前两步是SSL&#x2F;TLS的建立过程，即握手阶段，设计四次通信：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205091837504.png" alt="HTTPS 连接建立过程"></p><p>流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><blockquote><p>关于SSL和TLS：</p><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p><p>因此，SSL 和 TLS 可以视作同一东西的不同阶段。</p></blockquote><blockquote><p>SSL1.2 需要4次握手，2个RTT时延；而SSL&#x2F;TLS1.3 只需3次握手，1个RTT时延。</p></blockquote><h2 id="HTTP-x2F-1-1-2-3的演变"><a href="#HTTP-x2F-1-1-2-3的演变" class="headerlink" title="HTTP&#x2F;1.1~2~3的演变"></a>HTTP&#x2F;1.1~2~3的演变</h2><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p><ul><li>使用 TCP <strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持<strong>管道（pipeline）网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的<strong>顺序响应</strong>的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205091847917.png" alt="HTT/1 ~ HTTP/2"></p><p><em>1. 头部压缩</em></p><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><em>2. 二进制格式</em></p><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p>在收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p><em>3. 数据流</em></p><p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>在 HTTP&#x2F;2 中每个请求或相应的所有数据包，称为一个数据流（<code>Stream</code>）。每个数据流都标记着一个独一无二的编号（Stream ID），<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><p><em>4. 多路复用</em></p><p>HTTP&#x2F;2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p><blockquote><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p></blockquote><p><em>5. 服务器推送</em></p><p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p><blockquote><p>比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，而在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p></blockquote><p>HTTP&#x2F;2缺陷：</p><p>在TCP层仍存在队头阻塞问题：</p><p>TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><blockquote><p>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，</p><p>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p></blockquote><p>对此，HTTP&#x2F;3 把 HTTP 下层的 TCP 协议<strong>改成了 UDP</strong>！</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205091857744.png" alt="HTTP/1 ~ HTTP/3"></p><p>并且，基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC有以下特点：</p><ul><li><p><em>无队头阻塞</em></p><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。（Stream之间没有依赖，都是独立的）</p></li><li><p>更快的连接建立</p><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”</strong>，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 <strong>1 个 RTT 就可以「同时」完成建立连接与密钥协商</strong>，如图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205091901785.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p><blockquote><p>在第二次连接的时候，应用数据包还可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p></blockquote></li><li><p>连接迁移</p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p></li></ul><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>不过，QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><p>所以，HTTP&#x2F;3 现在普及的进度非常的缓慢。</p><h2 id="HTTP-x2F-1-1如何优化"><a href="#HTTP-x2F-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h2><p>思路：</p><ul><li><p><strong>尽量避免发送 HTTP 请求</strong>；</p><p>—— <strong>缓存</strong>：将请求的url作为key，响应作为value； 并估算一个过期时间，过期后发请求，会带上上一次请求的摘要，服务器比对后，如果一样，仅返回不含包体的 <code>304 Not Modified</code> 响应，不一样就带上最新的资源。</p></li><li><p><strong>在需要发送 HTTP 请求时，考虑如何减少请求次数</strong>；</p><p>—— <strong>减少重定向请求次数</strong>： 将重定向工作交给代理服务器。</p><p>—— <strong>合并请求</strong>： 比如将多个小图片放在一起发送，将css、js一起打包发送，但缺点是：如果其中一个资源发送变化，客户端必须重新下载整个大资源文件。</p><p>—— <strong>延迟发送请求</strong>：一般页面中有很多url，没必要全部获取，只获取当前用户所看到的页面资源。</p></li><li><p><strong>减少服务器的 HTTP 响应的数据大小</strong>；</p><p>—— <strong>无损压缩</strong>： 如Brotli，gzip等算法</p><p>—— <strong>有损压缩</strong>：WebP格式（图片压缩）</p></li></ul><h2 id="HTTPS-TLS握手解析"><a href="#HTTPS-TLS握手解析" class="headerlink" title="HTTPS TLS握手解析"></a>HTTPS TLS握手解析</h2><p>HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><blockquote><p><strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><ul><li>客户端：ClientHello</li><li>服务端：ServerHello，Certificate，ServerHelloDone</li><li>客户端：ClientKeyExchange，ChangeCipherSpec，Finished</li><li>服务端：ChangeCiipherSpec，Finished</li></ul></blockquote><p>早先的密钥交换算法是RSA算法，但<strong>不支持前向保密</strong>（一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解）。现在大多数网站使用的正是 ECDHE 密钥协商算法，</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>RSA算法中，TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，需要确保私钥不被窃取。</p><h4 id="TLS第一次握手"><a href="#TLS第一次握手" class="headerlink" title="TLS第一次握手"></a>TLS第一次握手</h4><p>客户端发出一个「<strong>Client Hello</strong>」，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111346948.png" alt="img"></p><h4 id="TLS第二次握手"><a href="#TLS第二次握手" class="headerlink" title="TLS第二次握手"></a>TLS第二次握手</h4><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111517197.png" alt="img"></p><blockquote><p>上图选择的密码套件： “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256” ，其基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」。</p><ul><li><p>其中 “TLS”后 “WITH” 前 一般有两个单词，为密钥交换算法 和 约定证书的验证算法。图中只有RSA，说明这个算法用的都是RSA；</p></li><li><p>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</p></li><li><p>摘要算法 SHA256 用于消息认证和产生随机数；</p></li></ul><p>此时，两个 HELLO 就确认了TLS 版本和使用的密码套件，并且各自发了一个随机数给对方，这是生成 「会话密钥」的条件。</p></blockquote><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111532597.png" alt="img"></p><p>随后，服务端发送「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111532847.png" alt="img"></p><h4 id="TLS第三次握手"><a href="#TLS第三次握手" class="headerlink" title="TLS第三次握手"></a>TLS第三次握手</h4><p>客户端验证完证书后，认为可信则继续往下走。</p><p>接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</p><blockquote><p>服务端会用RSA私钥解密，得到 pre-master。</p><p>此时，双方都有了三个随机数：<strong>Client Random、Server Random、pre-master</strong>，根据这三个随机数，就可以生成 <strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p></blockquote><p>客户端生成会话密钥后，发送一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111553333.png" alt="img"></p><p>然后再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111554344.png" alt="img"></p><blockquote><p>可以发现，在「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p></blockquote><h4 id="TLS第四次握手"><a href="#TLS第四次握手" class="headerlink" title="TLS第四次握手"></a>TLS第四次握手</h4><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>之后就可以用 会话密钥加解密 HTTP 请求和响应了。</p><h3 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h3><blockquote><p>ECDHE 密钥协商算法是 DH 算法演进过来，DH算法的核心数学思想是 离散对数。</p></blockquote><h4 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h4><p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，即 % 或 mod 。</p><p>式子： a^i^ % p &#x3D; b ， 底数a和模板p是公共参数，是公开的，b是真数，i 是对数。 </p><p>一般 对数 作为密钥，知道了对数，能算出真数，但只知道 真数，且<strong>模板p是很大的质数</strong>时，极难算出 对数。</p><h4 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h4><p>DH算法的密钥交换过程：</p><ul><li><p>首先双方会先确定<strong>模板</strong>和<strong>底数</strong>，两个数是公开的，设模板为P，底数为G；</p></li><li><p>然后各自生成一个随机整数为私钥，假设双方的密钥为a和b。</p></li><li><p>于是有：</p><p>公钥A &#x3D; G ^a^ % P</p><p>公钥B &#x3D; G ^b^ % P</p></li><li><p>之后将公钥发给对方， 双方都可以算出一个相同的<strong>对称加密密钥k</strong>， k &#x3D; B ^a^ % P &#x3D; A ^b^ % p。</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111612199.png" alt="img"></p><p>DH算法的实现：</p><p>DHE算法，E 是指 ephemeral（临时性的），即双方的私钥在每次密钥交换通信时，都是随机生成的、临时的。</p><blockquote><p>DH算法的另一个实现是 static DH，即有一方的私钥是静态的，一般是服务器方固定私钥，但这样通过大量密钥协商过程的数据 可能可以暴力破解出服务器的私钥。</p><p>所以 static DH 算法不具备前向安全性，并不被采用。</p></blockquote><h4 id="ECDHE算法-1"><a href="#ECDHE算法-1" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h4><p>现在广泛应用的密钥交换算法 —— ECDHE算法。</p><p>ECDHE算法在 DHE算法的基础上，利用了ECC椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种<strong>椭圆曲线</strong>，和曲线上的<strong>基点 G</strong>，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在TLS第二次握手中，客户端拿到服务端的数字证书后，要校验该数字证书的有效性。</p><p>数字证书 通常包含：</p><ul><li>公钥；</li><li>持有者信息；</li><li>证书认证机构（CA）的信息；</li><li>CA 对这份文件的数字签名及使用的算法；</li><li>证书有效期；</li><li>还有一些其他额外信息；</li></ul><p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名。</p><p>签名的作用：可以避免中间人在获取证书时对证书内容的篡改。</p><h4 id="数字证书签发和验证"><a href="#数字证书签发和验证" class="headerlink" title="数字证书签发和验证"></a>数字证书签发和验证</h4><p>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205111541262.png" alt="img"></p><p>证书链：</p><p>一般申请的证书由中间证书签发，而不是由根证书签发。 客户端发现签发者不是根证书时，会逐步向上验证，确保中间证书是可信的。</p><p>之所以要弄证书链，是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/Notes/2022/05/01/JVM/"/>
      <url>/Notes/2022/05/01/JVM/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/Notes/2022/04/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/Notes/2022/04/19/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。它描述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。</p><p>也就是说，它是解决特定问题的一系列套路，是历来 代码设计经验的总结，具有一定的普遍性，可以反复使用。</p><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p><p> UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><ul><li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li><li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li></ul><p><strong>用类图表示类：</strong></p><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，如：</p><table><thead><tr><th>Employee</th></tr></thead><tbody><tr><td>- name : String<br />- age : int<br />- address : String</td></tr><tr><td>+ work() : void</td></tr></tbody></table><blockquote><p>其中属性&#x2F;方法名称前加的加号和减号表示了这个属性&#x2F;方法的可见性，UML类图中表示可见性的符号有三种：</p><ul><li>+：表示public</li><li>-：表示private</li><li>#：表示protected</li></ul><p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ &#x3D; 缺省值]</strong>  </p><p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p></blockquote><h3 id="类与类之间的关系表示"><a href="#类与类之间的关系表示" class="headerlink" title="类与类之间的关系表示"></a>类与类之间的关系表示</h3><h4 id="关联关系"><a href="#关联关系" class="headerlink" title="关联关系"></a>关联关系</h4><p>关联关系是对象之间的一种引用关系，分为一般关联关系、聚合关系和组合关系。</p><p>一般关联又可以分为单向关联，双向关联，自关联。</p><p><strong>1，单向关联</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191809276.png" alt="image-20220419180908190"></p><p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p><p><strong>2，双向关联</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191809774.png" alt="image-20220419180916705"></p><p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p><p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p><p><strong>3，自关联</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191809881.png" alt="image-20220419180933811"></p><p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p><h4 id="聚合关系"><a href="#聚合关系" class="headerlink" title="聚合关系"></a>聚合关系</h4><p>聚合关系是关联关系的一种，是强关联关系，是整体和部分之间的关系。</p><p>聚合关系也是通过成员对象来实现的，其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p><p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191809941.png" alt="image-20220419180952864"></p><h4 id="组合关系"><a href="#组合关系" class="headerlink" title="组合关系"></a>组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种更强烈的聚合关系。</p><p>在组合关系中，整体对象可以控制部分对象的生命周期，一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。例如，头和嘴的关系，没有了头，嘴也就不存在了。</p><p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191810404.png" alt="image-20220419181001332"></p><h4 id="依赖关系"><a href="#依赖关系" class="headerlink" title="依赖关系"></a>依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类（被依赖类）中的某些方法来完成一些职责。</p><p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191810511.png" alt="image-20220419181011433"></p><h4 id="继承关系"><a href="#继承关系" class="headerlink" title="继承关系"></a>继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p><p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191810425.png" alt="image-20220419181020335"></p><h4 id="实现关系"><a href="#实现关系" class="headerlink" title="实现关系"></a>实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p><p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204191810872.png" alt="image-20220419181029785"></p><h1 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p><h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>&#x3D;&#x3D;对扩展开放，对修改关闭&#x3D;&#x3D;。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><p>想要达到这样的效果，我们需要使用接口和抽象类。</p><p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p><blockquote><p>【例】搜狗输入法 的皮肤设计。</p><p>分析：可以为 搜狗输入法的皮肤 定义一个抽象类（AbstractSkin），而每个具体的皮肤 是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p></blockquote><h2 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p><p>里氏代换原则：&#x3D;&#x3D;任何基类可以出现的地方，子类一定可以出现&#x3D;&#x3D;。通俗理解：子类可以扩展父类的功能，但不能改变父类原有的功能。换句话说，<strong>子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</strong> 因此可以定义更一般的父类。</p><p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p><h2 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求&#x3D;&#x3D;对抽象进行编程，不要对实现进行编程&#x3D;&#x3D;，这样就降低了客户与实现模块间的耦合。</p><p>下面看一个例子来理解依赖倒转原则</p><blockquote><p>【例】组装电脑</p><p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p><p>对此，应该先定义cpu类，硬盘类，内存条等接口，让具体的配件实现上述接口；而在计算机类中的成员参数在定义时应该为抽象的，实例化时在给予具体的对象。</p><p>错误方式：计算机类中的成员参数直接为具体的类或对象，如 计算机类的成员参数为 intel，希捷硬盘，金士顿内存条。</p></blockquote><p>一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p><p>下面看一个例子来理解接口隔离原则</p><blockquote><p>【例】鸟类</p><p>例如定义 鸟类接口的方法时，定义了“会飞”的方法，但部分鸟如鸵鸟、企鹅并不会飞，让它们继承 “鸟” 这个接口的话，就多了一个无用的方法。因为接口可以多继承，建议将接口进一步拆分。</p></blockquote><h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>迪米特法则又叫最少知识原则。</p><p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p><p>其含义是：&#x3D;&#x3D;如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用&#x3D;&#x3D;。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、成员对象、所创建的对象、方法参数等，这些“朋友”同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><blockquote><p>【例】明星与经纪人的关系实例</p><p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则：明星不直接与粉丝、媒体公司有关联，而是通过经纪人 管理他们之间的活动。</p></blockquote><h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h2><p>合成复用原则是指：&#x3D;&#x3D;尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现&#x3D;&#x3D;。（能用成员属性定义，就别去定义多种类）</p><p>通常类的复用分为继承复用和合成复用两种。</p><p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p><ol><li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li><li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li><li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li></ol><p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p><ol><li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li><li>对象间的耦合度低。可以在类的成员位置声明抽象。</li><li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li></ol><p>下面看一个例子来理解合成复用原则</p><blockquote><p>【例】汽车有不同颜色，颜色可以用成员属性定义，就不要去定义“白车”“红车”类了。</p></blockquote><hr><h1 id="创建者模式（5）"><a href="#创建者模式（5）" class="headerlink" title="创建者模式（5）"></a>创建者模式（5）</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p><p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li>单例模式</li><li>工厂方法模式</li><li>抽象工程模式</li><li>原型模式</li><li>建造者模式</li></ul><h2 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。它提供了一种创建对象的最佳方式。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类提供了一种访问其&#x3D;&#x3D;唯一的对象&#x3D;&#x3D;的方式，可以&#x3D;&#x3D;直接访问&#x3D;&#x3D;，不需要实例化该类的对象。</p><h3 id="单例模式的实现"><a href="#单例模式的实现" class="headerlink" title="单例模式的实现"></a>单例模式的实现</h3><blockquote><p>单例设计模式分类两种：</p><p>​饿汉式：类加载就会导致该单实例对象被创建</p><p>​懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p></blockquote><p>饿汉式-方式1（静态变量方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p><p>饿汉式-方式2（静态代码块方式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p><h4 id="饿汉式-枚举方式"><a href="#饿汉式-枚举方式" class="headerlink" title="饿汉式-枚举方式"></a>饿汉式-枚举方式</h4><p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>懒汉式-方式1（线程不安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p><p>懒汉式-方式2（线程安全）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在成员位置创建该类的对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p><h4 id="懒汉式-方式3（双重检查锁）"><a href="#懒汉式-方式3（双重检查锁）" class="headerlink" title="懒汉式-方式3（双重检查锁）"></a>懒汉式-方式3（双重检查锁）</h4><p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为null</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p><p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//抢到锁之后再次判断是否为空</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="literal">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">小结：</font></p><p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p><h4 id="懒汉式-方式4（静态内部类方式）"><a href="#懒汉式-方式4（静态内部类方式）" class="headerlink" title="懒汉式-方式4（静态内部类方式）"></a>懒汉式-方式4（静态内部类方式）</h4><p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性&#x2F;方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color='red'>说明：</font></p><p>​第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p><p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p><p><font color="red">小结：</font></p><p>​静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><h4 id="问题演示"><a href="#问题演示" class="headerlink" title="问题演示"></a>问题演示</h4><p>破坏单例模式：</p><p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是序列化和反射。</p><ul><li><p>序列化反序列化</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          <span class="comment">//往文件中写对象</span></span><br><span class="line">          <span class="comment">//writeObject2File();</span></span><br><span class="line">          <span class="comment">//从文件中读取对象</span></span><br><span class="line">          <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">          <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">  </span><br><span class="line">          <span class="comment">//判断两个反序列化后的对象是否是同一个对象</span></span><br><span class="line">          System.out.println(s1 == s2);</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton <span class="title function_">readObjectFromFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          <span class="comment">//创建对象输入流对象</span></span><br><span class="line">          <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">          <span class="comment">//第一个读取Singleton对象</span></span><br><span class="line">          <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) ois.readObject();</span><br><span class="line">  </span><br><span class="line">          <span class="keyword">return</span> instance;</span><br><span class="line">      &#125;</span><br><span class="line">  </span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObject2File</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">          <span class="comment">//获取Singleton类的对象</span></span><br><span class="line">          <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">          <span class="comment">//创建对象输出流</span></span><br><span class="line">          <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));</span><br><span class="line">          <span class="comment">//将instance对象写出到文件中</span></span><br><span class="line">          oos.writeObject(instance);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p></blockquote></li><li><p>反射</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Test类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//获取Singleton类的字节码对象</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Singleton.class;</span><br><span class="line">        <span class="comment">//获取Singleton类的私有无参构造方法对象</span></span><br><span class="line">        <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">        <span class="comment">//取消访问检查</span></span><br><span class="line">        constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建Singleton类的对象s1</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s1</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line">        <span class="comment">//创建Singleton类的对象s2</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">s2</span> <span class="operator">=</span> (Singleton) constructor.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断通过反射创建的两个Singleton对象是否是同一个对象</span></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p></blockquote></li></ul><blockquote><p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p></blockquote><h4 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h4><ul><li><p>序列化、反序列方式破坏单例模式的解决方法</p><p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p><p><strong>Singleton类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 下面是为了解决序列化反序列化破解单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>源码解析：</strong></p><p>ObjectInputStream类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title function_">readObject</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// if nested read, passHandle contains handle of enclosing object</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">outerHandle</span> <span class="operator">=</span> passHandle;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> readObject0(<span class="literal">false</span>);<span class="comment">//重点查看readObject0方法</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readObject0</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (tc) &#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> TC_OBJECT:</span><br><span class="line"><span class="keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="comment">//重点查看readOrdinaryObject方法</span></span><br><span class="line">...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        depth--;</span><br><span class="line">        bin.setBlockDataMode(oldMode);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">readOrdinaryObject</span><span class="params">(<span class="type">boolean</span> unshared)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span></span><br><span class="line">    obj = desc.isInstantiable() ? desc.newInstance() : <span class="literal">null</span>; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span></span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="literal">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;</span><br><span class="line">    <span class="comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span></span><br><span class="line">    <span class="comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">rep</span> <span class="operator">=</span> desc.invokeReadResolve(obj);</span><br><span class="line">     ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反射方式破解单例的解决方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">           反射破解单例模式需要添加的代码</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对外提供静态方法获取该对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">            <span class="keyword">if</span>(instance != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">说明:</font></p><p>​这种方式比较好理解。当通过反射方式调用构造方法进行创建创建时，直接抛异常。不运行此中操作。</p></li></ul><h3 id="JDK源码解析-Runtime类"><a href="#JDK源码解析-Runtime类" class="headerlink" title="JDK源码解析-Runtime类"></a>JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p><ol><li><p>通过源代码查看使用的是哪儿种单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Runtime</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Runtime</span> <span class="variable">currentRuntime</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runtime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the runtime object associated with the current Java application.</span></span><br><span class="line"><span class="comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span></span><br><span class="line"><span class="comment">     * methods and must be invoked with respect to the current runtime object.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span></span><br><span class="line"><span class="comment">     *          Java application.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title function_">getRuntime</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Don&#x27;t let anyone else instantiate this class */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Runtime</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p></li><li><p>使用Runtime类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RuntimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//获取Runtime类对象</span></span><br><span class="line">        <span class="type">Runtime</span> <span class="variable">runtime</span> <span class="operator">=</span> Runtime.getRuntime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回 Java 虚拟机中的内存总量。</span></span><br><span class="line">        System.out.println(runtime.totalMemory());</span><br><span class="line">        <span class="comment">//返回 Java 虚拟机试图使用的最大内存量。</span></span><br><span class="line">        System.out.println(runtime.maxMemory());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span></span><br><span class="line">        <span class="type">Process</span> <span class="variable">process</span> <span class="operator">=</span> runtime.exec(<span class="string">&quot;ipconfig&quot;</span>);</span><br><span class="line">        <span class="comment">//获取命令执行后的结果，通过输入流获取</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> process.getInputStream();</span><br><span class="line">        <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>* <span class="number">100</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> inputStream.read(arr);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr,<span class="number">0</span>,b,<span class="string">&quot;gbk&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>结构：</strong></p><ul><li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li><li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li><li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li></ul><p>原型模式分为：浅克隆 和 深克隆</p><blockquote><p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p></blockquote><p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 <strong>Cloneable 接口</strong>是上面的类图中的<strong>抽象原型类</strong>，而实现了<strong>Cloneable接口的子实现类</strong>就是具体的<strong>原型类</strong>。</p><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>Realizetype（具体的原型类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Realizetype</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Realizetype</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体的原型对象创建完成！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Realizetype <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;具体原型复制成功！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PrototypeTest（测试访问类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrototypeTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Realizetype</span>();</span><br><span class="line">        <span class="type">Realizetype</span> <span class="variable">r2</span> <span class="operator">=</span> r1.clone();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：</p><ul><li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li><li>性能和安全要求比较高。</li></ul><blockquote><p>例：学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，使用原型模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        c1.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//将奖状的名字修改李四</span></span><br><span class="line">        c2.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p>进行深克隆需要使用对象流。</p><blockquote><p>例：如果将浅克隆中 奖状的name属性换成自定义的Student类，那在浅克隆中，复制后的奖状的student仍指向 原奖状的student，是同一个对象；</p><p>所以浅克隆就是对具体原型类（Citation）中的引用类型的属性进行 引用的复制。以下仍是浅克隆的测试例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//奖状类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Citation</span> <span class="keyword">implements</span> <span class="title class_">Cloneable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Student stu;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getStu</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStu</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stu = stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(stu.getName() + <span class="string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Citation <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">        <span class="keyword">return</span> (Citation) <span class="built_in">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, String address)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//复制奖状</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> c1.clone();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 结果为true，两张奖状展示结果一摸一样，人名均为“李四”</span></span><br></pre></td></tr></table></figure></blockquote><p>因此，需要<strong>使用对象流，来进行深克隆</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CitationTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Citation</span>();</span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;西安&quot;</span>);</span><br><span class="line">        c1.setStu(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象输出流对象</span></span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//将c1对象写出到文件中</span></span><br><span class="line">        oos.writeObject(c1);</span><br><span class="line">        oos.close();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建对象出入流对象</span></span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        <span class="type">Citation</span> <span class="variable">c2</span> <span class="operator">=</span> (Citation) ois.readObject();</span><br><span class="line">        <span class="comment">//获取c2奖状所属学生对象</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">stu1</span> <span class="operator">=</span> c2.getStu();</span><br><span class="line">        stu1.setName(<span class="string">&quot;李四&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断stu对象和stu1对象是否是同一个对象</span></span><br><span class="line">        System.out.println(<span class="string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));</span><br><span class="line"></span><br><span class="line">        c1.show();</span><br><span class="line">        c2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。</p><p>如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><p>三种工厂方法：</p><ul><li>简单工厂模式（不属于GOF的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p><p><strong>结构</strong>：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><blockquote><p>例：设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在工厂中处理 创建对象的细节</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">&quot;americano&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">AmericanoCoffee</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">&quot;latte&quot;</span>.equals(type)) &#123;</span><br><span class="line">            coffee = <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态工厂: 将创建对象的功能定义为静态的，在上述代码中加上static即可</span></span><br></pre></td></tr></table></figure><p>优点：</p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，更容易拓展。</p><p>缺点：</p><p>产生了新的耦合：咖啡店对象和 工厂对象的耦合，工厂对象和商品对象的耦合。</p><p>如果要新增咖啡的种类，还是要修改 工厂的代码，违反了开闭原则。</p></blockquote><h3 id="工厂方法模式-1"><a href="#工厂方法模式-1" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><p>针对简单工厂的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p></blockquote><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><p><strong>结构</strong>：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><blockquote><p>例：还是咖啡店的例子</p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LatteCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanCoffeeFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeStore</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CoffeeStore</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.factory = factory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">        coffee.addMilk();</span><br><span class="line">        coffee.addsugar();</span><br><span class="line">        <span class="keyword">return</span> coffee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类（多态性），不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>缺点：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p></blockquote><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><p>工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机；但现实中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调。</p></blockquote><p>抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，即一个品牌下的不同产品 为一个产品族。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><p><strong>结构：</strong></p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li><li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li></ul><blockquote><p>例：咖啡店业务升级，处理咖啡，还卖甜点，如提拉米苏，抹茶慕斯。</p><p>要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（属于美式风味）。可以用抽象工厂实现：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204220954575.png" alt="image-20220422095403301"></p><p>抽象工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体工厂：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//美式甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AmericanCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchaMousse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//意大利风味甜点工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyDessertFactory</span> <span class="keyword">implements</span> <span class="title class_">DessertFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">LatteCoffee</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tiramisu</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：</p><p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>缺点：</p><p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p></blockquote><p><strong>使用场景</strong></p><ul><li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p></li><li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p></li><li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p></li></ul><p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p><p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p><p>第一步：定义配置文件</p><p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">american</span>=<span class="string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span></span><br><span class="line"><span class="attr">latte</span>=<span class="string">com.itheima.pattern.factory.config_factory.LatteCoffee</span></span><br></pre></td></tr></table></figure><p>第二步：改进工厂类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;bean.properties&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            p.load(is);</span><br><span class="line">            <span class="comment">//遍历Properties集合对象</span></span><br><span class="line">            Set&lt;Object&gt; keys = p.keySet();</span><br><span class="line">            <span class="keyword">for</span> (Object key : keys) &#123;</span><br><span class="line">                <span class="comment">//根据键获取值（全类名）</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> p.getProperty((String) key);</span><br><span class="line">                <span class="comment">//获取字节码对象</span></span><br><span class="line">                <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(className);</span><br><span class="line">                <span class="type">Coffee</span> <span class="variable">obj</span> <span class="operator">=</span> (Coffee) clazz.newInstance();</span><br><span class="line">                map.put((String)key,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String name)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> map.get(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p><h3 id="JDK源码-Collection-iterator方法"><a href="#JDK源码-Collection-iterator方法" class="headerlink" title="JDK源码-Collection.iterator方法"></a>JDK源码-Collection.iterator方法</h3><p>单列集合 获取迭代器的方法使用到了工厂方法模式。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204221001063.png" alt="image-20220422100142888"></p><p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p><blockquote><p>另：</p><p>​1,DateForamt类中的getInstance()方法使用的是工厂模式；</p><p>​2,Calendar类中的getInstance()方法使用的是工厂模式；</p></blockquote><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p><ul><li>分离部件的 构造(Builder负责) 和 装配(Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li><li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li><li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li></ul><p><strong>结构：</strong></p><ul><li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p></li><li><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p></li><li><p>产品类（Product）：要创建的复杂对象。</p></li><li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。</p></li></ul><blockquote><p>例：</p><p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自行车类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bike</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String frame;</span><br><span class="line">    <span class="keyword">private</span> String seat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFrame</span><span class="params">(String frame)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.frame = frame;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seat;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSeat</span><span class="params">(String seat)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.seat = seat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象 builder 类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">Bike</span> <span class="variable">mBike</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bike</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Bike <span class="title function_">createBike</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摩拜单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MobikeBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;铝合金车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;真皮车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ofo单车Builder类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OfoBuilder</span> <span class="keyword">extends</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildFrame</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setFrame(<span class="string">&quot;碳纤维车架&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buildSeat</span><span class="params">()</span> &#123;</span><br><span class="line">        mBike.setSeat(<span class="string">&quot;橡胶车座&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">createBike</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> mBike;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指挥者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Director</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Builder mBuilder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Director</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        mBuilder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Bike <span class="title function_">construct</span><span class="params">()</span> &#123;</span><br><span class="line">        mBuilder.buildFrame();</span><br><span class="line">        mBuilder.buildSeat();</span><br><span class="line">        <span class="keyword">return</span> mBuilder.createBike();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">OfoBuilder</span>());</span><br><span class="line">        showBike(<span class="keyword">new</span> <span class="title class_">MobikeBuilder</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">showBike</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        <span class="type">Director</span> <span class="variable">director</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Director</span>(builder);</span><br><span class="line">        <span class="type">Bike</span> <span class="variable">bike</span> <span class="operator">=</span> director.construct();</span><br><span class="line">        System.out.println(bike.getFrame());</span><br><span class="line">        System.out.println(bike.getSeat());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>优点：</strong></p><ul><li><p>建造者模式的封装性很好。</p><p>在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</p></li><li><p>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</p></li><li><p>可以更加精细地控制产品的创建过程 。</p><p>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</p></li><li><p>建造者模式很容易进行扩展。</p><p>如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</p></li></ul><p><strong>缺点：</strong></p><p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p><p><strong>使用场景：</strong></p><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><blockquote><p>拓展：</p><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p><p>如：假设Phone对象有四个参数，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Phone</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String cpu;</span><br><span class="line">    <span class="keyword">private</span> String screen;</span><br><span class="line">    <span class="keyword">private</span> String memory;</span><br><span class="line">    <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Phone</span><span class="params">(Builder builder)</span> &#123;</span><br><span class="line">        cpu = builder.cpu;</span><br><span class="line">        screen = builder.screen;</span><br><span class="line">        memory = builder.memory;</span><br><span class="line">        mainboard = builder.mainboard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Builder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> String cpu;</span><br><span class="line">        <span class="keyword">private</span> String screen;</span><br><span class="line">        <span class="keyword">private</span> String memory;</span><br><span class="line">        <span class="keyword">private</span> String mainboard;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Builder</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">cpu</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            cpu = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">screen</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            screen = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">memory</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            memory = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Builder <span class="title function_">mainboard</span><span class="params">(String val)</span> &#123;</span><br><span class="line">            mainboard = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Phone <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Phone</span>(<span class="built_in">this</span>);&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Phone&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Phone</span> <span class="variable">phone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Phone</span>.Builder()</span><br><span class="line">                .cpu(<span class="string">&quot;intel&quot;</span>)</span><br><span class="line">                .mainboard(<span class="string">&quot;华硕&quot;</span>)</span><br><span class="line">                .memory(<span class="string">&quot;金士顿&quot;</span>)</span><br><span class="line">                .screen(<span class="string">&quot;三星&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><strong>对比</strong></p><p><strong>工厂模式 VS 建造者模式</strong></p><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是各个部件构建的过程，然后再一步一步地组成一个复杂的对象。</p><p><strong>抽象工厂 VS 建造者模式</strong></p><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个具体的汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p><h1 id="结构型模式（7）"><a href="#结构型模式（7）" class="headerlink" title="结构型模式（7）"></a>结构型模式（7）</h1><p>结构型模式描述如何将类或对象按某种布局 组成更大的结构。它分为</p><ul><li>类 结构型模式：采用继承机制来组织接口和类；</li><li>对象 结构型模式：釆用组合或聚合来组合对象；</li></ul><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>处于某些原因，要给某对象提供一个代理以控制改对象的访问。这时，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照 代理类生成时机 不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><p><strong>结构：</strong></p><ul><li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><p><strong>使用场景：</strong></p><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成 使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。如VPN。</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>例：火车站卖票</p><p>如果要买火车票的话，一般都是去分布各地的代售点买票。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用&quot;</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。</p><h3 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h3><p>Java中提供了一个动态代理类 Proxy，Proxy提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>还是火车站售票的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">动态代理，相关问题：</font></p><ul><li><p>ProxyFactory是代理类吗？</p><p><strong>ProxyFactory不是</strong>代理模式中所说的<strong>代理类</strong>，而代理类是程序在运行过程中动态的在内存中生成的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类，只摘了重点源码：</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li></ul></li><li><p>动态代理的执行流程是什么样？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="string">&quot;sell&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable &#123;</span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行流程如下：</p><pre><code>1. 在测试类中通过代理对象调用sell()方法2. 根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法3. 代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</code></pre></li></ul><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;火车站卖票&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>随着对jdk动态代理的优化，在jdk1.8及之后，一般有接口使用JDK动态代理，如果没有接口才使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题。</p></li></ul><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>分为：类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204221949558.png" alt="image-20220422194951399"></p><p><strong>结构：</strong></p><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><p><strong>应用场景：</strong></p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><blockquote><p>例：</p><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。<br>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述中的 sd 是 StreamDecoder类对象，其类结构如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222011801.png" alt="image-20220422201101664"></p><p>从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。<br>而从如上Sun JDK中的实现类关系结构中看，是StreamDecoder的设计实现在实际上采用了适配器模式。</p></blockquote><blockquote><p>例：读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>（适配器类 要继承 目标接口， 其中 类适配器模式还要继承适配者类，调用其中的方法， 而对象适配器模式 不用继承适配者类，而是在里面创建适配者类的对象，再调用这个对象的方法；  根据<code>组合&gt;继承</code>的原则，更常用 对象适配器模式）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">&quot;sd card read a msg :hello word SD&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sd card write msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;sd card null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">&quot;tf card read msg : hello word tf card&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;tf card write a msg : &quot;</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类适配器 方式</span></span><br><span class="line"><span class="comment">// //定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="comment">// public class SDAdapterTF extends TFCardImpl implements SDCard &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     public String readSD() &#123;</span></span><br><span class="line"><span class="comment">//         System.out.println(&quot;adapter read tf card &quot;);</span></span><br><span class="line"><span class="comment">//         return readTF();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     public void writeSD(String msg) &#123;</span></span><br><span class="line"><span class="comment">//         System.out.println(&quot;adapter write tf card&quot;);</span></span><br><span class="line"><span class="comment">//         writeTF(msg);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器方式</span></span><br><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title class_">SDCard</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter read tf card &quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;adapter write tf card&quot;</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h2><p>桥接模式：</p><p>将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p><p>（例如：需求是创建不同的图形，每个图形可能有不同的颜色，这样存在多个维度的需求，如果用继承的方式来设计，会造成类爆炸，拓展起来不灵活；因此，尽量使用组合关系）</p><p><strong>结构：</strong></p><ul><li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li><li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用 实现化角色 中的业务方法。</li><li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li><li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li></ul><p><strong>优点：</strong></p><ul><li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p><blockquote><p>对下面例子：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p></blockquote></li><li><p>实现细节对客户透明</p></li></ul><p><strong>使用场景：</strong></p><ul><li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li><li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li><li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li></ul><blockquote><p>例：视频播放器</p><p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222049350.png" alt="image-20220422204931215"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现化角色</span></span><br><span class="line"><span class="comment">//视频文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//avi文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AVIFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;avi视频文件：&quot;</span>+ fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//rmvb文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">REVBBFile</span> <span class="keyword">implements</span> <span class="title class_">VideoFile</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;rmvb文件：&quot;</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象化角色</span></span><br><span class="line"><span class="comment">//操作系统版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> VideoFile videoFile;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OperatingSystemVersion</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.videoFile = videoFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Windows版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Windows</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystem</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Windows</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">        videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mac版本</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Mac</span> <span class="keyword">extends</span> <span class="title class_">OperatingSystemVersion</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Mac</span><span class="params">(VideoFile videoFile)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(videoFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">play</span><span class="params">(String fileName)</span> &#123;</span><br><span class="line">videoFile.decode(fileName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">OperatingSystem</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Windows</span>(<span class="keyword">new</span> <span class="title class_">AVIFile</span>());</span><br><span class="line">        os.play(<span class="string">&quot;战狼3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>装饰者模式：</p><p>指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p><p><strong>结构：</strong></p><ul><li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li><li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li><li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li><li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li></ul><blockquote><p>特点是：  装饰 &#x3D;&#x3D;继承&#x3D;&#x3D; 抽象构件，&#x3D;&#x3D;又聚合&#x3D;&#x3D;(使用)了构件。</p></blockquote><p><strong>优点：</strong></p><ul><li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。<br>装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，可以说：继承是静态的附加责任，装饰者则是动态的附加责任。</p></li><li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p></li></ul><p><strong>使用场景：</strong></p><ul><li><p>当不能采用继承的方式对系统进行扩充或者 采用继承不利于系统扩展和维护时。</p><p>不能采用继承的情况主要有两类：</p><ul><li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li><li>第二类是因为类定义不能继承（如final类）</li></ul></li><li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p></li><li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p></li></ul><p><strong>静态代理和装饰者的区别：</strong></p><ul><li>相同点：<ul><li>都要实现与目标类相同的业务接口</li><li>在两个类中都要声明目标对象</li><li>都可以在不修改目标类的前提下增强目标方法</li></ul></li><li>不同点：<ul><li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li><li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li></ul></li></ul><p><strong>JDK源码</strong>：</p><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p><p>以BufferedWriter为例，使用的方式很像装饰者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="comment">//创建BufferedWriter对象</span></span><br><span class="line">        <span class="comment">//创建FileWriter对象</span></span><br><span class="line">        <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);</span><br><span class="line">        <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(fw);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写数据</span></span><br><span class="line">        bw.write(<span class="string">&quot;hello Buffered&quot;</span>);</span><br><span class="line"></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其结构为：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222035563.png" alt="image-20220422203508427"></p><blockquote><p>例：</p><p>快餐店有炒面、炒饭这些快餐，可以额外附 加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p><p>为了不产生过多的子类，使用装饰者模式，配菜作为装饰，动态地添加道快餐上。</p><p>类结构如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222020464.png" alt="image-20220422202030337"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//快餐接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">float</span> price;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastFood</span><span class="params">(<span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPrice</span><span class="params">(<span class="type">float</span> price)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">getPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDesc</span><span class="params">(String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span>;  <span class="comment">//获取价格</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒饭</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedRice</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedRice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">10</span>, <span class="string">&quot;炒饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//炒面</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FriedNoodles</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FriedNoodles</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">12</span>, <span class="string">&quot;炒面&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//配料类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Garnish</span> <span class="keyword">extends</span> <span class="title class_">FastFood</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> FastFood fastFood;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> FastFood <span class="title function_">getFastFood</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFastFood</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Garnish</span><span class="params">(FastFood fastFood, <span class="type">float</span> price, String desc)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(price,desc);</span><br><span class="line">        <span class="built_in">this</span>.fastFood = fastFood;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//鸡蛋配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Egg</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Egg</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(fastFood, <span class="number">1</span>, <span class="string">&quot;鸡蛋&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//培根配料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bacon</span> <span class="keyword">extends</span> <span class="title class_">Garnish</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Bacon</span><span class="params">(FastFood fastFood)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">super</span>(fastFood,<span class="number">2</span>,<span class="string">&quot;培根&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">float</span> <span class="title function_">cost</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice() + getFastFood().getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.getDesc() + getFastFood().getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//点一份炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food.getDesc() + <span class="string">&quot; &quot;</span> + food.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加鸡蛋的炒饭</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedRice</span>();</span><br><span class="line"></span><br><span class="line">        food1 = <span class="keyword">new</span> <span class="title class_">Egg</span>(food1);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food1.getDesc() + <span class="string">&quot; &quot;</span> + food1.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========&quot;</span>);</span><br><span class="line">        <span class="comment">//点一份加培根的炒面</span></span><br><span class="line">        <span class="type">FastFood</span> <span class="variable">food2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FriedNoodles</span>();</span><br><span class="line">        food2 = <span class="keyword">new</span> <span class="title class_">Bacon</span>(food2);</span><br><span class="line">        <span class="comment">//花费的价格</span></span><br><span class="line">        System.out.println(food2.getDesc() + <span class="string">&quot; &quot;</span> + food2.cost() + <span class="string">&quot;元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><p>外观模式：</p><p>又叫门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><blockquote><p>外观（Facade）模式是“迪米特法则”的典型应用。</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222056529.png" alt="image-20220422205655364"></p><p><strong>结构：</strong></p><ul><li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li><li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li></ul><p><strong>优点：</strong></p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>不符合开闭原则，修改很麻烦</li></ul><p><strong>使用场景：</strong></p><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><blockquote><p>例：智能家电控制</p><p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222057086.png" alt="image-20220422205753964"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//灯类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Light</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了灯....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电视类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TV</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了电视....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AirCondition</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;打开了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;关闭了空调....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//智能音箱</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmartAppliancesFacade</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SmartAppliancesFacade</span><span class="params">()</span> &#123;</span><br><span class="line">        light = <span class="keyword">new</span> <span class="title class_">Light</span>();</span><br><span class="line">        tv = <span class="keyword">new</span> <span class="title class_">TV</span>();</span><br><span class="line">        airCondition = <span class="keyword">new</span> <span class="title class_">AirCondition</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(message.contains(<span class="string">&quot;打开&quot;</span>)) &#123;</span><br><span class="line">            on();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(message.contains(<span class="string">&quot;关闭&quot;</span>)) &#123;</span><br><span class="line">            off();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我还听不懂你说的！！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//起床后一键开电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">on</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;起床了&quot;</span>);</span><br><span class="line">        light.on();</span><br><span class="line">        tv.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//睡觉一键关电器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">off</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;睡觉了&quot;</span>);</span><br><span class="line">        light.off();</span><br><span class="line">        tv.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建外观对象</span></span><br><span class="line">        <span class="type">SmartAppliancesFacade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SmartAppliancesFacade</span>();</span><br><span class="line">        <span class="comment">//客户端直接与外观对象进行交互</span></span><br><span class="line">        facade.say(<span class="string">&quot;打开家电&quot;</span>);</span><br><span class="line">        facade.say(<span class="string">&quot;关闭家电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h2><p>享元模式：</p><p>通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p><p>享元（Flyweight ）模式中存在以下两种状态：</p><ol><li><strong>内部状态</strong>，即不会随着环境的改变而改变的可共享部分。</li><li><strong>外部状态</strong>，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li></ol><p><strong>结构：</strong></p><ul><li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合<code>单例模式</code>来设计具体享元类，为<code>每一个具体享元类提供唯一的享元对象</code>。</li><li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li></ul><p><strong>优点：</strong></p><ul><li>极大减少内存中相似或相同对象数量，节约系统资源，提供系统性能</li><li>享元模式中的外部状态相对独立，且不影响内部状态</li></ul><p><strong>缺点：</strong></p><p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p><p><strong>使用场景：</strong></p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><p><strong>JDK源码：</strong></p><p>Integer类使用了享元模式，看<code>valueOf()</code>方法， <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p><blockquote><p>例：俄罗斯方块</p><p>在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，而这些对象又有很多相似的地方，可以利用享元模式进行实现：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222137484.png" alt="image-20220422213744327"></p><p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getShape</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String color)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;方块形状：&quot;</span> + <span class="built_in">this</span>.getShape() + <span class="string">&quot; 颜色：&quot;</span> + color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;L&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OBox</span> <span class="keyword">extends</span> <span class="title class_">AbstractBox</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getShape</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;O&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">BoxFactory</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, AbstractBox&gt;();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">iBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">lBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LBox</span>();</span><br><span class="line">        <span class="type">AbstractBox</span> <span class="variable">oBox</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OBox</span>();</span><br><span class="line">        map.put(<span class="string">&quot;I&quot;</span>, iBox);</span><br><span class="line">        map.put(<span class="string">&quot;L&quot;</span>, lBox);</span><br><span class="line">        map.put(<span class="string">&quot;O&quot;</span>, oBox);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BoxFactory <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonHolder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">BoxFactory</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BoxFactory</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> AbstractBox <span class="title function_">getBox</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h2><p>组合模式：</p><p>又叫 部分整体模式。是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。</p><p><strong>结构：</strong></p><ul><li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li><li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li><li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li></ul><p><strong>分类：</strong></p><ul><li><p>透明组合模式</p><p>透明组合模式中，抽象根节点角色中<strong>声明了所有用于管理成员对象的方法</strong>，比如在下面示例中的<code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p><p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p></li><li><p>安全组合模式</p><p>在安全组合模式中，在抽象构件角色中<strong>没有声明任何用于管理成员对象的方法</strong>，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p></li></ul><p><strong>优点：</strong></p><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><p><strong>使用场景：</strong></p><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p><blockquote><p>例：软件菜单</p><p>即日常用到的树形结构的目录</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204222116319.png" alt="image-20220422211612159"></p><p>不管是菜单还是菜单项，都应该继承自统一的接口，这里将这个统一的接口称为菜单组件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除菜单</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取指定的子菜单</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取菜单名称</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Menu</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Menu</span><span class="params">(String name,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        menuComponentList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;MenuComponent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.add(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(MenuComponent menuComponent)</span> &#123;</span><br><span class="line">        menuComponentList.remove(menuComponent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MenuComponent <span class="title function_">getChild</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> menuComponentList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;</span><br><span class="line">            menuComponent.print();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span> <span class="keyword">extends</span> <span class="title class_">MenuComponent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MenuItem</span><span class="params">(String name,<span class="type">int</span> level)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; level; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;--&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p></blockquote><h1 id="行为型模式（11）"><a href="#行为型模式（11）" class="headerlink" title="行为型模式（11）"></a>行为型模式（11）</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式分为：</p><ul><li>模板方法模式</li><li>策略模式</li><li>命令模式</li><li>职责链模式</li><li>状态模式</li><li>观察者模式</li><li>中介者模式</li><li>迭代器模式</li><li>访问者模式</li><li>备忘录模式</li><li>解释器模式</li></ul><p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p><h2 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h2><p>模板方法模式：</p><p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p><blockquote><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p><p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p></blockquote><p><strong>结构：</strong></p><ul><li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p><ul><li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。（一般会加上final关键字）</p></li><li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p><ul><li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p></li><li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p></li><li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p><p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p></li></ul></li></ul></li><li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p></li></ul><p><strong>优点：</strong></p><ul><li><p>提高代码复用性</p><p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p></li><li><p>实现了反向控制</p><p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p></li></ul><p><strong>缺点：</strong></p><ul><li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li><li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li></ul><p><strong>适用场景：</strong></p><ul><li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><p><strong>JDK源码 —— InputStream</strong></p><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">InputStream</span> <span class="keyword">implements</span> <span class="title class_">Closeable</span> &#123;</span><br><span class="line">    <span class="comment">//抽象方法，要求子类必须重写</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[])</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span> b[], <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> read(); <span class="comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span></span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="type">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="type">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p><p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p><p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p><blockquote><p>例：炒菜</p><p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">cookProcess</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//第一步：倒油</span></span><br><span class="line">        <span class="built_in">this</span>.pourOil();</span><br><span class="line">        <span class="comment">//第二步：热油</span></span><br><span class="line">        <span class="built_in">this</span>.heatOil();</span><br><span class="line">        <span class="comment">//第三步：倒蔬菜</span></span><br><span class="line">        <span class="built_in">this</span>.pourVegetable();</span><br><span class="line">        <span class="comment">//第四步：倒调味料</span></span><br><span class="line">        <span class="built_in">this</span>.pourSauce();</span><br><span class="line">        <span class="comment">//第五步：翻炒</span></span><br><span class="line">        <span class="built_in">this</span>.fry();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;倒油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步：热油是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heatOil</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;热油&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四步：倒调味料是不一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五步：翻炒是一样的，所以直接实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fry</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;炒啊炒啊炒到熟啊&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_BaoCai</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是包菜&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是辣椒&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteClass_CaiXin</span> <span class="keyword">extends</span> <span class="title class_">AbstractClass</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourVegetable</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的蔬菜是菜心&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pourSauce</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;下锅的酱料是蒜蓉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//炒手撕包菜</span></span><br><span class="line">        <span class="type">ConcreteClass_BaoCai</span> <span class="variable">baoCai</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_BaoCai</span>();</span><br><span class="line">        baoCai.cookProcess();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//炒蒜蓉菜心</span></span><br><span class="line">        <span class="type">ConcreteClass_CaiXin</span> <span class="variable">caiXin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteClass_CaiXin</span>();</span><br><span class="line">        caiXin.cookProcess();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p></blockquote></blockquote><h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>策略模式：</p><p>​该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象以对这些算法进行管理。</p><blockquote><p>也就是说，提供了多个可以彼此替代的选择</p></blockquote><p><strong>结构：</strong></p><ul><li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li><li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li></ul><p><strong>优点：</strong></p><ul><li><p>策略类之间可以自由切换</p><p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p></li><li><p>易于扩展</p><p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p></li><li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p></li></ul><p><strong>缺点：</strong></p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><p><strong>使用场景：</strong></p><ul><li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li><li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li><li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li><li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li><li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li></ul><p><strong>JDK源码——Comparator</strong></p><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Arrays</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] a, Comparator&lt;? <span class="built_in">super</span> T&gt; c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            sort(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (LegacyMergeSort.userRequested)</span><br><span class="line">                legacyMergeSort(a, c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                TimSort.sort(a, <span class="number">0</span>, a.length, c, <span class="literal">null</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        Integer[] data = &#123;<span class="number">12</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">// 实现降序排序</span></span><br><span class="line">        Arrays.sort(data, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o2 - o1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(Arrays.toString(data)); <span class="comment">//[12, 5, 4, 3, 2, 2, 1]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。</p><blockquote><p>例：促销活动</p><p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204230934303.png" alt="image-20220423093435010"></p><p>定义百货公司所有促销活动的共同接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为春节准备的促销活动A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyA</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;买一送一&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为中秋准备的促销活动B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyB</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满200元减50元&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为圣诞准备的促销活动C</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StrategyC</span> <span class="keyword">implements</span> <span class="title class_">Strategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SalesMan</span> &#123;                        </span><br><span class="line">    <span class="comment">//持有抽象策略角色的引用                              </span></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;                 </span><br><span class="line">                                               </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SalesMan</span><span class="params">(Strategy strategy)</span> &#123;       </span><br><span class="line">        <span class="built_in">this</span>.strategy = strategy;              </span><br><span class="line">    &#125;                                          </span><br><span class="line">                                               </span><br><span class="line">    <span class="comment">//向客户展示促销活动                                </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">salesManShow</span><span class="params">()</span>&#123;                </span><br><span class="line">        strategy.show();                       </span><br><span class="line">    &#125;                                          </span><br><span class="line">&#125;                                              </span><br></pre></td></tr></table></figure></blockquote><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式：</p><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p><p><strong>结构：</strong></p><ul><li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li><li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li><li>实现者&#x2F;接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li><li>调用者&#x2F;请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li></ul><p><strong>优点：</strong></p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与下面的备忘录模式结合，实现命令的撤销与恢复。</li></ul><p><strong>缺点：</strong></p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。</li><li>系统结构更加复杂。</li></ul><p><strong>使用场景：</strong></p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li></ul><p><strong>JDK源码——Runnable</strong></p><p>Runable是一个典型命令模式，<br>Runnable是 抽象命令角色，Thread充当的是调用者，start方法就是其执行方法，start()会调用本地方法start0()，以调用系统方法，开启一个线程。  而接收者是由程序员定义的，即继承Runnable。</p><blockquote><p>例：餐厅点餐</p><p>在餐厅中，顾客点餐，服务员拿到订单，会通知大厨做饭；<br>其中，服务员是调用者，由她来接收订单、发起命令；大厨是接收者，执行命令；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231035351.png" alt="image-20220423103514830"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Command</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;<span class="comment">//只需要定义一个统一的执行方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCommand</span> <span class="keyword">implements</span> <span class="title class_">Command</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持有接受者对象</span></span><br><span class="line">    <span class="keyword">private</span> SeniorChef receiver;</span><br><span class="line">    <span class="keyword">private</span> Order order;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCommand</span><span class="params">(SeniorChef receiver, Order order)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.receiver = receiver;</span><br><span class="line">        <span class="built_in">this</span>.order = order;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>  &#123;</span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的订单：&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = order.getFoodDic().keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            receiver.makeFood(order.getFoodDic().get(key),key);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);<span class="comment">//停顿一下 模拟做饭的过程</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(order.getDiningTable() + <span class="string">&quot;桌的饭弄好了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="comment">// 餐桌号码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> diningTable;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用来存储餐名并记录份数</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDiningTable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDiningTable</span><span class="params">(<span class="type">int</span> diningTable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.diningTable = diningTable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Integer&gt; <span class="title function_">getFoodDic</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> foodDic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFoodDic</span><span class="params">(String name, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        foodDic.put(name,num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大厨类 是命令的Receiver</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeniorChef</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeFood</span><span class="params">(<span class="type">int</span> num,String foodName)</span> &#123;</span><br><span class="line">        System.out.println(num + <span class="string">&quot;份&quot;</span> + foodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Waitor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="comment">//可以持有很多的命令对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Waitor</span><span class="params">()</span> &#123;</span><br><span class="line">        commands = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCommand</span><span class="params">(Command cmd)</span>&#123;</span><br><span class="line">        commands.add(cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发出命令 喊 订单来了，厨师开始执行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">orderUp</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; commands.size(); i++) &#123;</span><br><span class="line">            <span class="type">Command</span> <span class="variable">cmd</span> <span class="operator">=</span> commands.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cmd != <span class="literal">null</span>) &#123;</span><br><span class="line">                cmd.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建2个order</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order1.setDiningTable(<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;西红柿鸡蛋面&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order1.getFoodDic().put(<span class="string">&quot;小杯可乐&quot;</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order2.setDiningTable(<span class="number">3</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="number">1</span>);</span><br><span class="line">        order2.getFoodDic().put(<span class="string">&quot;小杯雪碧&quot;</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建接收者</span></span><br><span class="line">        SeniorChef receiver=<span class="keyword">new</span> <span class="title class_">SeniorChef</span>();</span><br><span class="line">        <span class="comment">//将订单和接收者封装成命令对象</span></span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order1);</span><br><span class="line">        <span class="type">OrderCommand</span> <span class="variable">cmd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OrderCommand</span>(receiver, order2);</span><br><span class="line">        <span class="comment">//创建调用者 waitor</span></span><br><span class="line">        <span class="type">Waitor</span> <span class="variable">invoker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Waitor</span>();</span><br><span class="line">        invoker.setCommand(cmd1);</span><br><span class="line">        invoker.setCommand(cmd2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将订单带到柜台 并向厨师喊 订单来了</span></span><br><span class="line">        invoker.orderUp();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h2><p>职责链模式：</p><p>为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><strong>结构：</strong></p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><p><strong>优点：</strong></p><ul><li><p>降低了对象之间的耦合度</p><p>该模式降低了请求发送者和接收者的耦合度。</p></li><li><p>增强了系统的可扩展性</p><p>可以根据需要增加新的请求处理类，满足开闭原则。</p></li><li><p>增强了给对象指派职责的灵活性</p><p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p></li><li><p>责任链简化了对象之间的连接</p><p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p></li><li><p>责任分担</p><p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p></li></ul><p><strong>缺点：</strong></p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li></ul><p><strong>源码解析</strong></p><p>在javaWeb应用开发中，FilterChain（过滤器）是职责链模式的典型应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例：公司请假</p><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231108868.png" alt="image-20220423110846538"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请假条</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeaveRequest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> num;<span class="comment">//请假天数</span></span><br><span class="line">    <span class="keyword">private</span> String content;<span class="comment">//请假内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeaveRequest</span><span class="params">(String name, <span class="type">int</span> num, String content)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.num = num;</span><br><span class="line">        <span class="built_in">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getContent</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理者抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_ONE</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_THREE</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">NUM_SEVEN</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该领导处理的请假天数区间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numStart;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> numEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//领导上面还有领导</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围 上不封顶</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置请假天数范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Handler</span><span class="params">(<span class="type">int</span> numStart, <span class="type">int</span> numEnd)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.numStart = numStart;</span><br><span class="line">        <span class="built_in">this</span>.numEnd = numEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置上级领导</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNextHandler</span><span class="params">(Handler nextHandler)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交请假条</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">submit</span><span class="params">(LeaveRequest leave)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> == <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果请假天数达到该领导者的处理要求</span></span><br><span class="line">        <span class="keyword">if</span>(leave.getNum() &gt;= <span class="built_in">this</span>.numStart)&#123;</span><br><span class="line">            <span class="built_in">this</span>.handleLeave(leave);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="literal">null</span> != <span class="built_in">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;</span><br><span class="line">                <span class="built_in">this</span>.nextHandler.submit(leave);<span class="comment">//继续提交</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;流程结束&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//各级领导处理请假条方法</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//小组长</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupLeader</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GroupLeader</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//小组长处理1-3天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;小组长审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//部门经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Manager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理3-7天的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;部门经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总经理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneralManager</span> <span class="keyword">extends</span> <span class="title class_">Handler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GeneralManager</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//部门经理处理7天以上的请假</span></span><br><span class="line">        <span class="built_in">super</span>(Handler.NUM_SEVEN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleLeave</span><span class="params">(LeaveRequest leave)</span> &#123;</span><br><span class="line">        System.out.println(leave.getName() + <span class="string">&quot;请假&quot;</span> + leave.getNum() + <span class="string">&quot;天,&quot;</span> + leave.getContent() + <span class="string">&quot;。&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;总经理审批：同意。&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//请假条来一张</span></span><br><span class="line">        <span class="type">LeaveRequest</span> <span class="variable">leave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeaveRequest</span>(<span class="string">&quot;小花&quot;</span>,<span class="number">5</span>,<span class="string">&quot;身体不适&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//各位领导</span></span><br><span class="line">        <span class="type">GroupLeader</span> <span class="variable">groupLeader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GroupLeader</span>();</span><br><span class="line">        <span class="type">Manager</span> <span class="variable">manager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Manager</span>();</span><br><span class="line">        <span class="type">GeneralManager</span> <span class="variable">generalManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GeneralManager</span>();</span><br><span class="line"></span><br><span class="line">        groupLeader.setNextHandler(manager);<span class="comment">//小组长的领导是部门经理</span></span><br><span class="line">        manager.setNextHandler(generalManager);<span class="comment">//部门经理的领导是总经理</span></span><br><span class="line">        <span class="comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交申请</span></span><br><span class="line">        groupLeader.submit(leave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式：</p><p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><blockquote><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p><p>如果使用 条件判断的话，需要使用大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。<br>且扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑。</p></blockquote><p>结构</p><ul><li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li><li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li></ul><p><strong>优点：</strong></p><ul><li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li></ul><p><strong>缺点：</strong></p><ul><li>状态模式的使用必然会增加系统类和对象的个数。 </li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li><li>状态模式对”开闭原则”的支持并不太好。</li></ul><p><strong>使用场景：</strong></p><ul><li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li><li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li></ul><blockquote><p>例：对上述电梯的案例使用状态模式进行改进。类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231744953.png" alt="image-20220423114202658"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象状态类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span></span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setContext</span><span class="params">(Context context)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯开门动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯关门动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯运行动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯停止动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OpenningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开启当然可以关闭了，测试一下电梯门开关功能</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门开启...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门不能开着就跑，这里什么也不做</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开门状态已经是停止的了</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//运行状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunningState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行的时候不能开电梯</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//运行时，电梯是关着的，不用操作</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是在运行状态下要实现的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯正在运行...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换运行状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StoppingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态 可以开门</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;<span class="comment">//虽然可以关门，但这个动作不归我执行</span></span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.closeingState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换运行状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//状态修改</span></span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span></span><br><span class="line">        <span class="built_in">super</span>.context.getLiftState().run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//停止状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯停止了...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭状态</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClosingState</span> <span class="keyword">extends</span> <span class="title class_">LiftState</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">//电梯门关闭，这是关闭状态要实现的动作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;电梯门关闭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切换开关状态</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.openningState);</span><br><span class="line">        <span class="built_in">super</span>.context.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关了就跑</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.runningState);</span><br><span class="line">        <span class="built_in">super</span>.context.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//电梯门关着，不按楼层</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.context.setLiftState(Context.stoppingState);</span><br><span class="line">        <span class="built_in">super</span>.context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//环境角色</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Context</span> &#123;</span><br><span class="line">    <span class="comment">//定义出所有的电梯状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">OpenningState</span> <span class="variable">openningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OpenningState</span>();<span class="comment">//开门状态，这时候电梯只能关闭</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">ClosingState</span> <span class="variable">closeingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClosingState</span>();<span class="comment">//关闭状态，这时候电梯可以运行、停止和开门</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">RunningState</span> <span class="variable">runningState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RunningState</span>();<span class="comment">//运行状态，这时候电梯只能停止</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">StoppingState</span> <span class="variable">stoppingState</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StoppingState</span>();<span class="comment">//停止状态，这时候电梯可以开门、运行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义一个当前电梯状态</span></span><br><span class="line">    <span class="keyword">private</span> LiftState liftState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> LiftState <span class="title function_">getLiftState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.liftState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setLiftState</span><span class="params">(LiftState liftState)</span> &#123;</span><br><span class="line">        <span class="comment">//当前环境改变</span></span><br><span class="line">        <span class="built_in">this</span>.liftState = liftState;</span><br><span class="line">        <span class="comment">//把当前的环境通知到各个实现类中</span></span><br><span class="line">        <span class="built_in">this</span>.liftState.setContext(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">open</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.open();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.run();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.liftState.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Context</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Context</span>();</span><br><span class="line">        context.setLiftState(<span class="keyword">new</span> <span class="title class_">ClosingState</span>());</span><br><span class="line"></span><br><span class="line">        context.open();</span><br><span class="line">        context.close();</span><br><span class="line">        context.run();</span><br><span class="line">        context.stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式：</p><p>又被称为发布-订阅（Publish&#x2F;Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p><p><strong>结构：</strong></p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li><li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p><strong>优点：</strong></p><ul><li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li><li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li></ul><p><strong>缺点：</strong></p><ul><li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li><li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li></ul><p><strong>使用场景</strong></p><ul><li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li><li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li></ul><blockquote><p>【例】微信公众号</p><p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者。</p><p>类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231747763.png" alt="image-20220423174701535"></p><p>代码如下：</p><p>定义抽象观察者类，里面定义一个更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WeixinUser</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line">    <span class="comment">// 微信用户名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WeixinUser</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;-&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象主题类，提供了attach、detach、notify三个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//增加订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除订阅者</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通知订阅者更新消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubscriptionSubject</span> <span class="keyword">implements</span> <span class="title class_">Subject</span> &#123;</span><br><span class="line">    <span class="comment">//储存订阅公众号的微信用户</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">attach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">detach</span><span class="params">(Observer observer)</span> &#123;</span><br><span class="line">        weixinUserlist.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : weixinUserlist) &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端程序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SubscriptionSubject mSubscriptionSubject=<span class="keyword">new</span> <span class="title class_">SubscriptionSubject</span>();</span><br><span class="line">        <span class="comment">//创建微信用户</span></span><br><span class="line">        WeixinUser user1=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;孙悟空&quot;</span>);</span><br><span class="line">        WeixinUser user2=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;猪悟能&quot;</span>);</span><br><span class="line">        WeixinUser user3=<span class="keyword">new</span> <span class="title class_">WeixinUser</span>(<span class="string">&quot;沙悟净&quot;</span>);</span><br><span class="line">        <span class="comment">//订阅公众号</span></span><br><span class="line">        mSubscriptionSubject.attach(user1);</span><br><span class="line">        mSubscriptionSubject.attach(user2);</span><br><span class="line">        mSubscriptionSubject.attach(user3);</span><br><span class="line">        <span class="comment">//公众号更新发出消息给订阅的微信用户</span></span><br><span class="line">        mSubscriptionSubject.notify(<span class="string">&quot;专栏更新了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h3 id="JDK中提供的实现"><a href="#JDK中提供的实现" class="headerlink" title="JDK中提供的实现"></a>JDK中提供的实现</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p><p><strong>1，Observable类</strong></p><p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p><ul><li><p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p></li><li><p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p></li><li><p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p></li></ul><p><strong>2，Observer 接口</strong></p><p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p><blockquote><p>【例】警察抓小偷</p><p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p><p>小偷是一个被观察者，所以需要继承Observable类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thief</span> <span class="keyword">extends</span> <span class="title class_">Observable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Thief</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">steal</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小偷：我偷东西了！！！&quot;</span>);</span><br><span class="line">        <span class="built_in">super</span>.setChanged(); <span class="comment">//changed  = true</span></span><br><span class="line">        <span class="built_in">super</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>警察是一个观察者，所以需要让其实现Observer接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Policemen</span> <span class="keyword">implements</span> <span class="title class_">Observer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Policemen</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Observable o, Object arg)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="string">&quot;，我已经盯你很久了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建小偷对象</span></span><br><span class="line">        <span class="type">Thief</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thief</span>(<span class="string">&quot;隔壁老王&quot;</span>);</span><br><span class="line">        <span class="comment">//创建警察对象</span></span><br><span class="line">        <span class="type">Policemen</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Policemen</span>(<span class="string">&quot;小李&quot;</span>);</span><br><span class="line">        <span class="comment">//让警察盯着小偷</span></span><br><span class="line">        t.addObserver(p);</span><br><span class="line">        <span class="comment">//小偷偷东西</span></span><br><span class="line">        t.steal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式：</p><p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p><blockquote><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中；</p><p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231747048.png" alt="image-20220423174726716"></p></blockquote><p><strong>结构：</strong></p><ul><li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p></li><li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p></li><li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p></li><li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p></li></ul><p><strong>优点：</strong></p><ul><li><p>松散耦合</p><p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p></li><li><p>集中控制交互</p><p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p></li><li><p>一对多关联转变为一对一的关联</p><p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p></li></ul><p><strong>缺点：</strong></p><ul><li>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</li></ul><p><strong>使用场景:</strong></p><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li></ul><blockquote><p>【例】租房</p><p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p><p>类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231551378.png" alt="image-20220423155135175"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象中介者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//申明一个联络方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message,Person person)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象同事类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name,Mediator mediator)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 房屋拥有者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseOwner</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HouseOwner</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房主&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体同事类 承租人</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tenant</span> <span class="keyword">extends</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Tenant</span><span class="params">(String name, Mediator mediator)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//与中介者联系</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        mediator.constact(message, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;租房者&quot;</span> + name +<span class="string">&quot;获取到的信息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//中介机构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediatorStructure</span> <span class="keyword">extends</span> <span class="title class_">Mediator</span> &#123;</span><br><span class="line">    <span class="comment">//首先中介结构必须知道所有房主和租房者的信息</span></span><br><span class="line">    <span class="keyword">private</span> HouseOwner houseOwner;</span><br><span class="line">    <span class="keyword">private</span> Tenant tenant;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HouseOwner <span class="title function_">getHouseOwner</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHouseOwner</span><span class="params">(HouseOwner houseOwner)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.houseOwner = houseOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Tenant <span class="title function_">getTenant</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setTenant</span><span class="params">(Tenant tenant)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.tenant = tenant;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">constact</span><span class="params">(String message, Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (person == houseOwner) &#123;          <span class="comment">//如果是房主，则租房者获得信息</span></span><br><span class="line">            tenant.getMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;       <span class="comment">//反正则是房主获得信息</span></span><br><span class="line">            houseOwner.getMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//一个房主、一个租房者、一个中介机构</span></span><br><span class="line">        <span class="type">MediatorStructure</span> <span class="variable">mediator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MediatorStructure</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//房主和租房者只需要知道中介机构即可</span></span><br><span class="line">        <span class="type">HouseOwner</span> <span class="variable">houseOwner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HouseOwner</span>(<span class="string">&quot;张三&quot;</span>, mediator);</span><br><span class="line">        <span class="type">Tenant</span> <span class="variable">tenant</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tenant</span>(<span class="string">&quot;李四&quot;</span>, mediator);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中介结构要知道房主和租房者</span></span><br><span class="line">        mediator.setHouseOwner(houseOwner);</span><br><span class="line">        mediator.setTenant(tenant);</span><br><span class="line"></span><br><span class="line">        tenant.constact(<span class="string">&quot;需要租三室的房子&quot;</span>);</span><br><span class="line">        houseOwner.constact(<span class="string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式：</p><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p><p><strong>结构：</strong></p><ul><li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p></li><li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p></li><li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p></li><li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p></li></ul><p><strong>优点：</strong></p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li></ul><p><strong>缺点：</strong></p><p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p><p><strong>使用场景：</strong></p><ul><li>当需要为聚合对象提供多种遍历方式时。</li><li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li><li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li></ul><p><strong>JDK源码解析</strong></p><p>迭代器模式在 JAVA的很多集合类中被广泛应用，比如在遍历集合时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator(); <span class="comment">//list.iterator()方法返回的是Iterator接口的子实现类对象</span></span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单列集合都使用到了迭代器，以ArrayList举例来说明</p><ul><li>List：抽象聚合类</li><li>ArrayList：具体的聚合类</li><li>Iterator：抽象迭代器</li><li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li></ul><p>具体的来看看 ArrayList的代码实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">        <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Iterator&lt;E&gt; <span class="title function_">iterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Itr</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Itr</span> <span class="keyword">implements</span> <span class="title class_">Iterator</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="type">int</span> cursor;       <span class="comment">// 下一个要返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastRet</span> <span class="operator">=</span> -<span class="number">1</span>; <span class="comment">// 上一个返回元素的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否还有元素</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取下一个元素</span></span><br><span class="line">        <span class="keyword">public</span> E <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">            Object[] elementData = ArrayList.<span class="built_in">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p><blockquote><p>注意： </p><p>​当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p></blockquote><hr><blockquote><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231750338.png" alt="image-20220423175007997"></p><p>代码如下：</p><p>定义迭代器接口，声明hasNext、next方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span>;</span><br><span class="line">    Student <span class="title function_">next</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的迭代器类，重写所有的抽象方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentIteratorImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentIterator</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">position</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">StudentIteratorImpl</span><span class="params">(List&lt;Student&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> position &lt; list.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">currentStudent</span> <span class="operator">=</span> list.get(position);</span><br><span class="line">        position ++;</span><br><span class="line">        <span class="keyword">return</span> currentStudent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span>;</span><br><span class="line"></span><br><span class="line">    StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义具体的容器类，重写所有的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentAggregateImpl</span> <span class="keyword">implements</span> <span class="title class_">StudentAggregate</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();  <span class="comment">// 学生列表</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.add(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeStudent</span><span class="params">(Student student)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list.remove(student);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> StudentIterator <span class="title function_">getStudentIterator</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StudentIteratorImpl</span>(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式：</p><p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p><p><strong>结构：</strong></p><ul><li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li><li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li><li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li><li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li><li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li></ul><p>【例】给宠物喂食</p><p>假设家中宠物只有狗，猫，要给宠物喂食的话，主人可以喂，其他人也可以喂食。（不同人给猫狗喂食，猫狗固定）</p><ul><li>访问者角色：给宠物喂食的人</li><li>具体访问者角色：主人、其他人</li><li>抽象元素角色：动物抽象类</li><li>具体元素角色：宠物狗、宠物猫</li><li>结构对象角色：主人家</li></ul><p>类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231751843.png" alt="image-20220423175106513"></p><p>代码如下：</p><p>创建抽象访问者接口（访问者的数据结构应该不变，不然修改的话，其子类也要跟着修改，此处例子不太恰当）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Owner</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;主人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Someone</span> <span class="keyword">implements</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Cat cat)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食猫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">feed</span><span class="params">(Dog dog)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;其他人喂食狗&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象节点 – 宠物</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义实现<code>Animal</code>接口的 具体节点（元素）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123; <span class="comment">//双分派的第一次分派，这里方法是重写，所以person看的是实际类型</span></span><br><span class="line">        person.feed(<span class="built_in">this</span>);<span class="comment">//双分派的第二次分派，这个feed()是重载的，看的是静态类型，但这里this是Dog,不是animal</span></span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，汪汪汪！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        person.feed(<span class="built_in">this</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;好好吃，喵喵喵！！！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义对象结构，此案例中就是主人的家</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Home</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Animal&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Animal&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(Person person)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Animal node : nodeList) &#123;</span><br><span class="line">            node.accept(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(Animal animal)</span> &#123;</span><br><span class="line">        nodeList.add(animal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Home</span> <span class="variable">home</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Home</span>();</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Dog</span>());</span><br><span class="line">        home.add(<span class="keyword">new</span> <span class="title class_">Cat</span>());</span><br><span class="line"></span><br><span class="line">        <span class="type">Owner</span> <span class="variable">owner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Owner</span>();</span><br><span class="line">        home.action(owner);</span><br><span class="line"></span><br><span class="line">        <span class="type">Someone</span> <span class="variable">someone</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Someone</span>();</span><br><span class="line">        home.action(someone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>优点：</strong></p><ul><li><p>扩展性好</p><p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p></li><li><p>复用性好</p><p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p></li><li><p>分离无关行为</p><p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p></li></ul><p><strong>缺点：</strong></p><ul><li><p>对象结构变化很困难</p><p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p></li><li><p>违反了依赖倒置原则</p><p>访问者模式依赖了具体类，而没有依赖抽象类。</p></li></ul><p><strong>使用场景：</strong></p><ul><li>对象结构相对稳定，但其操作算法经常变化的程序。</li><li>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</li></ul><h3 id="扩展：分派"><a href="#扩展：分派" class="headerlink" title="扩展：分派"></a>扩展：分派</h3><p>访问者模式用到了一种双分派的技术。</p><p><strong>1，分派：</strong></p><p>变量被声明时的类型叫做变量的静态类型（或明显类型）；而变量所引用的对象的真实类型又叫做变量的实际类型。<br>比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)；</p><p>分派(Dispatch)又分为两种：静态分派和动态分派。</p><p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p><p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p><p><strong>2，动态分派：</strong></p><p>通过方法的重写支持动态分派。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        a.execute();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line">        a1.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码很明显是 多态，运行执行的是子类中的方法。</p><p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而<strong>方法的调用则是根据对象的真实类型</strong>，而不是静态类型。</p><p><strong>3，静态分派：</strong></p><p>通过方法重载支持静态分派。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        exe.execute(a);</span><br><span class="line">        exe.execute(a1);</span><br><span class="line">        exe.execute(a2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231751511.png" alt="image-20220423175136331"></p><p>出现这个结果，是因为：<strong>重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了。</strong></p><p><strong>4，双分派：</strong></p><p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Execute exe)</span> &#123;</span><br><span class="line">        exe.execute(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Execute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Animal a)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;animal&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Dog d)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;dog&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Cat c)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;cat&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Execute</span> <span class="variable">exe</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Execute</span>();</span><br><span class="line">        a.accept(exe);</span><br><span class="line">        d.accept(exe);</span><br><span class="line">        c.accept(exe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p><p>运行结果如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231751172.png" alt="image-20220423175151829"></p><p><strong>双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中重写的环节，由于重写是动态的，所以重载就是动态的了。</strong></p><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式：</p><p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p><blockquote><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，还有浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p></blockquote><p><strong>结构：</strong></p><ul><li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li><li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li><li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li></ul><blockquote><p>备忘录有两个等效的接口：</p><ul><li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li><li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li></ul></blockquote><p><strong>优点：</strong></p><ul><li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li><li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li><li>简化了 发起人 类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li></ul><p><strong>缺点：</strong></p><ul><li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li></ul><p><strong>使用场景：</strong></p><ul><li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p></li><li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p></li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>【例】游戏挑战BOSS</p><p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p><p>要实现上述案例，有两种方式：</p><ul><li>“白箱”备忘录模式</li><li>“黑箱”备忘录模式</li></ul><h4 id="“白箱”备忘录模式"><a href="#“白箱”备忘录模式" class="headerlink" title="“白箱”备忘录模式"></a>“白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231752254.png" alt="image-20220423175255892"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//游戏角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(RoleStateMemento roleStateMemento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//游戏状态存储类(备忘录类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> RoleStateMemento roleStateMemento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> RoleStateMemento <span class="title function_">getRoleStateMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRoleStateMemento</span><span class="params">(RoleStateMemento roleStateMemento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.roleStateMemento = roleStateMemento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p></blockquote><h4 id="“黑箱”备忘录模式"><a href="#“黑箱”备忘录模式" class="headerlink" title="“黑箱”备忘录模式"></a>“黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p><p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204231754348.png" alt="image-20220423175453982"></p><p>代码如下：</p><p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义发起人 类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">/游戏角色类</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GameRole</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> vit; <span class="comment">//生命力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> atk; <span class="comment">//攻击力</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> def; <span class="comment">//防御力</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//战斗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fight</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.atk = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.def = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存角色状态</span></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">saveState</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RoleStateMemento</span>(vit, atk, def);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回复角色状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">recoverState</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="type">RoleStateMemento</span> <span class="variable">roleStateMemento</span> <span class="operator">=</span> (RoleStateMemento) memento;</span><br><span class="line">        <span class="built_in">this</span>.vit = roleStateMemento.getVit();</span><br><span class="line">        <span class="built_in">this</span>.atk = roleStateMemento.getAtk();</span><br><span class="line">        <span class="built_in">this</span>.def = roleStateMemento.getDef();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stateDisplay</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;角色生命力：&quot;</span> + vit);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色攻击力：&quot;</span> + atk);</span><br><span class="line">        System.out.println(<span class="string">&quot;角色防御力：&quot;</span> + def);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vit = vit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.atk = atk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.def = def;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">RoleStateMemento</span> <span class="keyword">implements</span> <span class="title class_">Memento</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> vit;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> atk;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> def;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">RoleStateMemento</span><span class="params">(<span class="type">int</span> vit, <span class="type">int</span> atk, <span class="type">int</span> def)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getVit</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setVit</span><span class="params">(<span class="type">int</span> vit)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.vit = vit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAtk</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAtk</span><span class="params">(<span class="type">int</span> atk)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.atk = atk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDef</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> def;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDef</span><span class="params">(<span class="type">int</span> def)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.def = def;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//角色状态管理者类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoleStateCaretaker</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Memento <span class="title function_">getMemento</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMemento</span><span class="params">(Memento memento)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss前------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss前</span></span><br><span class="line">        <span class="type">GameRole</span> <span class="variable">gameRole</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GameRole</span>();</span><br><span class="line">        gameRole.initState();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存进度</span></span><br><span class="line">        <span class="type">RoleStateCaretaker</span> <span class="variable">roleStateCaretaker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoleStateCaretaker</span>();</span><br><span class="line">        roleStateCaretaker.setMemento(gameRole.saveState());</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;------------大战Boss后------------&quot;</span>);</span><br><span class="line">        <span class="comment">//大战Boss时，损耗严重</span></span><br><span class="line">        gameRole.fight();</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">        System.out.println(<span class="string">&quot;------------恢复之前状态------------&quot;</span>);</span><br><span class="line">        <span class="comment">//恢复之前状态</span></span><br><span class="line">        gameRole.recoverState(roleStateCaretaker.getMemento());</span><br><span class="line">        gameRole.stateDisplay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h2>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>项目结构</p><p>轮播图</p><p>swiper</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 轮播图 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">&quot;banners&quot;</span> <span class="attr">indicator-active-color</span>=<span class="string">&quot;#d43c33&quot;</span> <span class="attr">indicator-color</span>=<span class="string">&quot;ivory&quot;</span> <span class="attr">indicator-dots</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon5.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon2.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon3.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可滚动的视图区</p><p>scroll-view</p><p>接口数据：在代码&#x2F;硅谷音乐_server 目录下cmd进入输入： npm start</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/"/>
      <url>/Notes/2022/04/14/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="categories-基础"><a href="#categories-基础" class="headerlink" title="categories: 基础"></a>categories: 基础</h2><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><h4 id="X-amp-X"><a href="#X-amp-X" class="headerlink" title="X &amp; -X"></a>X &amp; -X</h4><p><strong>X &amp; -X 得到 二进制数的LowBit</strong>（其二进制最低位的1，其余位均为0）：</p><p>-X的值，是在X的基础上进行按位取反之后再加1得到的，</p><ul><li>当X为偶数时，~X为奇数，奇数加上1会发生进位，最低位的连续的1都会变为0，所以X和 ~X的低位都为0，高位都相反，只有得到进位的那个位置都为1，即X的最右边的1相等，所以，<strong>当一个偶数与它的负值相与时， 结果是能整除这个偶数的最大的2的幂, 即： m &#x3D; n &amp; -n , 则 n % m &#x3D; 0, 且 m &#x3D; 2^k^</strong></li><li><strong>当X为奇数时</strong>，因为奇数取反后为偶数，偶数加1并不会影响进位，所以<strong>此时 X &amp; -X 结果一定为1</strong>（奇数最低位的1就在二进制数的末尾）</li></ul><h2 id="双指针-Two-Pointers"><a href="#双指针-Two-Pointers" class="headerlink" title="双指针   Two Pointers"></a><strong>双指针   Two Pointer</strong>s</h2><h4 id="141：判断链表中是否有环："><a href="#141：判断链表中是否有环：" class="headerlink" title="141：判断链表中是否有环："></a><strong>141：</strong>判断链表中是否有环<strong>：</strong></h4><p>(快慢指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> listNode *head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="344：反转字符串"><a href="#344：反转字符串" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = sSize - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        swap(s + left, s + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="881：救生艇"><a href="#881：救生艇" class="headerlink" title="881：救生艇"></a>881：救生艇</h4><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果最重的人可以与最轻的人共用一艘船，那么就这样安排。否则，最重的人无法与任何人配对，那么他们将自己独自乘一艘船。</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>* people, <span class="type">int</span> peopleSize, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(peopleSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    qsort(people,peopleSize,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = peopleSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; left &lt; right; right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找法-Binary-Search"><a href="#二分查找法-Binary-Search" class="headerlink" title="二分查找法   Binary Search"></a><strong>二分查找法   Binary Search</strong></h2><p>二分査找也称折半査找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p><p>该算法的基本思想是将所要査找的序列的中间位置的数据与所要査找的元素进行比较，如果相等，则表示査找成功，否则将以该位置为基准将所要査找的序列分为左右两部分。接下来根据所要査找序列的升降序规律及中间元素与所查找元素的大小关系，，对其采用同样的方法进行査找，直至能够确定所要查找的元素是否存在。</p><h4 id="704：二分查找"><a href="#704：二分查找" class="headerlink" title="704：二分查找"></a>704：二分查找</h4><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 1: mid = (left + right) / 2</span></span><br><span class="line"><span class="comment">         * 2: mid = left + (right - left) / 2</span></span><br><span class="line"><span class="comment">         * 第2种可以防止(left + right)直接相加数值过大越界的问题</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="35：搜索插入的位置"><a href="#35：搜索插入的位置" class="headerlink" title="35：搜索插入的位置"></a>35：搜索插入的位置</h4><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="162：寻找峰值"><a href="#162：寻找峰值" class="headerlink" title="162：寻找峰值"></a>162：寻找峰值</h4><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>解：（巧用二分法）</p><p>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 numsnums 中找到中间的元素 midmid。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 midmid 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 midmid 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Left &lt; Right)</span><br><span class="line">    &#123;</span><br><span class="line">        iMid = (Left + Right) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(nums[Mid] &gt; nums[Mid + <span class="number">1</span>])&#123;</span><br><span class="line">            Right = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Left = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="74：搜索二维矩阵"><a href="#74：搜索二维矩阵" class="headerlink" title="74：搜索二维矩阵"></a>74：搜索二维矩阵</h4><p>在m * n矩阵中，搜索是否存在一个目标值。</p><p>该矩阵有如下特点：</p><ul><li><p>每行中的整数从左到右按升序排列；</p></li><li><p>每行的第一个整数大于前一行的最后一个整数；</p><p>示例：</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>两次二分查找：</p><p>我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">-1</span>, high = matrixSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>* row, <span class="type">int</span> rowSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = rowSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rowIndex = binarySearchFirstColumn(matrix, matrixSize, target);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一次二分查找：</p><p>若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。</p><p>代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrixSize, n = matrixColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> a = matrix[mid / n][mid % n];</span><br><span class="line">        <span class="keyword">if</span>(a == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口  Sliding Window"></a><strong>滑动窗口  Sliding Window</strong></h2><h4 id="209：长度最小的子数组"><a href="#209：长度最小的子数组" class="headerlink" title="209：长度最小的子数组"></a>209：长度最小的子数组</h4><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>,minSize = <span class="number">0</span>, sum = <span class="number">0</span>,ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;right &lt; numsSize; right++)&#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            minSize = right - left + <span class="number">1</span>;</span><br><span class="line">            ans = minSize &lt; ans ? minSize : ans;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1456：定长子串中元音的最大数目"><a href="#1456：定长子串中元音的最大数目" class="headerlink" title="1456：定长子串中元音的最大数目"></a>1456：定长子串中元音的最大数目</h4><p>给你字符串 s 和整数 k 。</p><p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 元音字母 为（a, e, i, o, u）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abciiidef&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[right] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[right] == <span class="string">&#x27;a&#x27;</span> || s[right] == <span class="string">&#x27;e&#x27;</span> || s[right] == <span class="string">&#x27;i&#x27;</span> || s[right] == <span class="string">&#x27;o&#x27;</span> || s[right] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            ans = sum &gt; ans ? sum : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">&#x27;a&#x27;</span> || s[left] == <span class="string">&#x27;e&#x27;</span> || s[left] == <span class="string">&#x27;i&#x27;</span> || s[left] == <span class="string">&#x27;o&#x27;</span> || s[left] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归  Recursion"></a><strong>递归  Recursion</strong></h2><h4 id="344：反转字符串-1"><a href="#344：反转字符串-1" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h4><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursion(s,left + <span class="number">1</span>,right - <span class="number">1</span>);</span><br><span class="line">    swap(&amp;s[left],&amp;s[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    recursion(s,<span class="number">0</span>,sSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206：反转一个单链表。"><a href="#206：反转一个单链表。" class="headerlink" title="206：反转一个单链表。"></a>206：反转一个单链表。</h4><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191708769.png" alt="image-20210402193739408"></p><h4 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687:最长同值路径"></a>687:最长同值路径</h4><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p>示例 1:</p><p>输入:</p><pre><code>          5         / \        4   5       / \   \      1   1   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>输入：</p><pre><code>          1         / \        4   5       / \   \      4   4   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrowLeft</span> <span class="operator">=</span> <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowRight += right +  <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *maxDep, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入最底层的节点，从下往上计算 */</span></span><br><span class="line">    <span class="type">int</span> leftDep = Dfs(root-&gt;left, maxDep, root-&gt;val);</span><br><span class="line">    <span class="type">int</span> rightDep = Dfs(root-&gt;right, maxDep, root-&gt;val);</span><br><span class="line"></span><br><span class="line">    *maxDep = MAX(*maxDep, leftDep + rightDep); </span><br><span class="line">    <span class="comment">// 从下往上遍历需要时刻更新最大值</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX(leftDep, rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxDep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Dfs(root, &amp;maxDep, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> maxDep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治法-Divide-amp-Conquer"><a href="#分治法-Divide-amp-Conquer" class="headerlink" title="分治法   Divide &amp; Conquer"></a><strong>分治法   Divide &amp; Conquer</strong></h2><p>分治法所能解决的问题一般具有以下几个特征：</p><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。(前提)</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；（分治的关键，如果不具备，可以考虑贪心算法和动态规划）</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（关系分治的效率，如果要反复求解公共子问题，用动态规划较好）</p></li></ol><p><strong>分治法在每一层递归上都有三个步骤：</strong></p><p><strong>step1 分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p><strong>step2 解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p><strong>step3 合并</strong>：将各个子问题的解合并为原问题的解。</p><p><strong>分治法的复杂性分析</strong></p><p>一个分治法将<strong>规模为n</strong>的问题分成<strong>k个规模为n／m</strong>的子问题去解。设分解阀值n0&#x3D;1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解**合并为原问题的解需用f(n)**个单位时间。用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p><p><strong>T（n）&#x3D; k T(n&#x2F;m)+f(n)</strong></p><h3 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h3><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>思路：</strong></p><p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p><p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p><p><strong>算法：</strong></p><p>我们使用分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countInRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) </span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">majorityElementRec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//大小为1的数组中唯一的元素是多数</span></span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这个切片的左右两半上递归。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> majorityElementRec(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> majorityElementRec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">//如果两半在多数元素上达成一致，则返回它。</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，计算每个元素并返回“赢家”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> countInRange(nums, left, lo, hi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> countInRange(nums, right, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h3><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯法-Backtracking"><a href="#回溯法-Backtracking" class="headerlink" title="回溯法   Backtracking"></a><strong>回溯法   Backtracking</strong></h2><p>常见问题：</p><ul><li>排列问题，讲究顺序，因此已经选过的元素还有可能再次被选中放置在不同的位置上，构成不同的排列；</li><li>组合问题与子集问题，因为不计算元素顺序，一个元素选还是没有选过很重要，因此需要设置搜索起点，搜索起点之前的元素不再考虑，这样才能做到不重不漏；</li><li>切割问题：如 给一字符串返回符合条件的子串</li><li>棋盘问题：如 N皇后，解数独</li></ul><blockquote><p>编码之前先根据具体的用例画出<code>树形图</code>，图和代码是一 一对应的关系，先画图再编码是不错的方式；</p></blockquote><h3 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            getParenthesis(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParenthesis</span><span class="params">(String str,<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> )&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                <span class="comment">//剩余左右括号数相等，下一个只能用左括号</span></span><br><span class="line">                getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="comment">//剩余左括号小于右括号，下一个可以用左括号也可以用右括号</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">                &#125;</span><br><span class="line">                getParenthesis(str+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h3><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k1判断a中添加元素的个数，n1用于表示加入的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span> n, <span class="type">int</span> n1, <span class="type">int</span> k, <span class="type">int</span> k1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n1 &lt;= n; n1++) &#123;</span><br><span class="line">            a.add(n1);</span><br><span class="line">            backtrack(a, n, n1 + <span class="number">1</span>, k, k1 + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//栈方便后进先出</span></span><br><span class="line">        backtrack(stack, n, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n为nums长度，m为指示下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; m &lt;= n; m++) &#123;</span><br><span class="line">            a.add(nums[m]);</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            backtrack(a, nums, n, m + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">        backtrack(a, nums, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a存储每一组答案， ind只放0和1，用来判断nums中的值是否被取过， n为nums长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span>[] ind, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            a.add(nums[i]);</span><br><span class="line">            ind[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(a, nums, ind, n);</span><br><span class="line">            ind[i] = <span class="number">0</span>;</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ind = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        backtrack(a, nums, ind, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a><strong>深度优先搜索</strong>（DFS）</h2><p><strong>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，再返回至最近的分支进行搜索，而且每个节点只能访问一次。</strong></p><p><strong>常用栈 或 递归 实现</strong></p><h4 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> width, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; length - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; width - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j, width, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length, width = grid.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j, width, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">searchLand_DFS</span><span class="params">(<span class="type">char</span> **grid, <span class="type">int</span> rowSize, <span class="type">int</span> colSize,<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="comment">//将搜索过的位置变为0</span></span><br><span class="line">    grid[row][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//向右搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col + <span class="number">1</span> &lt; colSize) &amp;&amp; (grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid,rowSize,colSize,row,col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row + <span class="number">1</span> &lt; rowSize) &amp;&amp; (grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row + <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize,colSize, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;gridColSize[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                searchLand_DFS(grid,gridSize, gridColSize[<span class="number">0</span>],i,j);</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.二叉搜索树的范围和</h4><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p>代码：(这里利用了递归实现深度优先搜索，下面两种代码一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; low )&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  root-&gt;val + </span><br><span class="line">       rangeSumBST(root-&gt;left,low,high) +</span><br><span class="line">        rangeSumBST(root-&gt;right,low,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = rangeSumBST(root -&gt;left,L,R) + rangeSumBST (root -&gt; right,L,R);</span><br><span class="line">    <span class="keyword">if</span>(root -&gt;val &lt;= R &amp;&amp; root -&gt;val &gt;= L)</span><br><span class="line">        sum += root -&gt;val;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i] [j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(isConnected, visited, n, i);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] isConnected, <span class="type">boolean</span>[] visited, <span class="type">int</span> n, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(isConnected, visited, n, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方格分割"><a href="#方格分割" class="headerlink" title="方格分割"></a>方格分割</h4><p>有一个6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如：</p><img src="https://img-blog.csdn.net/20180203161615277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTkVVUTUwZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:50%;" /><p>注意：旋转对称的属于同一种分割法。</p><p>题解：<br>如果把样例图案剪开，发现有且只有两个点在边界上，且一定经过 （3,3）点<br>那么以（3,3）为起点进行深搜，深搜到一个点那么他的中心对称点相当于也搜过了，如果发现搜到了边界，那么它的中心对称点也到了边界 ，沿着已经搜过的点剪开，那么，剪开的两个图形为中心对称图形，但要注意最终的结果要除以4<br>例如 我们从（3,3）点出发一直向右到边界 ， 或一直向左，或一直向上，或一直向下，剪出来的图形是同一个。</p><p>我们从中心点开始搜索，每次可以走四个方向。搜索的过程要将中心对称点顺便标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">7</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">6</span> || y == <span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span>- xx][<span class="number">6</span> - yy] = <span class="number">1</span>;</span><br><span class="line">            DFS(xx,yy);</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span> - xx][<span class="number">6</span> - yy] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a><strong>广度优先搜索</strong>（BFS）</h2><h4 id="107-二叉树的层序遍历"><a href="#107-二叉树的层序遍历" class="headerlink" title="107.二叉树的层序遍历"></a>107.二叉树的层序遍历</h4><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line">返回结果：</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tempNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tempNums.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tempNums);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = list.remove();</span><br><span class="line">            i = cur[<span class="number">0</span>]; j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="547-省份数量-1"><a href="#547-省份数量-1" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] visits = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                    visits[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isConnected[j][k] == <span class="number">1</span> &amp;&amp; visits[k] == <span class="number">0</span>)</span><br><span class="line">                            q.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集  Union Find"></a><strong>并查集  Union Find</strong></h2><h4 id="200-岛屿数量-2"><a href="#200-岛屿数量-2" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h4><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (cols == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rows * cols;</span><br><span class="line">        <span class="comment">// 多开一个结点，把 &#x27;0&#x27; 都与最后这个结点连在一起</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + direction[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> j + direction[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (inArea(newX, newY, rows, cols) &amp;&amp; grid[newX][newY] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            unionFind.union(getIndex(i, j, cols), getIndex(newX, newY, cols));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unionFind.union(getIndex(i, j, cols), size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.getCount() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="comment">//连通分量个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            count = n;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="comment">// 只实现了路径压缩，并且是隔代压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * cols + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="547-省份数量-2"><a href="#547-省份数量-2" class="headerlink" title="547.省份数量"></a>547.省份数量</h4><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] == i)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        parent[find(parent, i)] = find(parent, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index] != index)</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721.账户合并"></a>721.账户合并</h4><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：accounts = [</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john00@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john_newyork@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：[</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&#x27;john00@mail.com&#x27;</span>, <span class="string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="string">&#x27;johnsmith@mail.com&#x27;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 <span class="string">&quot;johnsmith@mail.com&quot;</span>。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">（可以以任何顺序返回这些列表）</span><br></pre></td></tr></table></figure><p>根据题意可知：</p><ul><li>存在相同邮箱的账号一定属于同一个人</li><li>名称相同的账户不一定属于同一个人</li></ul><p><strong>思路：</strong><br>由于名称相同无法判断为同1人，所以只能<strong>使用邮箱是否相同来判断是否为同一人。</strong></p><p>这样建立并查集就比较简单了：</p><ul><li>先初始化每个账户为1个连通分量</li><li>遍历每个账户下的邮箱，判断该邮箱是否在其他账户下出现</li><li>如果未出现，继续</li><li>如果账户A、B下出现了相同的邮箱email，那么将账户A和账户B两个连通分量进行合并</li><li>最后遍历并查集中每个连通分量，将所有连通分量内部账户的邮箱全部合并(相同的去重，不同的合并)</li><li>结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">myUnion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的邮箱对应到同一个id【也就是第一次出现的id，比如4、5在同一个连通域，那么这个连通域对应的id就是4】</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法   Greedy"></a><strong>贪心算法</strong>   Greedy</h2><h4 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h4><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实时维护 最远可以到达的位置。</span></span><br><span class="line"><span class="comment">// 对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，</span></span><br><span class="line"><span class="comment">// 因此我们可以用 i + nums[i] 更新最远可以到达的位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">far</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//最远可到达距离必须大于当前位置，否则说明无法到达当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= far) &#123;</span><br><span class="line">                far = Math.max(far, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (far &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化搜索-Menory-Search"><a href="#记忆化搜索-Menory-Search" class="headerlink" title="记忆化搜索   Menory Search"></a><strong>记忆化搜索   Menory Search</strong></h2><h2 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划   Dynamic Programming"></a><strong>动态规划   Dynamic Programming</strong></h2><p><strong>动态规划</strong>：先将问题分解为子问题，并且对于这些分解的子问题自身是最优的才能在这个基础上得出我们要解决的问题的最优方案.<br><strong>与贪心算法不同之处</strong>在于，贪心算法是从局部最优来解决问题，而动态规划则是从全局最优来解决问题，当对情况及条件加以限制时，贪心算法会因目光短浅而得到错误答案。<br><strong>记忆化搜索</strong>&#x3D;搜索的形式+动态规划的思想<br>搜索过程中会有很多重复计算，通过记录一些状态的答案减少重复搜索量.<br>搜索过程中一个搜索结果必须可以建立在同类型问题的结果上</p><p><strong>联系</strong><br>记忆化搜索与递归一样，都是自顶向下的思路，而动态规划则是自底向上的思路。<br>在平常练习中，我们一般是只考虑一个问题，一般习惯于自顶向下正向思考，这也比较符合人类的逻辑习惯嘛，这便是记忆化搜索（ms）。如果逆向思考，自底向上递推求解，这便是动态规划（dp）了。</p><hr><p>dp和ms 原理都是相同的，只是实现方法不同<br>可以明显的发现有以下几点不同：</p><p>1、DP是从下向上，而记忆化搜索是从上向下的</p><p>2、DP是从下向上，为了求到最终结果需要把过程中所有的值都保存下来，以便下一步可能会使用，而因为记忆化搜索是从上向下的，所以求解过程求的都是需要的；也就是说不需要的值并没有求</p><p>3、记忆化搜索使用递归实现的；</p><p>如果一个dp[i] [j]的值已经求过，使用DP直接调用即可；而使用记忆化搜索则要进入递归</p><p>如果一个dp[i] [j]的值还未求过，使用DP直接求得，而使用记忆化搜索则要进入递归中去求，而这个递归很有可能是多重的</p><p>这样一来DP在时间上几乎总是优于记忆化搜索的</p><hr><h4 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>解答：</p><p>我们采用自下而上的方式进行思考。定义 F(i) 为组成金额 i 所需最少的硬币数量，假设在计算 F(i)之前，我们已经计算出 F(0) - F(i-1) 的答案。 则 F(i) 对应的转移方程应为</p><p>F(i) &#x3D; min [  F( i - cj )  ]  +  1</p><p>{cj 表示第 j 枚硬币的面值，即我们枚举最后一枚硬币时，需要从  i - cj  这个金额状态 F( i - cj ) 转移过来，也就是求出 F( i - cj )  所需的硬币数量，再加1}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span> *coins, <span class="type">int</span> coinsSize, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、确定base case */</span></span><br><span class="line">    <span class="type">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 2、从面值为1开始，计算其dp值 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 2.1、确定状态：当前面值的 dp 值为 amount + 1 */</span></span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 2.2、确定选择：即为硬币的面值</span></span><br><span class="line"><span class="comment">         * 依次计算当前dp值是否可以再分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++) &#123;</span><br><span class="line">            <span class="comment">/* 判断条件是 i &gt; coins[j](1、2、5) */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                <span class="comment">/* dp(amount) = min(dp(amount - coins[1、2、5])) + 1 */</span></span><br><span class="line">                dp[i] = (dp[i - coins[j]] + <span class="number">1</span>) &lt; dp[i] ? (dp[i - coins[j]] + <span class="number">1</span>) : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3、若当前硬币不能被再分，则返回-1 */</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount] &lt; amount + <span class="number">1</span> ? dp[amount] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h4><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>假如计划在第 i 天卖出股票，那么最大利润的差值一定是在[0, i-1] 之间选最低点买入；所以遍历数组，依次求每个卖出时机的的最大差值，再从中取最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice=<span class="number">0xFFFFFF</span>;</span><br><span class="line">    <span class="type">int</span> maxret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxret = (prices[i]-minprice)&gt;maxret ? prices[i]-minprice:maxret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h4><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>解题思路与斐波那契一致；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最少爬一阶</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>,c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h4><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>动态规划转移方程：</p><p><strong>f(i, j) &#x3D; f(i-1, j) + f(i, j-1)</strong></p><p>注：网格的边界，它们的值均为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> nums[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h4><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>用<em>dp</em>( i , j ) 表示以 ( i, j ) 为右下角，且只包含 1 的正方形的边长最大值。</p><ul><li><p>如果该位置的值是 0，则dp( i , j )&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p></li><li><p>如果该位置的值是 1，则 dp( i , j ) 的值由其上方、左方和左上方的三个相邻位置的dp( i , j ) 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p><strong>dp(i, j)&#x3D;min( dp(i−1, j), dp(i−1, j−1), dp(i, j−1) )+1</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b,c) ((a)&lt;(b)?( (a)&lt;(c)?(a):(c) ):( (b)&lt;(c)?(b):(c) ))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrixSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j,k,ms = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;matrixSize;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;matrixColSize[j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; j&gt;<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>) matrix[j][k] = MIN(matrix[j<span class="number">-1</span>][k],matrix[j][k<span class="number">-1</span>],matrix[j<span class="number">-1</span>][k<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k] &gt; ms) ms = matrix[j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ms-<span class="string">&#x27;0&#x27;</span>)*(ms-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h4><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p>（完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p>这是完全背包问题的简单变形：</p><ul><li>背包大小即传入的参数<code>n</code></li><li>物品的重量是平方数的值<code>sqr</code></li><li>物品的价值是<code>1</code>，因为我们要求的是数字个数</li></ul><p>题目转换为，能用 [1,n]  里的共<code>m</code>个平方数（物品）刚好装满空间为<code>n</code>的背包的所有方法中，产生价值最少的装法。<br>完全背包问题模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记 dp[<span class="number">0.</span>.capa + <span class="number">1</span>] 是备忘录数组</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j = weight[i] to capa</span><br><span class="line">        dp[j] = max( dp[j] , dp[j - weight[i]] + val[i] )</span><br><span class="line">输出 dp[capa]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        dp[i] = INT_MAX - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">            dp[i] = min(dp[i],dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h4><p>（十一届蓝桥C++-B组）</p><p>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。</p><p>要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？</p><p>答案很大，你只需要给出方案数除以 2020 的余数即可。</p><p>题解：（动态规划）</p><p>用DP[i] [j]表示第一层有i个数，第二层有j个数有多少种方案</p><p>题目要求同一行中右边比左边大， 同一列中下边比上边的大，所以 j &lt;&#x3D; i</p><p>1.当j &lt; i 时， DP[i] [j]可以用此时少一个数的方案来表示，少一个数可以是DP[i - 1] [j]，也可以是DP[i] [j - 1]，所以：</p><p>DP[i] [j] &#x3D; DP[i - 1] [j] + DP[i] [j - 1]</p><p>2.当j &#x3D; i时， 因为要求，所以</p><p>DP[i] [j] &#x3D; DP[i] [j - 1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1011</span>][<span class="number">1011</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">DP[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) DP[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> DP[i][j] = (DP[i - <span class="number">1</span>][j] + DP[i][j - <span class="number">1</span>]) % <span class="number">2020</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, DP[<span class="number">1010</span>][<span class="number">1010</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)    <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h3><p>背包问题可以描述为：给定一组物品，每种物品都有自己的<strong>重量</strong>和<strong>价值</strong>，在<strong>限定的总重量</strong>内，如何选择才能使得物品的<strong>总价值</strong>最高。<br>背包问题是典型的动态规划问题。</p><p>而背包问题还存在需要<strong>恰好装满</strong>背包和<strong>不需要恰好装满</strong>两种情况</p><ol><li>01背包问题（每种物品只有一件，放或者不放）</li><li>完全背包问题（每件物品有无限件可用）</li><li>多重背包问题（每件物品有n[i]件可用）</li></ol><h4 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h4><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。求将哪些物品装入背包可使价值总和最大。</p><p>”01”的意思是：每种物品仅有一件，放为“1”，不放为“0”。<br>我们假定 f [i] [v] 为将前 i 件物品恰好放入一个容量为V的背包中可获得的最大价值。<br>则其状态转移方程是：</p><p><strong>f [i] [V]&#x3D;max{ f [i-1] [V] ,f [i-1] [V-weight[i] ]+value[i] }</strong></p><ul><li>公式中，即将前 i 件物品放入容量为V 的背包中：<ul><li>不放第 i 件：前 i - 1 件物品放入容量为V的背包中，价值为f [i - 1] [V] ;</li><li>放第 i 件：前 i - 1 件物品放入剩余容量为 V - weight[i] 的背包中，价值为f [i-1] [V-weight[i] ]+value[i]</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &lt;= j) &#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>还可以将二维数组转化为一维数组，减少空间复杂度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= weight[i]; --j)</span><br><span class="line">            f[j] = max(f[j], f[j - weight[i]] + value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><p>（在输出的时候，只能输出最后的价值，不能知道选择的物品是哪个。为此，在这里我们定义一个数组x[i]，对于每一个物品，如果被选择置为“1”，否则为“0”。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V  100  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> N,M; </span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//动态规划分析</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=M; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (weight[i]&lt;=j)  </span><br><span class="line">            &#123;  </span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-weight[i]]+value[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//输出选择的物品</span></span><br><span class="line">    <span class="type">int</span> j = M;</span><br><span class="line">    <span class="type">int</span> x[V];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=N; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] &gt; f[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            x[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            j = j - weight[i<span class="number">-1</span>];<span class="comment">//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; ++i)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[i]);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h4 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h4><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。每件物品可以无限选用，求将哪些物品装入背包可使价值总和最大。</p><p>完全背包问题不设定物品取用上限</p><p>对于算法的优化我们可以这样想：<br>在01背包问题中，我们要保证第i次循环中的f [i] [v]是由f [i-1] [ V-weight[i] ] 递推而来，每一次都是“加选出<strong>一个（即一种）</strong>物品”而这种方式同时也保证了每件物品只选一次。<br>而完全背包问题的特点刚好是每种物品可选无限件，所以在考虑“加选出<strong>一个（即一种）</strong>物品”时就是单纯的考虑“加选出<strong>一个（可能为同一种）</strong>物品”，这样我们就需要考虑选入的物品是已经选入的情况。相比来说，反而简化了代码。</p><p>同样，我们假定f [i] [v]为将前i件物品前恰好放入一个容量为V的背包中可获得的<strong>最大价值</strong><br>则其状态转移方程是：</p><p>*<em>f [i] [V]&#x3D;max{ f [i-1] [V]  ,  f [i-1] [ V-k</em>weight[i] ] + k <em>value[i] }</em>*</p><p>( 0&lt;&#x3D;k*weight[i]&lt;&#x3D;v，其中0&lt;&#x3D;k&lt;&#x3D;V&#x2F;weight[i+1]  )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">           f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] = max(f[j], f[j - weight[i]] + value[i]); </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[N][M]);<span class="comment">//输出最优解  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h4><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品最多有n[i]个，每个的费用是weight[i]，价值是value[i]。每件物品最多可以选用相应的最大个数，求将哪些物品装入背包可使价值总和最大。<br>多重背包问题设定物品选择上限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">               f[j] = max(f[j], f[j - k * weight[i]] + k * value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];   </span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M,cur;  </span><br><span class="line">    freopen(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;weight[i],&amp;value[i],&amp;num[i]); </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>LCS ：longest common sequence</p><p>子序列与子串不同，子序列：将给定序列中零个或多个元素去掉之后得到的结果；子串：给定串中任意个连续的字符组成的子序列称为该串的子串</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191708770.png"></p><p>此问题有最优子结构性质：</p><p>设序列S<del>1</del>&#x3D;{x<del>1</del>,x<del>2</del>,……x<del>n</del>}和S<del>2</del>&#x3D; {y<del>1</del>,y<del>2</del>,……y<del>m</del>}的最长公共子序列为S&#x3D;{z<del>1</del>,z<del>2</del>,……z<del>k</del>}，则：</p><p>1）若x<del>n</del>&#x3D;y<del>m</del>，那么zk&#x3D;xn&#x3D;ym 且S[k-1]是S1[n-1]和S2[m-1]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del> !&#x3D; x<del>n</del>，则S[k]是S1[n-1]和S2[m]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del>!&#x3D;y<del>m</del>，则S[k]是S1[n]和S2[m-1]的最长公共子序列</p><p>可见：两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列具有最优子结构性质，可以用动态规划求解。 </p><p><strong>递推公式：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191708771.png" alt="image-20210409174359997"></p><p>为了求出LCS中具体的字符，再用一个表格b[i] [j] 表示dp[i] [j]与周边表格的关系（也可以使用dp[i] [j]来推，不必再建一个表格）。</p><p>即 S1[i] 和 S2[j] 值相等时dp[i] [j] 的值与右上的dp[i-1] [j-1]有关 ，用1表示 ，以此类推；</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708772.png" alt="image-20210409175042466" style="zoom: 67%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708773.png" alt="image-20210409175548890" style="zoom:67%;" /><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><p>前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。</p><p>一维数组的前缀和 : sum[i] &#x3D; sum[i-1] + a[i] </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) y[i]=x[i];</span><br><span class="line">    <span class="keyword">else</span> y[i]=y[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组前缀和：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/webp" alt="img"></p><p>二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：</p><p><img src="https://www.zhihu.com/equation?tex=b_%7Bx,y%7D=b_%7Bx-1,y%7D+b_%7Bx,y-1%7D-b_%7Bx-1,y-1%7D+a_%7Bx,y%7D" alt="[公式]"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++)<span class="comment">//n行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)<span class="comment">//m列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) b[y][x]=a[y][x];<span class="comment">//左上角的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) b[y][x]=b[y<span class="number">-1</span>][x]+a[y][x];<span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>) b[y][x]=b[y][x<span class="number">-1</span>]+a[y][x];<span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">else</span> b[y][x]=b[y<span class="number">-1</span>][x]+b[y][x<span class="number">-1</span>]-b[y<span class="number">-1</span>][x<span class="number">-1</span>]+a[y][x];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树   Trie"></a><strong>前缀树   Trie</strong></h2><p>Trie 是一颗非典型的多叉树模型，</p><p>多叉：即每个结点的分支数量可能为多个。</p><p>非典型：因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，</p><p>比如一般的多叉树的结点是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    VALUETYPE value;    <span class="comment">//结点值</span></span><br><span class="line">    TreeNode* children[NUM];    <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TrieNode结点中并没有直接保存字符值的数据成员，而是用 字母映射表 next ，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">if</span> (parentNode-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        说明父结点的后一个字母不可为 ch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        说明父结点的后一个字母可以是 ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720.词典中最长的单词"></a>720.词典中最长的单词</h4><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p><p>若无答案，则返回空字符串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： </span><br><span class="line">单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：</span><br><span class="line">&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>将所有单词插入 <code>trie</code>，然后从 <code>trie</code> 进行深度优先搜索，每找到一个单词表示该单词的全部前缀均存在，我们选取长度最长的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    String word; <span class="comment">// 用来保存当前遍历的 word</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        getMaxLengthWord(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 insert()insert() 方法时：</span></span><br><span class="line"><span class="comment">若遍历的当前字符串 word 中的某个字符所在字母表中的位置上在对应 children[26] 数组中没有节点，即 **node.children[c - &#x27;a&#x27;] == null**，则在该位置上定义一个新的 Trie 节点并且 node 指向新定义的节点，即 **node = node.children[c - &#x27;a&#x27;]**。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当 word 全部遍历完成时，此时 node 为 word 中的最后一个位置上的节点，此时将 isEnd 设置为 true 表示该 word 已经遍历完并全部插入到 Trie 树中并将该 word 保存到最后一个节点上，即 **node.word = word**。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">        node.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 当调用 **getMaxLengthWord()** 方法时：</span></span><br><span class="line"><span class="comment">若当前传入的节点不是最后一个位置上节点而是中间某位置的节点，此时直接结束。</span></span><br><span class="line"><span class="comment">若当前传入的节点的深度 deep &gt; maxLength，此时应该更新 maxLength的值并且将该节点对应的 word保存下来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 通过递归遍历 node 的 children 数组并且每遍历一次深度 deep 增加 1：DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMaxLengthWord</span><span class="params">(Trie node, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">0</span> &amp;&amp; !node.isEnd) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxLength) &#123;</span><br><span class="line">            res = node.word;</span><br><span class="line">            maxLength = deep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前传入节点的 children[26]children[26] 对每一个不为空的节点都进行深度搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                getMaxLengthWord(node.children[i], deep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目顺序"><a href="#题目顺序" class="headerlink" title="题目顺序"></a>题目顺序</h2><p><strong>leetcode</strong></p><ul><li>数组Arrary：485，283，27</li><li>链表Linked List: 203,206</li><li>队列Queue：933，225（用队列实现<strong>栈</strong>），622，64</li><li>栈Atack：20，496，232（用栈实现队列）</li><li>哈希表Hash Table：217，389，496</li><li>集合Set：217，705（设计哈希集合）</li><li>堆Heap：215，692</li><li>树&#x2F;图：各种算法</li><li>双指针算法Two Pointers：141，344，881</li><li>二分查找法Binary Search(模板）：704，35，162，74</li><li>滑动窗口Sliding Window：209，1456</li><li>递归算法Recursion（开始练习时用笔画）：509，206，344，687</li><li>分治算法Divide &amp; Conquer：169，53</li><li>回溯算法Backtracking：22，78，77，46（全部非常经典）</li><li>深度优先搜索DFS：200，547，721</li><li>宽度优先搜索BFS：102，107，200</li><li>并查集Union Find（模板）：200，547，<strong>721</strong></li><li>贪心算法Greedy：<strong>322</strong>，1217，55</li><li>记忆化搜索Memoization：509，322</li><li><strong>动态规划</strong>Bynamic Bogramming：509，62，121，70，279，221</li><li>拓扑排序Topologic Sort：207，210</li><li>前缀Trie：208（模板），<strong>720</strong>，692</li></ul><h2 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h2><p>判断闰年：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//是闰年，m[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转数组：</p><p>Collections.reverse(ret);</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h2><p>数组：广义表</p><p>树：<del>层次遍历算法</del>，线索二叉树，<del>二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋）</del>，<del>B树（多路平衡查找树）</del>，<del>B+树</del>，——红黑树</p><p>并查集：</p><p>图：</p><h2 id="数组-Arrarry"><a href="#数组-Arrarry" class="headerlink" title="数组  Arrarry"></a><strong>数组  Arrarry</strong></h2><p><a href="#java%E6%95%B0%E7%BB%84">java</a></p><p>C</p><ul><li>使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）</li></ul><p>C 语言不允许返回一个完整的数组作为函数的参数。</p><p>想要从函数返回一个数组，需先声明一个返回指针的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">myFunction</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p><p>示例（生成随机数，并用数组返回）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java数组"><p> <strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数组创建</span></span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;b: &quot;</span> + Arrays.toString(b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 3</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;c: &quot;</span> + Arrays.toString(c));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 4</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr.add(i + <span class="number">1</span>);<span class="comment">//add方法：括号内为(数组索引值,元素），索引值可以不加，则将元素插入到末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr: &quot;</span> + arr.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        arr.add(<span class="number">99</span>);        <span class="comment">//O(1)</span></span><br><span class="line">        arr.add(<span class="number">3</span>, <span class="number">88</span>);     <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> arr.get(<span class="number">1</span>);      <span class="comment">//()里为索引值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新元素 ：O(1)</span></span><br><span class="line">        c[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        arr.set(<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.删除元素 ： O(N)</span></span><br><span class="line">        arr.remove(<span class="number">1</span>);      <span class="comment">//删除下标为1处的元素</span></span><br><span class="line">        arr.remove(Integer.valueOf(<span class="number">4</span>));     <span class="comment">//删除第一个值为4的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;      <span class="comment">//删除所有值为3的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">                arr.remove(i--);        <span class="comment">//每删除一个元素后当前下标应-1，否则会漏掉下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.数组长度 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSize</span> <span class="operator">=</span> arr.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历数组 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> c[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.查找元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">99</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;we found 99 at int c!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is99</span> <span class="operator">=</span> arr.contains(<span class="number">99</span>);    <span class="comment">//找到目标值则返回True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9. 数组排序 : O(N logN)</span></span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        Collections.sort(arr);  <span class="comment">//升序排列</span></span><br><span class="line">        Collections.sort(arr, Collections.reverseOrder());  <span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（N）</p><p>删除（Delete）：O（N）</p><h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表  Linked List"></a><strong>链表  Linked List</strong></h2><p><a href="#java%E9%93%BE%E8%A1%A8">java</a></p><p> <strong>C</strong></p><p>创建链表：</p><p>创建结构变量指针，使用前要先分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">LinkList *<span class="title function_">CreatList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList *temp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LinkList *a = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a-&gt;data);</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改链表结点的值</span></span><br><span class="line">LinkList  <span class="title function_">changeList</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;结点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表的第n个位置插入数据</span></span><br><span class="line">LinkList *<span class="title function_">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;   <span class="comment">//temp用于表示插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =  temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList  *in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;in-&gt;data);</span><br><span class="line">    in-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表中第n个节点</span></span><br><span class="line">LinkList *<span class="title function_">delete</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;    <span class="comment">//temp用于表示删除位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList *del = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkList *<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头插法和尾插法："><a href="#头插法和尾插法：" class="headerlink" title="头插法和尾插法："></a>头插法和尾插法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">p=head;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">q=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_1</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">p=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">p-&gt;next=head-&gt;next;</span><br><span class="line">head-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>=</span>head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">head</span>;</span></span><br><span class="line">head=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">creat(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line"></span><br><span class="line">creat_1(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java链表"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        list.add(<span class="number">1</span>);    <span class="comment">//O(1)</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">99</span>); <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.搜索元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">99</span>);   <span class="comment">//搜索元素值，然后返回索引值(下标)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.更新元素 : O(N)</span></span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">88</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.删除元素 : O(N)</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除头节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除链表头部节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//sentinel：哨兵</span></span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> ans, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的时间复杂度"><a href="#链表的时间复杂度" class="headerlink" title="链表的时间复杂度"></a>链表的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列  Queue"></a><strong>队列  Queue</strong></h2><p><a href="#java%E9%98%9F%E5%88%97">java</a></p><p><strong>C</strong></p><p>判断队列是否为空：</p><ol><li>设置一个标志变量；</li><li>当队列满时，保留一个元素空间；设队列最大尺寸为QueueSize，则<strong>队列满的条件是：（rear+1）%QueueSize &#x3D;&#x3D; front</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QuDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span> *_<span class="title">next</span>;</span></span><br><span class="line">    QuDataType _data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QueueNode *_front;</span><br><span class="line">    QueueNode *_rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue *q)</span>;<span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue *q,QuDataType data)</span>;<span class="comment">//队尾入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue *q)</span>;<span class="comment">//队头出队列</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列头部元素</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列中有效元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;<span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;<span class="comment">// 销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数据入队列必须要先创建节点</span></span><br><span class="line">QueueNode * <span class="title function_">BuyQueueNode</span><span class="params">(QuDataType x)</span>&#123;    <span class="comment">//创建节点并初始化此节点</span></span><br><span class="line">    QueueNode * cur = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    cur-&gt;_data = x;</span><br><span class="line">    cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>&#123; <span class="comment">//初始化队列结构</span></span><br><span class="line">    q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QuDataType x)</span> &#123; <span class="comment">//队列尾部入数据</span></span><br><span class="line">    QueueNode * cur = BuyQueueNode(x);  <span class="comment">//先把创建好的节点传过来</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;             <span class="comment">//若是队列本身为空，队列里就只有这一个节点，又为队列头又为队列尾</span></span><br><span class="line">        q-&gt;_front = q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;_rear-&gt;_next = cur; <span class="comment">//否则，链表尾插操作</span></span><br><span class="line">        q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span> &#123;    <span class="comment">//队列头部出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;    <span class="comment">//本身队列为空，不做操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* tmp = q-&gt;_front-&gt;_next;   <span class="comment">//先保留下一个节点，防止断链</span></span><br><span class="line">    <span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">    q-&gt;_front = tmp;   <span class="comment">//更新对列头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//获取队列首部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>&#123;<span class="comment">//获取队列尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front == <span class="literal">NULL</span>;   <span class="comment">//为空，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>&#123;  <span class="comment">//获取队列中的元素个数</span></span><br><span class="line">    QueueNode * cur;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur = q-&gt;_front; cur; cur = cur-&gt;_next)<span class="comment">//循环遍历，计数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* q)</span>  <span class="comment">//销毁队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;_front)&#123;</span><br><span class="line">        QueuePop(q);<span class="comment">//对每一个元素迭代出队即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q)); <span class="comment">//1</span></span><br><span class="line">    QueuePop(&amp;q);<span class="comment">//出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q));<span class="comment">//2   此时队首为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueBack(&amp;q));<span class="comment">//4  队尾为4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java队列"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建队列</span></span><br><span class="line">        <span class="comment">//用LinkedList(链表)作为对象,插入和删除操作时间复杂度只有O(1)</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素 :O(1)</span></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(temp1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.删除即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();   <span class="comment">//返回值，并将其删除 </span></span><br><span class="line">        System.out.println(temp2);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断队列是否为空 ：O(1)</span></span><br><span class="line">        System.out.println(queue.isEmpty());    <span class="comment">//队列空则返回True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.队列长度 ：O(1)</span></span><br><span class="line">        <span class="comment">//创建链表时会有一个变量，当加入一个元素时变量加1，获取长度时会直接返回这个变量值</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历队列 :O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933.最近的请求次数"></a>933.最近的请求次数</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h4><p>利用两个队列 来实现栈的基本操作：进栈，显示栈顶元素，删除栈顶元素，判空f</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a>622.设计循环队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[(rear + capacity - <span class="number">1</span>) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a>Deque（双端队列）</h4><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p><ul><li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li></ul><p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure><p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p><p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p><p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure><p>创建 ArrayDeque实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure><p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure><p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p><p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()<br>这些方法下面会一一讲解。</p><p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p><p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure><p><strong>获取元素：</strong></p><p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p><p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement的值是: “first element”。</p><p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p><p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure><p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p><p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure><p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure><p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure><p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p><p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure><p>执行完代码后size大小是2，因为Deque中包含两个元素。</p><p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p><p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p><p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的时间复杂度"><a href="#队列的时间复杂度" class="headerlink" title="队列的时间复杂度"></a>队列的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈   Stack"></a><strong>栈   Stack</strong></h2><p><strong>java：</strong></p><p>（Java堆栈Stack已经过时，推荐使用Deque替代Stack。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取栈顶元素 : O(1)</span></span><br><span class="line">        stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//pop方法会删除元素并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的大小 : O(1)</span></span><br><span class="line">        stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈是否为空 : O(1)</span></span><br><span class="line">        stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的遍历 : O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p><ul><li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li><li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li></ul><p>假设：</p><p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 </p><p>10入栈时，栈为空，直接入栈，栈内元素为10。</p><p>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</p><p>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</p><p>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</p><p>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</p><p><strong>伪代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(遍历这个数组)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        hash.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != hash.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素1"><a href="#496-下一个更大元素1" class="headerlink" title="496.下一个更大元素1"></a>496.下一个更大元素1</h3><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>只使用两个栈，实现一个先入先出的队列（push,pop,peek,empty)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack1中的数据依次出栈并入栈stack2</span></span><br><span class="line">    <span class="comment">//数据进栈stack2</span></span><br><span class="line">    <span class="comment">//stack2中数据依次出栈并入栈stack1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的时间复杂度"><a href="#栈的时间复杂度" class="headerlink" title="栈的时间复杂度"></a>栈的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串   String"></a><strong>字符串   String</strong></h2><p>字符串输入：</p><ol><li><p>数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">6</span>] = <span class="string">&quot;array&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;array&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %c %c&quot;</span>,p,*p,*(p + <span class="number">2</span>));   <span class="comment">//第一个输出字符串；第二个输出指针指向，即字符串的第一个字符；第三个输出字符串中 第三个字符</span></span><br></pre></td></tr></table></figure></li><li><p>数组&#x2F;指针 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">6</span>];</span><br><span class="line">scang(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line">gets(arr1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>( <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>) );  <span class="comment">//记得为指针数组分配内存，否则会报错之类的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>,arr2);</span><br><span class="line">gets(arr2);</span><br></pre></td></tr></table></figure><p>（scanf只能输入一个单词，当遇到空格时会认为字符串结束；gets函数只知道数组的开始，并不知道数组的大小，如果输入过长容易溢出，并可能擦掉程序中的其他数据）</p></li><li><p>使用while完成多组测试，而不是在输入完一组数据后退出控制台</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">100</span>],arr2[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a;   </span><br><span class="line"><span class="keyword">while</span>((a = <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,arr1,arr2)) != EOF)&#123;     <span class="comment">//也可用while((a = getchar(arr1)) != &#x27;\n&#x27;)</span></span><br><span class="line">    pritnf(<span class="string">&quot;scanf返回l %d,s1是%s，s2是%s&quot;</span>，a,arr1,arr2);   <span class="comment">//这行输出后可以继续进行输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>KMP算法实现过程接近人为模式匹配</p><ul><li>匹配失败后，模式串移动的距离和主串无关，只与模式串本身有关，模式串后移等价于指针j前移。</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/2-1Q212223I41Z.gif" alt="模式串后移等价于 j 前移"></p><p>因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j&#x3D;3，则该字符匹配失败后指针 j 指向模式串中第 3 个字符。</p><p>模式串中各字符对应 <strong>next 值</strong>的计算方式是，取该字符前面的字符串（不包含自己），其<strong>前缀字符串和后缀字符串相同字符的最大个数再 +1</strong> 就是该字符对应的 next 值。</p><p>（模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。）</p><h4 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h4><p>一般的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样可能会有多余的操作，如：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/2-1Q212224002945.gif" alt="Next函数的缺陷"></p><p>当匹配失败时，Next 函数会由图 10b) 开始继续进行模式匹配，但是从图中可以看到，这样做是没有必要的。</p><p>如此，问题在当 T[i-1]&#x3D;&#x3D;T[j-1] 成立时，没有继续对 i++ 和 j++ 后的 T[i-1] 和 T[j-1] 的值做判断。</p><p>因此改进后的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123; </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i<span class="number">-1</span>]!=T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               next[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i]=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a><strong>散列表（Hash）</strong></h2><ul><li><p><strong>哈希表</strong>（hashtable），又叫散列表，是根据关键码（key）来进行访问的数据结构，通过哈希函数把key转成哈希值来定位数据存储的位置。通常是键-值对（即key-value）的结构，即用key算出的哈希值来定位存储位置，在该位置上存储内容为value。</p></li><li><p><strong>哈希集合</strong>（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。<br>简单来说就是，哈希集合是不能存储重复元素的数据结构（集合），而哈希表是存储键-值对（key-value），其中键key不能重复。</p></li><li><p><strong>哈希映射</strong>（hashmap）是和哈希表（hashtable）相似的数据结构，也是键-值对存储，只是哈希映射是线程安全的，而哈希表是非线程安全的。所谓线程安全，就是多线程同时操作数据的时候，能确保在同一时刻只能有一个线程能访问同一个数据（也就是会给数据操作加锁）；如果不能确保这个，就是非线程安全。</p></li></ul><p>哈希表 可能存在特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。</p><p>目前，这个哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p><p>下面简单<strong>介绍几种哈希函数</strong>。</p><ul><li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li><li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li><li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取<strong>素数</strong>或者直接用 n。</li></ul><p><strong>对散列表函数产生冲突的解决办法</strong>：</p><p>​有时不同的 Key 通过哈希函数可能会得到相同的地址，这在我们操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 Key 计算之后获得了相同的地址。</p><p>冲突的处理方式也有很多，下面介绍几种。</p><ul><li><strong>开放地址法</strong>（也叫<strong>线性探测</strong>）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。(如  f（key) &#x3D; {  f(key + d)  } % m）</li><li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li><li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</li><li><strong>建立一个公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li></ul><h3 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h3><p><a href="java%E6%95%A3%E5%88%97%E8%A1%A8">java</a></p><p><strong>C：</strong></p><h5 id="实现简单的哈希表"><a href="#实现简单的哈希表" class="headerlink" title="实现简单的哈希表"></a>实现简单的哈希表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12   <span class="comment">//定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;    <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;    <span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;   <span class="comment">//散列表表长，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line">Status <span class="title function_">InterHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;     <span class="comment">//除留余数法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入关键字进散列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);   <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;      <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">    H-&gt;elem[addr] = key;        <span class="comment">//直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表查找关键字</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">    *addr = Hash(key);                 <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key) &#123;        <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;            <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;     <span class="comment">//如果循环回到原点</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       <span class="comment">//则说明关键字不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>] = &#123;<span class="number">12</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    InterHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        IntertHash(&amp;H, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入之后的哈希表为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, H.elem[i]);</span><br><span class="line">    <span class="type">int</span> addr, j;</span><br><span class="line">    j = SearchHash(H, a[<span class="number">5</span>], &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;搜索到a[5]的地址是：%d&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希集合"><a href="#实现哈希集合" class="headerlink" title="实现哈希集合"></a>实现哈希集合</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">listContains</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List *head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line">MyHashSet *<span class="title function_">myHashSetCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashSet *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetAdd</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetRemove</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">myHashSetContains</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetFree</span><span class="params">(MyHashSet *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希映射"><a href="#实现哈希映射" class="headerlink" title="实现哈希映射"></a>实现哈希映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">listFind</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line">MyHashMap* <span class="title function_">myHashMapCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a neme = "java散列表"><p><strong>java：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        String[] hashTable = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>]; <span class="comment">//用数组创建</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//用HashMap方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//将其改为不会用到的值</span></span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取元素 : O(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> hashTable[<span class="number">1</span>];</span><br><span class="line">        map.get(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查key是否存在 : O(1)</span></span><br><span class="line">        map.containsKey(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长度，是否为空 : O(1)</span></span><br><span class="line">        map.size();</span><br><span class="line">        </span><br><span class="line">        map.isEmpty();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key对应的value，如果找不到key，则返回设置的默认值。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p><p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p><ol><li><strong>访问速度很快</strong></li></ol><p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p><ol start="2"><li><strong>需要额外的空间</strong></li></ol><p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p><p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p><p><strong>3) 无序</strong></p><p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p><p><strong>4) 可能会产生碰撞</strong></p><p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p><h3 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h3><p>根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p><p><strong>缓存</strong></p><p>通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p><p>在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p><p>有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p><p><strong>快速查找</strong></p><p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p><p>这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p><p>还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p><p>当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢，而散列表则不会。</p><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (hash.containsKey(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">hash.put(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h3><p>给定两个字符串 <strong>s</strong> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p><p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表的时间复杂度"><a href="#哈希表的时间复杂度" class="headerlink" title="哈希表的时间复杂度"></a>哈希表的时间复杂度</h3><p>访问（Access）：</p><p>搜索（Search）：O（1)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合   Set"></a><strong>集合   Set</strong></h2><ul><li><strong>无序，不重复</strong></li></ul><ol><li>检查元素是否存在</li><li>检查元素是否重复（原数据长度与集合长度是否相同）</li></ol><h3 id="java（哈希集合HashSet）"><a href="#java（哈希集合HashSet）" class="headerlink" title="java（哈希集合HashSet）"></a>java（哈希集合HashSet）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//[10,2]</span></span><br><span class="line">        System.out.println(set.add(<span class="number">2</span>));<span class="comment">//添加的元素已存在，会返回false，不存在则返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索元素 : O(1)0</span></span><br><span class="line">        set.contains(<span class="number">2</span>);<span class="comment">//存在则返回true</span></span><br><span class="line">        System.out.println(set.contains(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素-1"><a href="#217-存在重复元素-1" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树   Tree"></a><strong>树   Tree</strong></h2><ul><li><p>树中有一个根结点，其余节点可以分成若干个互不相交的“子树”。</p></li><li><p>除了根节点，每个结点有且只有一个父节点；</p></li><li><p>一棵N个结点的树有N - 1条边；</p></li></ul><p>结点的度：结点的子树个数；</p><p>树的度：树中所有结点中最大的度；</p><p>叶结点：度为0的结点；</p><p>兄弟结点：具有同一父结点的各个结点；</p><p>路径和路径结点：从结点N到结点Nk的路径，其路径结点为路径中结点个数 - 1，即路径中所包含的边的个数；</p><p>祖先结点：从某一结点，到根结点的所有节点，都是这个结点的祖先节点；</p><p>子孙结点：某一结点的子树中的所有节点，都是这个结点的子孙；</p><p>层次：规定根结点  在0&#x2F;1层，其他结点的层数是其父结点的层数+1；</p><p>深度：从上往下数，等于层；高度：从下往上数</p><h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p><strong>普通二叉树</strong>：每个结点最多两个子结点</p><p><strong>满二叉树</strong>：除了叶结点，每个结点都有两个子结点，并且所有叶结点都在同一层上；</p><blockquote><p>满二叉树的深度为k，则该树一共有 2^k^ - 1 个节点。</p></blockquote><p><strong>完全二叉树</strong>：从树的根结点出发，从上到下，从左到右，依次填满结点形成的二叉树</p><p>（满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）</p><p><strong>二叉树的遍历：</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>前</strong>序遍历</td><td><strong>根节点</strong>-&gt;左子树-&gt;右子树</td></tr><tr><td><strong>中</strong>序遍历</td><td>左子树-&gt;<strong>根节点</strong>-&gt;右子树</td></tr><tr><td><strong>后</strong>序遍历</td><td>左子树-&gt;右子树-&gt;<strong>根子树</strong></td></tr><tr><td>层次遍历</td><td>从上到下，从左到右</td></tr></tbody></table><p>（层次遍历需要用到 队列 ）</p><h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">//创建树的结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//创建树根</span></span><br><span class="line">    Node *root;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Tree *tree, <span class="type">int</span> value)</span> &#123;     <span class="comment">//创建树</span></span><br><span class="line">    Node *node = (Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个结点</span></span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) tree-&gt;root = node;  <span class="comment">//判断树是不是空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">//不是空树</span></span><br><span class="line">        Node *temp = tree-&gt;root;    <span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123;    <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Deleteer</span><span class="params">(Node *node, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L,*LL;    <span class="comment">//在删除左右子树都有的结点时使用；</span></span><br><span class="line">    Node *p=node;</span><br><span class="line">    Node *parent=node;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;  <span class="comment">//0表示左子树，1表示右子树；</span></span><br><span class="line">    <span class="keyword">if</span>(!node)    <span class="comment">//如果排序树为空，则退出；</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p)  <span class="comment">//二叉排序树有效；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)  <span class="comment">//叶结点(左右子树都为空)；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == node)  <span class="comment">//被删除的结点只有根结点；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">NULL</span>;  <span class="comment">//设置父结点左子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);   <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//父结点为右子树；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;right=<span class="literal">NULL</span>;  <span class="comment">//设置父结点右子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);  <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;left)  <span class="comment">//左子树为空，右子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)    <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;right)  <span class="comment">//右子树为空，左子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)  <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LL=p;  <span class="comment">//保存左子树的结点；</span></span><br><span class="line">                L=p-&gt;right;  <span class="comment">//从当前结点的右子树进行查找；</span></span><br><span class="line">                <span class="keyword">if</span>(L-&gt;left)  <span class="comment">//左子树不为空；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LL=L;</span><br><span class="line">                    L=L-&gt;left;   <span class="comment">//查找左子树；</span></span><br><span class="line">                    p-&gt;data=L-&gt;data;  <span class="comment">//将左子树的数据保存到被删除结点；</span></span><br><span class="line">                    LL-&gt;left=L-&gt;left;  <span class="comment">//设置父结点的左子树指针为空；</span></span><br><span class="line">                    <span class="keyword">for</span>(; L-&gt;left; L=L-&gt;left);</span><br><span class="line">                    L-&gt;left=p-&gt;left;</span><br><span class="line">                    p-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;data=L-&gt;data;</span><br><span class="line">                    LL-&gt;right=L-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; p-&gt;data)  <span class="comment">//需删除记录的关键字小于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的左子树；</span></span><br><span class="line">            child=<span class="number">0</span>;  <span class="comment">//标记在当前结点左子树；</span></span><br><span class="line">            parent=p;<span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;left;  <span class="comment">//查找左子树；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//需删除记录的关键字大于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的右子树；</span></span><br><span class="line">            child=<span class="number">1</span>;  <span class="comment">//标记在当前结点右子树查找；</span></span><br><span class="line">            parent=p;  <span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;right;  <span class="comment">//查找右子树；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;  <span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;     <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(tree.root);</span><br><span class="line">    Deleteer(tree.root,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>二又排序树、二叉查找树（BST, Binary Search Tree）<br>是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又各是一棵二又排序树。</li></ul><blockquote><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值；</p><p>进行中序遍历，可以得到一个递增的有序序列。</p></blockquote><p><strong>查找：</strong>时间复杂度 O(h)，若排序树很平衡，则h接近log<del>2</del>n，若非常不平衡，则h会接近n。</p><p><strong>插入：</strong>时间复杂度 O(h)</p><p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于 根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p><p><strong>删除：</strong></p><p>先搜索找到目标结点：</p><ul><li>①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质。</li><li>②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ul><h3 id="自平衡二叉树AVL"><a href="#自平衡二叉树AVL" class="headerlink" title="自平衡二叉树AVL"></a>自平衡二叉树AVL</h3><p>平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)ー一树上任一结点的左子树和右子树的<strong>高度之差不超过1</strong>。</p><p>结点的平衡因子 &#x3D; 左子树高 - 右子树高。</p><ul><li>平衡二叉树结点的平衡因子的值只可能是-1、0或1。否则就不是平衡二叉树了。</li></ul><p>查找：时间复杂度不超过O(h) 、O(log<del>2</del>n)</p><p><strong>插入</strong>：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201805281.png" alt="image-20211228111813606"></p><p><strong>调整</strong>最小不平衡子树A（从插入点找到的第一个不平衡点为根的子树）：</p><ul><li><p><strong>LL</strong>：在A的左孩子的左子树中插入导致不平衡；<br>调整：A的左孩子结点<strong>右上旋</strong>；</p></li><li><p><strong>RR</strong> ：在A的右孩子的右子树中插入导致不平衡；</p><p>调整：A的右孩子结点<strong>左上旋</strong>；</p></li><li><p><strong>LR</strong> ：在A的左孩子的右子树中插入导致不平衡；<br>调整：A的左孩子的右孩子<strong>先左上旋再右上旋</strong>；</p></li><li><p><strong>RL</strong> ：在A的右孩子的左子树中插入导致不平衡；<br>调整：A的右孩子的左孩子<strong>先右上旋后左上旋</strong>；</p></li></ul><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>结点的带权路径长度：</strong></p><blockquote><p>树的每一个结点，都可以拥有自己的“权重”（Weight），权重在不同的算法当中可以起到不同的作用。结点的带权路径长度，是指树的根结点到该结点的路径长度，和该结点权重的乘积。</p></blockquote><p><strong>树的带权路径长度</strong></p><blockquote><p>在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p></blockquote><p><strong>而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</strong></p><p><strong>一颗有n个叶子结点的的哈夫曼树共有2n-1个结点</strong></p><p>原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p><p>思路：</p><blockquote><p>借助辅助队列，将权值最小的两个叶子节点挑出来，并根据这两个结点生成一个新的父结点，父节点的权值是这两个结点权值之和；从队列中移除已选择的节点，把新的父结点加入队列；</p><p>重复这一步骤，直到所有结点组成一颗完整二叉树</p><p>（如果是构造<strong>k叉哈夫曼树</strong>，且节点数无法严格构成k叉树，则需要补充几个<strong>权值为0的 “假节点”</strong>）</p></blockquote><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201806626.png" style="zoom: 33%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201806756.png" style="zoom:33%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201807079.png" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 结点权值?</span></span><br><span class="line">    <span class="type">int</span> parent, lc, rc; <span class="comment">// 双亲结点和左 右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minum;      <span class="comment">// 定义一个临时变量保存最小值?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;     <span class="comment">// 以下是找到第一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = minum;</span><br><span class="line">    <span class="comment">// 以下是找到第二个最小值，且与第一个不同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = minum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuff</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s1, s2;</span><br><span class="line">    m = n * <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>]; <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 1 - n 存放叶子结点，初始化</span></span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 非叶子结点的初始化</span></span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe HuffmanTree is: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)     <span class="comment">// 创建非叶子节点，建哈夫曼树</span></span><br><span class="line">    &#123;   <span class="comment">// 在HT[1]~HT[i-1]的范围内选择两个parent为0且weight最小的两个结点，其序号分别赋值给 s1 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;  <span class="comment">// 删除这两个结点</span></span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lc = s1;      <span class="comment">// 生成新的树，左右子节点是 s1和s2</span></span><br><span class="line">        HT[i].rc = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;   <span class="comment">// 新树的权�?</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d (%d, %d)\n&quot;</span>, HT[i].weight, HT[s1].weight, HT[s2].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *w, n, wei;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the number of node\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ninput the %dth node of value\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei);</span><br><span class="line">        w[i] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreatHuff</span>(HT, w, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋0，右分支赋1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的基本思想是：为出现次数较多的字符编以较短的编码，在压缩原理中有重要作用。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称<strong>多路平衡查找树</strong>。</p><p>B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的<strong>m叉树</strong>：</p><ol><li>树中每个结点<strong>至多有m棵子树</strong>，即<strong>至多含有m-1个关键字</strong></li><li>若<strong>根结点不是终端结点，则至少有两棵子树</strong>。</li><li>除根结点外的所有<strong>非叶结点至少有 m&#x2F;2 棵子树</strong>，即至少含有 (m&#x2F;2) -1 个关键字。</li><li><strong>所有的叶结点都出现在同一层次上，并且不帯信息</strong>（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201807887.png" alt="image-20211227205412747"></p><p><strong>m阶B树的核心特性</strong></p><ol><li>根节点的子树数∈[2,m], 关键字数∈[1, m-1]<br>其他结点的子树数∈ [(m&#x2F;2), m] ;关键字数∈[(m&#x2F;2)-1, m-1]</li><li>对任一结点，其所有子树高度都相同</li><li>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt;关键字2 &lt; 子树2 &lt;. (类比二叉査找树左&lt;中&lt;右)</li></ol><blockquote><p>注：算B树高度时，不用包括叶子节点&#x2F;失败节点；</p><p>n个关键字的B树必有n+1个叶子节点。（相当于在n个关键字中插入木板，两边也插，则插了n+1个木板）</p></blockquote><p><strong>B树的插入</strong></p><p><strong>新元素一定是插入到最底层“终端节点”</strong>，用“查找”来确定插入位置。</p><p>在插入key后，若导致原结点关键字数超过上限，则从中间位置( [m&#x2F;2] )将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置( [m&#x2F;2] )的结点插入原结点的父结点。 </p><p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201807992.png" alt="image-20211227210741287"></p><hr><p><strong>B树的删除</strong></p><ul><li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除</strong>该关键字（要注意节点关键字个数是否低于下限 [m&#x2F;2] - 1 )</p></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来<strong>替代</strong>被删除的关键字（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素）——对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201807165.png" alt="image-20211227211302810"></p><ul><li><p>若删除关键字所在节点删除后，<strong>关键字低于下限</strong>：</p><ul><li><p>如果<strong>兄弟节点关键字充足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>借关键字</strong>“的目的。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201807275.png" alt="image-20211227211924677"></p></li><li><p>如果<strong>兄弟节点关键字不足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>合并</strong>“的目的。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201808905.png" alt="image-20211227212543467"></p></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树 可以类比分块查找。</p><p>分块查找：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201808668.png" alt="image-20211227212836480"></p><p>B+树：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201808635.png" alt="image-20211227212949012"></p><p>一棵<strong>m阶的B+树</strong>需满足下列条件：</p><ol><li>每个分支结点最多有m棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 m&#x2F;2 棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。（区别于B树，因为B+树的关键字和子树是一一对应的）</li><li>所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（支持顺序查找）</li><li>所有<strong>分支结点</strong>中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的指针。</li></ol><p><strong>B+的查找：</strong></p><p><strong>无论查找成功与否，最终一定要走到最下面一层节点。</strong>因为只有叶子节点存放了所需记录。</p><hr><p><strong>B树和B+树的对比：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201808265.png" alt="image-20211227213649466"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="概念性质"><a href="#概念性质" class="headerlink" title="概念性质"></a>概念性质</h4><p>红黑树的概念模型是<strong>2-3-4树</strong>，以<strong>二叉树为基础</strong>，在二叉树属性中加入<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p><p>红黑树的<strong>五大定义</strong>：</p><ol><li><strong>节点颜色只能为红或黑；</strong></li><li><strong>根节点是黑色；</strong></li><li><strong>每个叶子节点是黑色的（这里的叶子节点其实是空节点）</strong></li><li><strong>不能出现连续的红色节点；</strong></li><li><strong>从任意节点到它的每个子节点的所有路径都包含相同的黑色节点；</strong></li></ol><p>这5条定义确保了红黑树的关键特性：</p><ul><li><strong>从根到叶子节点的最长路径，不会超过最短路径的两倍</strong>；</li><li>这棵树<strong>基本是平衡</strong>的；</li><li>虽然不是绝对平衡，但可以保证<strong>最坏情况下，红黑树依然是高效的</strong>；</li></ul><p>为什么能做到最长路径不超过最短路径的两倍？</p><blockquote><p>性质4规定了路径上不能有两个相连的红节点，因此，最长路径一定是红色节点和黑节点交替而成；</p><p>性质2和3规定了根节点和叶子节点都是黑色，所以最短路径的黑节点一定多于红节点（可能全部为黑）；</p><p>性质5规定每条路径黑节点的数目相同；</p><p>因此，没有路径的长能多于其他任何路径两倍。</p></blockquote><p>红黑树的<strong>三种变换：变色，左旋转，右旋转</strong></p><p>红黑树<strong>插入的新节点为红色</strong>的：</p><blockquote><p>因为插入红节点，不会违反红黑树的规则，虽然可能会红红相连，不过可以通过变色和旋转来调整；而插入黑色节点，必然会导致一条路径上多一个黑节点（难以调整）。</p></blockquote><hr><p><strong>左旋转</strong>：以当前节点X为根，逆时针旋转二叉树，使得<strong>父节点原来的位置被右子节点替代，左子节点的位置被父节点替代</strong>。同时，节点Y的<strong>左子树</strong> b 向<strong>左平移</strong>成为了节点X的<strong>右子树</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/2.png" alt="image-20200303132706061"></p><p>旋转之后仍然是二叉搜索树：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/3.png" alt="image-20200303132617108"></p><p><strong>右旋转</strong>：以节点X为根，<strong>顺时针</strong>旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/4.png" alt="image-20200303132529476"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h4 id="2-3树-到-红黑树"><a href="#2-3树-到-红黑树" class="headerlink" title="2-3树 到 红黑树"></a>2-3树 到 红黑树</h4><p>2-3-4树中的2节点对应红黑树中的黑色节点，而非2节点以红节点+黑节点的方式表示，黑色父节点+一个红色子节点表示3节点，黑色父节点+左右两个红色子节点表示4节点；</p><blockquote><p>2-3-4树 ：是一颗阶数为4的B树，它可能会存在2节点，3节点，4节点（2节点就是普通的二叉树节点；3节点：由2个属性X和Y，3个子节点，分别是小于X的，大于X小于Y的，大于Y的；4节点跟3节点类似）</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/9f7961f77546c8f13448372625282335.png" alt="B树到红黑树的转化"></p><p>下面是以较为简单的 2-3树和左倾红黑树 为例，理解两者的转化关系</p><blockquote><p>2-3树不用考虑2-3-4树中复杂的4节点分裂；</p><p>左倾红黑树规定了红色节点只能在左子树，这个限制减少了原本红黑树的调平难度，更容易理解；</p></blockquote><hr><p>2-3树 和 左倾红黑树 ：把左倾红黑树中的红色节点<strong>顺时针方向旋转45°</strong>使其与黑父平行，然后再将它们看作一个整体，可以近似得到一颗2-3树。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/5a84b9872980c9a8761d3b84315d5931.png" alt="B树到红黑树的转化"></p><p>从2-3树来看，红黑树的红节点和黑节点是绑定的，因为在2-3树中它们本来就在同一层，所有只有黑节点在2-3树中体现树的高度</p><hr><p><strong>对于2-3树的插入：</strong></p><p>我们的插入操作需要遵循一个<strong>原则</strong>：先将这个元素尝试性地放在<strong>已经存在的节点中</strong>（即插入一个红色节点），如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（<strong>临时</strong>）。然后，我们对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p><p>如图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/02050b1461f4b891a92052f41139c567.png" alt="2-3树的插入"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/706a4ae059ebd3b6cfd8dfef6a3f05e4.png" alt="2-3-4树的插入"></p><p>在2-3树中如果待插入节点是个2节点，而2节点对应着红黑树中的黑色父节点；所以向2节点插入元素，即在黑色父节点下面增加一个红色儿子，</p><p>3节点插入元素，即已经有一个黑色父节点和一个红色子节点，则再给黑色父节点一个红色子节点</p><hr><p><strong>对于2-3树的删除：</strong></p><p>2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p><p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己<strong>唯一的元素</strong>，引发2节点自身的删除，会使得树中某条路径的<strong>高度发生变化</strong>，树变得<strong>不平衡</strong>。</p><p>对此有两种方案：</p><ol><li>先删除这个2节点，再对树进行平衡调整；</li><li>想办法让被删除元素不可能出现在2节点中；</li></ol><p>这里看第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点。</p><p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/9f2f0ebec960203ecafac6bf91462be2.png" alt="2-3树的删除"></p><p>插入和删除操作的父子节点上下浮动和删除里借元素的做法，就是红黑树的调整（变色，旋转）；</p><p>看左倾红黑树的 插入和删除（图示）：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/4947b64375651e3b2072ecd09d3fad7b.png" alt="左倾红黑树的插入"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/03f56fa81ffaee6bfe4fd68d25b6bc63.png" alt="左倾红黑树的插入"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/162498f17b4122405b0ef04cefe55368.png" alt="左倾红黑树的插入"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/28d7b36542a54750935418950da5d8eb.png" alt="左倾红黑树的插入"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/cd622250cc9453c634658ae934defc88.png" alt="左倾红黑树的删除"></p><p>删除之后需要一些调整（左倾红黑树不允许出现右倾）</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/711d441a7e05c4843237ac5e6f424f26.png" alt="左倾红黑树的删除"></p><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆   Heap"></a><strong>堆   Heap</strong></h2><p>性质：</p><ol><li>结构性：用<strong>数组表示</strong>的<strong>完全二叉树</strong>。</li><li>有序性：任意结点的关键字（权值）是其子树所有结点的最小值&#x2F;最大值<br>1. 父结点大于子结点：最大堆&#x2F;大根堆（MaxHeap）<br>            2. 父结点小于子结点：最小堆&#x2F;小根堆（MinHeap）</li></ol><p>应用：</p><ol><li>优先队列：是一种特殊的“队列”，从队列中取出元素的顺序是依照元素的关键字（权值&#x2F;数值）大小，而不是元素进入队列的先后顺序。</li><li>堆排序</li></ol><h3 id="最小堆操作与实现："><a href="#最小堆操作与实现：" class="headerlink" title="最小堆操作与实现："></a>最小堆操作与实现：</h3><p>对于任意最多有MaxSize个元素的最小堆H ∈ MinHeap 元素，item ∈</p><p> ElementType主要操作有：</p><ul><li>MinHeap Create(int Maxsize): 创建一个空的最小堆。</li><li>void Destroy(MinHeap)：释放堆的空间。</li><li>Boolean IsFull(MinHeap H): 判断最小堆是否已满。</li><li>Boolean IsEmpty(MinHeap H): 判断最小堆是否为空。</li><li>void Insert(MinHeap H,ElementType item): 将元素item插入最小堆H。</li><li>ElementType DeleteMin(MinHeap H): 返回最小堆H中最小元素（高优先级）。</li><li>MinHeap BuildMinHeap(ElementType *Element,int Size,int MaxSize)：创建一个非空的最小堆</li></ul><p><strong>数组下标为0</strong>的位置放一个比所有堆中元素都要小的元素（可以是ElementType的最小值），称为“<strong>哨兵</strong>”。从下标为1的位置开始存放堆中元素。因为是完全二叉树，所以父亲节点与其左右子节点下标满足一些关系。</p><p><strong>由子节点找父节点：父节点下标&#x3D;子节点下标 &#x2F; 2</strong><br><strong>由父节点找左子节点：左子节点下标&#x3D;父节点下标 * 2</strong><br><strong>由父节点找右子节点：右子节点下标&#x3D;父节点下标 * 2 + 1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elenment;      <span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;       <span class="comment">//堆的当前元素个数（最后一个元素的下标）</span></span><br><span class="line">    <span class="type">int</span> MaxSize;        <span class="comment">//堆存储空间的大小</span></span><br><span class="line">&#125; HeapStruct, *MinHeap;</span><br><span class="line"></span><br><span class="line">MinHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span> &#123;</span><br><span class="line">    MinHeap H = (MinHeap) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));     <span class="comment">//分配堆结构空间</span></span><br><span class="line">    H-&gt;Elenment = (ElementType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType) * (MaxSize + <span class="number">1</span>));    <span class="comment">//分配储存堆元素的数组的空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;MaxSize = MaxSize;</span><br><span class="line">    H-&gt;Elenment[<span class="number">0</span>] = <span class="number">-2020</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆申请的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Elenment);     <span class="comment">//先释放堆节点的数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(H);        <span class="comment">//再释放堆节点的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;MaxSize); <span class="comment">//判断最小堆中元素个数size是否等于最大容量MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);  <span class="comment">//判断堆中元素个数是否等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素item插入最小堆H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inset</span><span class="params">(MinHeap H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断堆H是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果H未满，将item放入堆最后一个元素，查看它的父节点，如果它的父节点比它大，将它和它的父节点互换位置循环此过程，直至它的父节点小于它。可能它比所有它的父节点都要小，但是一定会比哨兵大（数组中下标为0的位置），所以一定最后它的下标一定大于哨兵的下标0。这就是哨兵的意义。</span></span><br><span class="line">    H-&gt;Size++;</span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;Size; H-&gt;Elenment[i / <span class="number">2</span>] &gt; item; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        H-&gt;Elenment[i] = H-&gt;Elenment[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最小堆H中最小元素（高优先级）</span></span><br><span class="line"><span class="comment">//将堆根结点元素取出，并将堆元素重新排序</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MinHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = <span class="number">0</span>,child = <span class="number">0</span>;</span><br><span class="line">    ElementType item, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否已经空了</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> H-&gt;Elenment[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆没有空，将根节点返回，最后一个叶子节点放到根节点位置，然后比较它与它的左右子节点中最小节点的大小，如果它比较大，则将它和它的较小的子节点互换位置，重复此过程，直至他比两个子节点都小或者它不在有子节点</span></span><br><span class="line">    item = H-&gt;Elenment[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elenment[H-&gt;Size];</span><br><span class="line">    H-&gt;Size--;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找出左右子结点最小的那个</span></span><br><span class="line">        <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child +<span class="number">1</span>]))&#123;</span><br><span class="line">            child ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">            H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非空的堆</span></span><br><span class="line"><span class="comment">//可以先建一个空堆，再用Insert函数将元素一个一个插入；另一种方法是：将数组复制到堆结点的Element，再进行排序第二种方法时间复杂度更低</span></span><br><span class="line"><span class="comment">//已知一个数组，创建一个由数组元素组成的最小堆</span></span><br><span class="line">MinHeap <span class="title function_">BuildMinHeap</span><span class="params">(ElementType *Element,<span class="type">int</span> Size,<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">    MinHeap H = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, parent = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">    ElementType Temp;</span><br><span class="line"></span><br><span class="line">    H = Create(MaxSize);    <span class="comment">//创建一个空最小堆</span></span><br><span class="line">    <span class="keyword">if</span> (Size &gt; H-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆储存空间不足\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;Size; i++)&#123;</span><br><span class="line">        H-&gt;Elenment[i + <span class="number">1</span>] = Element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Size = Size;</span><br><span class="line">    <span class="comment">//给最小堆排序</span></span><br><span class="line">    <span class="comment">//最后一个节点的父节点的左右指针都指向一个堆，将最后一个节点的父节点和它的两个子节点排序（方法类似与删除节点的操作），使得最后一个节点、其父节点和其兄弟节点形成一个堆。循环操作，从最后一个节点的父节点往上依次执行这个操作，最后使得整个树都是一个堆。</span></span><br><span class="line">    <span class="keyword">for</span> (parent = H-&gt;Size/<span class="number">2</span>; parent &gt;= <span class="number">1</span>; parent--)&#123;</span><br><span class="line">        Temp = H-&gt;Elenment[parent];</span><br><span class="line">        <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果左右子树都存在，将child作为两者较小者的下标</span></span><br><span class="line">            <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child + <span class="number">1</span>]))&#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较parent和child分别指向的结点的大小，parent较大则互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(Temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">                H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H-&gt;Elenment[parent] = Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heapsort是利用堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值总小于（或大于）它的父结点。它有两种方法来排序：</p><ol><li>大顶堆：每个结点的值都大于或等于其他子结点的值，在堆排序中可用于升序排序。（因为其中每一次排序都会先将堆顶的元素交换到后面）</li><li>小顶堆：每个结点的值都小于或等于其他子结点的值，在堆排序中可用于降序排序。</li></ol><p>堆排序的平均时间复杂度是O（nlogn）</p><h4 id="堆排序操作与实现"><a href="#堆排序操作与实现" class="headerlink" title="堆排序操作与实现"></a>堆排序操作与实现</h4><ol><li>创建一个堆；</li><li>把堆首与堆尾互换；</li><li>把堆的尺寸缩小1，并调用heapify（堆化）将堆重新调整好；</li><li>重复步骤2、3，直到堆的尺寸为1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="comment">//建立父结点指标和子结点指标</span></span><br><span class="line">    <span class="type">int</span> parent = start;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;    <span class="comment">//子结点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])     <span class="comment">//选择两个子结点中较大的</span></span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &gt; arr[child])     <span class="comment">//如果父结点较大，则表示调整完毕，直接跳出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则交换父子结点内容，再继续子结点和孙结点比较</span></span><br><span class="line">            swap(&amp;arr[parent],&amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_dort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        max_heapify(arr, i ,len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位交换，再重新调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//因为除了交换的两个元素，其他已经堆化好了，所以从上往下只经过一条路径即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>（可以自行构造最大堆或最小堆，加深对堆的认识）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            maxheap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxheap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆实现（只需k个元素在堆里）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            swim(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                sink(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    bool <span class="title function_">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; priorityThan(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; priorityThan(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (priorityThan(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="692-前k个高频单词"><a href="#692-前k个高频单词" class="headerlink" title="692.前k个高频单词"></a>692.前k个高频单词</h3><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小根优先队列。</span></span><br><span class="line"><span class="comment">//将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 kk 个元素就是前 kk 个出现次数最多的单词。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用哈希表存储字符串和出现次数</span></span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个PriorityQueue对象：将key-value转为entry对象，放入优先队列（堆）中，（自定义）排序（构造最小堆）</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; entry1, Map.Entry&lt;String, Integer&gt; entry2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();<span class="comment">//注意这里 entry2.compareTo(entry1) 中entry1与entry2在数组中的位置，entry2表示后加进来的元素，entry1表示原来的元素.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将哈希表中的key-value依次放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;    <span class="comment">//大小超过k后，去掉堆顶元素（去掉最小值，因为题目要求最大的k个）</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ret.add(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 + 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            hash.put(s, hash.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一组value变为一个entry对象存入list数组</span></span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hash.get(word1).equals(hash.get(word2)) ? word1.compareTo(word2) : hash.get(word2) - hash.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>G（ V , E ）：图由顶点集合V（G）和边集合E（G）构成；</p><p><strong>端点：</strong></p><p>无向图：一条边（i，j） ，它的顶点 i 和 j 叫<strong>端点</strong>，它们互为<strong>邻接点</strong>；</p><p>有向图：一条边&lt; i , j &gt;  ，它的顶点 i 为 起始端点 （起点），j 为终止端点 （终点），它们互为邻接点；</p><p><strong>度</strong>：</p><p>以某点为端点的 边的数量 叫该顶点的<strong>度</strong></p><p>入度：进入该点的边数；</p><p>出度：从该点出发的边数</p><p><strong>完全图：</strong></p><p>完全无向图：n( n - 1 ) &#x2F; 2 条边</p><p>完全有向图：n( n - 1) 条边</p><p>当一个图接近完全图时，称为<strong>稠密图</strong>，反之，则为<strong>稀疏图</strong>；</p><p><strong>路径：</strong></p><p>路径长度：一条路径上经过的边的数目；</p><p>简单路径：除开始点和结束点可以相同，其它顶点均不同；</p><p>环&#x2F;回路：一条路径上开始点和结束点为同一顶点；</p><p><strong>连通：</strong>指从 i 到 j 有路径，则 i 和 j 连通；</p><p>连通图：无向图中任意两点连通；</p><p>强连通图：有向图中任意两点连通；</p><p>连通分量：指无向图G中的极大连通子图；</p><p>强连通分量：指有向图G中的极大连通子图；</p><p>（强连通图的连通分量只有一个，非连通图有多个连通分量）（强连通图也一样）</p><p><strong>权：</strong>边上附加的一个数值，可以表示从一个顶点到另一个顶点的距离或代价；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问：</span><br><span class="line">设有一个图G=（V，E），取V的子集V&#x27;，E的子集E&#x27;。那么，（V&#x27;，E）一定是G的子图吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果对顶点的子集和边的子集不加限定的话，(V&#x27;,E&#x27;)不一定构成一个图。</span><br><span class="line">假如边集对应的顶点包含在所取的顶点集中，则(V&#x27;,E&#x27;)构成G的子图</span><br><span class="line">如果所取的顶点集不能包含s取的边集所对应的所有顶点，则(V&#x27;,E&#x27;)不构成G的子图。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 存储类型：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809164.png" alt="image-20211227214212034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define MAXV &lt;最大顶点个数&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 顶点 类型    </span></span><br><span class="line">typedef struct&#123;</span><br><span class="line"><span class="type">int</span> no;<span class="comment">//顶点编号</span></span><br><span class="line">InfoType info;<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接矩阵 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接表 存储类型：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809277.png" alt="image-20211227214032490"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 边节点 类型</span></span><br><span class="line">typedef struct ANode&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边的终点编号</span></span><br><span class="line">    struct ANode *next;<span class="comment">//指向下一条边</span></span><br><span class="line">    InfoType info;<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接表头节点 类型</span></span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    vertex data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstArc;<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 邻接表 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VNode adjList[MAXV];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 和 邻接表 对比：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809762.png" alt="image-20211227214112779"></p><p><strong>十字链表（有向图）</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809325.png" alt="image-20211227214400091"></p><p>找顶点出边： 顺着绿色线找</p><p>找顶点入边：顺着橙色线找</p><hr><p><strong>邻接多重表（无向图）</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809819.png" alt="image-20211227214717843"></p><hr><p><strong>四种存储方式 对比</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201809656.png" alt="image-20211227214851706"></p><h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createAdj</span><span class="params">(AdjGraph *G, <span class="type">int</span> a[MAXV][MAXV], <span class="type">int</span> n, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;      <span class="comment">//所有头节点的指针域赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; a[i][j] != INF) &#123;        <span class="comment">//这条边存在</span></span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;                  <span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = a[i][j];            <span class="comment">//存放 权</span></span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;   <span class="comment">//头插法插入节点</span></span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">displayAdj</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;</span><br><span class="line">        printf(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        pre = G-&gt;adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//释放第i个单链表的所有节点</span></span><br><span class="line">                free(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(G);    <span class="comment">//释放头节点数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵g 转化成 邻接表G （时间复杂度：O(n^2)）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;</span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将邻接表G转换成邻接矩阵g</span></span><br><span class="line"><span class="comment">//时间复杂度：无向图为O(n+2e)，有向图为O(n+e)，e为边数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)<span class="comment">//扫描所有的单链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;<span class="comment">//p指向第i个单链表的首结点while(p！=NULL)//扫描第i个单链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        g.n = G-&gt;n;</span><br><span class="line">        g.e = G-&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索: O(n+e)</span></span><br><span class="line"><span class="comment">//用栈 或 递归</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXV; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    p = G-&gt;adjList[v].firstArc;</span><br><span class="line">    <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">        w = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索: O(n+e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">//定义环形队列指针</span></span><br><span class="line">    IntiQueue(qu);      <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visit[MAXV];    <span class="comment">//顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%2d&quot;</span>, v); <span class="comment">//输出被访问的顶点 编号</span></span><br><span class="line">    visit[v] = <span class="number">1</span>;   <span class="comment">//此点 已访问</span></span><br><span class="line">    EnQueue(qu, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(qu))&#123;</span><br><span class="line">        DeQuenu(qu, w);     <span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjList[w].firstArc; <span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//查找w的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(qu, p-&gt;adjvex);<span class="comment">//该点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;<span class="comment">//找下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个<strong>连通图的生成树</strong>是一个<strong>极小连通子图</strong>，它含有图中<strong>全部n个顶点</strong>和构成一棵树的（<strong>n - 1</strong> ）条边。</p><p>遍历方法得到生成树：深度优先生成树，广度~~树</p><p>（所以一个连通图的生成树不一定唯一）</p><p><strong>最小生成树</strong></p><p>对 带权连通图G （权 均为大于0的实数），其权值之和最小的生成树 即 图的最小生成树。</p><h4 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a><strong>普里姆(prim)算法</strong></h4><p>（从顶点 考虑）</p><ol><li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li><li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li><li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li><li>重复步骤2，3，知道V-S为空集</li></ol><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201810815.png" style="zoom: 50%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201810813.png" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MAXV];<span class="comment">//lowcost存储到未标顶点的最小权值</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> closest[MAXV], i, j, k;<span class="comment">//closest存储最小权值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;         <span class="comment">//赋初值</span></span><br><span class="line">        lowcost[i] = g.edges[v][i];</span><br><span class="line">        closest[i] = v;<span class="comment">//此时生成树只有一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g.n; i++) &#123;     <span class="comment">//输出（n - 1）条边</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//在( V - U )中找出离U最近的顶点k</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;      <span class="comment">//k记录最近的顶点编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;     <span class="comment">//标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)        <span class="comment">//修改数组lowcost和cloest</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];<span class="comment">//更新S和V-S之间最小权值</span></span><br><span class="line">                closest[j] = k;<span class="comment">//最小权值对应的 在Sz</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="克鲁斯卡尔（kruskal-算法"><a href="#克鲁斯卡尔（kruskal-算法" class="headerlink" title="克鲁斯卡尔（kruskal)算法"></a><strong>克鲁斯卡尔（kruskal)算法</strong></h4><p>（从边 考虑）</p><ol><li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li><li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li><li>直到图中所有的顶点都在同一个顶点集为止</li></ol><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201810581.png" style="zoom: 80%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201810936.png" style="zoom: 67%;" /><p>思路：连通图的边按照权值从小到大进行排列；依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201811175.png" alt="image-20211227204922551"></p><h4 id="狄克斯特拉-Dijkstra-算法"><a href="#狄克斯特拉-Dijkstra-算法" class="headerlink" title="狄克斯特拉(Dijkstra)算法"></a><strong>狄克斯特拉(Dijkstra)算法</strong></h4><p>只适用 有向无环图，图中存在负权重、环 时，无法使用狄克斯特拉算法</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201811792.png" style="zoom:67%;" /><p>过程如下:</p><p>从起点开始，起点到其所有邻居的距离2和6是初始值，其他不相邻的节点的距离为无穷大，</p><p>然后从{2,6,无穷大}中找到最小值2,2对应的节点是B，然后从B开始遍历B的所有邻居{A,终点}，计算起点-&gt;B-&gt;A的距离为2+3&#x3D;5，比之前的距离6要小，所以更新A的记录为5，继续计算起点-&gt;B-&gt;终点的距离为2+5&#x3D;7，比之前的距离无穷大要小，所以更新终点的记录为7，至此B的所有相邻节点遍历完毕，故划去B，</p><p>之后继续从{2,5,7}中寻找最小值，由于2对应的B节点已经被划去，所以只要从{5,7}中找最小值，最小值为5，5对应于节点A，然后从A开始遍历A的所有邻居{终点}，计算起点-&gt;A-&gt;终点的距离6，比之前的距离7要小，故更新终点的记录为6，至此A的所有邻居遍历完毕，故划去A，</p><p>最后只剩下终点这个节点，由于终点没有邻居，故图中的所有邻居遍历完毕。至此得出从起点到终点的最短距离是6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//狄克斯特拉(Dijkstra)算法：O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;  <span class="comment">//v为源点</span></span><br><span class="line">    <span class="type">int</span> dist[MAXV], path[MAXV]; <span class="comment">//dist[]存放到某点的最短路径长度，path[]存放最短路径</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];    <span class="comment">//标记顶点是否访问过</span></span><br><span class="line">    <span class="type">int</span> mindis, u;      <span class="comment">//mindis为最短距离，u为新考虑的中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123; <span class="comment">//初始化dist和path</span></span><br><span class="line">        dist[i] = g.edges[v][i];    <span class="comment">//距离初始化，即v点到其余点的距离</span></span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        mindis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)       <span class="comment">//找最小路径长度的顶点u</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//修改未考虑的顶点的距离</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist, path, s, g.n, v); <span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弗洛伊德-Floyd）算法"><a href="#弗洛伊德-Floyd）算法" class="headerlink" title="弗洛伊德(Floyd）算法"></a><strong>弗洛伊德(Floyd）算法</strong></h4><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p><p>矩阵D记录顶点间的最小路径<br>例如D[0q0] [3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；</p><p>矩阵P记录顶点间最小路径中的中转点<br>例如P[0] [3]&#x3D; 1 说明，0 到 3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</p><p>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathmatirx[MAXV][MAXV];<span class="comment">//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2</span></span><br><span class="line"><span class="type">int</span> shortPath[MAXV][MAXV];<span class="comment">//记录顶点间的最小路径值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">short_path_floyd</span><span class="params">(MatGraph G, <span class="type">int</span> P[MAXV][MAXV], <span class="type">int</span> D[MAXV][MAXV])</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, k;</span><br><span class="line">    <span class="comment">//初始化floyd算法的两个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            D[v][w] = G.edges[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是弗洛伊德算法的核心部分</span></span><br><span class="line">    <span class="comment">//k为中间点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.n; k++) &#123;</span><br><span class="line">        <span class="comment">//v为起点</span></span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">            <span class="comment">//w为终点</span></span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; (D[v][k] + D[k][w])) &#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径</span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的D矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的P矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//求 0 到 3的最小路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;path: %d&quot;</span>, v);<span class="comment">//打印起点</span></span><br><span class="line">    <span class="keyword">while</span> (k != w) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>, k);<span class="comment">//打印中间点</span></span><br><span class="line">        k = P[k][w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p><blockquote><p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p></blockquote><p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现<code>一次</code>。</li><li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p><p><strong>代码思想为：</strong></p><p>新建node类，包含节点数值和它的指向；</p><p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p><p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p><p>重复上述操作，直到栈为空。</p><h3 id="210-课程表"><a href="#210-课程表" class="headerlink" title="210.课程表"></a>210.课程表</h3><p>现在你总共有 <strong>numCourses</strong> 门课需要选，记为 0 到 numCourses - 1。给你一个数组 <strong>prerequisites</strong> ，其中 <strong>prerequisites[i] &#x3D; [ai, bi]</strong> ，表示在选修课程 ai 前 必须 先选修 bi 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示：[<span class="number">0</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组。</p><p><strong>题解：</strong></p><p>本题是一道经典的「拓扑排序」问题。</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A 的前面。</p></li></ul><p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。</p><p><strong>方法一，深度优先搜索</strong></p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)(u,v) 之前的拓扑关系，所以不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: **O(n+m)**，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: **O(n+m)**。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n)的空间存储节点状态、最终答案等。</p></li></ul><p><strong>方法二：广度优先搜索</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/sort.png" alt="img"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称为缩小增量（递减增量）算法，是<strong>插入排序的改进</strong>。</p><p>希尔排序需要一个增量序列（增量会递减）,一般用len&#x2F;2，如：len为11，则增量分别为5，2，1，进行三次循环。</p><p>每次循环排序只排 间隔 为增量值的数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;      <span class="comment">//i为增量,初始化为len/2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;       <span class="comment">//j用于每次更改增量后遍历一次数组</span></span><br><span class="line">                <span class="type">int</span> k;          <span class="comment">//k用于对第j个元素进行插入排序，比较的是前面间隔为i的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                <span class="keyword">for</span> (k = j; k &gt;= i &amp;&amp; temp &lt; nums[k - i]; k -= i) &#123;</span><br><span class="line">                    nums[k] = nums[k - i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ShellSort</span>().shellSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数据不断分半，直到只剩下一个元素，然后从以分半的两段数据，逐个选出最小的元素移入临时数组的末尾。（归并排序需要用到临时数组）</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/Merge-sort-example-300px.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[],<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> l_pos = left;</span><br><span class="line">    <span class="comment">//标记右半曲第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//临时变量元素的下标</span></span><br><span class="line">    <span class="type">int</span> pos = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp;r_pos &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos])     <span class="comment">//左半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[l_pos++];</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//右半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l_pos &lt;= mid)&#123;       <span class="comment">//合并左半区剩余元素（右半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[l_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r_pos &lt;= right)&#123;      <span class="comment">//合并右半区剩余元素（左半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将临时数组中合并后的元素复制到原来的数组</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        arr[left] = tempArr[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//如果只有一个元素，那么不需要继续划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归划分左右半区</span></span><br><span class="line">        msort(arr,tempArr, left, mid);</span><br><span class="line">        msort(arr, tempArr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tempArr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//分配一个辅助数组</span></span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tempArr)&#123;    <span class="comment">//辅助数组分配成功</span></span><br><span class="line">        msort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tempArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: failed to allocate memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在区间中挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行同样操作。直到各个分区只有一个数时为止。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/quickSort.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以第一个元素作为基准</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> i = start, j = end, x = s[start];     <span class="comment">//以第一个元素作为基准，后面用了类似挖坑的写法，临时存储这个元素，遇到第一个需要交换的元素，直接赋值给基准处。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;     <span class="comment">//一边交换后，换另一边比较</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quicksort(s, start, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(s, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> i = start, j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= mid &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        quick_sort_recursive(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>（堆积是一个近似完全二叉树的结构，并同时满足堆积的性质）</p><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>算法步骤：</p><ol><li>创建一个堆</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸减少1，并调用上浮&#x2F;下沉操作，把新的最大值调整到堆首；</li><li>重复步骤2，3，直到堆的尺寸为1；</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/heapSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</p><p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。</p><p>由于<strong>用来计数的数组C的长度取决于待排序数组中数据的范围</strong>（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>算法的步骤如下：</p><ol><li><p>找出待排序的数组中最大和最小的元素</p></li><li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p></li><li><p>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/countingSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，<strong>尽量增大桶的数量</strong></li><li>使用的映射函数能够将输入的 <strong>N 个数据均匀的分配到 K 个桶中</strong></li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</p><p>最慢的情况：当输入的数据被分配到了同一个桶中。</p><p>示例：</p><p>元素分布在桶中：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);  <span class="comment">//桶大小是5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选出最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里的XxxSort根据情况而定</span></span><br><span class="line">            bucket = XxxSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（自动扩容）将元素加入到桶中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>下面三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/radixSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最高位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取位数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> (arr[j] % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>)     <span class="comment">//考虑正负数</span></span><br><span class="line">                    bucket += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bucket = -bucket;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容，并保存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>对磁盘中的数据进行排序。</p><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>最少只需要在内存中开辟2个输入缓冲区和一个输出缓冲区，每次将磁盘的数据块 输入到输入缓冲区，然后按 归并排序的规则，从2个输入缓冲区 每次跳出最小的数 放到输出缓冲区，当有输入缓冲区为空了，应该立刻将和它排好序的下一个数据块放到输入缓冲区中。当输出缓冲区满时，写出外存。</p><p>减少时间开销：进行<strong>K路归并排序</strong>，需要在内存中分配k个输入缓冲区和一个输出缓冲区。</p><blockquote><p>因为读写磁盘时间开销大，所以多几路可以提高效率，但也不能太多，因为需要在内存中开多个缓冲区，且每次比较都要比较这k个缓冲区的最小值</p></blockquote><p>时间开销：读写外存时间+内部排序时间+内部归并时间</p><p>优化：</p><ul><li><strong>增加归并路数k</strong><ul><li>代价1：需要增加相应的输入缓冲区</li><li>代价2：每次从k个归并段总选一个最小值需要（k-1）次比较。——<strong>可用败者树减少关键字比较次数</strong></li></ul></li><li><strong>减少初始归并段数量r</strong><ul><li>若有N个记录，内存工作区可放L个记录，则初始归并段数量 r &#x3D; N &#x2F; L ——<strong>可用 置换-选择排序 减少初始归并段</strong></li></ul></li></ul><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树解决的问题：使用多路平衡归并可減少归并趟数，但是用老土方法从k个归并段选出一个最小&#x2F;最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到 log<del>2</del>k。</p><p>败者树可视为一棵<strong>完全二又树（多了一个在根节点之上的头节点</strong>）。<strong>k个叶结点</strong>分别对应<strong>k个归并段</strong>中当前参加比较的元素，<strong>非叶子结点</strong>用来记忆<strong>左右子树中的“失败者”</strong>，而让胜者往上继续进行比较，一直到根结点。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201812994.png" alt="image-20211227202553354"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201812382.png" alt="image-20211227202243956"></p><h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>设初始待排文件为FI,初始归并段输出文件为FO,内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置換-选择算法的步骤如下：</p><ol><li>从FI输入w个记录到工作区WA</li><li>从WA中选出其中关键字取最小值的记录，记为 MIINIMAX记录。(MIINIMAX指不断选出的最小指中的最大值)</li><li>将 MINIMAX记录输出到FO中去。</li><li>若FI不空，则从FI输入下一个记录到WA中。</li><li>从WA中所有关键字比 MIINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li><li>重复(3)~(5),直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li><li>重复(2)~(6),直至WA为空。由此得到全部初始归并段。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201812678.png" alt="image-20211227203606666"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201813202.png" alt="image-20211227203540414"></p><h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol><li><p>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ ）。<br>(A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</p><blockquote><p>答案：A</p><p>先用指针变量q指向结点A的后继结点B，然后将结点B的值复制到结点A中，最后删除结点B。</p></blockquote></li><li><p>设有n个待排序的记录关键字，则在堆排序中需要（ ）个辅助记录单元。</p><blockquote><p>答案：1个。</p><p>堆排序只需一个辅助空间，用来记录当前操作的二叉树上的根节点的数字，来与其左右孩子节点比较。</p></blockquote></li><li><p>设某二叉树中度数为0的结点数为N0，度数为1的结点数为Nl，度数为2的结点数为N2，则下列等式成立的（ ）。</p><blockquote><p>答案：N<del>0</del> &#x3D; N<del>2</del> + 1</p></blockquote></li><li><p>设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（ ）。</p><blockquote><p>答案：log<del>2</del>n + 1</p></blockquote></li><li><p>1、数据的最小单位是（ A ）。<br>(A) 数据项<br>(B) 数据类型<br>(C) 数据元素<br>(D) 数据变量</p></li><li><p>设一棵m叉树中度数为0的结点数为N0，度数为1的结点数为N1，……，度数为m的结点数为Nm，则N0 &#x3D;（ B ）。<br>(A) Nl+N2+……+Nm<br>(B) <strong>1+N2+2N3+3N4+……+(m-1)Nm</strong><br>(C) N2+2N3+3N4+……+(m-1)Nm<br>(D) 2Nl+3N2+……+(m+1)Nm</p></li><li><p>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个。 </p><blockquote><p>解：6个</p><p>除了根节点外，其他节点均为孩子节点，而孩子节点等于总的分支数，即 孩子节点 &#x3D;  1 * n<del>1</del> + 2 * n<del>2</del>+3 * n<del>3</del> &#x3D; 10；</p><p>所以总节点数 &#x3D; 10 + 1 &#x3D; 11（1是指根节点），度数为0的节点数 &#x3D; 11 - n<del>1</del> - n<del>2</del> - n<del>3</del> &#x3D; 6;</p></blockquote></li><li><p>设顺序表的长度为n，则顺序查找的平均比较次数为（）。</p><blockquote><p>解：（n+1）&#x2F; 2</p><p>若第一个为查找元素，则查找次数为1，。。。。。所以 平均查找次数为 (1+2+3 + ….+ n) &#x2F; n&#x3D; (1+n) &#x2F; 2； </p></blockquote></li><li></li></ol><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol><li><p>通常从四个方面评价算法的质量：<u>正确性、易读性、强壮性、高效性</u>。</p></li><li><p>数据结构从逻辑上划分为三种基本类型：线性结构，树型结构，图型结构。</p></li><li><p>用链表存储二叉树，则有n个节点的二叉树共有 2n 个指针域，其中 n-1 个存放了地址，剩下的是空指针（n+1个）。</p></li><li><p>AOV网是一种 <u>有向无回路</u> 的图。</p></li><li><p>对于具有n个顶点和e条边的有向图和无向图，其对应的邻接表中，所含边节点分别有 e 和 2e 个。</p></li><li><p>在一个具有n个顶点的无向完全图中，包含有 n(n-1)&#x2F;2 条边，有n个顶点的有向完全图中，包含有 n(n-1) 条边。</p></li><li><p>设某二叉树中度数为0的节点数为 N，度数为1的节点数为 M，可得该二叉树中度数为2的节点数为 <u>N - 1</u> ，。</p></li><li><p>数据的物理结构主要包括 顺序存储结构 和 链式存储结构。</p></li><li><p>设满二叉树的深度为k， 则该树的节点数为 2^k^ - 1； 若用二叉链表作为二叉树的存储结构，设该树有 n 个节点，则一共有 n + 1个空指针域。</p></li><li><p>一个序列，经过栈的作用可以得到 C^n^<del>2n</del>&#x2F; (n+1) 中不同的输出序列。（卡特兰数）</p></li></ol><blockquote><p>如：序列有3个数，则有5中不同的输出序列。</p></blockquote><ol start="11"><li><p>设哈夫曼树有n个节点，则该树有 0 个度数为1的节点。</p></li><li><p>设有n个结点的完全二叉树，如果按照从自上到下、从左到右从1开始顺序编号，则第 i 个结点的双亲结点编号为 i &#x2F; 2 ;  右孩子结点的编号为 2i + 1。</p></li><li><p>设一组初始记录关键字为(72，73，71，23，94，16，5)，则以记录关键字72为基准的一趟快速排序结果为 </p><blockquote><p>答案：(5，16，71，23，72，94，73)</p><p>两个指针，从左开始，和从右开始，先从右开始选第一个遇到的小于基准的数，和基准数换位；换 从左开始，遇到的第一个大于基准的数，和基准换位；再从右继续……循环，直至小于基准的在左边，大于基准的在右边。</p></blockquote></li><li><p>在二叉排序树中插入一个结点的时间复杂度为 O(n)，如果该排序树即不平衡，需要遍历n个节点，如果该树很平衡，则只需log<del>2</del>n。</p></li><li><p>设初始记录关键字序列为(K1，K2，…，Kn)，则用筛选法思想建堆必须从第 <em><strong>n&#x2F;2</strong></em> 个元素开始进行筛选。</p></li><li><p>设哈夫曼树中共有99个结点，则该树中有<u>50</u> 个叶子结点；若采用二叉链表作为存储结构，则该树中有_<u>100</u>_个空指针。</p></li><li><p>设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储______m-1个队列元素；当前实际存储_____(R - F + M) % M_个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。</p></li><li><p>设顺序线性表中有n个数据元素，则第i个位置上插入一个数据元素需要移动表中 <em><strong><u>n-i+1</u></strong></em> 个数据元素；删除第i个位置上的数据元素需要移动表中 <u>n-i</u> 个元素。</p></li><li><p>根据二叉树的<u>先序和中序</u>遍历、或<u>中序和后序</u>遍历，可以唯一确定二叉树的形状。</p></li><li><p>筛选法建初始堆必须从第 n &#x2F; 2 个元素开始进行筛选。</p></li><li><p>快速排序在序列基本有序时为 O(n^2^)，在序列基本无序时为 O(nlog<del>2</del>n)。</p></li><li><p>设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有 <u>n(m-1)+1</u> 个空指针域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快捷键</title>
      <link href="/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
      <url>/Notes/2022/04/14/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Win-10-快捷键"><a href="#Win-10-快捷键" class="headerlink" title="Win 10 快捷键"></a>Win 10 快捷键</h1><p>win + shift + s  截图</p><h1 id="fvimium快捷键"><a href="#fvimium快捷键" class="headerlink" title="fvimium快捷键"></a>fvimium快捷键</h1><h3 id="页面操作"><a href="#页面操作" class="headerlink" title="页面操作"></a>页面操作</h3><p>j: 向下移动。<br>k：向上移动。（不明白默认的<c-y>表示是啥用法，使用了c-y这三个键没有效果）<br>h：向左移动。<br>l：向右移动。<br>zH：一直移动到左部。<br>zL:一直移动到右部。<br>gg：跳转到页面的顶部。<br>G：跳转到页面的底部。<br>d：向下翻页（相当于PageDown被按下了）<br>u：向上翻页（相当于PageUp被按下了）<br>r：重新载入该页（相当于F5刷新页面）<br>gs：查看页面源代码<br>yy：拷贝当前页面的URL到剪贴板<br>yf：拷贝某一个URL到剪贴板（实际上是相当于输入了f，然后出现很多编码的URL，选择某个之后，相当于拷贝了某个，因为一个页面中可能有很多超链接）<br>gu：跳转到父页面（比如<a href="http://www.douban.com/group/vim/%EF%BC%8C%E8%BE%93%E5%85%A5%E5%90%8E%E8%B7%B3%E8%BD%AC%E5%88%B0%E7%88%B6%E9%A1%B5%E9%9D%A2%E5%8D%B3http://www.douban.com/group/%EF%BC%8C%E6%89%80%E4%BB%A5%E4%B8%8D%E5%90%8C%E4%BA%8EH%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%98%AF%E5%9B%9E%E5%88%B0%E4%B8%8A%E4%B8%AA%E5%8E%86%E5%8F%B2%E9%A1%B5%E9%9D%A2%EF%BC%89">http://www.douban.com/group/vim/，输入后跳转到父页面即http://www.douban.com/group/，所以不同于H的快捷键是回到上个历史页面）</a></p><p>i：输入模式（如果发现命令不起作用，可能是进入输入模式了，此时按Esc回到命令模式）<br>gi：将焦点集中到第一个输入框（输入gNi则焦点集中到第N个输入框）<br>f：在当前的页面打开一个新的链接。<br>F：在新的页面打开一个新的链接。<br><a-f>:在当前页面打开多个链接（没感觉使用到了多个标签，不过表示的是输入af）<br>b：在当前页打开一个书签。（输入部分网址会自动进行搜索）<br>B：在新的标签页打开一个书签<br>gf：循环到当前页面的下一个框层（可能跟页面制作有关，目前没用到）</p><h3 id="查找模式：（和Vim相似）"><a href="#查找模式：（和Vim相似）" class="headerlink" title="查找模式：（和Vim相似）"></a>查找模式：（和Vim相似）</h3><p>&#x2F; : 查找<br>n: 向下查找匹配内容<br>N：向上查找匹配内容</p><h3 id="导航历史："><a href="#导航历史：" class="headerlink" title="导航历史："></a>导航历史：</h3><p>H：回退上一个历史页面（相当于浏览器中的向左箭头）<br>L：回到下一个历史页面（相当于浏览器的向右箭头）</p><h3 id="标签页操作："><a href="#标签页操作：" class="headerlink" title="标签页操作："></a>标签页操作：</h3><p>K，gt：跳转到右边的一个标签页<br>J，gT：跳转到左边的一个标签页<br>t：创建一个新的标签页<br>x：关闭当前的标签页<br>X：恢复刚刚关闭的标签页、<br>？：显示命令的帮助提示（再按一次关闭）<br>(红色为常用的命令)</p><p>另外，在当前的标签页直接输入一个新的网址，按F6就OK了。</p><h1 id="VS快捷键"><a href="#VS快捷键" class="headerlink" title="VS快捷键"></a>VS快捷键</h1><h1 id="CLion"><a href="#CLion" class="headerlink" title="CLion"></a>CLion</h1><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>CTRL+N  查找类</p><p>CIRL+B  找变量的来源</p><p>CTRL+G  定位行</p><p>CTRL+F  在当前窗口查找文本</p><p>CTRL+R  在 当前窗口替换文本</p><p>ALT+SHIFT+C 查找修改的文件</p><p>ALT+SHIFT+C 查找修改的文件</p><p>CTRL+E  最 近打开的文件</p><p>F4  查找变量来源</p><p>CTRL+ALT+F7 选 中的字符 查找工程出现的地方</p><h3 id="码字"><a href="#码字" class="headerlink" title="码字"></a>码字</h3><p>CTRL+ALT+L 格式化代码</p><p>ALT+SHIFT+C 最近更改的代码</p><p>CTRL+F  选中的文字,高亮显示</p><p>SHIFT+F2 高亮错误或警告快速定位</p><p>CTRL+&#x2F;  注释&#x2F;&#x2F; </p><p>CTRL+SHIFT+&#x2F; 注释&#x2F;<em>…</em>&#x2F;</p><p>CTRL+W  选中代码，连续按会 有其他效果</p><p>CTRL+B  快速打开光标处的类或方法</p><p>ALT+ ←&#x2F;→ 切换代码视图</p><p>CTRL+ALT ←&#x2F;→ 返回上次编辑的位置</p><p>ALT+ ↑&#x2F;↓ 在方法间快速移动定位</p><p>SHIFT+F6 重构-重命名</p><p>CTRL+H  显 示类结构图</p><p>CTRL+Q  显示注释文档</p><p>ALT+1  快速打开或隐藏工程面板</p><p>CTRL+SHIFT+UP&#x2F;DOWN 代码 向上&#x2F;下移动。</p><p>CTRL+UP&#x2F;DOWN 光标跳转到第一行或最后一行下</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试实习</title>
      <link href="/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E5%AE%9E%E4%B9%A0/"/>
      <url>/Notes/2022/04/14/%E9%9D%A2%E8%AF%95%E5%AE%9E%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>四要素：</p><p>简历，面经，知己知彼，录音设备</p><ol><li><p>简历：</p><p>（不会的东西不要写，趋利避害，自己框个考试范围；可以自己先维护一份理想中的简历，并面向简历去学习）</p><p>（跳槽相关，准备一份没有期望薪资的 简历，给技术面试官）</p></li><li><p>面经：</p></li><li><p>知己知彼：了解公司主要业务，主打产品，公司发展历程，准备一个跟公司业务相关的问题</p></li><li><p>录音：弄懂面试中不懂的问题，吸取经验；可以发现一些不易察觉的问题，如表达方式，用词习惯，语速，音量（沟通能力，表达能力在工作中可能比技术更重要）</p></li><li><p>自我介绍环节：尽量亲和</p><p>自我介绍三要素：秀优势（避免面试官忽略你的优势），套近乎（将收集到的公司情报用两三句话组织一下，自然点），摆技术（擅长的，如果能和面试官聊起来，成功率会上升，同时将自己不会的问题引导到自己较擅长的）</p></li><li><p>问完技术后，可能会问项目（能简单但详细阐明项目的主要业务，自己觉的项目亮点在哪，遇到什么问题，如何解决，学到什么，项目细节也要注意</p></li><li><p>hr：职业生涯规划打算，表示自己对当前职业，公司，城市有长久打算。</p></li></ol><p>实习途径</p><ul><li><p>高校就业指导中心</p></li><li><p>实习平台</p><p>app：</p><p>实习僧，刺猬实习，拉勾网，智联招聘，前程无忧</p><p>公众号：</p><p>大学生实习网，校园招，实习僧，TG实习狗，应届生求职网（大企业有自己的校招公众号）</p></li><li><p>企业官网</p></li><li><p>内推</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="一、计算机组成概论"><a href="#一、计算机组成概论" class="headerlink" title="一、计算机组成概论"></a>一、计算机组成概论</h1><h3 id="硬件组成"><a href="#硬件组成" class="headerlink" title="硬件组成"></a>硬件组成</h3><h4 id="早期冯诺依曼机"><a href="#早期冯诺依曼机" class="headerlink" title="早期冯诺依曼机"></a>早期冯诺依曼机</h4><ul><li>由五大部件组成；</li><li>指令和数据以同等地位存储于存储器，可按地址寻访；</li><li>指令和数据用二进制表示；</li><li>指令由操作码和地址码组成；</li><li>提前把程序放到存储器中；</li><li>以运算器为中心；（输入&#x2F;输出设备与存储器之间的数据传送通过运算器完成）</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191722854.png" alt="image-20220107160155158"></p><blockquote><p>在计算机系统中，软件和硬件在逻辑上是等效的。<br>例如：对于乘法运算，可以设计一个专门的硬件电路实现乘法运算，也可以用软件的方式，执行多次加法运算来实现。</p></blockquote><h4 id="现代计算机"><a href="#现代计算机" class="headerlink" title="现代计算机"></a>现代计算机</h4><ul><li>以存储器为中心，CPU &#x3D; 运算器+控制器；</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191722753.png" alt="image-20220107160853468"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733507.png" alt="image-20220107160814200"></p><h2 id="CPU、存储器及工作过程"><a href="#CPU、存储器及工作过程" class="headerlink" title="CPU、存储器及工作过程"></a>CPU、存储器及工作过程</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><ul><li><p><strong>运算器</strong></p><ul><li><p><strong>ALU：算数逻辑单元</strong>（Arithmetic and Logic Unit）(组合逻辑)，通过内部复杂的电路实现算数运算、逻辑运算；</p></li><li><p>MQ：乘商寄存器（Multiple-Quotient Register），在乘除运算时，用于存放操作数或运算结果；</p></li><li><p>ACC：累加寄存器（Accumulator），用于存放操作数，或运算结果；</p></li><li><p>X：通用寄存器（有很多个，X只是指在用其中某一个），用于存放操作数；</p></li><li><p>PSW：程序状态寄存器，存放状态信息和控制信息（Program Status Word）</p></li><li><p>MQ, ACC, X主要存放计算的中间结果：</p><table><thead><tr><th></th><th>加</th><th>减</th><th>乘</th><th>除</th></tr></thead><tbody><tr><td>ACC</td><td>被加数，和</td><td>被减数，差</td><td>乘积高位</td><td>被除数，余数</td></tr><tr><td>MQ</td><td></td><td></td><td>乘数，乘积低位</td><td>商</td></tr><tr><td>X</td><td>加数</td><td>减数</td><td>被乘数</td><td>除数</td></tr></tbody></table></li></ul></li><li><p><strong>控制器</strong></p><ul><li><strong>CU：控制单位</strong>，分析指令，给出控制信号（Control Unit）(时序逻辑)</li><li>IR：指令寄存器，存放当前执行的指令（Instruction Register）</li><li>PC：指令地址，存放下一条指令地址，可以自动加1</li></ul></li></ul><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><ul><li>存储体：数据在存储体内按地址存储；每个地址对应一个存储单位(存储字)</li><li>MAR：地址寄存器</li><li>MDR：数据寄存器</li></ul><p>注：MAR位数反映存储单元的个数，MAR&#x3D;4位：总共有2^4^个存储单位</p><p>MDR位数&#x3D;存储字长，MDR&#x3D;16位：每个存储单元可存放16bit，一个存储字(word)&#x3D;16bit； 易混淆：1个字节(Byte)&#x3D;8bit，1B&#x3D;1个字节，1b&#x3D;1bit</p><h3 id="计算机工作过程—取数指令"><a href="#计算机工作过程—取数指令" class="headerlink" title="计算机工作过程—取数指令"></a>计算机工作过程—取数指令</h3><p>（这里用M表示主存中某存储单元）</p><p>M(MAR)：根据MAR的数据访问存储体中的数据</p><p>(ACR)：取相应寄存器中的数据</p><p>指令：操作码+地址码； </p><p> OP(IR)：取操作码；  Ad(IR)：取地址码</p><p><strong>过程演示：取指令—分析指令—执行指令（指令周期）</strong></p><p>1  <strong>(PC) —&gt; MAR</strong>：将PC(指令地址) 中的指令地址放到MDR(地址寄存器)中；</p><p>2,3  <strong>M(MAR)—&gt;MDR</strong>：根据MAR中的地址，访问存储体中的数据，再将数据放入MDR(数据寄存器)（这里的数据是一条指令）；</p><p>4  <strong>(MDR) —&gt; IR</strong>：将MDR拿到的指令放到 IR(指令寄存器)；（到这里取指令阶段结束）</p><p>5  <strong>OP(IR) —&gt;CU</strong>：从IR中取出操作码，放入CU(控制单元) ，CU会分析指令；（分析指令阶段结束）</p><p>6 <strong>Ad(IR) —&gt; MAR</strong>：从IR中取出地址码，放入MAR；</p><p>7,8  <strong>M(MAR) —&gt;MDR</strong>：根据MAR中的地址，访问存储体中的数据，再将数据放入MDR(数据寄存器)（这里的数据是要进行操作的数据）；</p><p>9  <strong>MDR—&gt;(运算器中的寄存器)</strong> ：将MDR拿到的数据放到运算器中的对应的寄存器中（指令执行阶段结束）</p><p>注：CPU<strong>区分MDR中取出的是指令还是数据的依据：指令周期的不同阶段</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733007.png" alt="image-20211121101940553"></p><h2 id="计算机的层次结构"><a href="#计算机的层次结构" class="headerlink" title="计算机的层次结构"></a>计算机的层次结构</h2><p>从高到低依次为：</p><ul><li>软件<ul><li>虚拟机器M4（高级语言机器）：用编译程序翻译成汇编语言程序</li><li>虚拟机器M3（汇编语言机器）：用汇编程序翻译成机器语言程序</li><li>虚拟机器M2（操作系统机器）：向上提供“广义指令”（即系统调用）</li></ul></li><li>硬件<ul><li>传统机器M1（机器语言机器）：执行二进制机器指令</li><li>微程序机器M0（微指令系统）：用硬件直接执行微指令</li></ul></li></ul><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>存储器&#x3D;存储体+MAR+MDR</p><p>其中MAR位数反映存储单元的个数（最多存多少个），MDR位数&#x3D;存储字长&#x3D;每个存储单元的大小</p><p><strong>总容量 &#x3D; 存储单位个数 * 存储字长(bit)</strong></p><p>例：MAR为32位，MDR为8位，则总容量 &#x3D; 2^32^ * 8 bit &#x3D; 4GB</p><hr><h4 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h4><p><strong>CPU时钟周期</strong>：又称震荡周期，是计算机中最基本的，最小的时间单位。在一个时钟周期内，CPU仅能完成一个最基本的动作。单位：微秒、纳秒</p><p><strong>CPU主频（时钟频率）</strong>：1 &#x2F; CPU时钟周期， 单位：赫兹，Hz</p><p><strong>CPI</strong>（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数。不同指令或相同指令的CPI都可能不同</p><p><strong>执行一条指令的耗时</strong> &#x3D; CPI * CPU时钟周期</p><p><strong>CPU执行时间</strong> &#x3D; CPU时钟周期数 &#x2F; 主频 &#x3D; （指令条数 * CPI）&#x2F; 主频</p><p><strong>IPS</strong>（Instructions Per Second）：每秒执行多少条指令 （KIPS, MIPS….）</p><p><strong>IPS &#x3D; 主频 &#x2F; 平均CPI</strong></p><p><strong>FLOPS</strong>（Floating-point Operations Per Second）：每秒执行多少次浮点数运算（KFLOPS, MFLOPS, GFLOPS, TFLOPS….）</p><hr><h4 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h4><p>数据通路带宽：数据总线一次所能并行传递信息的位数；</p><p>吞吐量：系统在单位时间内处理请求的数量（主要取决于主存的存取周期）；</p><p>响应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得所需结果的等待时间；</p><hr><h1 id="二、数据的表示和运算"><a href="#二、数据的表示和运算" class="headerlink" title="二、数据的表示和运算"></a>二、数据的表示和运算</h1><h2 id="进位计数制"><a href="#进位计数制" class="headerlink" title="进位计数制"></a>进位计数制</h2><p>r进制：使用<strong>符号</strong> 和 <strong>符号所在的位置</strong>也反映权重。</p><ul><li>基数：每个位所能使用的不同符号个数，r进制的基数为r；</li></ul><blockquote><p>计算机采用二进制：</p><ul><li>数值的每个位，可以使用具有两个稳定状态的物理器件表示；</li><li>0，1正好对应逻辑值 真&#x2F;假，方便实现逻辑运算；</li><li>可利用逻辑门电路实现算术运算；</li></ul></blockquote><p>进制转换：</p><ul><li><p>r进制 到 十进制：</p><p>r 进制的数值 &#x3D; 各数码位与位权的乘积之和。</p></li><li><p>二进制 到 八进制：</p><p>每3个二进制位 对应一个八进制位；</p></li><li><p>二进制 到 十六进制：</p><p>每4个二进制位 对应一个八进制位；</p></li><li><p>十进制 到 r进制：</p><p>整数部分：除基取余法（先取得的“余”是整数的低位）</p><p>小数部分：乘基取整法（先取得的“整”是小数的高位）</p></li></ul><hr><p>真值：符合人类习惯，实际的带正负号的数字；</p><p>机器数：数字实际存到机器里的形式，正负号需要被“数字化”；</p><h2 id="BCD码"><a href="#BCD码" class="headerlink" title="BCD码"></a>BCD码</h2><h3 id="8421码"><a href="#8421码" class="headerlink" title="8421码"></a>8421码</h3><p>用二进制编码的十进制（Binary-Coded Decimal），使用 四位二进制 表示 十进制的 0 ~ 9，冗余6位，</p><p>BCD码的加法： 如果加法运算后，得到的十进制数为10 ~ 18，不在映射表内，即超过0~9的范围，则再加上6，即二进制的0110，则二进制数一定会前进一位，之后在前补3个0，则可以得到二个 四位二进制表示的数。</p><p>例：5 + 8 &#x3D; 13 —&gt; 0101 + 1000 &#x3D; 1101，超出范围，则再加6，得到 1 0011，在前面补0得到 0001 0011，即13</p><p>除了8421码，还有余3码，2421码也是用二进制编码表示十进制</p><h2 id="字符与字符串"><a href="#字符与字符串" class="headerlink" title="字符与字符串"></a>字符与字符串</h2><p>在<strong>ASCII码</strong>中， <strong>32~126为可印刷字符，其余为控制或通信字符（ASCII共128个）</strong></p><p>数字0~9：48（0011<strong>0000</strong>） ~ 57（0011<strong>1001</strong>）</p><p>大写字母：65（0100<strong>0001</strong>）~ 90（0101<strong>1010</strong>）</p><p>小写字母：97（0110<strong>0001</strong>）~ 122（0111<strong>1010</strong>）</p><p><strong>CB</strong> 2312-80码：汉字+各种符号共7445个</p><ul><li><strong>区位码</strong>：<strong>94个区，每个区94个位置</strong>，如 汉字“啊”的区位码：10H01H</li><li><strong>国标码</strong>：在区位码的两个标号上加上<strong>20H</strong>，防止信息交换时，与ASCII码的“控制&#x2F;通信字符”冲突</li><li><strong>汉字内码</strong>：在国标码的两个标号上加上<strong>80H</strong>，即加上128，保证高位为1，与ASCII区分</li></ul><p>输入：<strong>输入编码</strong>； </p><p>输出：<strong>汉字字形码</strong></p><p><strong>字符串存储</strong></p><p>字母用一个字节存储，<strong>汉字用两个字节</strong>存储，</p><p>汉字的存储又分为大端模式和小端模式，<strong>大端模式是将数据的最高有效字节存放在低地址单元中，小端模式放在高地址单元中</strong></p><h2 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h2><h3 id="奇偶校验码"><a href="#奇偶校验码" class="headerlink" title="奇偶校验码"></a>奇偶校验码</h3><p>奇校验码：整个校验码（有效信息位和校验位）中的“1”的个数为奇数；</p><p>偶校验码：整个校验码（有效信息位和校验位）中的“1”的个数为偶数；</p><p>奇偶校验码分为<strong>1位的奇偶校验位</strong>和n位的有效信息位，奇偶校验位是为了让“1”的个数维持想要的奇数或偶数。</p><p>偶校验位的硬件实现：<strong>各信息进行异或（模2加）运算，得到的结果即为偶校验位</strong></p><p>进行<strong>偶校验</strong>：<strong>所有位进行异或，如果结果为1说明出错</strong></p><p>偶校验只能发现奇数位错误，且无法确定哪一位出错。</p><h3 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h3><p>将信息位分组进行偶校验，即设立多个校验位，可以标注出出错位置</p><p>需要设立多少个校验位？</p><blockquote><p>设信息位有n位，校验位有k位，而k个校验位一共能表示2^k^种状态， 所以 2^k^ - 1 &gt;&#x3D; n + k（减1是因为有一个是正确的状态，没出错）</p></blockquote><p>n与k的关系部分关系表：</p><table><thead><tr><th>n</th><th>1</th><th>2~4</th><th>5~11</th><th>12~26</th><th>27~57</th><th>58~120</th></tr></thead><tbody><tr><td>k</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p>校验位的分布：<strong>校验位 P<del>i</del></strong> 应放在海明位号为 <strong>2^i-1^ 的位置</strong>上，其他位放有效信息。</p><p>求校验位的值：设各信息所在的位数 的二进制表示为x，第一个校验位等于 所有 x 的第一位(最低位)为1的 信息位值 的异或运算 结果；第二个校验位等于 所有 x 的第二位(最低第二位)为1的 信息位值 的异或运算 结果。。。</p><p>纠错：将第 i 个校验位值 和  x 的第i位(最低第 i 位)为1的 信息位值 进行异或运算，如果所有 运算后都得到0，则没有出错，如果有 结果为1 的情况出现，则说明出错，将所有校验位 拼成一个二进制表示，其值就是出错的位数。 </p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733184.png" alt="image-20211118185904877"></p><p>海明码检错能力：1位， 纠错能力 ： 2位，此时海明码没办法区分 是一个bit位出错还是两个bit位出错，为此，需加上全校验位，对全体再进行一次偶校验，才能识别是一位错还是两位错。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733454.png" alt="image-20211118185817499"></p><h3 id="循环冗余校验码-CRC"><a href="#循环冗余校验码-CRC" class="headerlink" title="循环冗余校验码(CRC)"></a>循环冗余校验码(CRC)</h3><p>CRC (Cyclic Redundancy Check)</p><ol><li><p>确定K, R, 生成多项式对应的二进制码</p><p>首先，需要先约定好 生成多项式 G(x) &#x3D; x^n^ + x^n-1^+ ….. + x^0^，</p><p>然后确定 信息位的长度K &#x3D; 信息码的长度， 校验位的长度 R &#x3D; 生成多项式最高次幂n，整个校验码位数&#x3D; K + R；</p><p>根据生成多项式里各项的常数部分，生成对应二进制码</p></li><li><p>移位</p><p>将信息码左移R位，低位补0，</p></li><li><p>相除</p><p>对<strong>移位后的信息码</strong>，用<strong>生成多项式的二进制码</strong> 进行<strong>模2除法</strong>，<strong>产生的余数</strong> 即为校验位信息</p><p>模2除，模2减（异或运算）：</p></li><li><p>检错和纠错</p><p>对接收的数据，用约定好的生成多项式的二进制码 进行模2除，得到余数为R位全为0，说明没有出错；余数不为0，说明出错，余数是多少，就是多少位出错。</p><p>CRC可检测出：所有奇数个错误；所有双比特错误；所有小于等于校验位长度的连续错误</p><p>CRC码中的信息位太多，会使纠错得到的余数无法表示太高位，如果满足2^R^-1&gt;&#x3D;K+R，则CRC可纠正1位错，不过CRC通常用于网络传输，只发挥检错功能（网络传输一次会发送较多bit）</p></li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733238.png" alt="image-20211118190033659"></p><h2 id="定点数表示"><a href="#定点数表示" class="headerlink" title="定点数表示"></a>定点数表示</h2><h3 id="原、补、移码"><a href="#原、补、移码" class="headerlink" title="原、补、移码"></a>原、补、移码</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733031.png" alt="image-20211118190147440"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734022.png" alt="image-20211118190157729"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201437657.png" alt="image-20211118190229297"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204192210113.png" alt="image-20211118190237631"></p><p>补码： </p><ul><li>正数的补码  &#x3D; 原码</li><li>负数的补码 &#x3D; 反码末尾 + 1 （要考虑进位）</li></ul><blockquote><p>补码的正值0 只有一种： [+0]<del>补</del> &#x3D; [-0]<del>补</del> &#x3D;  000000000</p><p>定点整数补码 的表示范围：比原码多表示一个 -2^n^； </p><p>定点小数补码 的表示范围：比原码多表示一个 -1 ； </p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734504.png" alt="image-20211118190244928"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734382.png" alt="image-20211118190252353"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734443.png" alt="image-20211118190302522"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204192214555.png" alt="image-20220419221426272"></p><p><strong>使用补码的意义：让减法操作转变为加法操作，节省硬件成本。</strong>（涉及求模运算的意义）</p><p>因为计算机是固定字长的，所以在进行运算时会舍去溢出的位，这相当于 直接对结果进行了求模运算（%2^n^）。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734109.png" alt="image-20211118190348822"></p><h3 id="符号拓展"><a href="#符号拓展" class="headerlink" title="符号拓展"></a>符号拓展</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734958.png" alt="image-20211118191549313"></p><h2 id="定点数运算"><a href="#定点数运算" class="headerlink" title="定点数运算"></a>定点数运算</h2><h3 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h3><h4 id="算数移位"><a href="#算数移位" class="headerlink" title="算数移位"></a>算数移位</h4><p> <img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734222.png" alt="image-20211118190446667"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734150.png" alt="image-20211118190500971"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734904.png" alt="image-20211118190508649"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734438.png" alt="image-20211118190521365"></p><h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734790.png" alt="image-20211118190549711"></p><h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734286.png" alt="image-20211118190557099"></p><h3 id="加减运算"><a href="#加减运算" class="headerlink" title="加减运算"></a>加减运算</h3><p>补码的加减运算：运算同源码一样，求出结果后再转为原码</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734956.png" alt="image-20211118190803498"></p><p>对于补码的加减运算出现 溢出情况的判断，有三种判断方式：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734873.png" alt="image-20211118191231755"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191734424.png" alt="image-20211118191321945"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191735427.png" alt="image-20211118191330388"></p><h3 id="乘法运算"><a href="#乘法运算" class="headerlink" title="乘法运算"></a>乘法运算</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191735150.png" alt="image-20211118191717510"></p><p>计算机 的乘法运算 可以对比平时 手算乘法时列的竖式公式，其本质是利用r进制的位权。</p><p>计算机实现 <strong>原码</strong>的乘法运算：<strong>先加法，再移位，重复n次</strong>（左移位相当于手算时的错位）</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736943.png" alt="image-20211118192237385"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736326.png" alt="image-20211118192245580"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736434.png" alt="image-20211118192252905"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736419.png" alt="image-20211118192305905"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736449.png" alt="image-20211118192328486"></p><p>补码的乘法运算：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736406.png" alt="image-20211118192428730"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736350.png" alt="image-20211118192540200"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736233.png" alt="image-20211118192547837"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191736060.png" alt="image-20211118192558787"></p><h3 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算"></a>除法运算</h3><p>根据手算除法的过程，计算机 实现原码的除法运算：<strong>看当前位的商为0&#x2F;1，得到余数，余数末尾补0，得到的余数当作新的被除数。</strong></p><p>（<strong>定点小数除法</strong> 规定 <strong>被除数一定要小于除数</strong>，不然结果会大于1，而定点小数无法表示大于1的数）</p><h4 id="原码—恢复余数法"><a href="#原码—恢复余数法" class="headerlink" title="原码—恢复余数法"></a>原码—恢复余数法</h4><p>计算机不会去判断当前被除数和除数谁打谁小，而是直接将当前商位置为1(MQ里操作)，计算得到余数（ 余数 &#x3D; 被除数 + [-|y|]<del>补码</del> ），如果余数为负，说明商为1是错的，所以会将商位置为0，让余数重新加上除数，即让余数恢复为被除数，然后再计算商为0时应得的余数。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201447937.png" alt="image-20211118192659788"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201447575.png" alt="image-20211118193424237"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201448844.png" alt="image-20211118193444434"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201448033.png" alt="image-20211118193453852"></p><h4 id="原码—加减交替法"><a href="#原码—加减交替法" class="headerlink" title="原码—加减交替法"></a>原码—加减交替法</h4><p>恢复余数法中的一些步骤可以合并，根据恢复余数法前后的结果，可以算出：如果商位置1是错的（即得到余数为负），则商位置1，然后让余数左移一位（乘2），再加上|除数|，这样可以直接将错误的余数转化为正确的余数。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201448499.png" alt="image-20211118193510093"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201449141.png" alt="image-20211118194222167"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201449144.png" alt="image-20211118194232160"></p><h4 id="补码—加减交替法"><a href="#补码—加减交替法" class="headerlink" title="补码—加减交替法"></a>补码—加减交替法</h4><p>补码的加减交替法，与原码不同在于：补码除法的<strong>符号位会参与运算</strong>（求补码时不会先求绝对值），数据采用<strong>双符号位</strong>。</p><p>补码除法<strong>求余数</strong>时，余数不会直接等于（被除数 + [-|y|]<del>补码</del> ），而是：<strong>1. 如果被除数和除数同号，则被除数减去除数，2. 如果异号，则被除数加上除数。</strong></p><p>对于<strong>商位是1还是0</strong>：<strong>1. 余数和除数同号，则商为1，然后余数左移一位，减去除数；2. 余数和除数异号，商为0，余数左移一位，加上除数。过程重复n次。</strong></p><p>最后，<strong>末尾商会恒置为1</strong>，这样可以不考虑最后算出的余数是否需要恢复余数，省去额外电路的设计，且这样做<strong>精度误差是不超过 2^-n^</strong> 的。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201449662.png" alt="image-20211118194241590"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201449642.png" alt="image-20211118194251001"></p><h2 id="数据存储-边界对齐"><a href="#数据存储-边界对齐" class="headerlink" title="数据存储|边界对齐"></a>数据存储|边界对齐</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201449610.png" alt="image-20211120184018313"></p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><h3 id="IEEE-754标准"><a href="#IEEE-754标准" class="headerlink" title="IEEE 754标准"></a>IEEE 754标准</h3><p>IEEE读作 i triple e ：triple是三倍的意思</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201450910.png" alt="image-20211120184237269"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201450649.png" alt="image-20211120184326877"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201450721.png" alt="image-20211120184331950"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201450499.png" alt="image-20211120184336345"></p><h3 id="浮点数的加减运算"><a href="#浮点数的加减运算" class="headerlink" title="浮点数的加减运算"></a>浮点数的加减运算</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451797.png" alt="image-20211120184152834"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451300.png" alt="image-20211120184617835"></p><p>强制类型转换</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451482.png" alt="image-20211120184633939"></p><h3 id="ALU大致原理"><a href="#ALU大致原理" class="headerlink" title="ALU大致原理"></a>ALU大致原理</h3><p>电路基础知识</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451045.png" alt="image-20211120184649625"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451463.png" alt="image-20211120184653982"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201451043.png" alt="image-20211120184658348"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452673.png" alt="image-20211120184706787"></p><p>加法器的实现</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452100.png" alt="image-20211120184713453"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452053.png" alt="image-20211120184718342"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452495.png" alt="image-20211120184732882"></p><p>加法器、ALU改进</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452963.png" alt="image-20211120184739339"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452967.png" alt="image-20220111095619918"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201452505.png" alt="image-20220111095547417"></p><h1 id="三、存储系统"><a href="#三、存储系统" class="headerlink" title="三、存储系统"></a>三、存储系统</h1><h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><p>功能：存放二进制信息。</p><p>层次：</p><ul><li>高速缓冲存储器（cache）</li><li>主存储器（主存、内存）</li><li>辅助存储器（辅存、外存）</li></ul><blockquote><p>Cache解决CPU和主存之间速度不匹配的问题，由硬件自动完成；</p><p>辅存解决主存容量不够的问题，需要硬件和操作系统配合完成。</p></blockquote><h3 id="存储器模型"><a href="#存储器模型" class="headerlink" title="存储器模型"></a>存储器模型</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453207.png" alt="image-20211120185413723"></p><ul><li>存储矩阵：由大量相同的位存储单元阵列构成。</li><li>译码驱动：将来自地址总线的地址信号翻译成对应存储单元的选通信号，该信号在读写电路的配合下完成对被选中单元的读&#x2F;操作。</li><li>读写电路：包括读出放大器和写入电路，用来完成读&#x2F;写操作。</li><li>读&#x2F;写控制线：决定芯片进行读&#x2F;写操作。</li><li>片选线：确定哪个存储芯片被选中。可用于容量扩充。</li><li>地址线：是单向输入的，其位数与存储字的个数有关。</li><li>数据线：是双向的，其位数与读出或写入的数据位数有关。</li><li>数据线数和地址线数共同反映存储芯片容量的大小；如地址线10根，数据线8根，则芯片容量-&#x3D;20×8-8K位。</li></ul><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>有多种方式：可按 字节、字、半字、双字 寻址；</p><p>多字节存放方式：</p><ul><li>大端方式：数值的高位放在地址的低位；</li><li>小端方式：数值的低位放在地址的低位；</li></ul><h3 id="随机存取器RAM"><a href="#随机存取器RAM" class="headerlink" title="随机存取器RAM"></a>随机存取器RAM</h3><p><strong>SRAM（Static Random Access Memory ）：静态随机存储器</strong></p><p><strong>DRAM（Dynamic Random Access Memory）：动态随机存取器</strong></p><blockquote><p>两者都是以电信号的形式存储0和1，断点就丢失信息，所以也叫易失性存储器。</p></blockquote><p><strong>SRAM：</strong></p><ul><li>存储信息（0、1）：使用<strong>触发器——双稳态</strong>；</li><li><strong>非破坏性读出</strong>：读——查看触发器状态；写——改变触发器状态；</li><li><strong>不需刷新</strong>：触发器能保持两种稳定的状态；</li><li><strong>同时送行列式地址</strong>；</li><li><strong>运行速度 快</strong></li><li><strong>集成度 低</strong>：6个逻辑元件；</li><li><strong>发热量 大</strong></li><li><strong>存储成本 高</strong></li></ul><p><strong>DRAM：</strong></p><ul><li>存储信息（0、1）：使用<strong>电容——充放电</strong>；</li><li><strong>破坏性读出</strong>：读——连接电容，检测电流变化，读出后需要重新充电；写——给电容充&#x2F;放电</li><li><strong>需刷新</strong>：电容上的电荷只能维持2ms；</li><li><strong>分两次送行列式地址</strong>：地址分成相同位的行列地址，地址线可以复用，线数减半；</li><li><strong>运行速度 慢</strong></li><li><strong>集成度 高</strong>：1或3个逻辑元件；</li><li><strong>发热量 小</strong></li><li><strong>存储成本 低</strong></li></ul><blockquote><p>由于SRAM速度快，成本高，所以常用作Cache；而DRAM常用作主存；</p><p>SDRAM：同步动态随机存储器，是DRAM的发展变形</p></blockquote><hr><hr><p><strong>DRAM的刷新</strong></p><p>刷新周期：一般2ms</p><p>每次刷新：以行为单位，每次刷新一行存储单元</p><blockquote><p>为什么使用行列地址？</p><p>因为如果采用一维模式的话，2^n^个存储单元需要2^n^根选通线；如果使用行列地址，将一个地址分成两半，则每一半地址只需2^n&#x2F;2^根线，一共需要2 * 2^n&#x2F;2^ 根线。</p><p>如：2^8^ &#x3D; 256根选通线，只需2 * 2^4^&#x3D; 32根选通线</p></blockquote><p>如何刷新：有硬件支持，读出一行的信息后重新写入，占用一个读&#x2F;写周期；</p><p>刷新时机：</p><ul><li><p>分散刷新：</p><p>每次读写完都刷新一行，这样系统的存取周期会翻倍。</p></li><li><p>集中刷新：</p><p>在刷新周期内集中安排一段时间用于刷新全部行，这段时间内无法访问存储器，称为访存“死区”。</p></li><li><p>异步刷新：</p><p>在刷新周期内刷新1次即可，即刷新请求在刷新周期内均匀分布，”死区“会被平均分散。</p></li></ul><h3 id="只读存储器ROM"><a href="#只读存储器ROM" class="headerlink" title="只读存储器ROM"></a>只读存储器ROM</h3><p>（Read-Only Memory）</p><blockquote><p>ROM是非易失性存储器</p></blockquote><p>类型：</p><ul><li><p>膜式只读存储器(MROM)：</p><p>存储内容由半导体制造厂按用户提出的要求<br>在芯片的生产过程中直接写入，无法修改。</p></li><li><p>一次可编程只读存储器（PROM）：</p><p>存储内容由用户用专门的设备（编程器）一次性写入，之后无法修改。</p></li><li><p>可擦除可编程只读存储器( EPROM)：</p><p>修改次数有限，写入时间很长；类型有 紫外线擦除（UVEPROM）、电擦除（EEPROM）。</p></li><li><p>闪速存储器（Flash Memory）：</p><p>如U盘，写入速度较快。</p></li><li><p>固态硬盘( Solid State Drives)：</p><p>控制单元 + FLASH芯片</p></li></ul><h2 id="主存与CPU连接"><a href="#主存与CPU连接" class="headerlink" title="主存与CPU连接"></a>主存与CPU连接</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453544.png" alt="image-20220110112634686"></p><p><strong>连接原理：</strong></p><ul><li>主存储器通过数据总线、地址总线和控制总线与CPU连接；</li><li>（数据总线的位数 * 工作频率 ）正比于数据传输速率；</li><li>地址总线的位数决定了可寻址的最大内存空间；</li><li>控制总线（读&#x2F;写）指出总线周期的类型 和 本次输入&#x2F;输出操作完成的时刻；</li></ul><p><strong>主存容量的扩展：</strong></p><p>由于单个存储芯片的容量有限，在字数或字长方面与实际的要求都有差距，因此需要在<strong>字</strong>和<strong>位</strong>两方面进行扩展。</p><ul><li><p><strong>位扩展法</strong></p><p>CPU的数据线数与存储芯片的数据位数不一定相等，此时必须对存储芯片扩位，使其数据位数与CPU的数据线数相等。<br>位扩展的连接方式是将多个存储芯片的地址端、片选端和读写控制端相应并联，数据端分别引出。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453264.png" alt="image-20220110113624661"></p></li><li><p><strong>字扩展法</strong></p><p>字扩展是指增加存储器中字的数量，而位数不变。字扩展将芯片的地址线、数据线、读写控制线相应并联，而由片选信号来区分各芯片的地址范围。</p></li><li><p><strong>字位同时扩展法</strong></p><p>实际上，存储器往往需要同时扩充字和位。字位同时扩展是指既增加存储字的数量，又增加存储字长。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453178.png" alt="image-20220110113930006"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453735.png" alt="image-20220110113939759"></p></li></ul><hr><p><strong>存储芯片的地址分配和片选</strong></p><p>CPU对存储器的访问：先片选 再字选。</p><ol><li>片选：选择存储器芯片；<ul><li>线选法：用除片内寻址外的高位地址线分别接至各个存储芯片的片选。（线路简单，地址不连续，一条线只产生一个选片信号）</li><li><strong>译码片选法</strong>：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号。（电路复杂，地址空间连续，可增加逻辑设计，n条线可产生2^n^个选片信号）</li></ul></li><li>字选：对选中的芯片，依据地址码 进行数据存取；</li></ol><h2 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h2><p>提高CPU访问存储器的速度：</p><ul><li>双端口存储器：空间并行；</li><li>多模块存储器：时间并行。</li></ul><p><strong>双端口RAM：</strong></p><p>双端口RAM是指同一个存储器有左、右两个独立的端口，分别具有两组相互独立的地址线、数据线和读写控制线，允许两个独立的控制器同时异步地访问存储单元。</p><p>注：当两个端口同时对存储器的同一地址进行修改时，可能会发生数据错误或读取错误；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453092.png" alt="image-20220110115750687"></p><p>存取周期：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201453008.png" alt="image-20220111085521860"></p><p><strong>多模块存储器：</strong></p><p>常用的有：单体多字存储器 ，多体低位交叉存储器。</p><ul><li><p>单体多字存储器：</p><p>单体多字系统的特点是存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一存储单元。<br>单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1&#x2F; m 存取周期，CPU向主存取一条指令。显然，这増大了存储器的带宽，提高了单体存储器的工作速度。</p><p>缺点：指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显。</p></li><li><p><strong>多体并行存储器：</strong></p><p>多体并行存储器由多体模块组成。每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路、地址寄存器和数据寄存器。它们既能并行工作，又能交叉工作。<br>多体并行存储器分为 高位交叉编址（顺序方式）和低位交又编址（交又方式）两种。</p><ul><li><p>高位交叉编制：</p><p>高位地址表示体号，低位地址表示体内地址；总是会把低位的体内地址送到由高位体号确定的模块内进行译码。</p><p>访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率。</p><blockquote><p>模块内的地址是连续的，存取方式仍是串行存取，因此这种存储器仍是顺序存储器</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454952.png" alt="image-20220110120657545"></p></li><li><p><strong>低位交叉编制：</strong></p><p>低位地址为体号，高位地址为体内地址。</p><p>低位交叉编址方式下，总是把高位的体内地址送到由低位体号确定的模块内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。</p><p>采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454395.png" alt="image-20220110120837771"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454326.png" alt="image-20220110120848340"></p></li></ul></li></ul><h2 id="高速缓冲存储器Cache"><a href="#高速缓冲存储器Cache" class="headerlink" title="高速缓冲存储器Cache"></a>高速缓冲存储器Cache</h2><p>提高整个存储系统的工作速度。</p><p>程序访问的局部性原理：</p><ul><li><strong>时间局部性</strong>：在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。</li><li><strong>空间局部性</strong>：在最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。</li></ul><p><strong>高速缓冲</strong>技术就是利用程序访问的局部性原理，把<strong>程序中正在使用的部分</strong>存放在一个<strong>高速的、容量较小的 Cache</strong>中，使CPU的访存操作大多数针对 Cache进行，从而大大提高程序的执行速度。</p><hr><hr><p><strong>Cache基本工作原理：</strong></p><p>Cache位于存储器层次结构的顶层，通常由SRAM构成，其基本结构如图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454857.png" alt="image-20220111090254388"></p><p>为了便于交换信息，Cache和主存都被划分为相等的块，Cache块也叫Cache行，每块的长度称为块长（Cache行长）；</p><p>由于Cache的容量远小于主存的容量，因此它只保存主存中最活跃的若干块的副本。</p><ul><li>当CPU发出读请求时，若访存地址在Cache中命中，则将该地址转化为Cache地址，对Cache进行读操作，与主存无关。若Cache未命中，则仍需要访问主存，将该字所在的块一次性从主存调入Cache，若Cache已满，则需要根据某替换算法，将Cache中的某块替换掉。</li><li>当CPU发出写请求时，若 Cache命中，有可能会遇到 Cache与主存中的内容不一致的问题。例如，由于CPU写 Cache，把 Cache某单元中的内容从X修改成了Y，而主存对应单元中的内容仍然是X，没有改变。所以若 Cache命中，需要按照一定的写策略处理，常见的处理方法有全写法和写回法。</li></ul><blockquote><p>数据交换单位：CPU与主存间以字为单位，Cache与主存间以Cache块为单位。</p><p>注：某些计算机也采用同时访问 Cache和主存的方式，若Cach命中，则主存访问终止。</p></blockquote><hr><hr><p><strong>Cache和主存的映射关系</strong></p><p>Cache行中的信息是主存中某个块的副本，地址映射是指把主存地址空间映射到 Cache地址空间，即把存放在主存中的信息按照某种规则装入 Cache.<br>由于 Cache行数比主存块数少得多，因此主存中只有一部分块的信息可放在 Cache中，因此在 Cache中要为每块加一个标记，指明它是主存中哪一块的副本。该标记的内容相当于主存中块的编号。为了说明 Cache行中的信息是否有效，每个 Cache行需要一个有效位。</p><ul><li><p>直接映射</p><p>主存中的每一块只能装入 Cache中的唯一位置。若这个位置已有内容，则产生块冲突，原来的块将无条件地被替换出去（无须使用替换算法）。</p><p>直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的块冲突概率最高，空间利用率最低。</p></li><li><p>全相联映射</p><p>主存中的每一块可以装入 Cache中的任何位置，每行的标记用于指出该行取自主存的哪一块，所以CPU访存时需要与所有 Cache行的标记进行比较。</p><p>全相联映射方式的优点是比较灵活， Cache块的冲突概率低，空间利用率高，命中率也高；缺点是标记的比较速度较慢，实现成本较高，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。</p></li><li><p>组相联映射</p><p>将 Cache空间分成大小相同的组，主存的一个数据块可以装入一组内的任何一个位置，即组间采取直接映射，而组内采取全相联映射。它是对直接映射和全相联映射的一种折中。</p></li></ul><hr><hr><p><strong>Cache块的替换算法</strong></p><ul><li><p>随机算法（RAND）</p></li><li><p>先进先出算法（FIFO）</p></li><li><p>近期最少使用算法（LRU）</p><p>LRU算法对每个 Cache行设置一个计数器，用计数值来记录主存块的使用情况，并根据计数值选择淘汰某个块。</p></li><li><p>最不经常使用算法（LFU）</p></li></ul><hr><hr><p><strong>Cache写策略</strong></p><p>因为 Cache中的内容是主存块副本，当对 Cache中的内容进行更新时，就需选用写操作策略使 Cache内容和主存内容保持一致。此时分两种情况。</p><ul><li><p>对于 Cache写命中( write hit)，有两种处理方法。</p><ul><li><p>全写法（写直通法、wite- through）：</p><p>当CPU对 Cache写命中时，必须把数据同时写入Cache和主存；当某一块需要替换时，不必把这一块写回主存，用新调入的块直接覆盖即可。</p><p>这种方法实现简单，能随时保持主存数据的正确性。缺点是增加了访存次数，降低了 Cache的效率。</p><blockquote><p>写缓冲：为减少全写法直接写入主存的时间损耗，在 Cache和主存之间加一个写缓冲( Write Buffer)。</p><p>CPU同时写数据到 Cache和写缓冲中，写缓冲再控制将内容写入主存。写缓冲是一个FIFO队列，写缓冲可以解决速度不匹配的问题。但若出现频繁写时，会使写缓冲饱和溢出。</p></blockquote></li><li><p>写回法( write-back)：</p><p>当CPU对 Cache写命中时，只修改 Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存。这种方法减少了访存次数，但存在不一致的隐患。采用这种策略时，每个 Cache行必须设置一个标志位（脏位），以反映此块是否被CPU修改过。</p></li></ul></li><li><p>对于 Cache写不命中，也有两种处理方法。</p><ul><li><p>写分配法(wite- allocate)：</p><p>加载主存中的块到 Cache中，然后更新这个Cache块。它试图利用程序的空间局部性，但缺点是每次不命中都需要从主存中读取一块。</p></li><li><p>非写分配法(not- write- allocate)法：</p><p>只写入主存，不进行调块。</p></li></ul></li></ul><blockquote><p>非写分配法通常与全写法合用，写分配法通常和写回法合用。</p><p>现代计算机的 Cache通常设立多级 Cache(通常为3级)，按离CPU的远近可各自命名为L1 Cache、L2 Cache、L3 Cache，离CPU越远，访问速度越慢，容量越大。<br>指令 Cache与数据 Cache分离一般在L1级，此时通常为写分配法与写回法合用。</p></blockquote><h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>提高存储系统的容量。</p><p>虚拟存储器将主存或辅存的地址空间统一编址，形成一个庞大的地址空间。虚拟存储器具有主存的速度和辅存的容量，提高了存储系统的性价比。</p><ul><li>虚地址、逻辑地址：用户编程所涉及的地址，虚地址对应的存储空间称为虚拟空间或逻辑空间。</li><li>实地址、物理地址：对应的是主存地址空间，也称实地址空间。虚地址要比实地址大得多。</li></ul><p>CPU使用虚地址时，由辅助硬件找出虚地址和实地址之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。——若已在主存中，则通过地址变换，CPU可直接访问主存指示的实际单元；——若不在主存中，则把包含这个字的一页或一段调入主存后再由CPU访问。——若主存已满，则采用替换算法置换主存中的一页或一段。</p><blockquote><p>在实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入磁盘，然后操作系统将当前运行所需要的部分调入主存，供CPU使用，其余暂不运行的部分则留在磁盘中。</p></blockquote><hr><p><strong>页式虚拟存储器</strong></p><p>虚拟空间和主存空间被划分为同样大小的页，主存的页叫实页，虚存的页叫虚页。</p><p>虚拟地址 被分为两个子段：虚页号和页内地址；虚拟地址到物理地址的转换由页表完成。</p><blockquote><p>页表</p><p>是一张存放在主存中的虚页号和实页号的对照表，一般长久地保存在内存中。</p><p>页表组成：</p><ul><li>有效位：也叫装入位，表示页面是否已调入主存；</li><li>脏位：也叫修改位，表示页面是否被修改过；虚存机制中使用回写策略。</li><li>引用位：也称使用位，用来配合替换策略进行设置。</li><li>物理地址：该页对应的物理地址指向。</li></ul></blockquote><p>CPU执行指令时，需要先将虚拟地址转换为主存物理地址。每个进程都有一个页表基址寄存器，存放该进程的页表首地址，然后根据虚拟地址高位部分的虚拟页号找到对应的页表项，若装入位为1,则取出物理页号，和虚拟地址低位部分的页内地址拼接，形成实际物理地址；若装入位<br>为0,则说明缺页，需要操作系统进行缺页处理。</p><p>页式虚拟存储器的优点是，页面的长度固定，页表简单，调入方便。缺点是，程序的最后一页经常会有浪费，并且页不是逻辑上独立的实体，所以在处理、保护和共享都不如段式虚拟存储器方便。</p><blockquote><p>由地址转换过程可知，访存时先访问一次主存去査页表，再访问主存才能取得数据。如果缺页，那么还要进行页面替换、页面修改等，因此采用虚拟存储机制后，访问主存的次数更多了。依据程序执行的局部性原理，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在高速缓冲器组成的快表(TLB)中，则可以明显提高效率。相应地把放在主存中的页表称为慢表(Page)。在地址转换时，首先査找快表，若命中，则无须访问主存中的页表。</p></blockquote><p><strong>段式虚拟存储器</strong></p><p>段式虚拟存储器中的段是按程序的逻辑结构划分的，各个段的长度因程序而异。</p><p>把虚拟地址分为两部分：段号和段内地址。虚拟地址到实地址之间的变换是由段表来实现的。</p><blockquote><p>段表</p><p>是程序的逻辑段和在主存中存放位置的对照表。段表的每行记录与某个段对应的段号、装入位、段起点和段长等信息。由于段的长度可变，所以段表中要给出各段的起始地址与段的长度。</p></blockquote><p>段式虚拟存储器的优点是，段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护也便于多道程序的共享；</p><p>缺点是因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费。</p><hr><p><strong>段页式虚拟存储器</strong></p><p>把程序按逻辑结构分段，每段再划分为固定大小的页，主存空间也划分为大小相等的页，程序对主存的调入、调出仍以页为基本传送单位，这样的虚拟存储器称为段页式虚拟存储器。</p><p>在段页式虚拟存储器中，每个程序对应一个段表，每段对应一个页表，段的长度必须是页长的整数倍，段的起点必须是某一页的起点。</p><p>虚地址分为段号、段内页号、页内地址三部分。CPU根据虚地址访存时，首先根据段号得到段表地址；然后从段表中取出该段的页表起始地址，与虚地址段内页号合成，得到页表地址；最后从页表中取出实页号，与页内地址拼接形成主存实地址。</p><p>段页式虚拟存储器的优点是，兼具页式和段式虚拟存储器的优点，可以按段实现共享和保护抑。缺点是在地址变换过程中需要两次查表，系统开销较大。</p><hr><p><strong>虚拟存储器 与 Cache 的比较</strong>：</p><p>相同处：</p><ul><li>最终目标都是为了提高系统性能，两者都有容量、速度、价格的梯度。</li><li>都把数据划分为小信息块，并作为基本的传递单位，虚存系统的信息块更大</li><li>都有地址的映射、替换算法、更新策略等问题。</li><li>依据程序的局部性原理应用“快速缓存的思想”，将活跃的数据放在相对高速的部件中</li></ul><p>不同处：</p><ul><li><p>Cache主要解决系统速度，而虚拟存储器是为了解决主存容量。</p></li><li><p>Cache全由硬件实现，是硬件存储器，对所有程序员透明。</p><p>而虚拟存储器由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明。</p></li><li><p>对于不命中性能影响，因为CPU的速度约为 Cache的10倍，主存的速度为硬盘的100倍以上，因此虛拟存储器系统不命中时对系统性能影响更大。</p></li><li><p>CPU与 Cache和主存都建立了直接访问的通路，而辅存与CPU没有直接通路。也就是说在 Cache不命中时主存能和CPU直接通信，同时将数据调入 Cache；而虚拟存储器系统不命中时，只能先由硬盘调入主存，而不能直接和CPU通信。</p></li></ul><h1 id="四、指令系统"><a href="#四、指令系统" class="headerlink" title="四、指令系统"></a>四、指令系统</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><blockquote><p>如何用二进制码表示指令</p></blockquote><p>指令（机器指令）是指示计算机执行某种操作的命令。一条指令就是机器语言的一个语句，是一组有意义的二进制代码。</p><p>指令系统：一台计算机的所有指令的集合，也称指令集。指令系统是计算机的主要属性，位于硬件和软件的中间。</p><p><strong>格式： 操作码字段 + 地址码字段</strong></p><ul><li><p>操作码：</p><p>指出指令中该指令应该执行什么性质的操作以及具有何种功能。</p><p>操作码是识别指令、了解指令功能 以及 区分操作数地址内容的组成和使用方法等的关键信息。例如，指出是算术加运算还是算术减运算，是程序转移还是返回操作。</p></li><li><p>地址码：</p><p>给出被操作的信息（指令或数据）的地址，包括参加运算的一个或多个操作数所在的地址、运算结果的保存地址、程序的转移地址、被调用的子程序的入口地址等。</p></li></ul><p>指令长度：指一条指令中所包含的二进制代码的位数。</p><ul><li><p>定长操作码指令格式</p><p>在指令字的最高位 分配固定的若干位（定长）表示操作码。</p><p>定长操作码有利于简化计算机硬件设计，提高指令译码和识别速度。</p></li><li><p>拓展操作码指令格式</p><p>为了在指令字长有限的前提下仍保持比较丰富的指令种类，可采取可变长度操作码，即操作码字段的位数不固定，且分散地放在指令字的不同位置。</p><p>最常见的变长操作码方法是 拓展操作码，它使操作码的长度随地址码的减少而增加。</p><p>会增加指令译码和分析的难度，使控制器的设计复杂化。</p></li></ul><p>根据指令中的 <strong>地址码的数目不同</strong>，可以将指令分为以下几种格式：</p><ul><li><p>零地址指令： OP</p><p>只给出操作码OP，没有显式地址。这种指令只有两种可能：</p><ul><li>不需要操作数的指令，如空操作指令、停机指令、关中断指令等。</li><li>零地址的运算类指令仅用在堆栈计算机中。通常参与运算的两个操作数隐含地从栈顶和次栈顶弹出，送到运算器进行运算，运算结果再隐含地压入堆栈。</li></ul></li><li><p>一地址指令： OP + A<del>1</del></p><ul><li><p>只有目的操作数的单操作数指令，按A<del>1</del>地址读取操作数，进行OP操作后，结果存回原地址。</p><p>指令含义：OP(A<del>1</del>)→A<del>1</del><br>如操作码含义是加1、减1、求反、求补等。</p></li><li><p>隐含约定目的地址的双操作数指令，按指令地址A<del>1</del>可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也将存放在AC中。<br>指令含义：(ACC)OP(A<del>1</del>)→ACC</p></li></ul><blockquote><p>若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为2^24^&#x3D;16M。</p></blockquote></li><li><p>二地址指令： OP + A<del>1</del> + A<del>2</del></p><p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>1</del></p><p>对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出目的操作数和源操作数的地址，其中目的操作数地址还用于保存本次的运算结果。</p><blockquote><p>若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为2^12^&#x3D;4K</p></blockquote></li><li><p>三地址指令： OP + A<del>1</del> + A<del>2</del> + A<del>3</del>(结果) </p><p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>3</del></p><blockquote><p>若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为28&#x3D;256。</p><p>若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次)</p></blockquote></li><li><p>四地址指令： OP + A<del>1</del> + A<del>2</del> + A<del>3</del>(结果) + A<del>4</del>(下址)</p><p>指令含义：(A<del>1</del>)OP(A<del>2</del>)→A<del>3</del>，A<del>4</del>&#x3D;下一条将要执行指令的地址。</p><blockquote><p>若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址<br>范围为2^6^&#x3D;64</p></blockquote></li></ul><hr><p><strong>指令的功能分类：</strong></p><ul><li><p><strong>数据传送</strong></p><p>传送指令通常有 寄存器之间的传送(MOV)、从内存单元读取数据到CPU寄存器(LOAD)、从CPU寄存器写数据到内存单元 (STORE)等。</p></li><li><p><strong>算术和逻辑运算</strong></p><p>这类指令主要有加(ADD)、减(SUB)、比较(CMP)、乘(MUL)、除(DIV)、加1 (INC)、减1(DEC)、与(AND)、或(OR)、取反(NOT)、异或(XOR)等。</p></li><li><p><strong>移位操作</strong></p><p>移位指令主要有算法移位、逻辑移位、循环移位等。</p></li><li><p><strong>转移操作</strong></p><p>转移指令主要有无条件转移(JMP)、条件转移(BRANCH)、调用(CALL)、返回(RET)、陷阱(TRAP)等。无条件转移指令在任何情况下都执行转移操作，而条件转移指令仅在特定条件满足时才执行转移操作，转移条件一般是某个标志位的值，或两个或两个以上的标志位组合。</p><p>调用指令和转移指令的区别：执行调用指令时必须保存下一条指令的地址（返回地址），当子程序执行结束时，根据返回地址返回到主程序继续执行；而转移指令则不返回执行。</p></li><li><p><strong>输入输出操作</strong></p><p>这类指令用于完成CPU与外部设备交换数据或传送控制命令及状态信息。</p></li></ul><h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><blockquote><p>给出下一条指令的地址，给出要操作的对象的地址</p></blockquote><p>寻址方式就是寻找 指令或操作数 有效地址的方式，寻址方式分为 指令寻址 和 数据寻址 两大类。</p><blockquote><p>指令中的地址码字段并不代表操作数的真实地址，这种地址称为形式地址(A)。形式地址结合寻址方式，可以计算出操作数在存储器中的真实地址，也叫有效地址(EA)。</p></blockquote><ul><li><p><strong>指令寻址</strong></p><ul><li><p>顺序寻址：</p><p>通过程序计数器(PC) 加1（1个指令字长），自动形成下一条指令的地址。</p></li><li><p>跳跃寻址：</p><p>通过转移指令实现。跳跃是指下一条指令的地址码不是由程序计数器给出，而是由本指令给出下一条指令地址的计算方式。</p></li></ul></li><li><p><strong>数据寻址</strong></p><p>在指令中表示 一个操作数的地址。由于数据寻址的方式较多，为加以区分，通常在指令字中设一个字段，用来表示属于哪种寻址方式，则指令格式变为：操作码 + 寻址特征 + 形式地址；</p></li></ul><hr><p><strong>常见的数据寻址方式：</strong></p><ul><li><p><strong>隐含</strong>寻址</p><p>不明显给出操作数的地址。如：单地址指令就 不指出第二操作数的地址，而规定累加器(ACC)作为第二操作数地址。</p><p>优点：利于缩短指令字长；缺点：需增加存储操作数或隐含地址的硬件。</p></li><li><p><strong>立即数</strong>寻址</p><p>地址字段 指出的不是操作数的地址，而是操作数本身，又称立即数。</p><p>优点：指令在执行阶段不访问主存，指令执行时间最短；缺点：地址字段的位数限制了立即数的范围。</p></li><li><p><strong>直接</strong>寻址</p><p>地址字段 就是操作数的真实地址。</p><p>优点：简单，只访问依次主存；缺点：地址字段限制了寻址范围，且操作数的地址不易修改。</p></li><li><p><strong>间接</strong>寻址</p><p>相对直接寻址，指令的地址字段 给出的形式地址是操作数的有效地址所在的存储单元的地址，即 操作数地址的地址。</p><p>优点：扩大了寻址范围，便于编制程序（方便子程序返回）；缺点：指令在执行阶段要多次访存。——由于访问速度过慢，所以问到扩大寻址范围时，通常指的是 寄存器间接寻址。</p></li><li><p><strong>寄存器</strong>寻址</p><p>在指令中直接给出操作数所在的寄存器编号。即EA&#x3D;R<del>i</del>，操作数存放在R<del>i</del>所指的寄存器中。</p><p>优点：不用访存，执行速度快；缺点：寄存器数量少，数量有限。</p></li><li><p><strong>寄存器间接</strong>寻址</p><p>寄存器间接寻址是指在寄存器 R<del>i</del> 中给出的不是一个操作数，而是操作数所在主存单元的地址，即EA&#x3D;(R<del>i</del>)。</p><p>比一般间接寻址快，但因为操作数在主存中，仍需访问一次主存。</p></li><li><p><strong>相对</strong>寻址</p><p>把程序计数器(PC)的内容加上指令中的形式地址A而形成的操作数的有效地址，即EA &#x3D; (PA) + A，其中A是相对与当前指令的位移量。</p><p>优点：操作数的地址不是固定的，而是随PC值的变化而变化，且与指令地址总是相差一个固定值，便于程序浮动。</p></li><li><p><strong>基址</strong>寻址</p><p>基址寻址是指将CPU中基址寄存器(BR) 的内容加上指令格式中的形式地址A而形成操作数的有效地址，即EA&#x3D;(BR)+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。</p><blockquote><p>基址寄存器是面向操作系统的，其内容由操作系统或管理程序确定，主要解决程序逻辑空间 与 物理空间的无关性。</p></blockquote><p>优点：可扩大寻址范围（基址寄存器的位数大于形式地址A的位数），用户不必考虑自己的程序存于主存的哪个空间区域，所以也有利于多道程序设计，并可用于编制浮动程序，但偏移量（A）的位数较短。</p></li><li><p><strong>变址</strong>寻址</p><p>变址寻址是指有效地址EA 等于指令字中的形式地址A与变址寄存器IX的内容之和，即 EA&#x3D;(IX)+A，其中 IX为变址寄存器（专用），也可用通用寄存器作为变址寄存器。</p><blockquote><p>变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。</p></blockquote><p>优点：可扩大寻址范围（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合编制循环程序。偏移量(变址寄存器IX) 的位数足以表示整个存储空间。</p></li><li><p><strong>堆栈</strong>寻址</p><p>堆栈是存储器（或专用寄存器组）中一块特定的、按后进先出(LIFO)原则管理的存储区，该存储区中读&#x2F;写单元的地址是用一个特定的寄存器给出的，该寄存器称为堆機指针(SP)。</p><p>堆栈可分为硬堆栈与软堆栈两种。</p><p>硬堆栈：指寄存器堆栈，成本高，不适合做大容量的堆栈；</p><p>软堆栈：从主存中划出一段区域 用来做堆栈，合算，也是最常用的。</p></li></ul><h2 id="CISC和RISC"><a href="#CISC和RISC" class="headerlink" title="CISC和RISC"></a>CISC和RISC</h2><blockquote><p>两种设计方向</p></blockquote><p><strong>CISC——复杂指令系统计算机</strong>——增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化；如采用X86架构的计算机。</p><p><strong>RISC——精简指令系统计算机</strong>——减少指令种类和简化指令功能，提供指令的指令速度；如ARM，MIPS架构的计算机。</p><hr><p>CISC的主要特点如下：</p><ol><li>指令系统复杂庞大，指令数目一般为200条以上。</li><li>指令的长度不固定，指令格式多，寻址方式多。</li><li>可以访存的指令不受限制。</li><li>各种指令使用频度相差很大。</li><li>各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。</li><li>控制器大多数采用微程序控制。有些指令非常复杂，以至于无法采用硬连线控制。</li><li>难以用优化编译生成高效的目标代码程序。</li></ol><p>RISC的中心思想是要求指令系统简化，尽量使用寄存器-寄存器操作指令，指令格式力求一致。RISC的主要特点如下：</p><ol><li>选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。</li><li>指令长度固定，指令格式种类少，寻址方式种类少。</li><li>只有 Load&#x2F;Store（取数存数）指令访存，其余指令的操作都在寄存器之间进行。</li><li>CPU中通用寄存器的数量相当多。</li><li>RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。</li><li>以硬布线控制为主，不用或少用微程序控制</li><li>特别重视编译优化工作，以减少程序执行时间</li></ol><blockquote><p>值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。</p><p>虽然RISC具有更强的实用性，看起来应该是未来处理器的发展方向。但事实上，早期很多软件都是根据CISC设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。CISC可以提供更多的功能，这是程序设计所需要的。</p></blockquote><h1 id="五、中央处理器"><a href="#五、中央处理器" class="headerlink" title="五、中央处理器"></a>五、中央处理器</h1><h2 id="CPU的功能和结构"><a href="#CPU的功能和结构" class="headerlink" title="CPU的功能和结构"></a>CPU的功能和结构</h2><p>中央处理器(CPU)由运算器和控制器组成。</p><ul><li>控制器：负责协调并控制计算机各部件执行程序的指令序列，包括取指令、分析指令和执行指令；</li><li>运算器：对数据进行加工。</li></ul><p><strong>CPU功能：</strong></p><ul><li>指令控制。完成取指令、分析指令和执行指令的操作，即程序的顺序控制</li><li>操作控制。一条指令的功能往往由若干操作信号的组合来实现。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作。</li><li>时间控制。对各种操作加以时间上的控制。时间控制要为每条指令按时间顺序提供应有的控制信号。</li><li>数据加工。对数据进行算术和逻辑运算。</li><li>中断处理。对计算机运行过程中出现的异常情况和特殊请求进行处理。</li></ul><hr><p><strong>运算器组成：</strong></p><ol><li><p>**算术逻辑单元(ALU)**。主要功能是进行算术&#x2F;逻辑运算；</p></li><li><p><strong>暂存寄存器</strong>。用于暂存从主存读来的数据，该数据不能存放在通用寄存器中，否则会破坏其原有内容。暂存寄存器对应用程序员是透明的。</p></li><li><p>**累加寄存器(ACC)**。它是一个通用寄存器，用于暂时存放ALU运算的结果信息，可以作为加法运算的一个输入端。</p></li><li><p><strong>通用寄存器组</strong>。如AX、BX、CX、DX、SP等，用于存放操作数（包括源操作数、目的操作数及中间结果）和各种地址信息等。SP是堆栈指针，用于指示栈顶的地址。</p></li><li><p>**程序状态字寄存器(PAW)**。保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息，如溢出标志(OF)、符号标志(SF)、零标志(ZF)、进位标志(CF)等。PSW中的这些位参与并决定微操作的形成。</p></li><li><p><strong>移位器</strong>。对操作数或运算结果进行移位运算。</p></li><li><p>**计数器(CT)**。控制乘除运算的操作步数。</p></li></ol><p><strong>控制器组成：</strong></p><ol><li>**程序计数器(PC)**。用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令。因程序中指令通常是顺序执行的，所以PC有自增功能。</li><li>**指令寄存器(IR)**。用于保存当前正在执行的那条指令。</li><li><strong>指令译码器</strong>。仅对操作码字段进行译码，向控制器提供特定的操作信号。</li><li>**存储器地址寄存器(MAR)**。用于存放要访问的主存单元的地址。</li><li>**存储器数据寄存器(MDR)**。用于存放向主存写入的信息或从主存读出的信息。</li><li><strong>时序系统</strong>。用于产生各种时序信号，它们都由统一时钟 ( CLOCK ) 分频得到。</li><li><strong>微操作信号发生器</strong>。根据R的内容（指令）、PSW的内容（状态信息）及时序信号，产生控制整个计算机系统所需的各种控制信号，其结构有组合逻辑型和存储逻辑型两种。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454608.png" alt="image-20220125162850050"></p><h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><blockquote><p>指令周期、数据流、指令执行方案</p></blockquote><p><strong>指令周期：</strong>CPU从主存中取出并执行一条指令的时间。（不同指令的指令周期可能不同）</p><p>指令周期 常用若干机器周期来表示，一个机器周期又包含若干时钟周期。</p><p>完整的指令周期组成：取指周期 + 间址周期 + 执行周期 + 中断周期</p><blockquote><p>这4个工作周期都有CPU访存操作，只是访存的目的不同。</p><p>取指周期是为了取指令，间址周期是为了取有效地址，执行周期是为了取操作数，中断周期是为了保存程序断点。</p></blockquote><p>为了区别不同的工作周期，在CPU内设置了4个标志触发器：FE， IND， EX， INT，分别对应取指，间址，执行，中断周期，并以“1”状态表示有效。</p><hr><p><strong>数据流</strong></p><p>数据流是根据指令要求依次访问的数据序列。</p><p>取指周期的数据流：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454092.png" alt="image-20220111202414358"></p><p>间址周期的数据流：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454299.png" alt="image-20220111202549519"></p><p>执行周期的任务是具体的，没有统一的数据流向。</p><p>中断周期的数据流：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201454970.png" alt="image-20220111202701385"></p><hr><p><strong>指令执行方案</strong></p><p>一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。</p><p>出于性能和硬件成本等考虑，可以选用3种不同的方案来安排指令的执行步骤。</p><ul><li><p><strong>单指令周期</strong><br>对所有指令都选用相同的执行时间来完成，称为单指令周期方案。</p><p>此时每条指令都在固定的时钟周期内完成，指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。因此，指令周期取决于执行时间最长的指令的执行时间。对于那些本来可以在更短时间内<br>完成的指令，要使用这个较长的周期来完成，会降低整个系统的运行速度。</p></li><li><p><strong>多指令周期</strong><br>对不同类型的指令选用不同的执行步骤来完成，称为多指令周期方案。</p><p>指令之间串行执行，即下一条指令只能在前一条指令执行结束后才能启动。但可选用不同个数的时钟周期来L完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，而不再要求所有指令占用相同的执行时间。</p></li><li><p><strong>流水线方案</strong><br>指令之间可以并行执行的方案，称为流水线方案，其追求的目标是力争在每个时钟脉冲周期完成一条指令的执行过程（只在理想情况下才能达到该效果）。</p><p>这种方案通过在每个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。</p></li></ul><h2 id="数据通路"><a href="#数据通路" class="headerlink" title="数据通路"></a>数据通路</h2><blockquote><p>设置部件间的连接路径，描述指令执行过程中信号和数据在这些路径上的传输</p></blockquote><p><strong>数据通路：指在功能部件之间传送的路径。</strong>这些部件称为<strong>数据通路部件</strong>，如ALU，通用寄存器，状态寄存器，异常和中断处理逻辑等。其中专门进行数据运算的部件称为 <strong>执行部件&#x2F; 功能部件</strong>。</p><p>数据通路描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器，这些都需要加以控制。</p><p><strong>数据通路的基本结构：</strong></p><ul><li><p>CPU内部单总线方式</p></li><li><p>CPU内部多总线方式</p><p>将所有寄存器的输入端和输出端都连接到多条公共通路上。相比之下，单总线中一个时钟内只允许传一个数据，指令执行效率很低，因此采用多总线方式，同时在多个总线上传送不同的数据，提高效率。</p></li><li><p>专用数据通路方式</p><p>根据指令执行过程中的数据和地址的流动方向安排连接线路，避免使用共享的总线，性能较高，但硬件量大。</p></li></ul><blockquote><p>注意：</p><p>内部总线是指同一部件之间的总线，如CPU内部连接各寄存器及运算部件之间的总线；</p><p>系统总线是指同一台计算机系统的各部件之间互相连接的总线，如CPU、内存、通道和各类IO接口之间相互连接的总线。</p></blockquote><h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><blockquote><p>控制器怎么指挥整个系统的工作？</p></blockquote><p>控制器是计算机系统的指挥中心，主要功能有：</p><ol><li>从主存中取出一条指令，并指出下一条指令在主存中的位置。</li><li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作。</li><li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向。</li></ol><p>根据控制器产生微操作控制信号的方式的不同，控制器可分为<u>硬布线控制器</u>和<u>微程序控制器</u>，两类控制器中的PC和IR是相同的，但确定和表示指令执行步骤的办法以及给出控制各部件运行所需要的控制信号的方案是不同的。</p><hr><p><strong>硬布线控制器</strong></p><p>硬布线控制器的基本原理是根据指令的要求、当前的时序及外部和内部的状态，按时间的顺序发送一系列微操作控制信号。</p><p>它由复杂的组合逻辑门电路和一些触发器构成，因此又称组合逻辑控制器。(主要涉及电路设计)</p><hr><p><strong>微程序控制器</strong></p><p>将每条机器指令编写成一个微程序，这些微程序存到一个控制存储器中，可以通过寻址找到每个微程序中的微指令。目前，大多数计算机都采用微程序设计技术。</p><blockquote><p>每个微程序包含若干微指令，每条微指令对应一个或几个微操作命令。</p></blockquote><p>基本术语：</p><ul><li><p><strong>微命令、微操作：</strong></p><p>一条机器指令可以分解成一个微操作序列；微操作是计算机最基本的、不可再分的操作。</p><p>将控制部件向执行部件发出的各种控制命令称为微命令，它是构成控制序列的最小单位。例如：打开或关闭某个控制门的电位信号。</p><p><strong>微命令和微操作是一一对应的</strong>。微命令是微操作的控制信号，微操作是微命令的执行过程。</p></li><li><p><strong>微指令、微周期：</strong></p><p>微指令是若干微命令的集合。存放微指令的控制存储器的单元地址称为微地址。</p><p>一条微指令至少包含两部分：</p><ul><li>操作控制字段（微操作码字段），用于生产某一步操作所需的各种操作控制信号。</li><li>顺序控制字段（微地址码字段），用于控制产生下一条要执行的微指令地址。</li></ul><p>微周期是指 从控制存储器中读取一条微指令并执行相应的微操作所需的时间。</p></li><li><p><strong>主存储器、控制存储器：</strong></p><p>主存储器用于存放程序和数据，在CPU外部，用RAM实现；</p><p>控制存储器(CM)用于存放微程序，在CPU内部，用 只读存储器ROM 实现。</p></li><li><p><strong>程序与微程序：</strong></p><p>程序是指令的有序集合，用于完成特定的功能；</p><p>微程序是微指令的有序集合，用于描述机器指令，一条指令的功能由一段微程序来思想。</p><blockquote><p>微程序实际上是机器指令的实时解释器，一般是事先编制好并存放在控制存储器中，对外一般透明</p></blockquote></li></ul><p><strong>组成：</strong></p><ul><li>**控制存储器(CM)**：核心部件，用于存放各指令对应的微程序；</li><li><strong>微指令寄存器</strong>：存放从CM中取出的微指令，它的位数同微指令字长相等。</li><li><strong>微地址形成部件</strong>：用于产生初始微地址和后继微地址，保证微指令的连续执行；</li><li><strong>微地址寄存器</strong>：接收微地址形成部件送来的微地址</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455367.png" alt="image-20220220104112886"></p><p><strong>工作过程：</strong></p><p>实际上就是在微程序控制器的控制下计算机执行机器指令的过程，这个过程可以描述如下：</p><p>① 执行取微指令公共操作。具体的执行是：在机器开始运行时，自动将取指微程序的入口地址送入CMAR,并从CM中读出相应的微指令送入CMDR。取指微程序的入口地址般为CM的0号单元，当取指微程序执行完后，从主存中取出的机器指令就已存入指令寄存器中。</p><p>② 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR.</p><p>③ 从CM中逐条取出对应的微指令并执行。</p><p>④ 执行完对应于一条机器指令的一个微程序后，又回到取指微程序的入口地址，继续第①步，以完成取下一条机器指令的公共操作</p><hr><p>注意区分一些寄存器的不同：</p><ul><li>地址寄存器(MAR)：用于存放主存的读&#x2F;写地址；</li><li>微地址寄存器(CMAR)：用于存放控制存储器的读&#x2F;写微指令的地址；</li><li>指令寄存器(IR)：用于存放从主存中读出的指令；</li><li>微指令寄存器(CMDR)：用于存放从控制存储器中读出的微指令。</li></ul><hr><p><strong>微指令的格式</strong></p><p>水平型微指令：一次能定义并执行多个并行操作</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455776.png" alt="image-20220220104430559"></p><p>垂直型微指令：类似机器指令操作码的方式，由微操作码字段规定微指令的功能。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455600.png" alt="image-20220220104442016"></p><hr><p><strong>微指令的编码方式</strong></p><ul><li><p>直接编码方式</p><p>n个微命令需要微指令的操作字段有n位，虽然简单，速度快，但对控制存储器容量要求极大。</p></li><li><p>字段直接编码方式</p><p>将微指令的微命令字段分成若干字段；  把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中；  每个字段独立编码，每种编码代表一个微命令且各字段编码含义单独定义，与其他字段无关，这就是字段直接编码方式。</p><p>优点：可以缩短微指令字长。</p><p>缺点：需经过译码再发出微命令，因此比直接编码方式慢。</p></li></ul><hr><p><strong>微指令的地址形成方式</strong></p><ol><li>由微指令的 <strong>下地址字段</strong> 指出（称为断定方式）；</li><li>根据机器指令的 <strong>操作码</strong> 形成：当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。</li></ol><hr><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455258.png" alt="image-20220220105619061"></p><h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>一条指令的执行过程：<strong>取指，分析，执行</strong></p><p><strong>取指</strong>：根据 PC内容访问主存储器，取出一条指令送到 IR 中。<br><strong>分析</strong>：对指令操作码进行译码，按照给定的寻址方式和地址字段中的内容形成操作数的有效地址EA,并从有效地址EA中取出操作数。<br><strong>执行</strong>：根据操作码字段，完成指令规定的功能，即把运算结果写到通用寄存器或主存中</p><p><strong>指令流水线</strong>：充分利用各功能部件。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455118.png" alt="image-20220220113352077"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455098.png" alt="image-20220220113548916"></p><hr><p>性能指标：吞吐率TP，加速比S，效率E</p><p>影响因素：结构相关（资源冲突），数据相关（数据冲突），控制相关（控制冲突）</p><p>分类：</p><p>多发技术：</p><h1 id="六、总线"><a href="#六、总线" class="headerlink" title="六、总线"></a>六、总线</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><u>总线是一组能为多个部件<strong>分时共享</strong>的<strong>公共</strong>信息传送线路。</u></p><p>共享：是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可以通过这组线路共享。<br>分时：是指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息。</p><blockquote><p>为什么使用总线？</p><p>早期计算机外部设备少时大多采用分散连接方式，不易实现随时增减外部设备。<br>为了更好地解决&#x2F;Oo设备和主机之间连接的灵活性问题，计算机的结构从分散连接发展为总线连接。</p></blockquote><p><strong>总线的特性：</strong></p><p>机械特性：尺寸、形状、管脚数、排列顺序；<br>电气特性：传输方向和有效的电平范围；<br>功能特性：每根传输线的功能(地址、数据、控制)；<br>时间特性：信号的时序关系；</p><p><strong>总线的分类：</strong></p><p>按数据传输格式：串行总线，并行总线；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455084.png" alt="image-20220220155959250"></p><p>按总线功能（连接的部件）：</p><ul><li><p><strong>片内总线</strong>：是芯片内部的总线。它是CPU芯片内部寄存器与寄存器之间、寄存器与AU之间的公共连接线。</p></li><li><p><strong>系统总线</strong>：是各功能部件（CPU，主存，I&#x2F;O接口）之间 相互连接的总线。可分为3类：数据总线，地址总线，控制总线；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201455904.png" alt="image-20220220152454394"></p></li><li><p>通信总线：是计算机系统之间 或 计算机与其他系统之间信息传送的总线。也称外部总线。</p></li></ul><p>按时序控制方式：同步总线，异步总线；</p><hr><p>总线的结构：</p><ul><li><p>单总线结构： </p><p>CPU、主存、IO设备(通过IO接口) 都连接在一组总线上，允许IO设备之间、I&#x2F;O设备和CPU之间或IO设备与主存之间直接交换信。<br>优点：结构简单，成本低，易于接入新的设备。<br>缺点：带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456859.png" alt="image-20220220152807606"></p></li><li><p>双总线结构：</p><p>有两条总线，一条是主存总线，用于CPU、主存和通道之间进行数据传送；另一条是 I&#x2F;O总线，用于多个外部设备与通道之间进行数据传送。<br>优点：将较低速的 I&#x2F;O设备从单总线上分离出来，实现存储器总线和 I&#x2F;O总线分离。<br>缺点：需要增加通道等硬件设备。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456385.png" alt="image-20220220153153326"></p></li><li><p>三总线结构：</p><p>在计算机系统各部件之间采用3条各自独立的总线来构成信息通路，这3条总线分别为<strong>主存总线</strong>、<strong>I&#x2F;O总线</strong>和直接内存访问<strong>DMA总线</strong>。<br>优点：提高了 I&#x2F;O设备的性能，使其更快地响应命令，提高系统吞吐量。<br>缺点：系统工作效率较低。</p><p> <img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456780.png" alt="image-20220220153412326"></p></li></ul><hr><p><strong>总线的性能指标：</strong></p><ul><li><p>总线的 传输周期（总线周期）：一次总线操作所需的时间（包括 申请，寻址，传输，结束），通常由若干个总线时钟周期构成。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456604.png" alt="image-20220220154622584"></p></li><li><p>总线的 时钟周期：即机器的时钟周期；</p></li><li><p>总线的 工作频率：为总线周期的倒数；</p></li><li><p>总线的 时钟频率：为时钟周期的倒数；</p></li><li><p>总线宽度：</p><p>又称为总线位宽，它是总线上同时能够传输的数据位数，通常是指数据总线的根数，如32根称为32位(bit)总线。</p></li><li><p>总线带宽：</p><p>可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数，通常用每秒钟传送信息的字节数来衡量，单位可用字节&#x2F;秒(B&#x2F;s)表示。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456312.png" alt="image-20220220155133573"></p><blockquote><p>例题：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456401.png" alt="image-20220220155730564"></p></blockquote></li><li><p>总线复用：一种信号线在不同时间 可以传输不同的信息。</p></li><li><p>信号线数：地址总线，数据总线，控制总线这3种总线数的总和称为信号线数。</p></li></ul><h2 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h2><blockquote><p>解决多个设备争用总线的问题</p></blockquote><p>同一时刻<strong>只能有一个</strong>设备<strong>控制</strong>总线传输操作，另外可以<strong>有一个或多个</strong>设备从总线<strong>接收</strong>数据。</p><p>将总线上所连接的各类设备按其对总线有无控制功能分为：<br><strong>主设备</strong>：获得总线控制权的设备。<br><strong>从设备</strong>：被主设备访问的设备，只能响应从主设备发来的各种总线命令。</p><ul><li><p>为什么要仲裁？</p><p>总线作为一种共享设备，不可避免地会出现同一时刻有多个主设备竞争总线控制权的问题。</p></li><li><p>总线仲裁的定义：</p><p>多个主设备同时竞争主线控制权时，以某种方式选择一个主设各优先获得总线控制权称为总线仲裁。</p></li><li><p>总线仲裁分类</p><ul><li><p>集中仲裁方式：</p><p>链式査询方式、计数器定时查询方式、独立请求方式</p></li><li><p>分布仲裁方式：</p></li></ul></li></ul><p>请求总线的<strong>工作流程</strong>：</p><ol><li>主设备发出请求信号；</li><li>若多个主设备同时要使用总线，则由总线控制器的判优、仲裁逻辑按一定的优先等级顺序确定哪主设各能使用总线；</li><li>获得总线使用权的主设备开始传送数据。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456802.png" alt="image-20220220161957124"></p><p>链式查询：<img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456667.png" alt="image-20220220162329585"></p><p>计数器定时查询：<img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456801.png" alt="image-20220220162516927"></p><p>独立请求：<img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201456077.png" alt="image-20220220162603652"></p><h2 id="操作和定时"><a href="#操作和定时" class="headerlink" title="操作和定时"></a>操作和定时</h2><blockquote><p>占用总线的一对设备如何进行数据传输</p></blockquote><p><strong>总线传输的四个阶段</strong>：</p><ol><li><p><strong>申请分配</strong>：</p><p>由需要使用总线的主模块（或主设备）提出申请，经总线仲裁机构決定将下一传输周期的总线使用权授予某一申请者。也可将此阶段细分为 传输请求 和 总线仲裁 两个阶段。</p></li><li><p><strong>寻址</strong>：获得使用权的主模块通过总线发出本次要访问的从模块的地址及有关命令，启动参与本次传输的从模块。</p></li><li><p><strong>传输</strong>：主模块和从模块进行数据交换，可单向或双向进行数据传送。</p></li><li><p><strong>结束阶段</strong>：主模块的有关信息均从系统总线上撤除，让出总线使用权。</p></li></ol><p><strong>总线定时</strong>：实质是一种协议或规则，用于在总线上 交换数据的双方 在时间上的配合。</p><ul><li><p><strong>同步通信（同步定时方式）</strong>：由 统一时钟 控制数据传送；</p><blockquote><p>优点：传送速度快，具有较高的传输速率；总线控制逻辑简单。<br>缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。</p><p>同步通信适用于总线长度较短及总线所接部件的存取时间比较接近的系统。</p></blockquote></li><li><p><strong>异通信（异步定时方式）</strong>：采用应答方式，没有公共时钟标准；</p><blockquote><p>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</p><p>缺点：比同步控制方式稍复杂一些，速度比同步定时方式慢。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201457330.png" alt="image-20220220164600629"></p></blockquote></li><li><p><strong>半同步通信</strong>：同步、异步结合；</p><blockquote><p>在统一时钟的基础上，增加一个“等待”响应信号。</p></blockquote></li><li><p><strong>分离式通信</strong>：充分利用总线的空闲阶段。</p><blockquote><p>上述三种通信，在主模块发地址、命令，从模块发数据时会使用总线，当在从模块准备数据时，没有使用总线，但主模块仍会占用总线。</p><p>所以分离式通信 将总线传输周期分为两个子周期：</p><ul><li>子周期1：主模块申请占用总线，使用完后放弃总线的使用权。</li><li>子周期2：从模块申请占用总线，将各种信息送至总线上。</li></ul><p>特点：</p><p>各模块均有权申请占用总线<br>采用同步方式通信，不等对方回答<br>各模块准备数据时，不占用总线<br>总线利用率提高</p></blockquote></li></ul><h2 id="标准"><a href="#标准" class="headerlink" title="标准"></a>标准</h2><blockquote><p>易于实现系统的模块化设计</p></blockquote><h1 id="七、输入输出系统"><a href="#七、输入输出系统" class="headerlink" title="七、输入输出系统"></a>七、输入输出系统</h1><h2 id="I-x2F-O接口"><a href="#I-x2F-O接口" class="headerlink" title="I&#x2F;O接口"></a>I&#x2F;O接口</h2><h2 id="I-x2F-O方式"><a href="#I-x2F-O方式" class="headerlink" title="I&#x2F;O方式"></a>I&#x2F;O方式</h2><blockquote><p>程序查询方式，程序中断方式，DMA方式</p></blockquote><ul><li><p>程序査询方式：</p><p>由CPU通过程序不断查询I&#x2F;O设备是否已做好准备，从而控制I&#x2F;O设备与主机交换信息。</p></li><li><p>程序中断方式：</p><p>只在 I&#x2F;O设备准备就绪并向CPU发出中断请求时才予以响应。</p></li><li><p>DMA方式：</p><p>主存和 I&#x2F;O设备之间有一条直接数据通路，当主存和 I&#x2F;O设备交换信息时无须调用中断服务程序。</p></li><li><p>通道方式：</p><p>在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行 I&#x2F;O命令时，只需启动有关通道，通道将执行通道程序，从而完成 I&#x2F;O操作。</p></li></ul><blockquote><p>程序查询方式和程序中断方式 用于 数据传输效率较低的外部设备，DMA方式和通道方式用于数据传输效率较高的设备。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(others)</title>
      <link href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/"/>
      <url>/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络已由一种<strong>通信基础设施</strong>发展为一种重要的<strong>信息服务基础设施</strong>。</p><h2 id="因特网概述"><a href="#因特网概述" class="headerlink" title="因特网概述"></a>因特网概述</h2><p><strong>网络、互联网 和 因特网：</strong></p><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><p>互连网（互联网）：多个网络通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><blockquote><p><strong>internet与Internet的区别</strong></p><ul><li><strong>internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是因特网(Internet)。</strong></p></blockquote><p><strong>因特网发展的三个阶段：</strong></p><p>一，从单个网络AEPANET向互联网发展</p><blockquote><p>1969年，第一个分组交换网AEPANET；</p><p>70年代中期，研究多种网络之间的互联；</p><p>1983年，TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生)</p></blockquote><p>二，逐步建成三级结构的因特网</p><blockquote><p>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网，地区网，校园网）；</p><p>1990年，ARPANET任务完成，正式关闭；</p><p>1991年，美国政府将因特网主干网交给私人公式经营，并开始对接入因特网的单位收费；</p></blockquote><p>三，逐步形成了多层次的ISP结构的因特网</p><blockquote><p>1993年，NSFNET逐渐被若干个商用因特网主干网替代，政府不再负责因特网运营，让各种<strong>因特网服务提供者ISP</strong>来运营；</p><p>1994年，万维网WWW技术促使因特网迅速发展；</p><p>1995年，NSFNET停止运作，因特网彻底商业化</p></blockquote><p><strong>因特网服务提供者ISP(Internet Service Provider)</strong></p><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过ISP接入因特网</strong></p><p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p><p><strong>因为因特网上的主机都必须有IP地址才能进行通信，所以要通过该ISP接入到因特网</strong></p><p>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</p><p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><p><strong>因特网的标准化工作：</strong></p><ul><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在指定其标准上的一个很大的特点是</p><p>面向公众。</p><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><p>因特网协会ISOC</p><p>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ul><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103816.png" alt="image-20201006170959060"></p><ul><li><p>制订因特网的正式标准要经过以下<strong>4个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是RFC文档）</p><p>2、建议标准（从这个阶段开始就成为RFC文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="因特网的组成"><a href="#因特网的组成" class="headerlink" title="因特网的组成"></a>因特网的组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103822.png" alt="image-20201006180725282"></p><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li></ol></blockquote><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103829.png" alt="image-20201010234145371"></p><p><strong>客户-服务器方式（C&#x2F;S方式）：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><hr><h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><h4 id="电路交换（Circuit-Switching）"><a href="#电路交换（Circuit-Switching）" class="headerlink" title="电路交换（Circuit Switching）"></a>电路交换（Circuit Switching）</h4><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103836.png" alt="image-20201006182240000"></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103840.png" alt="image-20201006182634249"></p><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103845.png" alt="image-20201006183020317"></p><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h4 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h4><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103852.png" alt="image-20201006183312843"></p><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li>缓存分组</li><li>转发分组</li><li>简称为“分组转发”</li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><h4 id="报文交换（Message-Switching）"><a href="#报文交换（Message-Switching）" class="headerlink" title="报文交换（Message Switching）"></a>报文交换（Message Switching）</h4><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><h4 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h4><blockquote><p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103900.png" alt="image-20201006184451671"></p><p>分析：</p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103949.png" alt="image-20201006185601460"></p><hr><h2 id="计算机网络的定义和分类"><a href="#计算机网络的定义和分类" class="headerlink" title="计算机网络的定义和分类"></a>计算机网络的定义和分类</h2><p><strong>定义</strong></p><ul><li><p>计算机网络的精确定义并未统一</p></li><li><p>计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合</p><ul><li>互连：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li>自治：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li>集合：是指至少需要两台计算机；</li></ul></li><li><p>计算机网络的较好的定义是：计算机网络主要是由一些</p><p>通用的，可编程的硬件（一定包含有中央处理机CPU）互连</p><p>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li></ul></li><li><p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</p></li></ul><p><strong>分类：</strong></p><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li><p>公用网</p></li><li><p>专用网</p></li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li>总线型网络</li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016103958.png" alt="image-20201007005149993"></p><ul><li>星型网络</li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104005.png" alt="image-20201007005203129"></p><ul><li>环形网络</li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104009.png" alt="image-20201007005212345"></p><ul><li>网状型网络</li></ul><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104015.png" alt="image-20201007005249137"></p><hr><h2 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h2><h3 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104021.png" alt="image-20201007012419698"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104026.png" alt="image-20201007012439769"></p><h3 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104031.png" alt="image-20201007012943970"></p><h3 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104038.png" alt="image-20201007013119621"></p><blockquote><p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li>发送时延</li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><ul><li>传播时延</li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><ul><li>处理时延</li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li>排队时延</li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104045.png" alt="image-20201007014139333"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104050.png" alt="image-20201007015401505"></p><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><h3 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h3><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104057.png" alt="image-20201007115317347"></p><h3 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h3><p>互联网上的信息不仅仅单方向传输而是双向交互的。因此，我们有时很需要知道<strong>双向交互一次所需的时间</strong>。</p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104104.png" alt="image-20201007115647631"></p><h3 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h3><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104110.png" alt="image-20201012164544306"></p><h3 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104116.png" alt="image-20201007132900210"></p><hr><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><h3 id="常见的体系结构"><a href="#常见的体系结构" class="headerlink" title="常见的体系结构"></a>常见的体系结构</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104122.png" alt="image-20201007133848212"></p><blockquote><p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104127.png" alt="image-20201007135220030"></p><blockquote><p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>只不过路由器一般只包含网络接口层和网际层。</p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104135.png" alt="image-20201007135518050"></p><blockquote><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p></blockquote><blockquote><p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104142.png" alt="image-20201007141110338"></p><blockquote><p>教学时把TCP&#x2F;IP体系结构的<strong>网络接口层</strong>分成了<strong>物理层</strong>和<strong>数据链路层</strong></p></blockquote><h3 id="结构分层的必要性"><a href="#结构分层的必要性" class="headerlink" title="结构分层的必要性"></a>结构分层的必要性</h3><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104151.png" alt="image-20201007141318411"></p><p><strong>物理层问题</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104156.png" alt="image-20201007141806675"></p><blockquote><p>这图说明</p><ul><li>第一，严格来说，传输媒体并不属于物理层</li><li>计算机传输的信号，并不是图示的方波信号</li></ul><p>这样举例只是让初学者容易理解</p></blockquote><p><strong>数据链路层问题</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104204.png" alt="image-20201007142049812"></p><p><strong>网络层问题</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104211.png" alt="image-20201007142408792"></p><p><strong>运输层问题</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104216.png" alt="image-20201007142631029"></p><blockquote><p>如何标识与网络通信相关的应用进程：一个分组到来，我们应该交给哪个进程处理呢？浏览器进程还是QQ进程</p></blockquote><p><strong>应用层问题</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104224.png" alt="image-20201007142755720"></p><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104231.png" alt="image-20201007204006284"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104235.png" alt="image-20201007143138937"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104241.png" alt="image-20201007195641140"></p><h3 id="结构分层思想举例"><a href="#结构分层思想举例" class="headerlink" title="结构分层思想举例"></a>结构分层思想举例</h3><p>例子：主机的浏览器如何与Web服务器进行通信</p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104246.png" alt="image-20201007144900565"></p><p><strong>解析：</strong></p><p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104254.png" alt="image-20201007145242020"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104300.png" alt="image-20201007145441370"></p><blockquote><p>第一步：</p><ul><li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li><li>应用层将<strong>HTTP请求报文</strong>交付给<strong>运输层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104304.png" alt="image-20201007145720661"></p><blockquote><p>第二步：</p><ul><li><strong>运输层</strong>给<strong>HTTP请求报文</strong>添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li><li><strong>TCP报文段的首部格式</strong>作用是区分应用进程以及实现可靠传输</li><li><strong>运输层</strong>将T<strong>CP报文段</strong>交付给<strong>网络层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104309.png" alt="image-20201007150234909"></p><blockquote><p>第三步：</p><ul><li><strong>网络层</strong>给<strong>TCP报文段</strong>添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li><li><strong>IP数据报的首部格式</strong>作用是使<strong>IP数据报</strong>可以在互联网传输，也就是被路由器转发</li><li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong>处理</li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104314.png" alt="image-20201007150723365"></p><blockquote><p>第四步：</p><ul><li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> （图示右边为首部，左边为尾部）</li><li>该<strong>首部</strong>的作用主要是为了让<strong>帧</strong>能够在一段链路上或一个网络上传输，能够被相应的目的主机接收</li><li>该<strong>尾部</strong>的作用是让目的主机检查所接收到的<strong>帧</strong>是否有误码</li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104319.png" alt="image-20201007151342502"></p><blockquote><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，这里的网络N1假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li><strong>物理层</strong>将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104325.png" alt="image-20201007151900254"></p><blockquote><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul></blockquote><p><strong>2、路由器转发</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104331.png" alt="image-20201007152029458"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104337.png" alt="image-20201007152138961"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104350.png" alt="image-20201007152627778"></p><blockquote><p>在路由器中</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></li><li><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></li></ul></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104356.png" alt="image-20201007152650863"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104400.png" alt="image-20201007152812431"> <img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104404.png" alt="image-20201007153714840"></p><blockquote><p>在路由器中</p><ul><li>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</li><li><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></li><li><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></li><li><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></li></ul></blockquote><p><strong>3、接收方接收</strong></p><blockquote><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><p><strong>发回响应报文的步骤和之前过程类似</strong></p></blockquote><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104410.png" alt="image-20201007155051275"></p><h3 id="结构中的专用术语"><a href="#结构中的专用术语" class="headerlink" title="结构中的专用术语"></a>结构中的专用术语</h3><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104417.png" alt="image-20201007155444920"></p><p><strong>协议</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104423.png" alt="image-20201007155545934"></p><blockquote><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul></blockquote><p><strong>服务</strong></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104434.png" alt="image-20201007160246561"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104757.png" alt="image-20201016104750288"></p><p><img src="https://gitee.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC1%E7%AB%A0%EF%BC%88%E6%A6%82%E8%BF%B0%EF%BC%89.assets/20201016104806.png" alt="image-20201007162620250"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="体系结构题目"><a href="#体系结构题目" class="headerlink" title="体系结构题目"></a>体系结构题目</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816036.png" alt="image-20201007230219248"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816006.png" alt="image-20201007230242426"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816577.png" alt="image-20201007230300194"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816509.png" alt="image-20201007230345580"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816604.png" alt="image-20201007230404271"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816327.png" alt="image-20201007230432453"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816796.png" alt="image-20201007230450993"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201816958.png" alt="image-20201007230511370"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817497.png" alt="image-20201007230548012"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817672.png" alt="image-20201007230616796"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817303.png" alt="image-20201007230635007"></p><h3 id="时延相关题目"><a href="#时延相关题目" class="headerlink" title="时延相关题目"></a>时延相关题目</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817503.png" alt="image-20201007230747143"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817860.png" alt="image-20201007231024960"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817068.png" alt="image-20201007230843470"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817264.png" alt="image-20201007231125552"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817817.png" alt="image-20201007231159268"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817500.png" alt="image-20201007231234486"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817962.png" alt="image-20201007231318549"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201817733.png" alt="image-20201007231338817"></p><hr><hr><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="物理层的基本概念"><a href="#物理层的基本概念" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201818277.png" alt="image-20201008130211749"></p><hr><h2 id="物理层下面的传输媒体"><a href="#物理层下面的传输媒体" class="headerlink" title="物理层下面的传输媒体"></a>物理层下面的传输媒体</h2><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。<strong>传输媒体</strong>课分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><h3 id="导引型传输媒体"><a href="#导引型传输媒体" class="headerlink" title="导引型传输媒体"></a>导引型传输媒体</h3><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820064.png" alt="image-20201008132050917"></p><p><strong>双绞线</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820943.png" alt="image-20201008132225715"></p><p><strong>光纤</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820250.png" alt="image-20201008132403903"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820991.png" alt="image-20201011001240573"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><strong>电力线</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820364.png" alt="image-20201008132709015"></p><h3 id="非导引型传输媒体"><a href="#非导引型传输媒体" class="headerlink" title="非导引型传输媒体"></a>非导引型传输媒体</h3><p>非导引型传输媒体是指自由空间。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820859.png" alt="image-20201008132857833"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201820579.png" alt="image-20201008132943176"></p><p><strong>无线电波</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821443.png" alt="image-20201008133135659"></p><p><strong>微波</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821980.png" alt="image-20201008133317293"></p><p><strong>红外线</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821480.png" alt="image-20201008133421986"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821992.png" alt="image-20201008133718810"></p><hr><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821958.png" alt="image-20201008135603009"></p><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h3 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821033.png" alt="image-20201008140209430"></p><blockquote><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201821161.png" alt="image-20201008140850958"></p><blockquote><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul></blockquote><h3 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即只能有一个方向的通信而没有反方向的交互。无线电广播或有线电以及电视广播就属于这种类型</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201822213.png" alt="image-20201008141345239"></p><p><strong>双向交替通信</strong>：</p><p>又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但不能双方同时发送（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201822875.png" alt="image-20201008141921924"></p><p><strong>双向同时通信</strong>：</p><p>又称为<strong>全双工通信</strong>，即通信的双发可以同时发送和接收信息。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201822138.png" alt="image-20201008142037846"></p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201822780.png" alt="image-20201008144616896"></p><blockquote><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p></li><li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p></li></ul></blockquote><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823502.png" alt="image-20201008145747263"></p><h3 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h3><blockquote><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li></ul></blockquote><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823914.png" alt="image-20201008145304974"></p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823855.png" alt="image-20201008145329540"></p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p><strong>不归零编码</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823868.png" alt="image-20201008150058039"></p><blockquote><ul><li><p>正电平表示比特1&#x2F;0</p></li><li><p>负电平表示比特0&#x2F;1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823531.png" alt="image-20201008150528228"></p><blockquote><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li><strong>但是</strong>对于计算机网络，<strong>宁愿利用这根传输线传输数据信号</strong>，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823665.png" alt="image-20201008195033189"></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823524.png" alt="image-20201008151347028" style="zoom:67%;" /><blockquote><p><strong>归零编码</strong>虽然<strong>自同步</strong>，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823274.png" alt="image-20201008195148727"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1&#x2F;0</li><li>正跳变表示比特0&#x2F;1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201823543.png" alt="image-20201008195235561"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1&#x2F;0</li><li>不变化表示比特0&#x2F;1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824841.png" alt="image-20201008153522501"></p><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824797.png" alt="image-20201008155429044"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824211.png" alt="image-20201008155804617"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824116.png" alt="image-20201008155835940"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824483.png" alt="image-20201008155955169"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201824648.png" alt="image-20201008160133748"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201828876.png" alt="image-20201008160208060"></p><h3 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h3><p>在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201828564.png" alt="image-20201010204336400"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201828574.png" alt="image-20201010204818976"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201828860.png" alt="image-20201010204928756"></p><p>奈氏准则和香农公式对比：</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829903.png" alt="image-20201010205029346"></p><h2 id="补充：信道复用技术"><a href="#补充：信道复用技术" class="headerlink" title="补充：信道复用技术"></a>补充：信道复用技术</h2><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829130.png" alt="image-20201011001949479"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829906.png" alt="image-20201011002236208"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829227.png" alt="image-20201011002540041"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829160.png" alt="image-20201011002842704"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201829046.png" alt="image-20201011002953703"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201830773.png" alt="image-20201011003214653"></p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><h3 id="物理层的基本概念-1"><a href="#物理层的基本概念-1" class="headerlink" title="物理层的基本概念"></a>物理层的基本概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201830239.png" alt="image-20201010213213489"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201830843.png" alt="image-20201010213423319"></p><h3 id="编码与调制习题"><a href="#编码与调制习题" class="headerlink" title="编码与调制习题"></a>编码与调制习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201830814.png" alt="image-20201008154232079"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201831643.png" alt="image-20201010213815232"></p><h3 id="信道的极限容量习题"><a href="#信道的极限容量习题" class="headerlink" title="信道的极限容量习题"></a>信道的极限容量习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201831374.png" alt="image-20201010205425612"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201831817.png" alt="image-20201010205914234"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201831990.png" alt="image-20201010210031254"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201831754.png" alt="image-20201010210217898"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832708.png" alt="image-20201010210350902"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="数据链路层概述"><a href="#数据链路层概述" class="headerlink" title="数据链路层概述"></a>数据链路层概述</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832281.png" alt="image-20201011102531462"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832208.png" alt="image-20201014004326549"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832305.png" alt="image-20201011102618878"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832076.png" alt="image-20201011102653161"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832730.png" alt="image-20201011102733584"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201832446.png" alt="image-20201014004459744"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><h3 id="三个重要问题"><a href="#三个重要问题" class="headerlink" title="三个重要问题"></a>三个重要问题</h3><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201833689.png" alt="image-20201011103650253"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201834092.png" alt="image-20201011103917512"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201834059.png" alt="image-20201011105314053"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201834929.png" alt="image-20201011105824466"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835050.png" alt="image-20201011110017415"></p><p>还有数据碰撞问题</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835279.png" alt="image-20201011110129994"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p><p>在无线局域网中仍然使用的是共享信道技术</p></blockquote><hr><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><strong>帧头和帧尾中包含有重要的控制信息</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835745.png" alt="image-20201011110851301"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835483.png" alt="image-20201011111334052"></p><p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835950.png" alt="image-20201011111729324"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835266.png" alt="image-20201011112450187"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835838.png" alt="image-20201011113207944"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835258.png" alt="image-20201011113804721"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul><p><strong>帧的数据部分长度</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835162.png" alt="image-20201011115008209"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201835744.png" alt="image-20201011115049672"></p><hr><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836377.png" alt="image-20201011133757804"></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836792.png" alt="image-20201011234428217"></p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836931.png" alt="image-20201011234605045"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836456.png" alt="image-20201011234701845"></p><p><strong>例题</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836330.png" alt="image-20201011235128869"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836299.png" alt="image-20201011235325022"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201836992.png" alt="image-20201011235726437"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>下面是比特差错</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837668.png" alt="image-20201012153605893"></p><p><strong>其他传输差错</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837902.png" alt="image-20201012153811724"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837434.png" alt="image-20201012154910921"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837981.png" alt="image-20201012155300937"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837448.png" alt="image-20201012160026362"></p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><h5 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h5><p><strong>确认与否认</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201837618.png" alt="image-20201012162009780" style="zoom:67%;" /><p><strong>超时重传</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838548.png" alt="image-20201012162112151" style="zoom:67%;" /><p><strong>确认丢失</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838886.png" alt="image-20201012162318298" style="zoom:67%;" /><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838138.png" alt="image-20201012162348428" style="zoom:67%;" /><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838714.png" alt="image-20201012162815885" style="zoom:67%;" /><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838787.png" alt="image-20201012164008780"></p><h5 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838614.png" alt="image-20201012164924635"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201838894.png" alt="image-20201012181005719"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201839189.png" alt="image-20201012181047665"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h5><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201839407.png" alt="image-20201012190027828"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201839877.png" alt="image-20201012190632086"></p><h5 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h5><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201839295.png" alt="image-20201012191936466"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840102.png" alt="image-20201012192932035"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840642.png" alt="image-20201012193212419"></p><h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h5><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840820.png" alt="image-20201012194304696"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h5><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840684.png" alt="image-20201012195440780"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840224.png" alt="image-20201012195629368"></p><p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840568.png" alt="image-20201012195836902"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840802.png" alt="image-20201012200120166"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840452.png" alt="image-20201012200454557"></p><p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201840611.png" alt="image-20201012201109774"></p><p>习题</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841879.png" alt="image-20201012202419107"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841136.png" alt="image-20201012202222138"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841235.png" alt="image-20201012203638722"></p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p><p><strong>习题</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841142.png" alt="image-20201012205250996"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841680.png" alt="image-20201012204742870"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841365.png" alt="image-20201012205133924"></p><hr><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841059.png" alt="image-20201012210844629"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201841191.png" alt="image-20201012211423528"></p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>必须规定特殊的字符作为帧定界符</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842227.png" alt="image-20201012211826281"></p><h3 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h3><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842132.png" alt="image-20201012212148803"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842896.png" alt="image-20201012212255550"></p><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842191.png" alt="image-20201012212558654"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842702.png" alt="image-20201012213021860"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h2 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h2><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842052.png" alt="image-20201013201521915"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201842967.png" alt="image-20201013201533445"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843155.png" alt="image-20201013201133903"></p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843066.png" alt="image-20201013152007335"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843815.png" alt="image-20201013152453425"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p><strong>信道复用</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843541.png" alt="image-20201013153642544"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843603.png" alt="image-20201013153947668"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843265.png" alt="image-20201013154142540"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843757.png" alt="image-20201013202218132"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201843093.png" alt="image-20201013203126625"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844662.png" alt="image-20201013203324709"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062102991.png" alt="image-20201013203459640"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844943.png" alt="image-20201013203819578"></p><h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844121.png" alt="image-20201013211620687"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844069.png" alt="image-20201013213102777"></p><h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844417.png" alt="image-20201013215400688"></p><h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201844253.png" alt="image-20201013215530979"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845220.png" alt="image-20201013221240514"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845573.png" alt="image-20201013221834942"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h4 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845196.png" alt="image-20201013221705893"></p><h4 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845009.png" alt="image-20201013223235305"></p><h4 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845970.png" alt="image-20201013224051932"></p><h4 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201845234.png" alt="image-20201013225400777"></p><h4 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846259.png" alt="image-20201013230717856"></p><h4 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846454.png" alt="image-20201013231430295"></p><h4 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846704.png" alt="image-20201013231703302"></p><h4 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p><h4 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846916.png" alt="image-20201014192811760"></p><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846204.png" alt="image-20201014200149717"></p><h4 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201846513.png" alt="image-20201014200833233"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847394.png" alt="image-20201014201511741"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847865.png" alt="image-20201014201927680"></p><h4 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847251.png" alt="image-20201014202213766"></p><p><strong>退避算法的示例</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847562.png" alt="image-20201014202819851"></p><h4 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847732.png" alt="image-20201014203119710"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847138.png" alt="image-20201014203506878"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201847909.png" alt="image-20201014203859033"></p><hr><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201848054.png" alt="image-20201014222831663"></p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201848361.png" alt="image-20201014223659993"></p><h4 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201848447.png" alt="image-20201014224732019"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201848580.png" alt="image-20201014225358570"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong>网络接口标识符</strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849458.png" alt="image-20201014230248959"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849957.png" alt="image-20201014230625182"></p><h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849376.png" alt="image-20201014230822305"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849241.png" alt="image-20201014231244655"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849435.png" alt="image-20201014231754669"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201849979.png" alt="image-20201014232132424"></p><blockquote><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201850865.png" alt="image-20201014232714791"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201850050.png" alt="image-20201015001243584"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201850804.png" alt="image-20201015001535528"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202204201850938.png" alt="image-20201015002054876"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址属于网 络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032136208.png" alt="image-20201015104441580"></p><h4 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032136442.png" alt="image-20201015104913755"></p><h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032136019.png" alt="image-20201015105455043"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032136695.png" alt="image-20210103212224961"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137675.png" alt="image-20201015113826197"></p><p>ARP高速缓存表</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137411.png" alt="image-20201015114052206"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137758.png" alt="image-20201015114444263"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137663.png" alt="image-20201015114811501"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137915.png" alt="image-20201015115212170"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137213.png" alt="image-20201015115236673"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137862.png" alt="image-20201015115252972"></p><p>动态与静态的区别</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137135.png" alt="image-20201015115831543"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137959.png" alt="image-20201015120108028"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032137362.png" alt="image-20201015120707150"></p><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><hr><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138058.png" alt="image-20201015144628691"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h4 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h4><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138728.png" alt="image-20201015145732275"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138344.png" alt="image-20201015150620067"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h4 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138342.png" alt="image-20201015152232158"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138603.png" alt="image-20201015152858146"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138172.png" alt="image-20201015153907268"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138132.png" alt="image-20201015154523036"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138199.png" alt="image-20201015155408692"></p><p><strong>广播</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138404.png" alt="image-20201015155440402"></p><p><strong>多个单播</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138655.png" alt="image-20201015155526386"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138589.png" alt="image-20201015155706698"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138900.png" alt="image-20201015160146482"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138739.png" alt="image-20201015160526999"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138019.png" alt="image-20201015161015165"></p><h3 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h3><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139714.png" alt="image-20201015161458528"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032138052.png" alt="image-20201015162310922"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139151.png" alt="image-20201015162622462"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139175.png" alt="image-20201015163157140"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139956.png" alt="image-20201015164210543"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139732.png" alt="image-20201015170656500"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139056.png" alt="image-20201015170739679"></p><hr><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><h3 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139171.png" alt="image-20201015171453001"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139047.png" alt="image-20201015171515481"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139916.png" alt="image-20201015171900775"></p><h3 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032139764.png" alt="image-20201015172204419"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140370.png" alt="image-20201015202257756"></p><hr><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140175.png" alt="image-20201015202859124"></p><p><strong>分割广播域的方法</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140409.png" alt="image-20201015203113654"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140285.png" alt="image-20201015203559548"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140278.png" alt="image-20201015204639599"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140318.png" alt="image-20201015204749141"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140563.png" alt="image-20201015205311757"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140910.png" alt="image-20201015205947636"></p><p><strong>小例题</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140498.png" alt="image-20201015210417695"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140897.png" alt="image-20201015211031361"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140495.png" alt="image-20201015211349531"></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032140189.png" alt="image-20201015211512622"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol></blockquote><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><h3 id="封装成帧习题"><a href="#封装成帧习题" class="headerlink" title="封装成帧习题"></a>封装成帧习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141621.png" alt="image-20201011114856991"></p><h3 id="差错检测习题"><a href="#差错检测习题" class="headerlink" title="差错检测习题"></a>差错检测习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141534.png" alt="image-20201011235128869"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141798.png" alt="image-20201011235325022"></p><h3 id="可靠传输习题"><a href="#可靠传输习题" class="headerlink" title="可靠传输习题"></a>可靠传输习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062102392.png" alt="image-20201012181005719"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141698.png" alt="image-20201012182002090"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141804.png" alt="image-20201012202419107"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141578.png" alt="image-20201012205250996"></p><h3 id="媒体接入控制习题"><a href="#媒体接入控制习题" class="headerlink" title="媒体接入控制习题"></a>媒体接入控制习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141212.png" alt="image-20201013203459640"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141265.png" alt="image-20201013204352725"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141599.png" alt="image-20201013205054730"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141363.png" alt="image-20201013232656202"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141094.png" alt="image-20201013232840109"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141269.png" alt="image-20201013233632636"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141947.png" alt="image-20201014204557440"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141898.png" alt="image-20201014204839055"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032141187.png" alt="image-20201014204939865"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062102983.png" alt="image-20201014224410943"></p><h3 id="MAC地址、IP地址以及ARP协议习题"><a href="#MAC地址、IP地址以及ARP协议习题" class="headerlink" title="MAC地址、IP地址以及ARP协议习题"></a>MAC地址、IP地址以及ARP协议习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142430.png" alt="image-20201015110420372"></p><h3 id="以太网交换机自学习和转发帧的流程-1"><a href="#以太网交换机自学习和转发帧的流程-1" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142915.png" alt="image-20201015164846227"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142603.png" alt="image-20201015165218663"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142639.png" alt="image-20201015170131492"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142421.png" alt="image-20201017134630948"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142155.png" alt="image-20201017135644630"></p><ul><li>路由选择问题</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142899.png" alt="image-20201017135710478"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142162.png" alt="image-20201017135914985"></p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142418.png" alt="image-20201017142545630"></p><blockquote><p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142125.png" alt="image-20201017140623851"></p><hr><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li></ul><h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142954.png" alt="image-20201017141425892"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142664.png" alt="image-20201017141851030"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h3 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h3><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032142076.png" alt="image-20201017143206060"></p><h3 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143571.png" alt="image-20201017144317166"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143355.png" alt="image-20201017145210533"></p><p><strong>B类地址</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062102164.png" alt="image-20201017145508001"></p><p><strong>C类地址</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143066.png" alt="image-20201017150204774"></p><p><strong>练习</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143152.png" alt="image-20201017150543386"></p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>IP 地址的指派范围</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143626.png" alt="image-20201017152911541"></p><p><strong>一般不使用的特殊的 IP 地址</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143431.png" alt="image-20201017152959586"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><h4 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143914.png" alt="image-20201017154645198"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143642.png" alt="image-20201017154852896"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143283.png" alt="image-20201017155026814"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。</li></ul></blockquote><h4 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h4><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143325.png" alt="image-20201017155930011"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143933.png" alt="image-20201017160116239"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143413.png" alt="image-20201017160252066"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143377.png" alt="image-20201017161651058"></p><p>例子2</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032143929.png" alt="image-20201017161719339"></p><p><strong>默认子网掩码</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144827.png" alt="image-20201017162807076"></p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144957.png" alt="image-20201017162938612"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h4><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144773.png" alt="image-20201017164031532"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li></ul></blockquote><h4 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144818.png" alt="image-20201017165037268"></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144385.png" alt="image-20201017165113442"></p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144984.png" alt="image-20201017165615915"></p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144727.png" alt="image-20201017170552495"></p><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><h4 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144640.png" alt="image-20201018143550103"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144885.png" alt="image-20201018140809079"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144054.png" alt="image-20201018140916631"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144749.png" alt="image-20201018141132446"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p></blockquote><h4 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144829.png" alt="image-20201018143632352"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144019.png" alt="image-20201018142333145"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144315.png" alt="image-20201018143344440"></p><hr><h2 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144538.png" alt="image-20201018144335297"></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144393.png" alt="image-20201018151314019"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032144091.png" alt="image-20201018150151171"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145423.png" alt="image-20201018150223497"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062102692.png" alt="image-20201018145501063"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145850.png" alt="image-20201018150029179"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145151.png" alt="image-20201018151108989"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145272.png" alt="image-20201018151528027"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145885.png" alt="image-20201018151956275"></p><p>路由器是隔离广播域的</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145075.png" alt="image-20201018152040610"></p><hr><h2 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145422.png" alt="image-20201018155702081"></p><h3 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h3><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145136.png" alt="image-20201018160349375"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145293.png" alt="image-20201018160906284"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145925.png" alt="image-20201018161440257"></p><blockquote><p>多条路由可选，匹配路由最具体的</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145060.png" alt="image-20201018161542579"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145063.png" alt="image-20201018162041966"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103223.png" alt="image-20201018162333671"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145038.png" alt="image-20201018162759562"></p><p>错误情况</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145591.png" alt="image-20201018163323343"></p><p>解决方法</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145392.png" alt="image-20201018163933715"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145058.png" alt="image-20201018164453398"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032145273.png" alt="image-20201018164811811"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146199.png" alt="image-20201018164913684"></p><p>解决方法</p><p>添加故障的网络为黑洞路由</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146545.png" alt="image-20201018165122023"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146380.png" alt="image-20201018165153517"></p><p>假设。一段时间后故障网络恢复了</p><p>R1又自动地得出了其接口0的直连网络的路由条目</p><p>针对该网络的黑洞网络会自动失效</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146323.png" alt="image-20201018165328319"></p><p>如果又故障</p><p>则生效该网络的黑洞网络</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146375.png" alt="image-20201018165521938"></p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146543.png" alt="image-20201018165709294"></p><hr><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146916.png" alt="image-20201019134827343"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146505.png" alt="image-20201019134946971"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146310.png" alt="image-20201019135122326"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146733.png" alt="image-20201019135328925"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146209.png" alt="image-20201019140009740"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146950.png" alt="image-20201019140234652"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146852.png" alt="image-20201019141149194" style="zoom:50%;" /><p>物理层将信号转换成比特流，送交数据链路层处理</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146584.png" alt="image-20201019141210774" style="zoom: 50%;" /><p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146443.png" alt="image-20201019141242246" style="zoom:50%;" /><p>  如果送交网络层的分组是普通待转发的数据分组</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146012.png" alt="image-20201019141305650" style="zoom:50%;" /><p>   则根据分组首部中的目的地址进行查表转发</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146996.png" alt="image-20201019141327380" style="zoom:50%;" /><p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p></li><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032146712.png" alt="image-20201019141745375" style="zoom:50%;" /><p>数据链路层将数据分组封装成帧，交给物理层处理</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147738.png" alt="image-20201019141838032" style="zoom:50%;" /><p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p></li></ul><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147346.png" alt="image-20201019143040253"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147888.png" alt="image-20201019142228360" style="zoom:50%;" /><p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147781.png" alt="image-20201019142415055"></p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147895.png" alt="image-20201019142924889"></p></li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032147697.png" alt="image-20201019144915687"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032159586.png" alt="image-20201019145247606"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032159219.png" alt="image-20201019145510947"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032159339.png" alt="image-20201019145627339"></p><blockquote><p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200780.png" alt="image-20201019150120900"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200091.png" alt="image-20201019150412666"></p><p>举例2</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200777.png" alt="image-20201019150525711"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200128.png" alt="image-20201019151041492"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200717.png" alt="image-20201019151135255"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200320.png" alt="image-20201019151332767"></p><p>解决方法</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200545.png" alt="image-20201019151639181"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200548.png" alt="image-20201019152526098"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200244.png" alt="image-20201019161841695"></p><p><strong>问候（Hello）分组</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200585.png" alt="image-20201019161653875"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200277.png" alt="image-20201019162341151"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200131.png" alt="image-20201019162933483"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200046.png" alt="image-20201019163148068"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103702.png" alt="image-20201019163250129"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200953.png" alt="image-20201019163746254"></p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200826.png" alt="image-20201019164657606"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032200436.png" alt="image-20201019170100568"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201556.png" alt="image-20201019170217622"></p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201816.png" alt="image-20201019191438399"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201342.png" alt="image-20201019191718506"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201443.png" alt="image-20201019191836397"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201643.png" alt="image-20201019192031087"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201648.png" alt="image-20201019192059962"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201534.png" alt="image-20201019192840368"></p><h3 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201784.png" alt="image-20201019192800829"></p><hr><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><h3 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201646.png" alt="image-20201019205931748"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201149.png" alt="image-20201019211719880"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201065.png" alt="image-20201019212617006"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201308.png" alt="image-20201019220435415"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201665.png" alt="image-20201019221021157"></p><p>​        现在假定分片2的IP数据报经过某个网络时还需要进行分片</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201471.png" alt="image-20201019221246870"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201363.png" alt="image-20201019222512112"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032201290.png" alt="image-20201019222552444"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202265.png" alt="image-20201019222729797"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202402.png" alt="image-20201019223101434"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202510.png" alt="image-20201019225141559"></p><hr><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202306.png" alt="image-20201019232539898"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202517.png" alt="image-20201020001035813"></p><h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202270.png" alt="image-20201019230838587"></p><h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202289.png" alt="image-20201019231022291"></p><h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202565.png" alt="image-20201019231230798"></p><h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202256.png" alt="image-20201019231355471"></p><h4 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202910.png" alt="image-20201019231553990"></p><h4 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202227.png" alt="image-20201019231733673"></p><h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202208.png" alt="image-20201019233817921"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202658.png" alt="image-20201019234123026"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032202439.png" alt="image-20201019234718107"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203184.png" alt="image-20201019234741268"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203507.png" alt="image-20201019234758693"></p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203373.png" alt="image-20201019234909146"></p><hr><h2 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h3><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203221.png" alt="image-20201019235534728"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203199.png" alt="image-20201019235631474"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203051.png" alt="image-20201019235718010"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203532.png" alt="image-20201020000136443"></p><blockquote><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203609.png" alt="image-20201020000618797"></p><p>部门A向部门B发送数据流程</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203083.png" alt="image-20201020001107425"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203813.png" alt="image-20201020001528569"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203256.png" alt="image-20201020001935801"></p><h3 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203331.png" alt="image-20201020002020607"></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203215.png" alt="image-20201020002439942"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203339.png" alt="image-20201020002734192"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203296.png" alt="image-20201020003238729"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203259.png" alt="image-20201020003411024"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203895.png" alt="image-20201020003658349"></p><p>这种基本转换存在一个问题</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203017.png" alt="image-20201020003733863"></p><p>解决方法</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032203526.png" alt="image-20201020003840584"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204315.png" alt="image-20201020004159360"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204805.png" alt="image-20201020004312942"></p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204532.png" alt="image-20201020004447021"></p><h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><h3 id="IPv4习题"><a href="#IPv4习题" class="headerlink" title="IPv4习题"></a>IPv4习题</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204392.png" alt="image-20201017151024579"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204149.png" alt="image-20201017151500372"></p><blockquote><p>题目的注意点</p><p><strong>本题按照节约原则</strong></p><p>路由器的接口也要分配一个IP地址</p><p>所以橙色网络的IP地址数量是 65534 + 1 &#x3D; 65535，同理 蓝色网络的是 255 个，绿色网络（交换式以太网）的是 16 + 24 + 1 &#x3D; 41 个，红色网络（两台路由器通过一段链路直连，它们的直连接口也属于一个网络）是 2 个</p><p>分配IP地址不能相同</p><p>不能出现两个一样的网络号</p></blockquote><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204613.png" alt="image-20201017161733295"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204915.png" alt="image-20201017162644758"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204956.png" alt="image-20201017165224804"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204998.png" alt="image-20201017170339534"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204982.png" alt="image-20201017170516701"></p><h3 id="IP数据报的发送和转发过程-1"><a href="#IP数据报的发送和转发过程-1" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204474.png" alt="image-20201018152326777"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204995.png" alt="image-20201018152504951"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103142.png" alt="image-20201018152811812"></p><h3 id="路由选择协议-1"><a href="#路由选择协议-1" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204524.png" alt="image-20201019150738458"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204229.png" alt="image-20201019152221295"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204574.png" alt="image-20201019192349770"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204352.png" alt="image-20201019192546327"></p><h3 id="IPv4数据报的首部格式-1"><a href="#IPv4数据报的首部格式-1" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032204163.png" alt="image-20201019223719168"></p><blockquote><p>780&#x2F;8向下取整等于97</p><p>97*8 &#x3D; 776</p></blockquote><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205086.png" alt="image-20201019224949922"></p><h3 id="网际控制报文协议ICMP-1"><a href="#网际控制报文协议ICMP-1" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205294.png" alt="image-20201019232300815"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p><strong>进程之间的通信</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205838.png" alt="image-20201020211725185" style="zoom:67%;" /><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205927.png" alt="image-20201020211339131"></p><p><strong>进程之间通信流程</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205734.png" alt="image-20201020213721054"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205206.png" alt="image-20201020220439303"></p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205023.png" alt="image-20201020220545411"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205119.png" alt="image-20201020222828878"></p><hr><h2 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h2><h3 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205780.png" alt="image-20201020223242364"></p><h3 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205662.png" alt="image-20201020223920225"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h3 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205858.png" alt="image-20201020224521744"></p><h3 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h3><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205262.png" alt="image-20201020224658524"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205805.png" alt="image-20201020225830336"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205637.png" alt="image-20201020230059196"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205063.png" alt="image-20201020231032812"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205474.png" alt="image-20201020231308120"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205335.png" alt="image-20201020231935656"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205940.png" alt="image-20201020232517383"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032205718.png" alt="image-20201020232132890"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206490.png" alt="image-20201020232548833"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206268.png" alt="image-20201020232337332"></p><hr><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li></ul><p>可靠信道与不可靠信道</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206322.png" alt="image-20201021192221061"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206996.png" alt="image-20201021193640130"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h3 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h3><p>可以发送广播</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206740.png" alt="image-20201021194104694" style="zoom: 50%;" /><p>可以向某个多播组发送多播</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206379.png" alt="image-20201021194225567" style="zoom:50%;" /><p>还可以发送单播</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206513.png" alt="image-20201021194341256" style="zoom:50%;" /><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206431.png" alt="image-20201021195034383"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206471.png" alt="image-20201021204152175"></p><p>UDP结构</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206342.png" alt="image-20201021205214512"></p><h3 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h3><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206928.png" alt="image-20201021194557102" style="zoom:50%;" /><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206359.png" alt="image-20201021194749562" style="zoom:50%;" /><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206050.png" alt="image-20201021195435677"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206491.png" alt="image-20201021204508839"></p><p>TCP结构</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032206112.png" alt="image-20201021205307406"></p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032207577.png" alt="image-20201023004653315"></p><hr><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032207073.png" alt="image-20201021223432091"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032207882.png" alt="image-20201021231801076"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205032207604.png" alt="image-20201021231904707"></p><p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103829.png" alt="image-20201021231945653"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103375.png" alt="image-20201021232027721"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103814.png" alt="image-20201021232600497"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103574.png" alt="image-20201021232645300"></p><blockquote><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></blockquote><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103652.png" alt="image-20201021234004254"></p><hr><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103929.png" alt="image-20201022141057083"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062103604.png" alt="image-20201022142108309"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104447.png" alt="image-20201022141423443"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104250.png" alt="image-20201022141556134"></p><blockquote><p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><h5 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h5><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109242.png" alt="image-20201022145631052"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104406.png" alt="image-20201022144725100"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104418.png" alt="image-20201022150143886"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104769.png" alt="image-20201022145749592"></p><p>这个时候又回到了慢开始</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104855.png" alt="image-20201022145544163"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104111.png" alt="image-20201022145824004"></p><h5 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h5><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104118.png" alt="image-20201022150236926"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104896.png" alt="image-20201022150902709"></p><h5 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h5><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109112.png" alt="image-20201022151250183"></p><h5 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h5><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104801.png" alt="image-20201022151819265"></p><h5 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h5><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104335.png" alt="image-20201022152041751"></p><hr><h2 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104854.png" alt="image-20201022152651184"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104075.png" alt="image-20201022152708875"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104379.png" alt="image-20201022153244047"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104395.png" alt="image-20201022153518218"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104356.png" alt="image-20201022153758413"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104634.png" alt="image-20201022154045440"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104875.png" alt="image-20201022154137911"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104017.png" alt="image-20201022154350745"></p><p><strong>总结</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062104292.png" alt="image-20201022154418863"></p><hr><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105424.png" alt="image-20201022161436801"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105231.png" alt="image-20201022161734997"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105357.png" alt="image-20201022164339902"></p><hr><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105494.png" alt="image-20201022193215183"></p><h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h4 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109760.png" alt="image-20201022193418673"></p><h4 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105786.png" alt="image-20201022194219693"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105116.png" alt="image-20201022194350899"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105666.png" alt="image-20201022194926877"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105383.png" alt="image-20201022195108616"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105987.png" alt="image-20201022195847144"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105453.png" alt="image-20201022202010182"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105501.png" alt="image-20201022202932905"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105669.png" alt="image-20201022203744174"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105664.png" alt="image-20201022204422775"></p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h4 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105712.png" alt="image-20201022205124204"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105153.png" alt="image-20201022210030419"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105425.png" alt="image-20201022232158631"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105761.png" alt="image-20201022233050922"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105795.png" alt="image-20201022233941557"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105899.png" alt="image-20201022234741310"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105753.png" alt="image-20201022234942562"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h4 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h4><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105118.png" alt="image-20201022235800155"></p><hr><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105209.png" alt="image-20201023000859363"></p><h3 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><p>源端口和目的端口</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105005.png" alt="image-20201023005210010"></p><p>序号、确认号和确认标志位</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062105887.png" alt="image-20201023003826059"></p><p>数据偏移、保留、窗口和校验和</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106212.png" alt="image-20201023004227265"></p><p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106148.png" alt="image-20201023005001450"></p><p>选项和填充</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106152.png" alt="image-20201023005132426"></p><h2 id="TCP的流量控制-1"><a href="#TCP的流量控制-1" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106867.png" alt="image-20201021233918057"></p><h2 id="TCP的拥塞控制-1"><a href="#TCP的拥塞控制-1" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109288.png" alt="image-20201022152255103"></p><h2 id="TCP可靠传输的实现-1"><a href="#TCP可靠传输的实现-1" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106986.png" alt="image-20201022163045361"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106939.png" alt="image-20201022164057627"></p><h2 id="TCP的运输连接管理-1"><a href="#TCP的运输连接管理-1" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106225.png" alt="image-20201022204336098"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106569.png" alt="image-20201023195112701"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106908.png" alt="image-20201023200511781"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106981.png" alt="image-20201023200819770"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106076.png" alt="image-20201023201028141"></p><p>常见的应用</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106165.png" alt="image-20201023201101024"></p><p>总结</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106303.png" alt="image-20201023201137047"></p><hr><h2 id="客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h2><h3 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106479.png" alt="image-20201023201308269"></p><h3 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106472.png" alt="image-20201023201610088"></p><h3 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106650.png" alt="image-20201023202017683"></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106641.png" alt="image-20201023202049202"></p><hr><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h3 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h3><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h3 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h3><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106291.png" alt="image-20201023205719672"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106375.png" alt="image-20201023210345650"></p><h3 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h3><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062110903.png" alt="image-20201023211525686"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062106009.png" alt="image-20201023213058543"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062110726.png" alt="image-20201023214542329"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107981.png" alt="image-20201023215341522"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107820.png" alt="image-20201023215652859"></p></blockquote><p>剩下流程图示</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107359.png" alt="image-20201023220114952"></p><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107631.png" alt="image-20201023221111923"></p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107088.png" alt="image-20201023221251022"></p><hr><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>域名相比IP地址更容易记忆</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107866.png" alt="image-20201023234832678"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107594.png" alt="image-20201023235123151"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107384.png" alt="image-20201023235231869"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107412.png" alt="image-20201023235457857"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062110026.png" alt="image-20201023235617575"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107303.png" alt="image-20201023235910545"></p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107162.png" alt="image-20201024000255580"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107018.png" alt="image-20201024000335147"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107997.png" alt="image-20201024000408396"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107763.png" alt="image-20201024002135210"></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107450.png" alt="image-20201024002224354"></p><hr><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107047.png" alt="image-20201024132745558"></p><h3 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h3><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107714.png" alt="image-20201024133155327" style="zoom:50%;" /><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107071.png" alt="image-20201024133247537" style="zoom:50%;" /><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107982.png" alt="image-20201024133400777"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107875.png" alt="image-20201024133601943"></p><h3 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h3><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107109.png" alt="image-20201024134319922"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062110318.png" alt="image-20201024134624114"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107237.png" alt="image-20201024135018620" style="zoom:67%;" /><p>两种模式对比</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062107529.png" alt="image-20201024135050743"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108898.png" alt="image-20201024135848563"></p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108116.png" alt="image-20201024151757221"></p><h3 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108781.png" alt="image-20201024152052056"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108941.png" alt="image-20201024152628966"></p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108716.png" alt="image-20201024153425016"></p><h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108381.png" alt="image-20201024153736033"></p><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108265.png" alt="image-20201024154039565"></p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108299.png" alt="image-20201024154744175"></p><hr><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h3><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108341.png" alt="image-20201024170819303"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108866.png" alt="image-20201024171432743"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108120.png" alt="image-20201024170923530"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108679.png" alt="image-20201024171058583"></p><p><strong>万维网的文档</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108199.png" alt="image-20201024171724030"></p><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h3><h4 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h4><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108275.png" alt="image-20201024222457800"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108924.png" alt="image-20201024222825888"></p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><strong>HTTP请求报文格式</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108707.png" alt="image-20201024224828528"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108837.png" alt="image-20201024224920638"></p><h4 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108083.png" alt="image-20201024224945200"></p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108970.png" alt="image-20201024224632514"></p><p>如果该请求有缓存</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108019.png" alt="image-20201024224720124"></p><p>如果该请求没有缓存</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108709.png" alt="image-20201024225013288"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062108683.png" alt="image-20201024225504869"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109037.png" alt="image-20201024225846863"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109122.png" alt="image-20201024230242550"></p><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109946.png" alt="image-20201024231143505"></p><h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><h3 id="域名系统DNS-1"><a href="#域名系统DNS-1" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109103.png" alt="image-20201024000627823"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109876.png" alt="image-20201024002135210"></p><h3 id="文件传送协议FTP-1"><a href="#文件传送协议FTP-1" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109711.png" alt="image-20201024135242632"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109336.png" alt="image-20201024135740064"></p><h3 id="电子邮件-1"><a href="#电子邮件-1" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109425.png" alt="image-20201024154357384"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109231.png" alt="image-20201024154637025"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109217.png" alt="image-20201024154704101"></p><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109301.png" alt="image-20201024230522020"></p><hr><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109729.png" alt="image-20201024230846111"></p><h1 id="网络是怎么连接的"><a href="#网络是怎么连接的" class="headerlink" title="网络是怎么连接的"></a>网络是怎么连接的</h1><h2 id="0、大致流程"><a href="#0、大致流程" class="headerlink" title="0、大致流程"></a>0、大致流程</h2><ul><li>首先，用户输入网址</li><li><strong>浏览器</strong>解析网址，生成HTTP消息并转交给Socket库</li><li><strong>Socket库</strong>将收到 的HTTP消息作为数据转交给协议栈</li><li><strong>TCP</strong>按照网络包的长度对数据进行拆分，在每个包前面加上TCP头部并转交给IP——【TCP-HTTP数据块】</li><li><strong>IP</strong>在TCP包前加上IP头部，然后查询MAC地址并加上MAC头部，然后将包转交给网卡驱动——【MAC-IP-TCP-HTTP数据块】</li><li><strong>网卡驱动</strong>收到IP发来的包，将其转交给网卡并发出发送指令</li><li><strong>网卡</strong>检查以太网的可发送状态，将包转换成电信号，通过双绞线发送出去</li><li>信号通过<strong>双绞线</strong>到达集线器</li><li><strong>集线器</strong>将信号广播到所有端口，信号会到达交换机</li><li><strong>交换机</strong>根据收到的包的接收方MAC地址查询自身的地址表，找到输出端口，并将包转发到输出端口——【IP-TCP-HTTP数据块】</li><li><strong>互联网接入路由器</strong>根据收到的包的接收方IP地址查询自身的路由表，找到输出端口，并将包转发到输出端口（互联网接入路由器输出到互联网的包带有PPPoE头部和PPP头部）——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li><strong>ADSL Modem</strong>将收到的包拆分成ATM信元，然后转换成电信号通过电话线发送到电话局的DSLAM</li><li><strong>DSLAM</strong>（局端多路Modem）将收到的电信号还原成ATM信号并发送给BAS</li><li><strong>BAS</strong>将ATM信元还原成网络包，根据接收方IP地址进行转发——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li>BAS转发的包加上L2TP头部并通过<strong>隧道</strong>——【L2TP-PPP-IP-TCP-HTTP数据块】</li><li>网络包到达位于隧道出口的隧道路由器，L2TP头部和PPP头部被丢弃，通过互联网流向Web服务器【MAC-IP-TCP-HTTP数据块】</li><li>服务器端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过。Web服务器前面如果有缓存服务器，会拦截通过防火墙的包。如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据。如果请求的页面没有被缓存，缓存服务器会将请求转发给Web服务器</li><li>Web服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈</li><li>协议栈依次检查IP头部和TCP头部，如果没有问题则取出HTTP消息的数据进行组装</li><li>HTTP消息被恢复成原始状态，然后通过Socket库转交给Web服务器，Web服务器分析HTTP信息的内容，并根据请求内容将读取的数据返回给客户端</li></ul><h2 id="一、浏览器生成消息"><a href="#一、浏览器生成消息" class="headerlink" title="一、浏览器生成消息"></a><strong>一、浏览器生成消息</strong></h2><h3 id="1-生成HTTP-1-请求消息"><a href="#1-生成HTTP-1-请求消息" class="headerlink" title="1.生成HTTP[^1]请求消息"></a>1.生成HTTP[^1]请求消息</h3><p>当使用浏览器输入网址时，浏览器首先会对URL[^2]进行解析，（URL有多种格式<a href="%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%B1%E4%BA%8E%E5%BC%80%E5%A4%B4%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%EF%BC%8CFTP%E5%8D%8F%E8%AE%AE%EF%BC%8Cfile%EF%BC%88%E8%AF%BB%E5%8F%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8Cmallto%EF%BC%88%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%89%E7%AD%89%EF%BC%8C%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82%E5%85%B6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%90%8E%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9C%81%E7%95%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%8B%E5%85%88%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%B3%E4%B8%BB%E9%A1%B5%E3%80%82">^3</a>）浏览器由此可确定服务器的域名和文件名，接下来便根据这些信息生成HTTP请求消息，</p><p>[^2]: URL:Uniforn Resource Locator,统一资源定位符，即网址。<br>[^1]: HTTP:Hypertext Transfer Protocol,超文本传送协议</p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109442.jpg" alt="网络连接大致流程1"></p><p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205062109530.jpg" alt="网络连接大致流程2"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机操作系统</title>
      <link href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="一、初识操作系统"><a href="#一、初识操作系统" class="headerlink" title="一、初识操作系统"></a>一、初识操作系统</h1><h3 id="操作系统是什么？"><a href="#操作系统是什么？" class="headerlink" title="操作系统是什么？"></a>操作系统是什么？</h3><p><strong>操作系统（Operating System，OS）</strong>：是指控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p><p>用户角度：操作系统是一个<strong>控制软件</strong></p><ul><li>管理应用程序</li><li>为应用程序提供服务</li><li>杀死应用程序</li></ul><p>程序角度：操作系统是<strong>资源管理器</strong></p><ul><li>管理外设、分配资源</li><li>抽象<ul><li>将CPU抽象成进程</li><li>将磁盘抽象成文件</li><li>将内存抽象成地址空间</li></ul></li></ul><p><strong>操作系统层次</strong>：位于硬件之上，应用程序之下</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p><strong>接口：操作系统为用户和计算机之间的交互提供接口</strong></p><ul><li><strong>命令接口</strong>：允许用户直接使用<ul><li><strong>联机命令接口</strong>：交互式命令接口，“说一句，做一句”</li><li><strong>脱机命令接口</strong>：批处理命令接口，“说一堆，做一堆”</li></ul></li><li>程序接口：允许用户通过程序间接使用，也叫<strong>系统调用</strong>，广义指令；</li><li>CUI：图形化用户接口</li></ul><p><strong>内部组件</strong>：</p><ul><li>CPU调度器</li><li>物理内存管理</li><li>虚拟内存管理</li><li>文件系统管理</li><li>中断处理与设备驱动</li></ul><h3 id="四大特征"><a href="#四大特征" class="headerlink" title="四大特征"></a>四大特征</h3><ul><li><p><strong>并发</strong></p><ul><li><p>一段时间内运行多个进程，宏观上是同时发生的，但微观上仍是交替发生的</p><blockquote><p>并行 : 一个时间点运行多个进程，一般要求有多个CPU</p></blockquote></li><li><p>需要OS管理和调度</p></li></ul></li><li><p><strong>共享</strong></p><p>指资源共享，是指系统中的资源能让内存中的多个并发执行的进程共同使用；</p><ul><li>“同时”共享：一个时间段内只允许多个进程访问该资源，“同时”一般是宏观的；</li><li>互斥共享：一个时间段内只允许一个进程访问该资源；</li></ul></li><li><p><strong>虚拟</strong></p><p>虚拟 是指把物理上的实体转变为若干个逻辑上的对应物，让每一个用户觉得的有一个计算机专门为他服务；</p><blockquote><p>并发是虚拟的前提，如果没有并发性，则一段时间内只运行一道程序，就没有实现虚拟性的必要了。</p></blockquote><ul><li>空分复用技术：虚拟存储器技术</li><li>时分复用技术：如虚拟处理器</li></ul></li><li><p><strong>异步</strong></p><p>多个程序并发执行，由于资源有限，进程是走走停停，而不是一直运行的；</p><blockquote><p>并发是异步性的前提。</p></blockquote></li></ul><h3 id="OS的发展"><a href="#OS的发展" class="headerlink" title="OS的发展"></a>OS的发展</h3><ul><li><p>手工操作阶段：</p><ul><li>缺点：人机速度矛盾；</li></ul></li><li><p>批处理阶段：<strong>单道批处理系统</strong></p><p>引入脱机输入输出技术，并监督程序的输入输出（操作系统雏形）</p><ul><li>优点：缓解人机速度矛盾；</li><li>缺点：内存中只有一道程序运行，CPU有大量空闲时间等待IO完成，资源利用率依然很低；</li></ul></li><li><p>批处理阶段：<strong>多道批处理系统</strong></p><ul><li><p>优点：<strong>多道程序并发执行，共享计算机资源</strong>。资源利用率大幅提升，系统吞吐量增大；</p></li><li><p>缺点：等待用户响应时间长，且<strong>没有人机交互功能</strong>；</p></li></ul></li><li><p><strong>分时操作系统</strong></p><p>计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户&#x2F;作业服务，用户可以通过终端与计算机交互。</p><ul><li>优点：用户请求可以被<strong>及时响应，解决了人机交互问题</strong>。允许多个用户同时使用同一台计算机，且用户间的操作互相独立，不会相互影响；</li><li>不能优先处理一些紧急任务，OS对所有的用户完全公平，<strong>不能区分任务的优先度</strong>；</li></ul></li><li><p><strong>实时操作系统</strong></p><p>实时操作系统 能在严格的时限内处理事件，特点是及时性、可靠性；</p><ul><li>优点：能优先响应一些紧急任务；</li></ul></li></ul><h3 id="OS内容"><a href="#OS内容" class="headerlink" title="OS内容"></a>OS内容</h3><h4 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h4><p>两种指令</p><blockquote><p>指令是指 CPU处理器能识别、执行的最基本命令，一条高级语言的代码可能会对应对条指令</p></blockquote><ul><li><strong>特权指令</strong>：不允许用户使用的指令，如内存清零指令；</li><li><strong>非特权指令</strong>：如普通的运算指令；</li></ul><p>两种处理器状态</p><blockquote><p>程序状态寄存器PSW中断有一个标志位 用于标识当前CPU处于什么状态，如：0为用户态，1为核心态。</p></blockquote><ul><li><strong>核心态（管态）</strong>：可以执行特权指令、非特权指令；</li><li><strong>用户态（目态）</strong>：只能执行非特权指令；</li></ul><p>两种程序</p><ul><li><strong>内核程序</strong>：是系统的管理者，运行在核心态，特权、非特权指令都能指令；</li><li><strong>应用程序</strong>：运行在用户态，为了系统安全，只能执行非特权指令；</li></ul><h4 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h4><p>内核是计算机上的底层软件，是操作系统最基本，最核心的部分；</p><p>内核程序：实现内核功能的程序；</p><ul><li><p><strong>时钟管理</strong>：实现计时功能；</p></li><li><p><strong>中断处理</strong>：负责实现中断机制；</p></li><li><p><strong>原语</strong>：是一种特殊的程序，处于操作系统最底层，是最接近硬件的部分；这种程序速度运行具有<strong>原子性</strong>——其运行不可中断；特点：运行时间短，调用频繁；</p><blockquote><p>原语的原子性，即运行不可中断，由关中断指令，开中断指令来完成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关中断指令;</span><br><span class="line">原语代码1#暂时屏蔽中断</span><br><span class="line">原语代码2</span><br><span class="line">开中断指令;</span><br><span class="line">代码...</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>对系统资源的管理</strong>（有些时候不被划分在内核中）</p><ul><li>进程管理</li><li>存储器管理</li><li>设备管理</li></ul></li></ul><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p>操作系统有两种体系结构：大内核，微内核</p><ul><li><p><strong>大内核</strong></p><p>将操作系统的主要功能模块作为系统内核，运行在核心态；</p><p>优点：高性能</p><p>缺点：内核代码庞大，结构混乱，难以维护</p></li><li><p><strong>微内核</strong></p><p>只把最基本的功能保留在内核；</p><p>优点：内核功能少，结构清晰，方便维护</p><p>缺点：性能低，需频繁在核心态和用户态之间切换</p></li></ul><h1 id="二、中断、系统调用"><a href="#二、中断、系统调用" class="headerlink" title="二、中断、系统调用"></a>二、中断、系统调用</h1><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断是为了实现多道程序并发执行而引入的一种技术，发生中断，就意味着需要系统介入开展管理工作；</p><p>当<strong>发生中断时，CPU会立即进入核心态</strong>；在<strong>中断发生后，当前运行的进程暂停</strong>，并交由操作系统内核对中断进行处理；</p><p><strong>中断是用户态到核心态的唯一途径</strong>；而核心态到用户态，通过执行一个特权指令，将PSW的标志位设置为“用户态”；</p><p><strong>中断分类</strong></p><ul><li><p>内中断（异常、例外、陷入）</p><ul><li>自愿中断：指令中断，如：系统调用时的访管指令（陷入指令&#x2F;trap指令）；</li><li>强迫中断：硬件中断（如缺页），软件中断（如整数除0）；</li></ul><blockquote><p>内中断 也可分为：陷入trap，故障fault，终止abort；</p><p>陷入：有意为之的异常，如系统调用；</p><p>故障：由错误条件引起的，可以被故障处理程序修复，如缺页；</p><p>终止：不可修复的致命错误造成的结果，如整数除0；</p></blockquote></li><li><p>外中断</p><ul><li>外设请求：如IO操作完成发出的中断信号；</li><li>人工干预：用户强行终止一个进程；</li></ul></li></ul><p><strong>外中断处理过程</strong></p><ol><li>执行完每个指令后，CPU都要检查当前是否有外部中断信号；</li><li>如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC，各种通用寄存器）；</li><li>根据中断信号类型转入相应的中断处理程序；</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续往下执行；</li></ol><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>概念：应用程序通过<strong>系统调用</strong>请求操作系统的服务。</p><p>用户通过程序 间接 使用系统调用功能，系统调用在核心态中执行。</p><p><strong>作用：</strong></p><blockquote><p>系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作(如存储分配， I&#x2F;O操作、文件管理等)，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。</p><p>这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</p></blockquote><p><strong>功能分类</strong></p><ul><li>设备管理：完成设备的请求&#x2F;释放&#x2F;启动 等功能</li><li>文件管理：完成文件的读&#x2F;写&#x2F;创建&#x2F;删除 等功能</li><li>进程控制：完成进程的创建&#x2F;撒销&#x2F;阻塞&#x2F;唤醒 等功能</li><li>进程通信：完成进程之间的消息传递&#x2F;信号传递 等功能</li><li>内存管理：完成内存的 分配&#x2F;回收 等功能</li></ul><p><strong>系统调用与库函数的区别</strong></p><table><thead><tr><th>普通应用程序</th><th>可直接进行系统调用，也可使用库函数。有的库函数包含系统调用，有的不涉及</th></tr></thead><tbody><tr><td>编程语言</td><td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</td></tr><tr><td>操作系统</td><td>向上提供系统调用</td></tr><tr><td>裸机</td><td></td></tr></tbody></table><p><strong>过程：</strong></p><ol><li>传递系统调用参数；</li><li>执行陷入指令（陷入指令在<strong>用户态</strong>下执行，执行完后立即<strong>引发一个内中断，使CPU进入核心态</strong>）；</li><li>执行系统调用相应服务程序（<strong>核心态</strong>）；</li><li>返回用户程序；</li></ol><blockquote><p><strong>陷入指令（访管指令）</strong>：用于<strong>让用户态进入核心态</strong>，是唯一一个只能在用户态使用，<strong>不能在核心态使用</strong>的指令。</p></blockquote><p><strong>特点</strong></p><ul><li>通常情况下，每个系统调用有对应的序号<ul><li>系统调用接口根据这些序号来维护表的索引</li></ul></li><li>系统调用接口调用内核态中预期的系统调用<ul><li>并返回系统调用的状态和其他任何返回值</li></ul></li><li>用户不需要知道系统调用是如何实现的<ul><li>只需要获取API和了解操作系统将什么作为返回结果</li><li>操作系统接口的细节大部分都隐藏在API中</li></ul></li></ul><p><strong>对于这些操作需要 跨越操作系统边界的开销，是值得的且必须的（保证了操作系统的安全性）</strong></p><ul><li>前提：程序在执行时间上的开销远超过程序调用的开销。</li><li>开销：<ul><li>建立中断、异常、系统调用与对应服务例程映射关系的初始化开销</li><li>建立内核堆栈</li><li>验证参数</li><li>内核态映射到用户态的地址空间（更新页面映射权限）</li><li>内核态独立地址空间（TLB）</li></ul></li></ul><p><strong>中断，异常，系统调用的区别：</strong></p><table><thead><tr><th>类型</th><th>源头</th><th>处理时间</th><th>响应</th></tr></thead><tbody><tr><td>中断</td><td>外设</td><td>异步</td><td>持续，对应用程序透明</td></tr><tr><td>异常</td><td>应用程序意向不到的行为</td><td>同步</td><td>杀死或重新执行指令</td></tr><tr><td>系统调用</td><td>应用程序请求系统提供服务</td><td>同步或异步</td><td>等待和持续</td></tr></tbody></table><blockquote><p>  异步：应用程序不知道什么时候会发生中断</p><p>  同步：执行到某一条指令一定会发生该事件</p></blockquote><p>为什么应用程序不能直接访问硬件？</p><ul><li>在计算机运行时，内核是被信任的第三方</li><li>只有内核可以执行特权指令</li><li>为了方便应用程序</li></ul><h1 id="三、内存管理"><a href="#三、内存管理" class="headerlink" title="三、内存管理"></a>三、内存管理</h1><p><strong>计算机体系结构</strong></p><ol><li>CPU</li><li>内存</li><li>I&#x2F;O</li></ol><h2 id="内存分层体系"><a href="#内存分层体系" class="headerlink" title="内存分层体系"></a>内存分层体系</h2><p>存储器：运行内存(主存) 和 磁盘(虚拟内存)。 主存是在运行程序时所需要保存的数据空间，而磁盘是用于持久化数据保存的数据空间.</p><p>CPU可以访问的内存包括两大类 : 寄存器 &#x2F; cache(L1缓存 &#x2F; L2缓存)</p><p><strong>层次</strong></p><p>微处理器(CPU访问)</p><p>CPU寄存器 &#x2F; L1缓存</p><p>L2缓存</p><p>主存(程序访问)</p><p>磁盘(程序访问)</p><blockquote><p>  从CPU寄存器到磁盘，读写速度不断降低，单位成本不断降低，大小不断增大。</p></blockquote><p><strong>内存管理目标</strong></p><ul><li>抽象：逻辑地址空间</li><li>保护：独立地址空间</li><li>共享：访问相同内存</li><li>虚拟：更多的地址空间</li></ul><p>内存保护：即保证程序在内存中不会超出规定的范围，有两种方式：</p><ul><li>设置上下限寄存器；</li><li>利用重定位寄存器，界地址寄存器进行判断；</li></ul><p><strong>内存管理方法</strong></p><ul><li>程序重定位</li><li>分段</li><li>分页</li><li>虚拟内存</li><li>按需分页虚拟内存</li></ul><blockquote><p>  实现高度依赖于硬件, 其中内存管理单元(MMU)负责处理CPU的内存访问请求</p></blockquote><p><strong>地址空间</strong></p><p>地址空间的定义</p><ul><li>物理地址空间 —— 硬件支持的地址空间</li><li>逻辑地址空间 —— 一个运行在程序所拥有的的内存范围</li></ul><h2 id="程序运行原理"><a href="#程序运行原理" class="headerlink" title="程序运行原理"></a>程序运行原理</h2><p>从写程序到程序运行：</p><ol><li>编辑源代码</li><li><strong>编译</strong>：由源代码文件生成目标文件；</li><li><strong>链接</strong>：由目标模块生成装入模块，链接后形成完整的逻辑地址；</li><li><strong>装入</strong>：将装入模块装入内存，装入后形成物理地址；</li></ol><p>三种链接方式：</p><ul><li>静态链接：装入前形成一个完整的装入模块；</li><li>装入时动态链接：运行时边装入边链接；</li><li>运行时动态链接：运行时需要目标模块才能装入并链接；</li></ul><p>三种装入方式：</p><ul><li>绝对装入：编译时产生绝对地址；（单道批处理阶段使用）</li><li>可重定位装入：装入时将逻辑地址转换为物理地址；（早期的多道批处理操作系统使用）</li><li>动态运行装入：运行时将逻辑地址转换为物理地址，需设置重定位寄存器；（现代操作系统）</li></ul><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p><strong>连续分配</strong></p><p>存在 内存碎片问题：内存碎片问题指的是空闲的内存无法被利用</p><ul><li>外部碎片 : 分配单元间的未使用内存</li><li>内部碎片 : 分配单元内的未使用内存</li></ul><p><strong>分区的动态分配</strong></p><p>分区的动态分配方式有以下三种 :</p><ol><li><p><strong>首次适应算法</strong> : 空闲区按地址递增顺序排序，在内存中找到第一个满足需求的空闲块, 分配给应用程序</p><p>（<strong>临近适应算法</strong>：和首次适应算法相似，但避免每次都要经过低地址的很多小碎片区，每次查找都从上次查找结束的位置开始）</p></li><li><p><strong>最佳适应算法</strong> : 空闲区按尺寸从小到大排序，在内存中找到最小的空闲块, 分配给应用程序</p></li><li><p><strong>最坏适应算法</strong> : 空闲区按尺寸从大到小排序，在内存中找到最大的空闲块, 分配给应用程序</p></li></ol><p>分配方式的区别</p><table><thead><tr><th>分配方式</th><th>首次适应算法</th><th>最佳适应算法</th><th>最坏适应算法</th></tr></thead><tbody><tr><td>分配方式实现需求</td><td>1. 按地址排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td><td>1. 按尺寸排序的空闲块列表<br />2. 分配需要寻找一个合适的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td><td>1. 按尺寸排序的空闲块列表<br />2. 分配最大的分区<br />3. 重分配需要检查是否可以合并相邻空闲分区</td></tr><tr><td>优势</td><td>简单 &#x2F; 易于产生更大空闲块</td><td>比较简单 &#x2F; 大部分分配是小尺寸时高效</td><td>分配很快 &#x2F; 大部分分配是中尺寸时高效</td></tr><tr><td>劣势</td><td>产生外部碎片 &#x2F; 不确定性</td><td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 产生很多没用的微小碎片</td><td>产生外部碎片 &#x2F; 重分配慢 &#x2F; 易于破碎大的空闲块以致大分区无法被分配</td></tr></tbody></table><blockquote><p>  三种分配方式并无优劣之分，因为我们无法判断内存请求的大小</p></blockquote><h2 id="碎片整理方法"><a href="#碎片整理方法" class="headerlink" title="碎片整理方法"></a>碎片整理方法</h2><p>可以看到的是，三种分区动态分配的方式都会产生外部碎片，因此我们可以对碎片进行一定的整理来解决碎片问题。</p><ol><li><p>压缩式碎片整理</p><ul><li>重置程序以合并碎片</li><li>要求所有程序是动态可重置的</li><li>问题 : <ul><li>何时重置 ：在程序处于等待状态时才可以重置</li><li>需要考虑内存拷贝的开销</li></ul></li></ul></li><li><p>交换式碎片整理</p><ul><li><p>运行程序需要更多的内存时，抢占等待的程序并且回收它们的内存</p></li><li><p>问题 ：</p><ul><li>哪些程序应该被回收 ?</li></ul></li><li><p>情况 :</p><p>运行中 : P3</p><p>等待中 : P1 P2 P4</p><p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2 &#x2F; P4 磁盘 : 空</p><p>当P3程序需要更大的内存时 -&gt;</p><p>内存分布 -&gt; 主存 : OS &#x2F; P1 &#x2F; P3 &#x2F; P2         磁盘 : P4</p></li></ul></li></ol><h1 id="四、非连续内存分配"><a href="#四、非连续内存分配" class="headerlink" title="四、非连续内存分配"></a>四、非连续内存分配</h1><h2 id="非连续内存分配的必要性"><a href="#非连续内存分配的必要性" class="headerlink" title="非连续内存分配的必要性"></a>非连续内存分配的必要性</h2><p><strong>连续内存分配的缺点：</strong></p><ol><li>分配给一个程序的物理内存是连续的</li><li>内存利用率低</li><li>有外碎片 &#x2F; 内碎片的问题</li></ol><p><strong>非连续内存分配的优点：</strong></p><ol><li><p>一个程序的物理地址空间是非连续的</p></li><li><p>更好的内存利用和管理</p></li><li><p>允许共享代码与数据(共享库等…)</p></li><li><p>支持动态加载和动态链接</p></li></ol><p><strong>非连续内存分配的缺点：</strong></p><ol><li><p>建立虚拟地址和物理地址的转换难度大</p><ul><li><p>软件方案</p></li><li><p>硬件方案(采用硬件方案) : 分段 &#x2F; 分页</p></li></ul></li></ol><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段-Segmentation"><a href="#分段-Segmentation" class="headerlink" title="分段(Segmentation)"></a>分段(Segmentation)</h3><p><strong>段 :</strong> 在程序中会有来自不同文件的函数 ; 在程序执行时, 不同的数据也有不同的字段, 比如 : 堆 &#x2F; 栈 &#x2F; .bss &#x2F; .data 等</p><p>**分段 : ** 更好的分离和共享</p><p>程序的分段地址空间如下图所示 : </p><img src="https://camo.githubusercontent.com/9db208b68e844759210535e7ec1929186e60dae2153ac930d2e662a782ca7bd1/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31312f31312f4e416e7a484b6a3574454d343136682e6a7067"/><p><strong>分段寻址方案</strong></p><p>逻辑地址空间连续，但是物理地址空间不连续，使用映射机制进行关联.</p><p>一个段 : 一个内存”块”</p><p>程序访问内存地址需要 : 一个二维的二元组(s, addr) → (段号, 地址)</p><p>操作系统维护一张段表, 存储(段号, 物理地址中的起始地址, 长度限制)</p><p>物理地址 : 段表中的起始地址 + 二元组中的偏移地址</p><h3 id="分页-Paging"><a href="#分页-Paging" class="headerlink" title="分页(Paging)"></a>分页(Paging)</h3><p><strong>分页地址空间：</strong></p><p>划分<strong>物理内存</strong>至固定大小的<strong>帧</strong>(Frame)</p><ul><li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li></ul><p>划分<strong>逻辑地址</strong>空间至相同大小的<strong>页</strong>(Page)</p><ul><li>大小是2的幂, 512 &#x2F; 4096 &#x2F; 8192</li></ul><p>建立方案 → 转换逻辑地址为物理地址(pages to frames)</p><ul><li>页表</li><li>MMU &#x2F; TLB（快表）</li></ul><p><strong>帧(Frame)</strong></p><p>物理内存被分割为大小相等的帧. 一个内存物理地址是一个二元组(f, o) → (帧号, 帧内偏移)</p><p>帧号 : F位, 共有2^F^个帧</p><p>帧内偏移 : S位, 每帧有2^S^个字节</p><p>物理地址 &#x3D; 2^S^ * f + o</p><p>(例子 : 16-bit地址空间, 9-bit(512 byte) 大小的页帧， 物理地址 &#x3D; (3,6) ，物理地址 &#x3D; 2^9^ * 3 + 6 &#x3D; 1542)</p><blockquote><p>  <strong>分页和分段的最大区别 : 这里的 S 是一个固定的数, 而分段中的长度限制不定</strong></p></blockquote><p><strong>页(Page)</strong></p><p>一个程序的逻辑地址空间被划分为大小相等的页. 页内偏移的大小 &#x3D; 帧内偏移的大小， 页号大小 &#x3D; 帧号大小</p><p>一个逻辑地址是一个二元组(p, o) → (页号, 页内偏移)</p><p>页号 : P位, 共有2^P^个页</p><p>页内偏移 : S位, 每页有2^S^个字节</p><p>虚拟地址  &#x3D; 2^S^ * p + o</p><h4 id="页表-Page-Table"><a href="#页表-Page-Table" class="headerlink" title="页表(Page Table)"></a>页表(Page Table)</h4><p><strong>页寻址方案：</strong></p><p>操作系统维护一张<strong>页表</strong>, 页表保存了逻辑地址——物理地址之间的映射关系</p><p>存储 : (页号, 帧号)</p><ul><li>逻辑地址空间应当大于物理内存空间</li><li>页映射到帧</li><li>页是连续的虚拟内存</li><li>帧是非连续的物理内存(有助于减少碎片的产生)</li><li>不是所有的页都有对应的帧</li></ul><p><strong>页表概述：</strong></p><p>每一个运行的程序都有一个页表</p><ul><li>属于程序运行状态, 会动态变化</li><li>PTBR : 页表基址寄存器</li></ul><p><strong>转换流程</strong></p><p>CPU根据程序的page的页号的若干位, 计算出索引值index, 在页表中搜索这个index, 得到的是帧号, 帧号和原本的offset组成物理地址.</p><p><strong>分页机制的性能问题：</strong></p><p>访问一个内存单元需要2次内存访问</p><ul><li>一次用于获取页表项</li><li>一次用于访问数据</li></ul><p>页表可能非常大</p><ul><li>64位机器如果每页1024字节, 那么一个页表的大小会是多少？(2^64 &#x2F; 2^10 &#x3D; 2^54 存放不下)</li><li>每一个运行的程序都需要有一个页表</li></ul><p>如何处理？</p><ul><li>缓存(Caching)</li><li>间接(Indirection)访问</li></ul><h4 id="转换后备缓冲区-快表TLB"><a href="#转换后备缓冲区-快表TLB" class="headerlink" title="转换后备缓冲区(快表TLB)"></a>转换后备缓冲区(快表TLB)</h4><p>能缓解时间问题</p><p>Translation Look-aside Buffer(TLB) 是一个缓冲区. CPU中有<strong>快表TLB</strong>（可以将经常访问的页表存放在这边)</p><p>缓存近期访问的页帧转换表项</p><ul><li>TLB使用关联内存实现, 具备快速访问性能</li><li>如果TLB命中, 物理页号可以很快被获取</li><li>如果TLB未命中, 对应的表项被更新到TLB中(x86的CPU由硬件实现, 其他的可能是由操作系统实现)</li></ul><h4 id="二级-x2F-多级页表"><a href="#二级-x2F-多级页表" class="headerlink" title="二级&#x2F;多级页表"></a>二级&#x2F;多级页表</h4><p>时间换空间</p><p>二级页表</p><ul><li>将页号分为两个部分, 页表分为两个, 一级页号对应一级页表, 二级页号对应二级页表.</li><li>一级页号查表获得在二级页表的起始地址, 地址加上二级页号的值, 在二级页表中获得帧号</li><li>节约了一定的空间, 在一级页表中如果resident bit &#x3D; 0, 可以使得在二级页表中不存储相关index,而只有一张页表的话, 这一些index都需要保留</li></ul><p>多级页表</p><ul><li>通过把页号分为k个部分, 来实现多级间接页表, 建立一棵页表”树”</li></ul><blockquote><p>注：采用多级页表机制，各级页表的大小不能超过一个页面。</p><p>例：</p><p>若某系统按字节编址，采用40位逻辑地址，页面大小为4KB，页表项大小为4B，问应采用多少级页表，页内偏移量为几位？</p><p>答：</p><p>页面大小 &#x3D; 4KB &#x3D; 2^12^B，因为是按字节编址，所以页内偏移量为12位。</p><p>页号 &#x3D; 40 - 12 &#x3D; 18位</p><p>因为页面大小 &#x3D; 2^12^B，页表项大小 &#x3D; 4B，则每个页面可存放 2^12^ &#x2F; 4 &#x3D; 2^10^个页表项，即各级页表需要10位来映射2^10^个页表项。</p><p>所以28位的页号至少需要分成3级。</p></blockquote><h4 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h4><p>解决大地址空间问题</p><p>目的 : 根据帧号获得页号</p><p>反向页表只需要存在一张即可</p><ul><li>有大地址空间(64-bits), 前向映射页表变得繁琐. 比如 : 使用了5级页表</li><li>不是让页表与逻辑地址空间的大小相对应, 而是当页表与物理地址空间的大小相对应. 逻辑地址空间增长速度快于物理地址空间</li></ul><h5 id="基于页寄存器-Page-Registers-的方案"><a href="#基于页寄存器-Page-Registers-的方案" class="headerlink" title="基于页寄存器(Page Registers)的方案"></a>基于页寄存器(Page Registers)的方案</h5><p>存储 (帧号, 页号) 使得表大小与物理内存大小相关, 而与逻辑内存关联减小.</p><p>每一个帧和一个寄存器关联, 寄存器内容包括 :</p><ul><li>resident bit : 此帧是否被占用</li><li>occupier : 对应的页号 p</li><li>protection bits : 保护位</li></ul><p>实例 :</p><ul><li>物理内存大小是 : 4096 * 4096 &#x3D; 4K * 4KB &#x3D; 16 MB</li><li>页面大小是 : 4096 bytes &#x3D; 4 KB</li><li>页帧数 : 4096 &#x3D; 4 K</li><li>页寄存器使用的空间(假设8 bytes &#x2F; register) : 8 * 4096 &#x3D; 32 Kbytes</li><li>页寄存器带来的额外开销 : 32K &#x2F; 16M &#x3D; 0.2%</li><li>虚拟内存大小 : 任意</li></ul><p>优势 :</p><ul><li>转换表的大小相对于物理内存来说很小</li><li>转换表的大小跟逻辑地址空间的大小无关</li></ul><p>劣势 :</p><ul><li>需要的信息对调了, 即根据帧号可以找到页号</li><li>如何转换回来? (如何根据页号找到帧号)</li><li>在需要在反向页表中搜索想要的页号</li></ul><h5 id="基于关联内存-associative-memory-的方案"><a href="#基于关联内存-associative-memory-的方案" class="headerlink" title="基于关联内存(associative memory)的方案"></a>基于关联内存(associative memory)的方案</h5><p>硬件设计复杂, 容量不大, 需要放置在CPU中</p><ul><li>如果帧数较少, 页寄存器可以被放置在关联内存中</li><li>在关联内存中查找逻辑页号<ul><li>成功 : 帧号被提取</li><li>失败 : 页错误异常 (page fault)</li></ul></li><li>限制因素:<ul><li>大量的关联内存非常昂贵(难以在单个时钟周期内完成 ; 耗电)</li></ul></li></ul><h5 id="基于哈希-hash-的方案"><a href="#基于哈希-hash-的方案" class="headerlink" title="基于哈希(hash)的方案"></a>基于哈希(hash)的方案</h5><p>哈希函数 : h(PID, p) 从 PID 标号获得页号</p><p>在反向页表中通过哈希算法来搜索一个页对应的帧号</p><ul><li>对页号做哈希计算, 为了在帧表中获取对应的帧号</li><li>页 i 被放置在表 f(i) 位置, 其中 f 是设定的哈希函数</li><li>为了查找页 i , 执行下列操作 :<ul><li>计算哈希函数 f(i) 并且使用它作为页寄存器表的索引, 获取对应的页寄存器</li><li>检查寄存器标签是否包含 i, 如果包含, 则代表成功, 否则失败</li></ul></li></ul><h3 id="段页式"><a href="#段页式" class="headerlink" title="段页式"></a>段页式</h3><p>段页式系统的逻辑地址结构为：</p><p>段号，页号，页内地址(业内偏移量)</p><p>如：</p><table><thead><tr><th>31……16</th><th>15……12</th><th>11……0</th></tr></thead><tbody><tr><td>段号</td><td>页号</td><td>页内偏移量</td></tr></tbody></table><ul><li>段号的位数决定了每个进程最多可以分几个段</li><li>页号位数决定了每个段最大有多少页</li><li>页内位移决定了页面大小、内存块大小是多少</li></ul><blockquote><p>一个进程对应一个段表，但每个段会对应一个页表，所以一个进程可以对应多个页表</p><p>访存次数：第一次访问段表，第二次访问页表，第三次访问实际物理地址（同样可以添加以快表来减少访存次数）</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191729109.png" alt="image-20211222192103363"></p><h1 id="五、虚拟内存"><a href="#五、虚拟内存" class="headerlink" title="五、虚拟内存"></a>五、虚拟内存</h1><h2 id="虚拟内存的起因"><a href="#虚拟内存的起因" class="headerlink" title="虚拟内存的起因"></a>虚拟内存的起因</h2><p>使用硬盘&#x2F;磁盘使更多的程序在有限的内存中运行</p><p>理想的存储器 : 更大更快更便宜和非易失性的存储区</p><blockquote><p>传统的存储管理要求作业必须一次性装入内存后才能开始运行，且很多暂时用不到的数据也会长期占用内存，导致内存利用率不高。</p></blockquote><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>如果是程序太大, 超出了内存的容量, 可以采用手动的概率(overlay)技术, 只把需要的指令和数据保存在内存当中</p><p>目的 : 是在较小的可用内存中运行较大的程序, 常用于多道程序系统, 与分区存储管理配合使用.</p><p>原理 ：</p><p>把程序按照其自身逻辑结构, 划分为若干个功能上相互独立的程序模块, 那些不会同时执行的模块共享同一块内存区域, 按时间先后来运行.</p><ul><li>必要部分(常用功能)的代码和数据常驻内存;</li><li>可选部分(不常用功能)在其他程序模块中实现, 平时存放在外存中, 在需要用到时才装入内存;</li><li>不存在调用关系的模块不必同时装入到内存, 从而可以相互覆盖, 即这些模块共用一个分区.</li></ul><blockquote><p>  也就是说,程序松耦合的部分可以按需装入内存,不需要的时候放在外存中,多个不常用部分共用一个分区.</p></blockquote><p>实例 :</p><p>A(20k) <strong><strong>B(50k) ____ D(30k)<br>        | ____ C(30k) ____ E(20k)<br>                             |</strong></strong> F(40k)</p><p>因此不需要将整个程序190k的数据全部放入内存中, 而是划分为 常驻区(20k) 、覆盖区0(50k) 、覆盖区1(40k) 压缩至了110k的内存空间使用</p><p>缺点 :</p><ul><li>由程序员来把一个大的程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 费时费力, 增加了编程的复杂度;</li><li>覆盖模块并从外存装入内存, 实际上是以时间延长来换取空间节省.</li></ul><h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>如果是程序太多, 超过了内存的容量, 可以采用自动的交换(swapping)技术, 把暂时不能执行的程序送到外存中</p><p>目的 : 多道程序在内存时, 让正在运行的程序或需要运行的程序获得更多的内存资源</p><p>原理 :</p><p>可将暂时不能运行的程序送到外存, 从而获得空闲内存空间. 操作系统把一个进程的整个地址空间的内容保存到外存中(换出 swap out), 而将外存中的某个进程的地址空间读入到内存中(换入 swap in). 换入换出内容的大小为整个程序的地址空间.</p><p>存在问题 :</p><ul><li>交换时机的确定 : 何时需要发生交换? 只当内存空间不够或有不够的危险时换出;</li><li>交换区的大小 : 必须足够大以存放所有用户进程的所有内存映像的拷贝, 必须能够对这些内存映像进行直接存取</li><li>程序换入时的重定位 : 换出后再换入的内存位置一定要在原来的位置上嘛?(可能出现寻址问题) 最好采用动态地址映射的方法</li></ul><h2 id="覆盖技术和交换技术的对比"><a href="#覆盖技术和交换技术的对比" class="headerlink" title="覆盖技术和交换技术的对比"></a>覆盖技术和交换技术的对比</h2><p>特点 :</p><ul><li>覆盖只能发生在那些相互之间没有调用关系的程序模块之间, 因此程序员必须给出程序内的各个模块之间的逻辑覆盖结构.</li><li>交换技术是以在内存中的程序大小为单位进行的, 它不需要程序员给出各个模块之间的逻辑覆盖结构.</li><li>换言之, 交换发生在内存中程序与管理程序或操作系统之间, 而覆盖则发生在运行程序的内部.</li></ul><p>在内存不够用的情形下, 可以采用覆盖技术和交换技术, 但是 :</p><ul><li>覆盖技术 : 需要程序要自己把整个程序划分为若干个小的功能模块, 并确定各个模块之间的覆盖关系, 增加了程序员的负担.</li><li>交换技术 : 以进程作为交换的单位, 需要把进程的整个地址空间都换入换出, 增加了处理器的开销.</li></ul><h2 id="虚拟内存管理技术"><a href="#虚拟内存管理技术" class="headerlink" title="虚拟内存管理技术"></a>虚拟内存管理技术</h2><p>如果想要在有限容量的内存中, 以更小的页粒度为单位装入更多更大的程序, 可以采用自动的虚拟存储技术</p><ul><li><p>目标</p><p>像覆盖技术那样, 不是把程序的所有内容都放在内存中, 因而能够运行比当前的空闲内存空间还要大的程序. 但做的更好, 由操作系统自动来完成, 无需程序员的干涉.</p><p>像交换技术那样, 能够实现进程在内存与外存之间的交换, 因而获得更多的空闲内存空间. 但做的更好, 只对进程的部分内容在内存和外存之间进行交换.</p></li><li><p>程序局部性原理</p><p>程序的局部性原理(principle of locality) : 指程序在执行过程中的一个较短时期, 所执行的指令地址和指令的操作数地址, 分别局限于一定的区域.</p><ul><li>时间局部性 : 一条指令的一次执行和下次执行, 一个数据的一次访问和下次访问都集中在一个较短时期内 ;</li><li>空间局部性 : 当前指令和邻近的几条指令, 当前访问的数据和邻近的几个数据都集中在一个较小区域内.</li></ul><p>程序的局部性原理表明, 从理论上来说, 虚拟存储技术是能够实现的. 而且在实现了以后应该是能够取得一个满意的效果.</p><p>实例 :</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">题目描述 :</span><br><span class="line">页面大小为<span class="number">4</span>k, 分配给每个进程的物理页面是<span class="number">1.</span> </span><br><span class="line">在一个进程中, 定义了如下的二维数组 <span class="type">int</span> A[<span class="number">1024</span>][<span class="number">1024</span>]. 该数组按行存放在内存, 每一行放在一个页面中.</span><br><span class="line">考虑一下程序的编写方法对缺页率的影响?</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">1</span> : (发生了<span class="number">1024</span>*<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line">A[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">程序编写方法<span class="number">2</span> : (发生了<span class="number">1024</span>次缺页中断)</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1024</span>; i++)</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">1024</span>; j++)</span><br><span class="line">A[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li><li><p>基本概念</p><p>可以在页式或段式内存管理的基础上实现</p><ul><li>在装入程序时, 不必将其全部装入内存, 而只需将当前需要执行的部分页面或段装入到内存中, 就可以让程序开始执行;</li><li>在程序执行过程中, 如果需执行的指令或访问的数据尚未在内存中(称为缺页或缺段), 则由处理器通知操作系统将相应的页面或段调入到内存, 然后继续执行程序;</li><li>另一方面, 操作系统将内存中暂时不使用的页面或段调出保存在外存上, 从而腾出更多空闲内存空间存放将要装入的程序以及将要调入的页面或段.</li></ul></li><li><p>基本特征</p><ul><li>大的用户空间 : 通过把物理内存和外存相结合, 提供给用户的虚拟内存空间通常大于实际的物理内存, 即实现了这两者的分离. 如32位的虚拟地址理论上可以访问4GB, 而可能计算机上仅有256M的物理内存, 但硬盘容量大于4GB.</li><li>部分交换 : 与交换技术相比较, 虚拟存储的调入和调出是对部分虚拟地址空间进行的;</li><li>不连续性 : 物理内存分配的不连续性, 虚拟地址空间使用的不连续性.</li></ul></li><li><p>虚拟页式内存管理</p><p>页式内存管理</p><p>页表 : 完成逻辑页到物理页帧的映射</p><p>根据页号去页表中寻找索引, 先查看 resident bit 是否为0, 0表示不存在, 1表示映射关系存在, 获得帧号加上原本的偏移, 获得了物理地址.</p><p>虚拟页式内存管理</p><ul><li><p>大部分虚拟存储系统都采用虚拟页式存储管理技术, 即在页式存储管理的基础上, 增加请求调页和页面置换功能.</p></li><li><p>基本思路</p><ul><li>当一个用户程序要调入内存运行时, 不是将该程序的所有页面都装入内存, 而是只装入部分的页面, 就可启动程序运行.</li><li>在运行的过程中, 如果发现要运行的程序或要访问的数据不在内存, 则向系统发出缺页的中断请求, 系统在处理这个中断时, 将外存中相应的页面调入内存, 使得该程序能够继续运行.</li></ul></li><li><p><strong>请求页表表项</strong></p><p>逻辑页号 | 访问位 | 修改位 | 保护位 | 驻留位 | 物理页帧号</p><p>驻留位 : 表示该页是在内存中还是在外存.</p><p>保护位 : 表示允许对该页做何种类型的访问, 如只读, 可读写, 可执行等</p><p>修改位 : 表示此页在内存中是否被修改过. 当系统回收该物理页面时, 根据此位来决定是否把它的内容写回外存</p><p>访问位 : 如果该页被访问过(包括读写操作), 则设置此位. 用于页面置换算法.</p></li><li><p>缺页中断处理过程 :</p><ol><li>如果在内存中有空闲的物理页面, 则分配一物理页帧f, 然后转第4步; 否则转到第2步;</li><li>采用某种页面置换算法, 选择一个将被替换的物理页帧f, 它所对应的逻辑页为q, 如果该页在内存期间被修改过, 则需要把它写回外存;</li><li>对q所对应的页表项修改, 把驻留位置为0;</li><li>将需要访问的页p装入到物理页面f当中;</li><li>修改p所对应的页表项的内容, 把驻留位置为1, 把物理页帧号置为f;</li><li>重新运行被中断的指令.</li></ol></li><li><p>虚拟内存性能</p><p>为了便于理解分页的开销, 使用有效存储器访问时间 effective memory access time (EAT)</p><p>EAT &#x3D; 访存时间 * 页表命中几率 + page fault处理时间 * page fault几率</p><p>实例 :</p><p>访存时间 : 10 ns</p><p>磁盘访问时间 : 5 ms</p><p>参数 p  &#x3D; page fault 几率</p><p>参数 q &#x3D; dirty page 几率(对页面写操作) </p><p>EAT &#x3D; 10*(1-p) + 5000000*p*(1+q)</p></li></ul></li></ul><h1 id="六、页面置换算法"><a href="#六、页面置换算法" class="headerlink" title="六、页面置换算法"></a>六、页面置换算法</h1><h2 id="功能与目标"><a href="#功能与目标" class="headerlink" title="功能与目标"></a>功能与目标</h2><p>功能 : 当缺页中断发生， 需要调入新的页面而内存已满时， 选择内存当中哪个物理页面被置换.</p><p>目标 : 尽可能地减少页面的换进换出次数(即缺页中断的次数)。 具体来说， 把未来不再使用的或短期内较少使用的页面换出， 通常只能在局部性原理指导下依据过去的统计数据来进行预测.</p><p>页面锁定 : 用于描述必须常驻内存的操作系统的关键部分或时间关键的应用进程。 实现的方式是 : 在页表中添加锁定标记位(lock bit).</p><h2 id="局部页面置换算法"><a href="#局部页面置换算法" class="headerlink" title="局部页面置换算法"></a>局部页面置换算法</h2><h3 id="最优页面置换算法-OPT"><a href="#最优页面置换算法-OPT" class="headerlink" title="最优页面置换算法(OPT)"></a>最优页面置换算法(OPT)</h3><p>基本思路 : 当一个缺页中断发生时, 对于保存在内存当中的每一个逻辑页面, 计算在它的下一次访问之前, 还需等待多长时间, 从中选择等待时间最长的那个, 作为被置换的页面.</p><p>这是一种理想情况, 在实际系统中是无法实现的, 因为操作系统无法知道每一个页面要等待多长时间以后才会再次被访问.</p><p>可用作其他算法的性能评价的依据.(在一个模拟器上运行某个程序, 并记录每一次的页面访问情况, 在第二遍运行时即可使用最优算法)</p><h3 id="先进先出算法-FIFO"><a href="#先进先出算法-FIFO" class="headerlink" title="先进先出算法(FIFO)"></a>先进先出算法(FIFO)</h3><p>基本思路 : 选择在内存中驻留时间最长的页面淘汰. 具体来说, 系统维护着一个链表, 记录了所有位于内存当中的逻辑页面. 从链表的排列顺序来看, 链首页面的驻留时间最长, 链尾页面的驻留时间最短. 当发生一个缺页中断时, 把链首页面淘汰出去, 并把新的页面添加到链表的末尾.</p><p>性能较差, 调出的页面有可能是经常要访问的页面. 并且有 belady现象. FIFO算法很少单独使用.</p><h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><p>LRU(Least Recently Used)</p><p>基本思路 : 当一个缺页中断发生时, 选择最久未使用的那个页面, 并淘汰.</p><p>它是对最优页面置换算法的一个近似, 其依据是程序的局部性原理, 即在最近一小段时间(最近几条指令)内, 如果某些页面被频繁地访问, 那么再将来的一小段时间内, 他们还可能会再一次被频繁地访问. 反过来说, 如果过去某些页面长时间未被访问, 那么在将来它们还可能会长时间地得不到访问.</p><p>LRU算法需要记录各个页面使用时间的先后顺序, 开销比较大.</p><p>两种可能的实现方法是 :</p><ul><li>系统维护一个页面链表, 最近刚刚使用过的页面作为首节点, 最久未使用的作为尾结点. 再一次访问内存时, 找出相应的页面, 把它从链表中摘下来, 再移动到链表首. 每次缺页中断发生时, 淘汰链表末尾的页面.</li><li>设置一个活动页面栈, 当访问某页时, 将此页号压入栈顶, 然后, 考察栈内是否有与此页面相同的页号, 若有则抽出. 当需要淘汰一个页面时, 总是选择栈底的页面, 它就是最久未使用的.</li></ul><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>基本思路 :</p><p>需要用到页表项的访问位, 当一个页面被装入内存时, 把该位初始化为0. 然后如果这个页面被访问, 则把该位置设为1;</p><p>把各个页面组织成环形链表(类似钟表面), 把指针指向最老的页面(最先进来);</p><p>当发生一个缺页中断时, 考察指针所指向的最老页面, 若它的访问位为0, 立即淘汰; 若访问位为0, 然后指针往下移动一格. 如此下去, 直到找到被淘汰的页面, 然后把指针移动到下一格.</p><p>流程 :</p><p>如果访问页在物理内存中, 访问位置1.</p><p>如果不在物理页, 从指针当前指向的物理页开始, 如果访问位0, 替换当前页, 指针指向下一个物理页; 如果访问位为1, 置零以后访问下一个物理页再进行判断. 如果所有物理页的访问位都被清零了, 又回到了第一次指针所指向的物理页进行替换.</p><h3 id="二次机会算法"><a href="#二次机会算法" class="headerlink" title="二次机会算法"></a>二次机会算法</h3><p>因为考虑到时钟页面置换算法, 有时候会把一些 dirty bit 为1(有过写操作)的页面进行置换, 这样的话, 代价会比较大. 因此, 可以结合访问位和脏位一起来决定应该置换哪一页.</p><p>used   dirty     →  used   dirty</p><p> 0         0                  replace</p><p> 0         1                  0         0</p><p> 1          0                 0         0 </p><p> 1          1                 0         1 </p><p>相当于说, 替换的优先级, 没有读写也没写过, 那么直接走, 如果写过或者访问过, 那么给你一次机会, 如果又写过, 又访问过, 那么久给你两次机会.</p><h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法(LFU)"></a>最不常用算法(LFU)</h3><p>Least Frequently used, LFU</p><p>基本思路 : 当一个缺页中断发生时, 选择访问次数最少的那个页面, 并淘汰.</p><p>实现方法 : 对每一个页面设置一个访问计数器, 每当一个页面被访问时, 该页面的访问计数器加1. 当发生缺页中断时, 淘汰计数值最小的那个页面.</p><p>LRU和LFU的对比 : LRU考察的是多久未访问, 时间越短越好. 而LFU考察的是访问的次数和频度, 访问次数越多越好.</p><h3 id="Belady现象-科学家名字"><a href="#Belady现象-科学家名字" class="headerlink" title="Belady现象(科学家名字)"></a>Belady现象(科学家名字)</h3><p>在采用FIFO算法时, 有时会出现分配的物理页面数增加, 缺页率反而提高的异常现象;</p><p>出现原因 : FIFO算法的置换特征与进程访问内存的动态特征是矛盾的, 与置换算法的目标是不一致的(即替换较少使用的页面), 因此, 被他置换出去的页面不一定是进程不会访问的.</p><h3 id="LRU-x2F-FIFO-和-Clock-的比较"><a href="#LRU-x2F-FIFO-和-Clock-的比较" class="headerlink" title="LRU &#x2F; FIFO 和 Clock 的比较"></a>LRU &#x2F; FIFO 和 Clock 的比较</h3><p>LRU和FIFO都是先进先出的思路, 只不过LRU是针对页面最近访问时间来进行排序, 所以需要在每一次页面访问的时候动态地调整各个页面之间的先后顺序(有一个页面的最近访问时间变了). 而FIFO是针对页面进入内存的时间来进行排序, 这个时间是固定不变的, 所以各个页面之间的先后顺序是固定的. 如果一个页面在进入内存后没有被访问, 那么它的最近访问时间就是它进入内存的时间. 换句话说, 如果内存当中的所有页面都未曾访问过, 那么LRU算法就退化为了FIFO算法.</p><p>例如 : 给进程分配3个物理页面, 逻辑页面的访问顺序是 : 1,2,3,4,5,6,1,2,3 …</p><h2 id="全局页面置换算法"><a href="#全局页面置换算法" class="headerlink" title="全局页面置换算法"></a>全局页面置换算法</h2><h3 id="工作集模型"><a href="#工作集模型" class="headerlink" title="工作集模型"></a>工作集模型</h3><p>前面介绍的各种页面置换算法, 都是基于一个前提, 即程序的局部性原理. 但是此原理是否成立?</p><ul><li>如果局部性原理不成立, 那么各种页面置换算法就没有说明分别, 也没有什么意义. 例如 : 假设进程对逻辑页面的访问顺序是1,2,3,4,5,6,6,7,8,9…, 即单调递增, 那么在物理页面数有限的前提下, 不管采用何种置换算法, 每次的页面访问都必然导致缺页中断.</li><li>如果局部性原理是成立的, 那么如何来证明它的存在, 如何来对它进行定量地分析? 这就是工作集模型.</li></ul><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>工作集 : 一个进程当前正在使用的逻辑页面集合.</p><p>可以使用一个二元函数 W(t, delta) 来表示：</p><p>t 是当前的执行时刻;</p><p>delta 称为工作集窗口, 即一个定长的页面访问的时间窗口;</p><p>W(t, delta) &#x3D; 在当前时刻 t 之前的 delta 时间窗口当中的所有页面所组成的集合(随着 t 的变化, 该集合也在不断的变化)</p><p>|W(t, delta)| 是工作集的大小, 即逻辑页的数量.</p><p>工作集大小的变化 : 进程开始执行后, 随着访问新页面逐步建立较稳定的工作集. 当内存访问的局部性区域的位置大致稳定时, 工作集大小也大致稳定; 局部性区域的位置改变时, 工作集快速扩张和收缩过渡到下一个稳定值.</p><h3 id="常驻集"><a href="#常驻集" class="headerlink" title="常驻集"></a>常驻集</h3><p>常驻集是指在当前时刻, 进程实际驻留在内存当中的页面集合.</p><ul><li>工作集是进程在运行过程中固有的性质, 而常驻集取决于系统分配给进程的物理页面数目, 以及所采用的页面置换算法;</li><li>如果一个进程的整个工作集都在内存当中, 即常驻集 包含 工作集, 那么进程将很顺利地运行, 而不会造成太多的缺页中断(直到工作集发生剧烈变动, 从而过渡到另一个状态);</li><li>当进程常驻集的大小达到某个数目之后, 再给它分配更多的物理页面, 缺页率也不会明显下降.</li></ul><h3 id="工作集页置换算法"><a href="#工作集页置换算法" class="headerlink" title="工作集页置换算法"></a>工作集页置换算法</h3><p>当工作集窗口在滑动过程中, 如果页面不在集合中, 那么就会直接丢失这个不在窗口中页面, 而不会等待缺页中断再丢弃.</p><h3 id="缺页率置换算法"><a href="#缺页率置换算法" class="headerlink" title="缺页率置换算法"></a>缺页率置换算法</h3><p>可变分配策略 : 常驻集大小可变. 例如 : 每个进程在刚开始运行的时候, 先根据程序大小给它分配一定数目的物理页面, 然后在进程运行过程中, 再动态地调整常驻集的大小.</p><ul><li>可采用全局页面置换的方式, 当发生一个缺页中断时, 被置换的页面可以是在其他进程当中, 各个并发进程竞争地使用物理页面.</li><li>优缺点 : 性能较好, 但增加了系统开销.</li><li>具体实现 : 可以使用缺页率算法来动态调整常驻集的大小.</li></ul><p>缺页率 : 表示 “缺页次数 &#x2F; 内存访问次数”</p><p>影响因素 : 页面置换算法, 分配给进程的物理页面数目, 页面本身的大小, 程序的编写方法.</p><h3 id="抖动问题"><a href="#抖动问题" class="headerlink" title="抖动问题"></a>抖动问题</h3><ul><li>如果分配给一个进程的物理页面太少, 不能包含整个的工作集, 即常驻集 属于 工作集, 那么进程将会造成很多的缺页中断, 需要频繁的在内存与外存之间替换页面, 从而使进程的运行速度变得很慢, 我们把这种状态称为 “抖动”.</li><li>产生抖动的原因 : 随着驻留内存的进程数目增加, 分配给每个进程的物理页面数不断就减小, 缺页率不断上升. 所以OS要选择一个适当的进程数目和进程需要的帧数, 以便在并发水平和缺页率之间达到一个平衡.</li></ul><h1 id="七、进程"><a href="#七、进程" class="headerlink" title="七、进程"></a>七、进程</h1><h2 id="进程-process-描述"><a href="#进程-process-描述" class="headerlink" title="进程(process)描述"></a>进程(process)描述</h2><p><strong>进程定义</strong></p><p>进程 : 一个具有一定独立功能的程序在一个数据集合上的<strong>一次动态执行过程</strong>，是系统进行资源分配和调度的一个独立单位。</p><p><strong>进程的组成</strong></p><p>进程包括 ：程序段、数据段、PCB</p><ul><li>程序段：程序的代码</li><li>数据段：程序处理的数据</li><li>程序计数器中的值, 指示下一条将运行的指令</li><li>一组通用的寄存器的当前值, 堆, 栈</li><li>一组系统资源(如打开的文件)</li></ul><p><strong>进程和程序的联系 :</strong></p><ul><li>程序是产生进程的基础</li><li>程序的每次运行构成不同的进程</li><li>进程是程序功能的体现</li><li>通过多次执行, 一个程序可以对应多个进程, 通过调用关系, 一个进程可包括多个程序.</li></ul><p><strong>进程和程序的区别 :</strong></p><ul><li>进程是动态的,  程序是静态的 : 程序是有序代码的集合. 进程是程序的执行, 进程有核心态 &#x2F; 用户态.</li><li>进程是暂时的, 程序是永久的. 进程是一个状态变化的过程, 程序可以长久保存.</li><li>进程和程序的组成不同 : 进程的组成包括程序代码, 数据和进程控制块(进程状态信息)</li></ul><p><strong>进程的特点</strong></p><ul><li><p><strong>动态性</strong> : 可动态地创建, 结束进程;</p></li><li><p><strong>并发性</strong> : 进程可以被独立调度并占用处理机运行 (并发: 一段； 并行:一时刻)</p></li><li><p><strong>独立性</strong> : 不同进程的工作不相互影响;（页表是保障措施之一)</p></li><li><p><strong>制约性</strong> : 因访问共享数据, 资源或进程间同步而产生制约.</p></li></ul><h2 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h2><p>描述进程的数据结构 : 进程控制块 (Process Control Block)</p><p>操作系统为每个进程都维护了一个PCB, 用来保存与该进程有关的各种状态信息.</p><p><strong>进程控制块 :</strong> 操作系统管理控制进程运行所用的信息集合.</p><ul><li><p>进程的创建 : 为该进程生成一个PCB</p></li><li><p>进程的终止 : 回收它的PCB</p></li><li><p>进程的组织管理 : 通过对PCB的组织管理来实现</p></li></ul><p>(PCB具体包含什么信息? 如何组织的? 进程的状态转换?)</p><p><strong>PCB有以下三大类信息 :</strong></p><ul><li><strong>进程标志信息</strong>：<ul><li>进程标识符UID：当进程被创建时，操作系统会为该进程分配一个唯一的、不重复的ID，用于区分不同的进程；</li><li>用户标识符UID</li></ul></li><li><strong>处理机信息保存区</strong> : 保存进程的运行现场信息 :<ul><li>用户可见寄存器. 用户程序可以使用的数据, 地址等寄存器</li><li>控制和状态寄存器. 如程序计数器(PC), 程序状态字(PSW)</li><li>栈指针. 过程调用, 系统调用, 中断处理和返回时需要用到它</li></ul></li><li><strong>进程控制信息</strong><ul><li>调度和状态信息：用于操作系统调度进程并占用处理机使用.</li><li>进程间通信信息： 为支持进程间与通信相关的各种标志, 信号, 信件等, 这些信息都存在接收方的进程控制块中.</li><li>存储管理信息：包含有指向本进程映像存储空间的数据结构.</li><li>进程所用资源：说明由进程打开, 使用的系统资源. 如打开的文件等.</li><li>有关数据结构的链接信息：进程可以连接到一个进程队列中, 或连接到相关的其他进程的PCB.</li></ul></li></ul><p><strong>进程的组织方式</strong></p><p>链表 : 同一状态的进程其PCB成一链表, 多个状态对应多个不同的链表.(各状态的进程形成不同的链表 : 就绪链表, 阻塞链表)</p><p>索引表 : 同一状态的进程归入一个index表(由index指向PCB), 多个状态对应多个不同的index表(各状态的进行形成不同的索引表 : 就绪索引表, 阻塞索引表)</p><h2 id="进程状态-state"><a href="#进程状态-state" class="headerlink" title="进程状态(state)"></a>进程状态(state)</h2><h3 id="进程的生命期管理"><a href="#进程的生命期管理" class="headerlink" title="进程的生命期管理"></a>进程的生命期管理</h3><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>引起进程创建的3个主要事件 :</p><ul><li>系统初始化;</li><li>用户请求创建一个新进程;</li><li>正在运行的进程执行了创建进程的系统调用.</li></ul><h4 id="进程运行"><a href="#进程运行" class="headerlink" title="进程运行"></a>进程运行</h4><p>内核选择一个就绪的进程, 让它占用处理机并执行；</p><p>(为何选择?如何选择?)</p><h4 id="进程等待-阻塞"><a href="#进程等待-阻塞" class="headerlink" title="进程等待(阻塞)"></a>进程等待(阻塞)</h4><p>在以下情况下, 进程等待(阻塞):</p><ol><li>请求并等待系统服务, 无法马上完成</li><li>启动某种操作, 无法马上完成</li><li>需要的数据没有到达</li></ol><p>进程只能自己阻塞自己, 因为只有进程自身才能知道何时需要等待某种事件的发生.</p><h4 id="进程唤醒"><a href="#进程唤醒" class="headerlink" title="进程唤醒"></a>进程唤醒</h4><p>唤醒进程的原因 :</p><ol><li>被阻塞进程需要的资源可被满足</li><li>被阻塞进程等待的事件到达</li><li>将该进程的PCB插入到就绪队列</li></ol><p>进程只能被别的进程或操作系统唤醒</p><h4 id="进程结束"><a href="#进程结束" class="headerlink" title="进程结束"></a>进程结束</h4><p>在以下四种情况下, 进程结束 :</p><ul><li>正常退出(自愿)</li><li>错误退出(自愿)</li><li>致命错误(强制性)</li><li>被其他进程杀死(强制性)</li></ul><h3 id="进程状态变化模型"><a href="#进程状态变化模型" class="headerlink" title="进程状态变化模型"></a>进程状态变化模型</h3><p><strong>进程的三种基本状态 :</strong> 进程在生命结束前处于三种基本状态之一.</p><p>不同系统设置的进程状态数目不同.</p><p><strong>三种基本状态</strong></p><ol><li>运行状态(Running) : 当一个进程正在处理机上运行时</li><li>就绪状态(Ready) : 一个进程获得了除处理机之外的一切所需资源, 一旦得到处理机即可运行</li><li>等待状态(阻塞状态 Blocked) : 一个进程正在等待某一时间而暂停运行时. 如等待某资源, 等待输入&#x2F;输出完成.</li></ol><p><strong>进程其它的基本状态</strong></p><p>创建状态(New) : 一个进程正在被创建, 还没被转到就绪状态之前的状态</p><p>结束状态(Exit): 一个进程正在从系统中消失时的状态, 这是因为进程结束或由于其它原因所导致.</p><p><strong>可能的状态变化如下 :</strong></p><p>NULL → New : 一个新进程被产生出来执行一个程序</p><p>New → Ready: 当进程创建完成并初始化后, 一切就绪准备运行时, 变为就绪状态</p><p>Ready → Running  : 处于就绪态的进程被进程调度程序选中后, 就分配到处理机上来运行</p><p>Running → Exit   : 当进程表示它已经完成或者因出错, 当前运行进程会由操作系统作结束处理</p><p>Running → Ready  : 处于运行状态的进程在其运行过程中, 由于分配它的处理机时间片用完而让出处理机</p><p>Running → Blocked: 当进程请求某样东西且必须等待时</p><p>Blocked → Ready  : 当进程要等待某事件到来时, 它从阻塞状态变到就绪状态</p><h3 id="进程挂起"><a href="#进程挂起" class="headerlink" title="进程挂起"></a>进程挂起</h3><p>进程挂起, 为了合理且充分地利用系统资源.</p><p>进程在挂起状态时, 意味着进程没有占用内存空间, 处在挂起状态的进程映像在磁盘上。（把进程放到磁盘上)</p><p><strong>两种挂起状态</strong></p><ol><li>阻塞挂起状态 : 进程在外存并等待某事件的出现;</li><li>就绪挂起状态 : 进程在外存, 但只要进入内存, 即可运行.</li></ol><p><strong>与挂起相关的状态转换</strong></p><p><strong>挂起 :</strong> 把一个进程从内存转到外存, 可能有以下几种情况 :</p><ul><li>阻塞到阻塞挂起 : 没有进程处于就绪状态或就绪进程要求更多内存资源时, 会进行这种转换, 以提交新进程或运行时就绪进程.</li><li>就绪到就绪挂起 : 当有高优先级阻塞(系统认为会很快就绪的)进程和低优先级就绪进程时, 系统会选择挂起低优先级就绪进程.</li><li>运行到就绪挂起 : 对抢先式分时系统, 当有高优先级阻塞挂起进程因事件出现而进入就绪挂起时, 系统可能会把运行进程转导就绪挂起状态.</li></ul><p><strong>在外存时的状态转换 :</strong></p><ul><li>阻塞挂起到就绪挂起 : 当有阻塞挂起因相关事件出现时, 系统会把阻塞挂起进程转换为就绪挂起进程.</li></ul><p><strong>解挂, 激活 :</strong> 把一个进程从外存转到内存; 可能有以下几种情况 :</p><ul><li>就绪挂起到就绪 : 没有就绪进程或挂起就绪进程优先级高于就绪进程时, 会进行这种转换.</li><li>阻塞挂起到阻塞 : 当一个进程释放足够内存时, 系统会把一个高优先级阻塞挂起(系统认为会很快出现所等待的事件)进程转换为阻塞进程.</li></ul><blockquote><p>  抛出一个问题 : OS怎么通过PCB和定义的进程状态来管理PCB, 帮助完成进程的调度过程?</p></blockquote><h3 id="状态队列"><a href="#状态队列" class="headerlink" title="状态队列"></a>状态队列</h3><ul><li>由操作系统来维护一组队列, 用来表示系统当中所有进程的当前状态;</li><li>不同的状态分别用不同的队列来表示(就绪队列, 各种类型的阻塞队列)；</li><li>每个进程的PCB都根据它的状态加入到相应的队列当中, 当一个进程的状态发生变化时, 它的PCB从一个状态中脱离出来, 加入到另外一个队列.</li></ul><h2 id="线程-thread"><a href="#线程-thread" class="headerlink" title="线程(thread)"></a>线程(thread)</h2><h3 id="为什么使用线程"><a href="#为什么使用线程" class="headerlink" title="为什么使用线程?"></a>为什么使用线程?</h3><p>实例 : 编写一个MP3播放软件.</p><p>核心功能 : (1)从MP3音频文件中读取数据; (2)对数据进行解压缩; (3)把解压缩后的音频数据播放出来.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单进程方式</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Read</span>();</span><br><span class="line"><span class="built_in">Decompress</span>();</span><br><span class="line"><span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题: 播放出来的声音能否连贯? 各个函数之间不是并发执行, 影响资源的使用效率.</span></span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//多进程</span></span><br><span class="line"><span class="comment">//进程1</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程2</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Decompress</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//进程3</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Play</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//问题: 进程之间如何通信,共享数据?另外,维护进程的系统开销较大:</span></span><br><span class="line"><span class="comment">//创建进程时,分配资源,建立PCB;撤销进程时,回收资源,撤销PCB;进程切换时,保存当前进程的状态信息</span></span><br></pre></td></tr></table></figure><p>由于有的进程需要“同时”做很多事，而一个进程只能串行地执行一系列程序；</p><p>因此需要提出一种新的实体, 满足以下特征:</p><ol><li>实体之间可以并发执行;</li><li>实体之间共享相同的地址空间.</li></ol><p>这实体就是线程。</p><h3 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h3><p>线程是进程当中的一条执行流程。是一个基本的CPU执行单元，也是程序执行 流的最小单元。</p><p>从两个方面重新理解进程:</p><ol><li>从资源组合的角度: 进程把一组相关的资源组合起来，构成了一个资源平台(环境)，包括地址空间(代码段,数据段)，打开的文件等各种资源;</li><li>从运行的角度：代码在这个资源平台上的一条执行流程(线程).</li></ol><blockquote><p>即引入线程后，进程转变为 除CPU外的系统资源的分配单元。</p></blockquote><p>线程 &#x3D; 进程 - 共享资源</p><h3 id="线程的优缺点"><a href="#线程的优缺点" class="headerlink" title="线程的优缺点"></a>线程的优缺点</h3><p>线程的优点:</p><ul><li>一个进程中可以同时<strong>存在多个线程</strong>;</li><li>各个线程之间可以<strong>并发</strong>地执行;</li><li>各个线程之间可以<strong>共享</strong>地址空间和文件等资源.</li></ul><p>线程的缺点:</p><ul><li><p>一个线程崩溃，会导致其所属进程的所有线程崩溃。(给它了”权限”就得有更高的”责任”)</p></li><li><p>线程所需的资源</p><p>不同的线程需要独立的寄存器和堆栈, 共享代码,数据和文件等.</p></li></ul><h3 id="线程和进程的比较"><a href="#线程和进程的比较" class="headerlink" title="线程和进程的比较"></a>线程和进程的比较</h3><ul><li><strong>进程是资源分配单位</strong>，<strong>线程是CPU调度单位</strong>;</li><li>进程拥有一个完整的资源平台， 而<strong>线程只独享必不可少的资源</strong>，如寄存器和栈;</li><li>线程<strong>同样具有就绪、阻塞和执行三种基本状态，同样具有状态之间的转换关系</strong>;</li><li>线程能<strong>减少并发执行的时间和空间开销</strong>:<ul><li>线程的创建时间比进程短；(直接利用所属进程的一些状态信息)</li><li>线程的终止时间比进程短；(不需要考虑把这些状态信息给释放)</li><li>同一进程内的线程切换时间比进程短；(同一进程不同线程的切换不需要切换页表)</li><li>由于同一进程的各线程之间共享内存和文件资源，可直接进行不通过内核的通信。(直接通过内存地址读写资源)</li></ul></li></ul><h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>主要有三种线程的实现方式:</p><ul><li>用户线程  : 在用户空间实现； POSIX Pthreads, Mach C-threads, Solaris threads</li><li>内核线程  : 在内核中实现； Windows, Solaris, Linux</li><li>轻量级进程: 在内核中实现,支持用户线程； Solaris</li></ul><h4 id="用户线程"><a href="#用户线程" class="headerlink" title="用户线程"></a><strong>用户线程</strong></h4><p>操作系统只能看到进程, 看不到线程, 线程的TCB在线程库中实现;</p><p><strong>在用户空间实现的线程机制， 它不依赖于操作系统的内核</strong>， 由一组用户级的线程库来完成线程的管理， 包括进程的创建、终止、同步和调度等.</p><ul><li>由于用户线程的维护由相应的进程来完成(通过线程库函数)，不需要操作系统内核了解用户进程的存在，可用于不支持线程技术的多进程操作系统；</li><li>每个进程都需要它自己私有的线程控制块(TCB)列表，用来跟踪记录它的各个线程的状态信息(PC,栈指针,寄存器)，TCB由线程库函数来维护;</li><li>用户线程的切换也是由线程库函数来完成，无需用户态&#x2F;核心态切换，所以速度特别快;</li><li>允许每个进程拥有自定义的线程调度算法.</li></ul><p>用户线程的缺点:</p><ul><li>阻塞性的系统调用如何实现？如果一个线程发起系统调用而阻塞，则整个进程在等待;</li><li>当一个线程开始运行时，除非它主动地交出CPU的使用权，否则它所在的进程当中的其他线程将无法运行;</li><li>由于时间片分配给进程，所以与其他进程比，在多线程执行时，每个线程得到的时间片较少，执行会较慢.</li></ul><h4 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a><strong>内核线程</strong></h4><p>操作系统能够看到进程也可能看到线程,线程在内核中实现;</p><p>内核线程是在操作系统的内核当中实现的一种线程机制，由操作系统的内核来完成线程的创建、终止和管理.</p><ul><li>在支持内核线程的操作系统中，由内核来维护进程和线程的上下文信息(PCB和TCB);</li><li>线程的创建、终止和切换都是通过系统调用、内核函数的方式来进行，由内核来完成，因此系统开销较大;</li><li>在一个进程当中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他内核线程的运行;</li><li>时间片分配给线程，多线程的进程获得更多CPU时间;</li></ul><p><strong>轻量级进程</strong></p><p>它是内核支持的用户线程.一个进程可以有一个或多个轻量化进程,每个量级进程由一个单独的内核线程来支持.(Solaris,Linux)</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>由于内核级线程才是处理机分配的单位，所以可以采用组合的方法：将n个用户线程映射到m个内核线程上。</p><p><strong>多对一模型</strong>：多个用户线程映射到一个内核进程，每个进程只对应一个内核进程；</p><ul><li>优点：用户线程切换在用户空间即可完成，不需切到核心态，系统开销小，效率高；</li><li>缺点：当一个用户线程被阻塞，整个进程都会被阻塞，并发度不高；且多个线程不可在多核处理机上并行运行。</li></ul><p><strong>一对一模型：</strong>一个用户线程映射到一个内核线程，每个进程有多个内核进程；</p><ul><li>优点：一个线程被阻塞后，别的线程可以继续执行，并发度高；且多个线程可在多核处理机上并发执行；</li><li>缺点：一个用户进程占用多个内核线程，因为内核线程的操作 需要在操作系统核心态下进行，因此，线程管理开销大；</li></ul><p><strong>多对多模型：</strong>多个用户线程通过线程库映射到多个内核线程；</p><ul><li>客服了多对一的并发度不高的缺点，和一对一开销大的缺点。</li></ul><h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>停止当前运行进程(从运行状态变成其他状态),并且调度其他进程(转变为运行状态)</p><ul><li>必须在切换之前存储进程上下文</li><li>必须能够在之后恢复他们,所以进程不能显示它曾经被暂停过</li><li>必须快速(上下文切换时非常频繁)</li></ul><p>切换上下文需要存储：寄存器(PC,SP…)，CPU状态等信息。</p><p>操作系统为 进程 维护进程控制块。</p><p>操作系统将进程控制块放置在一个合适的队列中</p><ul><li>就绪队列</li><li>等待IO队列(每个设备的队列)</li><li>僵尸队列</li></ul><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h3><p>fork()的简单实现</p><ul><li>对子进程分配内存</li><li>复制父进程的内存和CPU寄存器到子进程</li><li>开销昂贵</li></ul><p>在99%的情况下,我们在调用fork()之后调用exec()</p><ul><li>在fork()操作中内存复制是没有作用的</li><li>子进程将可能关闭打开的文件和连接</li><li>开销因此是最高的</li></ul><p>vfork()</p><ul><li>一个创建进程的系统调用,不需要创建一个同样的内存映像</li><li>一些时候称为轻量级fork()</li><li>子进程应该几乎立即调用exec()</li><li>现在不再使用，如果我们使用 copy on write 技术</li></ul><h3 id="加载和执行进程"><a href="#加载和执行进程" class="headerlink" title="加载和执行进程"></a>加载和执行进程</h3><p>系统调用exec()加载程序取代当前运行的进程</p><p>exec()调用允许一个进程”加载”一个不同的程序并且在main开始执行(事实上 _start)</p><p>它允许一个进程指定参数的数量(argc)和它字符串参数数组(argv)</p><p>如果调用成功(相同的进程,不同的程序)</p><p>代码,stack,heap重写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork(); <span class="comment">//创建子进程</span></span><br><span class="line"><span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;    <span class="comment">//子进程</span></span><br><span class="line">exec_status = <span class="built_in">exec</span>(<span class="string">&quot;calc&quot;</span>, argc, argv0,argv1,...);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Why would I execute?&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; <span class="comment">//父进程</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Whose your daddy?&quot;</span>);</span><br><span class="line">...</span><br><span class="line">child_status = <span class="built_in">wait</span>(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待和终止进程"><a href="#等待和终止进程" class="headerlink" title="等待和终止进程"></a>等待和终止进程</h3><p>wait()系统调用是被父进程用来等待子进程的结束</p><ul><li>一个子进程向父进程返回一个值,所以父进程必须接受这个值并处理</li><li>wait()系统调用担任这个要求<ul><li>它使父进程去睡眠来等待子进程的结束</li><li>当一个子进程调用exit()的时候,操作系统解锁父进程,并且将通过exit()传递得到的返回值作为wait调用的一个结果(连同子进程的pid一起)如果这里没有子进程存活,wait()立刻返回</li><li>当然,如果这里有为父进程的僵尸等待,wait()立即返回其中一个值(并且解除僵尸状态)</li></ul></li><li>进程结束执行之后,它调用exit()</li><li>这个系统调用:<ul><li>将这程序的”结果”作为一个参数</li><li>关闭所有打开的文件,连接等等</li><li>释放内存</li><li>释放大部分支持进程的操作系统结构</li><li>检查父进程是存活着的:<ul><li>如果是的话,它保留结果的值直到父进程需要它;在这种情况里,进程没有真正死亡,但是它进入了僵尸状态</li><li>如果没有,它释放所有的数据结构,这个进程死亡</li></ul></li><li>清理所有等待的僵尸进程</li></ul></li><li>进程终止是最终的垃圾收集(资源回收)</li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><p>由于各进程拥有的内存地址空间相互独立，且为了保证安全，一个进程不能直接访问另一个进程的地址空间，所以操作系统需要提供一些安全的进程间通信：</p><ul><li><p><strong>共享存储</strong></p><p>开辟给若干进程的共享空间，且进程间对共享空间的<strong>访问是互斥</strong>的；</p></li><li><p><strong>消息传递</strong></p><p>进程间传递 结构化的消息（消息头，消息体），系统会提供发送&#x2F;接收的原语</p><ul><li>直接通信方式：消息直接挂到接收方的消息队列里；</li><li>间接通信方式(信箱)：消息先发到中间体(信箱)；</li></ul></li><li><p><strong>管道通信</strong></p><p>“管道”是指 用于连接读写进程 的一个共享文件（pipe文件），实质是在内存中开辟一个大小固定的缓冲区。</p><ul><li><p>管道只能采用半双工通信；如果要双向同时通信，需设置两个管道；</p></li><li><p>各进程要互斥地访问管道；</p></li><li><p>数据以字符流的形式写入管道，当管道写满时，写进程的write()会被阻塞，等待读进程将数据取走。</p><p>当读进程将数据全部取走后，管道为空，则读进程的read()会被阻塞。</p></li><li><p>如果管道没写满，则不允许读；管道还没读空，则不允许写。</p></li><li><p>数据一旦被读出，管道会立刻抛弃这些数据。</p></li></ul></li></ul><h1 id="八、调度算法"><a href="#八、调度算法" class="headerlink" title="八、调度算法"></a>八、调度算法</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><strong>上下文切换</strong></p><ul><li>切换CPU的当前任务, 从一个进程&#x2F;线程到另一个</li><li>保存当前进程&#x2F;线程在PCB&#x2F;TCB中的执行上下文(CPU状态)</li><li>读取下一个进程&#x2F;线程的上下文</li></ul><p><strong>CPU调度</strong></p><ul><li>从就绪队列中挑选一个进程&#x2F;线程作为CPU将要运行的下一个进程&#x2F;线程</li><li>调度程序: 挑选进程&#x2F;线程的内核函数(通过一些调度策略)</li><li>什么时候进行调度?</li></ul><p><strong>内核运行调度程序的条件(满足一条即可)</strong></p><ul><li>一个进程从运行状态切换到等待状态</li><li>一个进程被终结</li></ul><p><strong>不可抢占</strong></p><ul><li>调度程序必须等待事件结束</li></ul><p><strong>可以抢占</strong></p><ul><li>调度程序在中断被相应后执行</li><li>当前的进程从运行切换到就绪, 或者一个进程从等待切换到就绪</li><li>当前运行的进程可以被换出</li></ul><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h3><p>从就绪队列中按照一定的算法选择一个进程，并将处理机分配给它，以实现进程的并发执行；</p><h3 id="三个层次"><a href="#三个层次" class="headerlink" title="三个层次"></a><strong>三个层次</strong></h3><ul><li><p><strong>高级调度（作业调度）</strong>：</p><p>从后备队列中选择合适的作业将其调入内存，并为其创建进程；</p></li><li><p><strong>中级调度（内存调度）</strong>：</p><p>从挂起队列中选择合适的进程将其数据调回内存；</p></li><li><p><strong>低级调度（进程调度）</strong>：</p><p>从就绪队列中选择一个进程为其分配处理机；</p></li></ul><table><thead><tr><th></th><th>地点</th><th>频率</th><th>进程状态的改变</th></tr></thead><tbody><tr><td>高级调度（作业调度）</td><td>外存—》内存</td><td>最低</td><td>无—创建态—就绪态</td></tr><tr><td>中级调度（内存调度）</td><td>外存—》内存</td><td>中等</td><td>挂起态—就绪态（阻塞挂起——阻塞态）</td></tr><tr><td>低级调度（进程调度）</td><td>内存—》CPU</td><td>频繁</td><td>就绪态—运行态</td></tr></tbody></table><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730100.png" alt="image-20211217164209134"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730440.png" alt="image-20211217164239810"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730005.png" alt="image-20211217164315314"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730446.png" alt="image-20211217164259133"></p><h3 id="调度时机"><a href="#调度时机" class="headerlink" title="调度时机"></a>调度时机</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730350.png" alt="image-20211217165244133"></p><p>例题：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730266.png" alt="image-20211217165357442"></p><h3 id="切换与过程"><a href="#切换与过程" class="headerlink" title="切换与过程"></a>切换与过程</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730741.png" alt="image-20211217165515355"></p><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730830.png" alt="image-20211217165446842"></p><h2 id="调度原则"><a href="#调度原则" class="headerlink" title="调度原则"></a>调度原则</h2><ul><li><p><strong>调度策略</strong></p><p>人们通常都需要”更快”的服务</p><p>什么是更快?</p><ul><li>传输文件时的高带宽</li><li>玩游戏时的低延迟</li><li>这两个因素是独立的</li></ul><p>和水管类比</p><ul><li>低延迟: 喝水的时候想要一打开水龙头水就流出来</li><li>高带宽: 给游泳池充水时希望从水龙头里同时流出大量的水,并且不介意是否存在延迟</li></ul><p>我们的目标:</p><ul><li>减少响应时间: 及时处理用户的输出并且尽快将输出提供给用户</li><li>减少平均响应时间的波动: 在交互系统中,可预测性比高差异性低平均更重要</li><li>增加吞吐量: 减少开销(操作系统开销,上下文切换);系统资源的高效率用(CPU,IO设备)</li><li>减少等待时间: 减少每个进程的等待时间</li></ul></li><li><p><strong>程序执行模型</strong></p><p>执行模型 : 程序在CPU突发和IO中交替</p><ul><li>每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU</li><li>在时间分片机制下,线程可能在结束当前CPU突发前被迫放弃CPU</li></ul></li></ul><ul><li><p><strong>公平的目标</strong></p><p>举例:</p><ul><li>保证每个进程占用相同的CPU时间</li><li>这公平嘛?如果一个用户比其他用户运行更多的进程怎么办</li></ul><p>举例:</p><ul><li>保证每个进程都等待相同的时间</li></ul><p>公平通常会增加平均响应时间</p></li></ul><h2 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h2><ul><li><p><strong>CPU使用率</strong>： CPU处于忙状态所占时间的百分比</p></li><li><p><strong>吞吐量</strong>： 在单位时间内完成的进程&#x2F;作业数量</p></li><li><p><strong>周转时间</strong>： 一个进程从初始化到结束,包括所有等待时间所花费的时间，即<strong>作业完成时间 - 作业提交时间；</strong></p><p>平均周转时间：各作业周转时间之和&#x2F;作业数；</p><p><strong>带权周转时间：作业周转时间 &#x2F; 作业实际运行时间；</strong></p><p>平均带权周转时间：各作业带权周转时间之和&#x2F;作业数；</p></li><li><p><strong>等待时间</strong>： 进程在就绪队列中的总时间</p></li><li><p><strong>响应时间</strong>：  从一个请求被提交到产生第一次相应所花费的总时间</p></li></ul><p>各指标在操作系统上的表现:</p><p>低延迟调度增加了交互式表现(如果移动了鼠标,但是屏幕中的光标却没动,我们可能会重启电脑)</p><p>操作系统需要保证低吞吐量不受影响(我想要结束长时间的编程,所以操作系统必须不时进行调度,即使存在许多交互任务)</p><p>吞吐量是操作系统的计算带宽</p><p>响应时间是操作系统的计算延迟</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="FCFS-先来先服务"><a href="#FCFS-先来先服务" class="headerlink" title="FCFS(先来先服务)"></a>FCFS(先来先服务)</h3><p>First come, First Served</p><p>按照作业&#x2F;进程到达的先后顺序进行服务。（是非抢占式的算法，不会导致饥饿）</p><p>优点: 简单</p><p>缺点:</p><ul><li>平均等待时间波动较大</li><li>花费时间少的任务可能排在花费时间长的任务后面</li><li>可能导致IO和CPU之间的重叠处理  (CPU密集型进程会导致IO设备闲置时, IO密集型进程也在等待)</li></ul><h3 id="SJF-短作业优先"><a href="#SJF-短作业优先" class="headerlink" title="SJF(短作业优先)"></a>SJF(短作业优先)</h3><p><strong>SPN(SJF) SRT(短进程优先(短作业优先)短剩余时间优先)[最优平均等待时间]</strong></p><p>Shortest Process Next(<strong>Shortest Job First</strong>) Shortest Remaining Time</p><blockquote><p>使最短的作业优先得到服务（要求服务时间最短）。</p><p>可以是抢占的或者是不可抢占的</p><p>可能导致饥饿</p><ul><li>连续的短任务流会使长任务饥饿</li><li>短任务可用时的任何场任务的CPU时间都会增加平均等待时间</li></ul></blockquote><p>需要预测未来</p><ul><li>怎么预估下一个CPU突发的持续时间</li><li>简单的解决: 询问用户</li><li>如果用户欺骗就杀死进程</li></ul><h3 id="HRRN-最高响应比优先"><a href="#HRRN-最高响应比优先" class="headerlink" title="HRRN(最高响应比优先)"></a>HRRN(最高响应比优先)</h3><p>Highest Response Ratio Next</p><p>在每次调度时，计算各个作业&#x2F;进程的响应比，选择响应比最高的作业&#x2F;进程为其服务。</p><p>响应比：( 等待时间+要求服务时间 )  &#x2F; 要求服务时间</p><p>(非抢占式算法，不会导致饥饿)</p><h3 id="Round-Robin-轮循"><a href="#Round-Robin-轮循" class="headerlink" title="Round Robin(轮循)"></a>Round Robin(轮循)</h3><p>使用时间切片和抢占来轮流执行任务</p><p>在叫做量子(或者时间切片)的离散单元中分配处理器</p><p>时间片结束时,切换到下一个准备好的进程</p><p>花销: 额外的上下文切换</p><p>时间量子太大:</p><ul><li>等待时间过长</li><li>极限情况退化成FCFS</li></ul><p>时间量子太小:</p><ul><li>反应迅速</li><li>吞吐量由于大量的上下文切换开销受到影响</li></ul><p>目标:</p><ul><li>选择一个合适的时间量子</li><li>经验规则: 维持上下文切换开销处于1%以内</li></ul><h3 id="MFQ-多级反馈队列"><a href="#MFQ-多级反馈队列" class="headerlink" title="MFQ(多级反馈队列)"></a>MFQ(多级反馈队列)</h3><p><strong>Multilevel Feedback Queues(多级反馈队列)</strong></p><p>就绪队列被划分成多个独立的队列，并设置优先级；每个队列拥有自己的调度策略；</p><p>一个进程可以在不同的队列中移动</p><p>例如,n级优先级调度在所有级别中,RR在每个级别中</p><ul><li>时间量子大小随优先级级别增加而增加</li><li>如果任务在当前的时间量子中没有完成,则降到下一个优先级</li></ul><blockquote><p>各级队列的优先级越高，其分得的时间片越小；</p><p>新进程到达时先进入第1级队列，若用完当前队列分给它的时间片且还没运行完成，则该进程 进入下一级队列；如果以及在最低级队列，则还是在最低级队列重新排队；</p><p>如果允许抢占的话，被抢占的进程回重新在原队列排队。</p></blockquote><p>优点: <strong>CPU密集型任务的优先级下降很快;IO密集型任务停留在高优先级</strong></p><h3 id="FSS-公平共享调度"><a href="#FSS-公平共享调度" class="headerlink" title="FSS(公平共享调度)"></a>FSS(公平共享调度)</h3><p><strong>Fair Share Scheduling(公平共享调度)</strong></p><p>FSS控制用户对系统资源的访问</p><ul><li>一些用户组比其他用户组更重要</li><li>保证不重要的组无法垄断资源</li><li>未使用的资源按照每个组所分配的资源的比例来分配</li><li>没有达到资源使用率目标的组获得更高的优先级</li></ul><h2 id="评价方式"><a href="#评价方式" class="headerlink" title="评价方式"></a>评价方式</h2><p>确定性建模: 确定一个工作量,然后计算每个算法的表现</p><p>队列模型: 用来处理随机工作负载的数学方法</p><p>实现&#x2F;模拟: 建立一个允许算法运行实际数据的系统;最灵活,最具一般性</p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><ul><li><p>实时系统</p><p>定义: 正确性依赖于其时间和功能两方面的一个操作系统</p><p>性能指标: 时间约束的及时性;速度和平均性能相对不重要</p><p>主要特征: 时间约束的可预测性</p><p>分类:</p><ul><li>强实时系统: 需要在保证时间内完成重要的任务,必须完成</li><li>弱实时系统: 要求重要的进程的优先级更高,尽量完成,并非必须</li></ul><p>任务(工作单元): 一次计算,一次文件读取,一次信息传递等</p><p>属性: 去的进展所需要的资源;定时参数.</p></li><li><p>单调速率(RM)</p><ul><li>最佳静态优先级调度</li><li>通过周期安排优先级</li><li>周期越短优先级越高</li><li>执行周期最短的任务</li></ul></li><li><p>截止日期最早优先(EDF)</p><ul><li>最佳的动态优先级调度</li><li>Deadline越早优先级越高</li><li>执行Deadline最早的任务</li></ul></li></ul><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>多处理器的CPU调度更复杂:</p><ul><li>多个相同的单处理器组成一个多处理器</li><li>优点: 复杂共享</li></ul><p>对称多处理器(SMP)</p><ul><li>每个处理器运行自己的调度程序</li><li>需要在调度程序中同步</li></ul><h2 id="优先级反转"><a href="#优先级反转" class="headerlink" title="优先级反转"></a>优先级反转</h2><p>可以发生在任务基于优先级的可抢占的调度机制中</p><p>当系统内的环境强制使高优先级任务等待低优先级任务时发生</p><h1 id="九、同步和互斥"><a href="#九、同步和互斥" class="headerlink" title="九、同步和互斥"></a>九、同步和互斥</h1><h2 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h2><p>并发性带来了异步性，有时需要通过进程同步来解决这种异步问题；一些进程之间需要相互配合地完成工作，或进程共享一个存储区，对其中的操作需要是同步的。</p><h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p><strong>互斥</strong>(Mutual exclusion)：又称间接制约关系。进程互斥是指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。</p><p><strong>临界资源</strong>：一段时间内只允许一个进程使用的资源；对临界资源的访问，必须互斥地进行。</p><p><strong>临界区</strong>(Critical section)是指进程中访问临界资源的代码段。（进入区和退出区是负责实现互斥的代码段）</p><p><strong>死锁</strong>(Dead lock)是指两个或以上进程,在相互等待完成特定任务,而最终没法将自身任务进行下去。</p><p><strong>饥饿</strong>(Starvation)是指一个可执行的进程,被调度器持续忽略,以至于虽然处于可执行状态却不被执行。</p><h2 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h2><p>”互斥“要求 同一时间临界区中最多存在一个线程</p><p>如果一个线程想要进入临界区,那么它最终会成功；</p><ul><li><p><strong>空闲让进</strong>：当临界区空闲时，应允许一个进程进入；</p></li><li><p><strong>有限等待</strong>：在有限时间内进入临界区，保证不会饥饿；</p></li><li><p><strong>忙则等待</strong>: 如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起；</p></li><li><p><strong>让权等待</strong>：暂时进不了临界区的进程，要释放处理机，防止忙等；</p></li></ul><h2 id="软件实现互斥"><a href="#软件实现互斥" class="headerlink" title="软件实现互斥"></a>软件实现互斥</h2><ul><li><p><strong>单标志法</strong></p><p>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程，即每个进程进入临界区的权限只能被另一个进程赋予。</p><p>此算法实现“同一时刻最多只允许一个进程访问临界区”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示当前允许进入临界区的进程号</span></span><br><span class="line">p0进程:</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)</span><br><span class="line">临界区</span><br><span class="line">turn = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">1</span>)</span><br><span class="line">临界区</span><br><span class="line">turn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>缺点：违背了“空闲让进”原则，如果p0一直不访问临界区，则p1也无法访问临界区。</p></li><li><p><strong>双标志先检查</strong></p><p>设置一个布尔类型数组flag[]，用于标记各进程想进入临界区的意愿；每个进程在进入临界区之前，先检查当前是否有别的进程进入临界区。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进程是否进入临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>;    </span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;    </span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>缺点：违背了“忙则等待”原则，因为进入区的“检查和上锁”不是一气呵成的，“检查”后，“上锁”前可能发生进程切换，导致多个进程同时访问临界区。</p></li><li><p><strong>双标志后检查</strong></p><p>先上锁再检查；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>]; <span class="comment">//表示进程是否进入临界区</span></span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">true</span>; <span class="comment">//先上锁</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>]);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">true</span>;  <span class="comment">//先上锁 </span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>]);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>缺点：虽然解决了“忙则等待”问题，但又违背了“空闲让进”和“有限等待”原则，可能导致进程“饥饿”。</p></li><li><p><strong>Peterson算法</strong></p><p>进程会先进行礼让，主动让对方先使用临界区；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> turn = <span class="number">0</span>; <span class="comment">//表示哪个进程优先进入临界区</span></span><br><span class="line"></span><br><span class="line">p0进程:</span><br><span class="line">flag[<span class="number">0</span>] = ture;<span class="comment">//自己想进临界区</span></span><br><span class="line">turn = <span class="number">1</span>;<span class="comment">//可以优先让对方先进</span></span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">1</span>] &amp;&amp; turn == <span class="number">1</span>); <span class="comment">//对方想进且最后一次是自己进行礼让，则自己等待</span></span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">p1进程:</span><br><span class="line">flag[<span class="number">1</span>] = ture;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(flag[<span class="number">0</span>] &amp;&amp; turn == <span class="number">0</span>);</span><br><span class="line">临界区</span><br><span class="line">flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>缺点：没遵循”让权等待“原则（上面几个算法都在等待时占用CPU资源来检查），因为没有提供阻塞排队之类的机制，所以等待的时候需要一直检查条件，占用CPU。</p></li></ul><h2 id="硬件实现互斥"><a href="#硬件实现互斥" class="headerlink" title="硬件实现互斥"></a>硬件实现互斥</h2><ul><li><p><strong>中断屏蔽方法</strong></p><p>利用”开&#x2F;关中断指令“指令，在进入临界区前关闭中断，出临界区打开中断，这样，单个处理机上的进程就不会同时访问一个临界区；</p><p>优点：简单，高效；</p><p>缺点：不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（开&#x2F;关中断指令只能在运行在内核态）</p></li><li><p><strong>TestAndSet（TS指令&#x2F;TSL指令）</strong></p><p>TSL指令是用硬件实现，执行的过程不允许被中断，可让”上锁“和”检查“操作一气呵成；</p><p>优点：实现简单；适用多处理机；</p><p>缺点：不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，导致忙等；</p></li><li><p><strong>Swap指令（XCHG指令）</strong></p><p>Swap指令是用硬件实现，用于交换两个变量的值，执行过程不许打断。</p></li></ul><h1 id="十、信号量、管程"><a href="#十、信号量、管程" class="headerlink" title="十、信号量、管程"></a>十、信号量、管程</h1><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量是一个整数或更复杂的记录型变量，用来表示系统中<strong>某种资源的数量</strong>。</p><p>操作信号量的一对<strong>原语</strong>：（S是传入的信号量)</p><ul><li><strong>wait (S) 原语：S减1，简称P操作</strong></li><li><strong>signal (S) 原语：S加1，简称V操作</strong></li></ul><blockquote><p>P()能够阻塞，V()不会阻塞</p><p>对信号量的操作只能有：初始化，P(S)，V(S)</p></blockquote><p><strong>使用记录型信号量可以避免忙等</strong>，即设置一个队列，在P操作时，如果信号量小于0，则主动阻塞并挂到信号量的等待队列中，V操作时，如果信号量小于等于0时，等唤醒一个等待队列中的进程。</p><h2 id="信号量使用"><a href="#信号量使用" class="headerlink" title="信号量使用"></a>信号量使用</h2><ol><li><p><strong>互斥</strong>信号量：信号量的值只有0和1；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">p1()&#123;</span><br><span class="line">...</span><br><span class="line"> P(mutex);</span><br><span class="line">    临界区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">p2()&#123;</span><br><span class="line">...</span><br><span class="line"> P(mutex);</span><br><span class="line">    临界区;</span><br><span class="line">    V(mutex);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>同步</strong>信号量：用信号量实现的调度约束，一个线程等待另一个线程处理事务完后再执行；</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore S = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P1</span>()&#123;</span><br><span class="line">    ... <span class="comment">//需要先执行的代码;</span></span><br><span class="line">    <span class="built_in">V</span>(S);  <span class="comment">//让资源从0到1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">P2</span>()&#123;</span><br><span class="line">    <span class="built_in">P</span>(s);<span class="comment">//等待前代码执行完后的V操作</span></span><br><span class="line">    ...<span class="comment">//需要后执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现<strong>前驱关系</strong>，前驱关系类似一个有向图，操作之间有前后之分；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191730185.png" alt="image-20211219114540945"></p></li></ol><h2 id="信号量实现"><a href="#信号量实现" class="headerlink" title="信号量实现"></a>信号量实现</h2><p>使用硬件原语</p><ul><li>禁用中断</li><li>原子指令</li></ul><p>类似锁</p><ul><li>禁用中断</li></ul><p>信号量的双用途：</p><ul><li>互斥和条件同步</li><li>但等待条件是独立的互斥</li></ul><p>但使用信号量，使得读、开发代码比较困难，程序员必须非常精通信号量</p><blockquote><p>容易出错</p><ul><li>使用的信号量已经被另一个线程占用</li><li>忘记释放信号量</li></ul></blockquote><p>使用信号量不能够处理死锁问题</p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><strong>管程的组成：</strong></p><ul><li>共享的数据结构；</li><li>对数据结构初始化的语句；</li><li>一组用来访问数据结构的函数&#x2F;方法；</li></ul><p><strong>基本特征：</strong></p><ul><li><strong>各个外部进程&#x2F;线程只能通过管程提供的特定“入口”才能访问共享数据；</strong></li><li><strong>每次仅允许一个进程在管程内执行某个内部过程；</strong></li></ul><p>注：各进程必须互斥访问管程的特性是由编译器实现的；可在管程中设置条件变量及等待&#x2F;唤醒操作以解决同步问题；</p><hr><p>管程解决生产者-消费者问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BoundedBuffer</span>&#123;</span><br><span class="line">Lock lock;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">//buffer 为空</span></span><br><span class="line">Condition notFull, notEmpty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Deposit</span>(c)&#123;</span><br><span class="line">lock-&gt;<span class="built_in">Acquire</span>();    <span class="comment">//管程的定义:只有一个线程能够进入管程</span></span><br><span class="line"><span class="keyword">while</span>(count == n)</span><br><span class="line">notFull.<span class="built_in">Wait</span>(&amp;lock); <span class="comment">//释放前面的锁</span></span><br><span class="line">Add c to the buffer;</span><br><span class="line">count++;</span><br><span class="line">notEmpty.<span class="built_in">Signal</span>();</span><br><span class="line">lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BoundedBuffer::<span class="built_in">Remove</span>(c)&#123;</span><br><span class="line">lock-&gt;<span class="built_in">Acquire</span>();</span><br><span class="line"><span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">notEmpty.<span class="built_in">Wait</span>(&amp;lock);</span><br><span class="line">Remove c from buffer;</span><br><span class="line">count--;</span><br><span class="line">notFull.<span class="built_in">Signal</span>();</span><br><span class="line">lock-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><ol><li><p><strong>生产者—消费者问题</strong></p></li><li><p><strong>吸烟者问题</strong></p></li><li><p><strong>读者-写者问题</strong></p><p>动机: 共享数据的访问</p><p>两种类型的使用者: 读者(不修改数据) 写者(读取和修改数据)</p><p>问题的约束:</p><ul><li>允许同一时间有多个读者,但在任何时候只有一个写者</li><li>当没有写者时,读者才能访问数据</li><li>当没有读者和写者时,写者才能访问数据</li><li>在任何时候只能有一个线程可以操作共享变量</li></ul><p>多个并发进程的数据集共享</p><ul><li>读者: 只读数据集;他们不执行任何更新</li><li>写者: 可以读取和写入</li></ul><p>共享数据</p><ul><li>数据集</li><li>信号量CountMutex初始化为1</li><li>信号量WriteMutex初始化为1</li><li>整数Rcount初始化为0(当前读者个数)</li></ul><p>读者优先设计</p><p>只要有一个读者处于活动状态, 后来的读者都会被接纳.如果读者源源不断的出现,那么写者使用处于阻塞状态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//信号量实现</span></span><br><span class="line"><span class="comment">//writer</span></span><br><span class="line"><span class="built_in">sem_wait</span>(WriteMutex);</span><br><span class="line">write;</span><br><span class="line"><span class="built_in">sem_post</span>(WriteMutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line"><span class="built_in">sem_wait</span>(CountMutex);</span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">sem_wait</span>(WriteMutex); <span class="comment">//确保后续不会有写者进入</span></span><br><span class="line">++Rcount;</span><br><span class="line">read;</span><br><span class="line">--Rcount;</span><br><span class="line"><span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">sem_post</span>(WriteMutex); <span class="comment">//全部读者全部离开才能唤醒写者</span></span><br><span class="line"><span class="built_in">sem_post</span>(CountMutex);</span><br></pre></td></tr></table></figure><p>写者优先设计</p><p>一旦写者就绪,那么写者会尽可能的执行写操作.如果写者源源不断的出现的话,那么读者就始终处于阻塞状态.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//writer</span></span><br><span class="line">Database::<span class="built_in">Write</span>()&#123;</span><br><span class="line">Wait until readers/writers;</span><br><span class="line">write database;</span><br><span class="line">check out - wake up waiting readers/writers;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line">Database::<span class="built_in">Read</span>()&#123;</span><br><span class="line">Wait until no writers;</span><br><span class="line">read database;</span><br><span class="line">check out - wake up waiting writers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//管程实现</span></span><br><span class="line">AR = <span class="number">0</span>; <span class="comment">// # of active readers</span></span><br><span class="line">AW = <span class="number">0</span>; <span class="comment">// # of active writers</span></span><br><span class="line">WR = <span class="number">0</span>; <span class="comment">// # of waiting readers</span></span><br><span class="line">WW = <span class="number">0</span>; <span class="comment">// # of waiting writers</span></span><br><span class="line">Condition okToRead;</span><br><span class="line">Condition okToWrite;</span><br><span class="line">Lock lock;</span><br><span class="line"><span class="comment">//writer</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Write</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Wait until no readers/writers;</span></span><br><span class="line"><span class="built_in">StartWrite</span>();</span><br><span class="line">write database;</span><br><span class="line"><span class="comment">//check out - wake up waiting readers/writers;</span></span><br><span class="line"><span class="built_in">DoneWrite</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line"><span class="keyword">while</span>((AW + AR) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">WW++;</span><br><span class="line">okToWrite.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">WW--;</span><br><span class="line">&#125;</span><br><span class="line">AW++;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::DoneWrite</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line">AW--;</span><br><span class="line"><span class="keyword">if</span>(WW &gt; <span class="number">0</span>)&#123;</span><br><span class="line">okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(WR &gt; <span class="number">0</span>)&#123;</span><br><span class="line">okToRead.<span class="built_in">broadcast</span>(); <span class="comment">//唤醒所有reader </span></span><br><span class="line">&#125;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//reader</span></span><br><span class="line"><span class="function">Public <span class="title">Database::Read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//Wait until no writers;</span></span><br><span class="line"><span class="built_in">StartRead</span>();</span><br><span class="line">read database;</span><br><span class="line"><span class="comment">//check out - wake up waiting writers;</span></span><br><span class="line"><span class="built_in">DoneRead</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Private <span class="title">Database::StartRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line"><span class="keyword">while</span>(AW + WW &gt; <span class="number">0</span>)&#123;    <span class="comment">//关注等待的writer,体现出写者优先</span></span><br><span class="line">WR++;</span><br><span class="line">okToRead.<span class="built_in">wait</span>(&amp;lock);</span><br><span class="line">WR--;</span><br><span class="line">&#125;</span><br><span class="line">AR++;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Database::DoneRead</span><span class="params">()</span></span>&#123;</span><br><span class="line">lock.<span class="built_in">Acquire</span>();</span><br><span class="line">AR--;</span><br><span class="line"><span class="keyword">if</span>(AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>)&#123;  <span class="comment">//只有读者全部没有了,才需要唤醒</span></span><br><span class="line">okToWrite.<span class="built_in">signal</span>();</span><br><span class="line">&#125;</span><br><span class="line">lock.<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哲学家就餐问题</p><p>一圆桌坐着5位哲学家，他们有思考和吃饭两种状态，而每两个人之间有一根筷子，哲学家只有在饥饿时才试图拿起左右的两只筷子去吃饭（一根一根的拿），如果筷子被别人拿了则需要等待，而哲学家在用餐完后会放下筷子继续思考。</p><p>思路：</p><ol><li>最多允许4个哲学家同时进餐，这样就至少保证有一个哲学家可以拿到左右两只筷子；</li><li>依次给哲学家和筷子编号，要求奇数号的哲学家先拿左边筷子，偶数号的哲学家先拿右边筷子。这样当相邻两个哲学家都想进餐时，只有一个可以拿起筷子，另一个会直接阻塞，避免了占有一只筷子再等待另一只筷子的情况；</li><li>仅当一个哲学家左右两只筷子都可用时才允许他抓起筷子，拿两只筷子的过程应该连续，即拿筷子前加锁，拿完&#x2F;吃完后解锁。</li></ol><hr><p> 共享数据:</p><ul><li>Bowl of rice(data set)</li><li>Semaphone fork [5] initialized to 1</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEFT (i + N - 1) % N <span class="comment">// 左邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT (i + 1) % N    <span class="comment">// 右邻居</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THINKING 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HUNGRY   1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EATING   2</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> semaphore;</span><br><span class="line"><span class="type">int</span> state[N];                <span class="comment">// 跟踪每个哲学家的状态</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;         <span class="comment">// 临界区的互斥，临界区是 state 数组，对其修改需要互斥</span></span><br><span class="line">semaphore s[N];              <span class="comment">// 每个哲学家一个信号量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">philosopher</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TRUE) &#123;</span><br><span class="line">        <span class="built_in">think</span>(i);</span><br><span class="line">        <span class="built_in">take_two</span>(i);</span><br><span class="line">        <span class="built_in">eat</span>(i);</span><br><span class="line">        <span class="built_in">put_two</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">take_two</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = HUNGRY;</span><br><span class="line">    <span class="built_in">check</span>(i);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">    <span class="built_in">down</span>(&amp;s[i]); <span class="comment">// 只有收到通知之后才可以开始吃，否则会一直等下去</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">put_two</span><span class="params">(i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = THINKING;</span><br><span class="line">    <span class="built_in">check</span>(LEFT); <span class="comment">// 尝试通知左右邻居，自己吃完了，你们可以开始吃了</span></span><br><span class="line">    <span class="built_in">check</span>(RIGHT);</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">down</span>(&amp;mutex);</span><br><span class="line">    state[i] = EATING;</span><br><span class="line">    <span class="built_in">up</span>(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查两个邻居是否都没有用餐，如果是的话，就 up(&amp;s[i])，使得 down(&amp;s[i]) 能够得到通知并继续执行</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span><span class="params">(i)</span> </span>&#123;         </span><br><span class="line">    <span class="keyword">if</span>(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123;</span><br><span class="line">        state[i] = EATING;</span><br><span class="line">        <span class="built_in">up</span>(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="十一、死锁，进程通信"><a href="#十一、死锁，进程通信" class="headerlink" title="十一、死锁，进程通信"></a>十一、死锁，进程通信</h1><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>一组阻塞的进程持有一种资源等待获取另一个进程所占有的一个资源</p><p>示例:</p><ul><li>系统有2个磁带驱动器</li><li>P1和P2各有一个,都需要另外一个</li></ul><h2 id="死锁特征"><a href="#死锁特征" class="headerlink" title="死锁特征"></a>死锁特征</h2><p>死锁出现一定会出现以下四个条件，但是出现以下四个条件不一定死锁：</p><ul><li><strong>互斥</strong>：在一个时间只能有一个进程使用资源；</li><li><strong>持有并等待</strong>：进程持有至少一个资源，并等待获取其他进程持有的资源；</li><li><strong>不可剥夺</strong>： 进程所获得的资源在未使用完之前，不能被强行夺走，只能主动释放；</li><li>**循环等待(环路条件)**： 存在等待进程集合{P0,P1,…,Pn}，P0正在等待P1所占用的资源，P1正在等待P2占用的资源…Pn-1在等待Pn的资源，Pn正在等待P0所占用的资源</li></ul><h2 id="死锁处理方法"><a href="#死锁处理方法" class="headerlink" title="死锁处理方法"></a>死锁处理方法</h2><p>常见方法</p><ul><li>确保系统永远不会进入死锁状态</li><li>运行系统进入死锁状态,然后恢复.</li><li>忽略这个问题,假装系统中从来没有发生死锁,用于大多数操作系统,包括UNIX</li></ul><h3 id="Deadlock-Prevention-预防"><a href="#Deadlock-Prevention-预防" class="headerlink" title="Deadlock Prevention    预防"></a>Deadlock Prevention    预防</h3><p>限制申请方式（破环四种条件）：</p><ul><li>破坏”互斥“ —— 共享资源不是必须的</li><li>破坏”占用并等待“ —— 当一个进程请求资源前，它不持有任何其他资源<ul><li>一次性申请所需要的所有资源，才开始执行进程；</li><li>资源利用率低，可能发生饥饿；</li></ul></li><li>破坏”不可剥夺“——<ul><li>如果进程占有某些资源,并请求其他不能被立即分配的资源,则释放当前正占有的资源</li><li>被抢占资源添加到资源列表中</li><li>只有当它能够获得旧的资源以及它请求新的资源,进程可以得到执行</li><li>可能导致饥饿；</li></ul></li><li>破坏”环路条件&#x2F;循环等待“ - 对所有资源类型进行排序,并要求每个进程按照资源的顺序进行申请（顺序资源分配法）<ul><li>不方便新增设备；</li><li>实际使用资源的顺序和资源的编号&#x2F;申请顺序不一致，导致资源浪费；</li></ul></li></ul><h3 id="Deadlock-Avoidance-避免"><a href="#Deadlock-Avoidance-避免" class="headerlink" title="Deadlock Avoidance     避免"></a>Deadlock Avoidance     避免</h3><ul><li><p>最简单和最有效的模式是要求每个进程声明它可能需要的每个类型资源的最大数目</p></li><li><p>资源的分配状态是通过限定提供与分配的资源数量,和进程的最大需求</p></li><li><p>死锁避免算法动态检查的资源分配状态,以确保永远不会有一个环形等待状态</p></li><li><p><strong>当一个进程请求可用资源,系统必须判断立即分配是否能使系统处于安全状态</strong></p></li><li><p>系统<strong>处于安全状态是指: 针对所有进程,存在安全序列</strong></p><blockquote><p><strong>安全序列：按照此序列分配资源，则最终每个进程都能顺利完成</strong>。安全序列可能有多个；</p></blockquote></li><li><p>序列&lt;P1,P2,…,Pn&gt;是安全的: 针对每个Pi,Pi要求的资源能够由当前可用的资源+所有的Pj持有的资源来满足,其中j&lt;i.</p><ul><li>如果Pi资源的需求不是立即可用,那么Pi可以等到所有Pj完成</li><li>当Pi完成后,Pi+1可以得到所需要的资源,执行,返回所分配的资源,并终止.</li><li>用同样的方法,Pi+2,Pi+3和Pn能获得其所需的资源.</li></ul></li><li><p>如果系统处于<strong>安全状态→无死锁</strong></p></li><li><p>如果系统处于不安全状态→可能死锁</p></li><li><p>避免死锁: 确保系统永远不会进入不安全状态</p></li></ul><p><strong>银行家算法：</strong></p><ol><li><p>检查此次申请是否超过之前声明的最大需求数；</p></li><li><p>检查此时系统剩余的可用资源是否能满足此次申请；</p></li><li><p>试探性分配，更改数据结构；</p></li><li><p>用安全性算法检查此次分配是否会让系统进入不安全状态；</p><blockquote><p>安全性算法：</p><p>检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收；</p><p>不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p></blockquote></li></ol><h3 id="Deadlock-Detection-检测"><a href="#Deadlock-Detection-检测" class="headerlink" title="Deadlock Detection     检测"></a>Deadlock Detection     检测</h3><p>进行死锁检测，需要：</p><ul><li>一种数据结构，用来保存资源的请求和分配信息；</li><li>提供一种算法，利用上述信息来检测系统是否已进入死锁状态；</li></ul><p>数据结构：<strong>资源分配图</strong></p><ul><li>两种节点<ul><li>进程节点：对应一个进程；</li><li>资源节点：对应一类资源，一类资源可能有多个；</li></ul></li><li>两种边<ul><li>进程点—》资源点：表示进程想申请几个资源，一条边代表一个资源；</li><li>资源点—》进程点：表示已经为进程分配了几个资源；</li></ul></li><li>示例图：<img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731864.png" alt="image-20211222100333315"></li></ul><p>算法：</p><ol><li>在资源分配图中，找出既不阻塞又不是孤点的进程节点，消去它的所有请求边和分配边，使之成为孤立的点。（如上图中，p1满足条件，于是先将p1的所有边消去）</li><li>第一步中进程释放了资源，以此可以唤醒等待这些资源而阻塞的进程，重复第一步，如果最终能消去图中所有的边，则称该图是可完全简化的。（如果某时刻系统的资源分配图不可完全简化，则此时系统死锁）</li></ol><p>如果检测算法多次被调用,有可能是资源图有多个循环,所以我们无法分辨出多个可能死锁进程中的哪些”造成”死锁</p><h3 id="Recovery-from-Deadlock-恢复"><a href="#Recovery-from-Deadlock-恢复" class="headerlink" title="Recovery from Deadlock 恢复"></a>Recovery from Deadlock 恢复</h3><ul><li><p>撤销进程法：终止所有的死锁进程</p></li><li><p>资源剥夺法：抢夺一个或多个死锁进程占有的资源，使死锁消除</p></li><li><p>进程回退法：让一个或多个死锁进程回退到足以避免死锁的地步（要求系统记录进程的历史信息，设置还原点）</p></li></ul><p>终止进程应该考虑：</p><ul><li>进程的优先级</li><li>进程运行了多久</li><li>需要多少时间才能完成</li><li>进程占用的资源</li><li>进程完成需要的资源</li><li>多少进程需要被终止</li><li>进程是交互还是批处理</li></ul><p>选择一个受影响最小的方法</p><p>回滚 - 返回到一些安全状态,重启进程到安全状态</p><p>饥饿 - 同一进程可能一直被选作受害者,包括回滚的数量</p><h2 id="进程间通信-IPC"><a href="#进程间通信-IPC" class="headerlink" title="进程间通信(IPC)"></a>进程间通信(IPC)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>进程通信的机制及同步</p><p>不使用共享变量的进程通信</p><p>IPC facility 提供2个操作:</p><ul><li>send(message) - 消息大小固定或者可变</li><li>receive(message)</li></ul><p>如果P和Q想通信,需要:</p><ul><li>在它们之间建立通信链路</li><li>通过send&#x2F;recevie交换消息</li></ul><p>通信链路的实现</p><ul><li>物理(例如,共享内存,硬件总线)</li><li>逻辑(例如,逻辑属性)</li></ul><h3 id="直接通信"><a href="#直接通信" class="headerlink" title="直接通信"></a>直接通信</h3><p>进程必须正确的命名对方:</p><ul><li>send(P, message) - 发送消息到进程P</li><li>receive(Q, message) - 从进程Q接收信息</li></ul><p>通信链路的属性</p><ul><li>自动建立链路</li><li>一条链路恰好对应一对通信进程</li><li>每对进程之间只有一个链路存在</li><li>链路可以是单向的,但通常是双向的</li></ul><h3 id="间接通信"><a href="#间接通信" class="headerlink" title="间接通信"></a>间接通信</h3><p>定向从消息队列接收消息</p><ul><li>每个消息对垒都有一个唯一的ID</li><li>只有它们共享了一个消息队列,进程才能够通信</li></ul><p>通信链路的属性</p><ul><li>只有进程共享一个共同的消息队列,才建立链路</li><li>链接可以与许多进程相关联</li><li>每对进程可以共享多个通信链路</li><li>链接可以是单向或者双向</li></ul><p>操作</p><ul><li>创建一个新的消息队列</li><li>通过消息队列发送和接收消息</li><li>销毁消息队列</li></ul><p>原语的定义如下:</p><ul><li><p>send(A, message)</p></li><li><p>receive(A, message)</p></li><li><p>通信链路缓冲</p><p>  通信链路缓存大小:</p><ol><li>0容量 - 0 message : 发送方必须等待接收方</li><li>有限容量 - n messages的有限长度 : 发送方必须等待,如果队列满</li><li>无限容量 - 无限长度 : 发送方不需要等待</li></ol></li></ul><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>信号Signal</p><ul><li>软件中断通知事件处理</li><li>Examples: SIGFPE, SIGKILL, SIGUSRI, SIGSTOP, SIGCONT</li></ul><p>接收到信号时会发生什么?</p><ul><li>catch:  指定信号处理函数被调用</li><li>ignore: 依靠操作系统的默认操作(abort, memory dump, suspend or resume process)</li><li>mask:   闭塞信号因此不会传送(可能是暂时的,当处理同样类型的信号)</li></ul><p>不足:</p><ul><li>不能传输要交换的任何数据</li></ul><h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>数据交换</p><p>子进程从父进程继承文件描述符(0 stdin, 1 stdout, 2 stderr)</p><p>进程不知道(或不关心)从键盘,文件,程序读取或写入到终端,文件,程序.</p><p>例如: $ ls | more (两个进程, 管道是缓存,对于ls来说是stdout,对于more来说是stdin )</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列按FIFO来管理消息</p><ul><li>message: 作为一个字节序列存储</li><li>message queues: 消息数组</li><li>FIFO &amp;  FILO configuration</li></ul><h3 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h3><p>进程</p><ul><li>每个进程都有私有地址空间</li><li>在每个地址空间内,明确地设置了共享内存段</li></ul><p>优点</p><ul><li>快速,方便地共享数据</li></ul><p>不足</p><ul><li>必须同步数据访问</li></ul><p>最快的方法</p><p>一个进程写另一个进程立即可见</p><p>没有系统调用干预</p><p>没有数据复制</p><p>不提供同步</p><ul><li>Socket</li></ul><h1 id="十二、文件管理"><a href="#十二、文件管理" class="headerlink" title="十二、文件管理"></a>十二、文件管理</h1><h2 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h2><p><strong>无结构文件</strong></p><ul><li>文件内部的数据就是一系列二进制流或字符流组成，又称“流式文件”，如 .txt文件</li></ul><p><strong>有结构文件</strong>：由一组相似的记录组成，又称“记录式文件”，每条记录由若干个数据项组成。根据各条记录的长度是否相等，又可分为定长记录和可变长记录。</p><ul><li><p>顺序文件</p><p>文件中的记录一个接一个地顺序排列（逻辑上），记录可以是定长的或可变长的，在物理上可以顺序存储或链式存储。</p><ul><li><p>链式存储：无法实现随机存取，每次只能从第一个记录开始依次往后查找；</p></li><li><p>顺序存储：</p><ul><li><p>可变长记录：</p><p>无法实现随机存取，每次只能从第一个记录开始依次往后查找；</p></li><li><p>定长记录：</p><p>可随机存取，能快速找到某关键字对应的记录。</p></li></ul></li></ul></li><li><p>索引文件</p><p>文件的记录在物理上离散地存放，并建立一张索引表，其中<strong>每条</strong>记录对应一个索引项，可以快速找到对应的文件记录。</p><p>索引表是定长记录的顺序文件，可以快速查找；</p></li><li><p>索引顺序文件</p><p>索引文件存在缺点：每个记录对应一个索引表项，会使索引表占用较大空间；因此，可以使<strong>一组</strong>顺序的记录对应一个索引表项，这就是索引顺序文件。</p><p>当记录过多时，可建立多级索引表。</p></li></ul><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><strong>文件控制块（FCB）</strong>：目录文件中的一条记录。</p><ul><li>基本信息：<strong>文件名、物理地址</strong>、逻辑结构、物理结构等；</li><li>存取控制信息：是否可读&#x2F;可写、禁止访问的用户名单等；</li><li>使用信息：文件的建立时间、修改时间等；</li></ul><p><strong>FCB的有序集合称为“文件目录”</strong>，一个FCB就是一个文件目录项。</p><hr><p><strong>目录操作</strong></p><ul><li>搜索</li><li>创建文件</li><li>删除文件</li><li>显示文件</li><li>修改目录</li></ul><hr><p><strong>目录结构：</strong></p><ul><li><p>单极目录结构：只有一个目录（不适用）</p></li><li><p>两级目录结构（早期的多用户操作系统）：主文件目录和用户文件目录，允许不同用户的文件重名，可以添加访问限制。缺乏灵活性，用户不能对自己的文件分类。</p></li><li><p>多级目录结构（树形目录结构）：有一个根目录，下有多个子目录，子目录也有它的子目录，跟树结构一样。</p><p>有相对路径、绝对路径，使用相对路径可以直接从当前目录出发寻找数据，而不用从根目录开始。</p><p>缺点：不便于文件的共享。</p></li><li><p>无环图目录结构：跟多级目录结构很像，只是可以让不同的文件名指向同一个文件，或指向同一个目录（共享同一个目录下的所有内容）；</p><p>共享计数器：用于记录有多少个地方在共享该节点。当用户删除节点时，只是删除该用户的FCB，并使共享计数器减1，并不会直接删除该共享节点；只有当共享计数器为0时，才删除节点。</p><blockquote><p>共享文件不是复制文件，所以当某个用户修改了文件数据，所有用户都可以看到文件数据的变化。</p></blockquote></li></ul><hr><p><strong>索引节点（FCB的改进）</strong></p><p>由于FCB是一张表，记录了每个文件的很多信息，这会占用不少空间，由于磁盘I&#x2F;O每次读入一块磁盘，当需要查询很多表项时，需要启动磁盘多次；因此，应该减少FCB的占用空间，这样在查询时就不用启动磁盘过多次。</p><p>由于查找时只使用文件名作为关键字，因此可以建立索引表，用文件名作为关键字，其他文件信息放到索引节点去，这样一个索引表的大小就小很多了。</p><hr><hr><hr><h2 id="磁盘块管理"><a href="#磁盘块管理" class="headerlink" title="磁盘块管理"></a>磁盘块管理</h2><ul><li>对<strong>非空闲</strong>磁盘块的管理（存放了文件数据的磁盘块）——文件的<strong>物理结构&#x2F;文件分配方式</strong></li><li>对<strong>空闲</strong>磁盘块的管理——文件<strong>存储空间管理</strong></li></ul><h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><p>（文件的分配方式）</p><p>类似于内存分页，磁盘中的存储单元也会被分为一个个 <strong>“磁盘块”</strong>，磁盘块的大小和内存块、页面的大小相同（方便数据交换）。</p><p>在外村中，文件的逻辑空间也被分为一个个的 <strong>“文件块”</strong>，文件的逻辑地址也可以表示为 <strong>“逻辑块号，块内地址”</strong> 的形式。</p><ul><li><p><strong>连续分配</strong></p><p>每个文件在磁盘上占用一组连续的块。</p><ul><li>文件目录中记录了存放的<strong>起始块号 和 长度</strong>；</li><li>映射：<strong>（逻辑块号，块内地址）——&gt; （物理块号，块内地址）</strong>；只需转换块号，块内地址不变，<strong>物理块号 &#x3D; 起始块号 + 逻辑块号</strong>。</li><li>支持<strong>随机访问</strong>，因为可以直接算出逻辑块号对应的物理块号。</li><li>在<strong>顺序读&#x2F;写</strong>时速度<strong>最快</strong>，因为读取磁盘块时需要移动磁头，而相邻两个块距离最近，磁头移动距离最短。</li><li>缺点：不方便拓展，存储空间利用率低，会产生难以利用的磁盘碎片。同样可费很大的时间代价，用紧凑来处理碎片。</li></ul></li><li><p><strong>隐式链接</strong></p><p>离散存储，指针指向下一个逻辑块号。</p><ul><li>文件目录记录了存放的 起始块号 和 结束块号；</li><li>方便拓展，外存利用率高，不会有碎片问题；</li><li>只支持顺序访问，不能随机访问，查找效率低；</li></ul></li><li><p><strong>显式链接</strong></p><p>将链接文件各物理块的指针显示地存放在一张表中，即<strong>文件分配表（FAT</strong>，File Allocation Taable），<strong>一个磁盘仅设置一张FAT</strong>，开机时，将FAT读入内存，并<strong>常驻内存</strong>；</p><p>如：（物理块号字段可以是隐含的）</p><table><thead><tr><th>物理块号</th><th>下一块</th></tr></thead><tbody><tr><td>0</td><td>1</td></tr><tr><td>1</td><td>5</td></tr><tr><td>2</td><td>-1</td></tr></tbody></table><ul><li>文件目录只记录存放的 起始块号；</li><li>支持<strong>随机访问</strong>，因为查找物理块号的过程是在内存的FAT表上进行的，不需要读磁盘操作，即通过顺序查找FAT实现随机查找磁盘；</li><li>方便拓展，不会有外部碎片；</li><li>文件分配表FAT需要<strong>占用额外的存储空间</strong>；</li></ul></li><li><p><strong>索引分配</strong></p><p>文件离散分配，系统会为<strong>每个文件</strong>建立<strong>一张索引表</strong>，<strong>索引表记录了文件的各个逻辑块对应的物理块</strong>（逻辑块号顺序分布，可以隐去）。索引表存放的磁盘块称为<strong>索引块</strong>，文件数据存放的磁盘称为<strong>数据块</strong>。</p><ul><li>目录文件中记录了文件的索引块的物理块号；</li><li>支持随机访问，文件拓展方便；</li></ul><p>当一个文件很大，使一个磁盘块装不下文件的整张索引表时，可以使用：</p><ul><li><p>链接</p><ul><li>想找到第 i 号索引块，必须先依次读入 0 ~ i - 1号索引块，磁盘I&#x2F;O次数多，查找效率低。</li></ul></li><li><p>多层索引：</p><p>类似多级页表，使第一层索引指向第二层的索引块。</p><ul><li>使用K层索引，不管大小文件，访问数据块都需要K+1次读磁盘。</li></ul></li><li><p>混合索引：</p><p>文件的顶级索引表中，即有 直接地址索引，又有一级间接索引（指向单层索引表），二级间接索引（指向两级索引表）。</p><ul><li>对小文件，访问数据块所需读磁盘次数更少。</li></ul></li></ul></li><li><p>重要考点：</p><ul><li>根据索引的结构，计算出文件的最大长度（各级索引表不能超过一个块）；</li><li>访问某个数据结构所需要的读磁盘次数（FCB存有指向顶级索引块的指针，因此可以根据FCB读入顶级索引块，则每次读入下一级的索引块都需要一次读磁盘操作，注意题目有没有说 顶级索引块是否已调入内存）</li></ul></li></ul><h3 id="存储空间管理"><a href="#存储空间管理" class="headerlink" title="存储空间管理"></a>存储空间管理</h3><p><strong>存储空间的划分与初始化</strong></p><ul><li><p>划分：将物理磁盘划分为一个个文件卷（逻辑卷、逻辑盘，如Windows的c盘、d盘）；</p><blockquote><p>有的系统支持超大型文件，可由多个磁盘组成一个文件卷；</p></blockquote></li><li><p>初始化：将各个文件卷划分为目录区、文件区；</p><blockquote><p>目录区：存放文件目录信息（FCB），用于磁盘存储空间管理的信息；</p><p>文件区：存放文件数据；</p></blockquote></li></ul><p><strong>管理方法：</strong></p><ul><li><p><strong>空闲表法</strong></p><p><strong>用表记录空闲区的位置和数量</strong>。适用于“连续分配方式”；</p><ul><li><p>分配磁盘块：</p><p>与内存管理的动态分区分配类似，为一个文件分配连续的存储空间，同样可用首次适应、最佳适应、最坏适应等算法来决定文件的空间如何分配；</p></li><li><p>回收磁盘块：</p><p>与内存管理的动态分区分配类似，回收时要考虑四种情况：</p><ul><li>回收区的前后都没有相邻空闲区；</li><li>回收区的前后都是空闲区；</li><li>回收区前面是空闲区；</li><li>回收区后面是空闲区；</li></ul><p>总之，回收时要注意表项的合并问题。</p></li></ul><table><thead><tr><th>第一个空闲盘 块号</th><th>空闲盘 块数</th></tr></thead><tbody><tr><td>0</td><td>2</td></tr><tr><td>5</td><td>1</td></tr><tr><td>13</td><td>4</td></tr></tbody></table></li><li><p><strong>空闲链表法</strong>：</p><ul><li><p><strong>空闲盘 块链</strong>：以盘块为单位组成一条空闲链；操作系统保存链头、链尾指针；</p><ul><li><p>分配：从链头开始依次摘下空闲盘块，并修改空闲链的链头指针；</p></li><li><p>回收：回收的盘块依次挂到链尾，并修改链尾指针；</p></li></ul></li><li><p><strong>空闲盘 区链</strong>：以盘区为单位组成一条空闲链；操作系统保存链头、链尾指针；</p><ul><li><p>分配：可以按首次适应、最佳适应等算法，从链头开始检索，找到一个大小符合要求的盘曲进行分配；如果没有合适的盘区，也可将不同盘区的盘块同时分配给一个文件，注意要修改相应的链指针和盘区大小等数据；</p></li><li><p>回收：如果相邻有空闲盘区，则合并，没有的话则单独作为一个盘区挂到链尾</p></li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731017.png" alt="image-20211223151833561"></p></li><li><p><strong>位示图法</strong></p><p>位示图：每个二进制位对应一个盘块，如用“0”表示盘块空闲，“1”表示盘块已分配。</p><table><thead><tr><th></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>0</td><td>…</td><td>…</td><td></td><td></td><td></td></tr><tr><td>2</td><td>…</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>计算：这里用一个字节（8位）表示一行，一般是用一个字（16位）来表示的；</p><p>（1，4）&#x3D; b &#x3D; 1 * 8 + 4 &#x3D; 12；</p><p>b &#x3D; 13 —— i &#x3D; 13 &#x2F; 8 &#x3D; 1;  j &#x3D; 13% 8 &#x3D; 5;</p><ul><li>分配：扫描位示图，找到大小符合要求的“0”，分配后，将相应位设为“1”；</li><li>回收：将对应盘块号的二进制位设为“0”；</li></ul></li><li><p><strong>成组链接法</strong></p><p>（UNIX采用的策略，适合大型文件系统）</p><p>在文件卷的目录区中专门有一个磁盘块作为“超级块”，当系统启动时需要将超级块读入内存。</p><ul><li>“超级块”的首部记录了下一组空闲盘的的块数，后面存放能指向这一组空闲盘块的指针；</li><li>在下一组空闲盘块中，它的首个盘块跟“超级块”类似，首部也记录它的下一组空闲盘块数，后面存放能指向这一组空闲盘块的指针；</li><li>依次类推，直至最后一个分组，它没有下一组空闲块，则将第一个盘块设为一个特殊值。</li></ul></li></ul><h2 id="文件基本操作"><a href="#文件基本操作" class="headerlink" title="文件基本操作"></a>文件基本操作</h2><ul><li><p><strong>创建文件</strong></p><p>进行 Create系统调用时，需要提供的几个主要参数：</p><ol><li>所需的外存空间大小 (如：一个盘块，即1KB)</li><li>文件存放路径</li><li>文件名</li></ol><p>操作系统在处理 Create系统调用时，主要做了两件事</p><ol><li><p>在外存中找到文件所需的空间（使用空闲链表法、位示图、成组链接法等管理策略，找到空闲空间）</p></li><li><p>根据文件存放路径的信息找到该目录对应的目录文件，在目录中创建该文件对应的目录项。目录项中包含了文件名、文件在外存中的存放位置等信息。</p></li></ol></li><li><p><strong>删除文件</strong></p><p>进行 Delete系统调用时，需要提供的几个主要参数：</p><ol><li><p>文件存放路径</p></li><li><p>文件名</p></li></ol><p>操作系统在处理 Delete系统调用时，主要做了几件事：</p><ol><li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的目录项。</p></li><li><p>根据该目录项记录的文件在外存的存放位置文件大小等信息，回收文件占用的磁盘块。<br>(回收磁盘块时，根据空闲表法、空闲链表法、位图法等管理策略的不同，需要做不同的处理）</p></li><li><p>从目录表中删除文件对应的目录项。</p></li></ol></li><li><p><strong>打开文件</strong></p><p>在很多操作系统中，在对文件进行操作之前，要求用户先使用open系统调用“打开文件”，需要提供的几个主要参数：</p><ol><li><p>文件存放路径</p></li><li><p>文件名</p></li><li><p>要对文件的操作类型（如：r只读，rw读写等）</p></li></ol><p>操作系统在处理open系统调用时，主要做了几件事：</p><ol><li><p>根据文件存放路径找到相应的目录文件，从目录中找到文件名对应的的目录项，并检查该用户是否有指定的操作权限。</p></li><li><p>将目录项复制到内存中的“打开文件表”中。并将对应表目的编号返回给用户。之后用户使用打开文件表的编号来指明要操作的文件。</p></li></ol><blockquote><p>整个系统只有一张系统的打开文件表，其中有一项为 ：打开计数器，即有多少各用户进程打开了该文件；如：在Windows中，如果尝试删除某文件，而该系统已被某进程打开，就会提示“暂时无法删除该文件”，这其实是系统先检查了打开文件表，确认是否有进程在使用该文件。</p></blockquote></li><li><p><strong>关闭文件</strong></p><p>进程使用完文件后，要“关闭文件”，操作系统在处理Cose系统调用时，主要做了几件事：</p><ol><li><p>将进程的打开文件表相应表项删除</p></li><li><p>回收分配给该文件的内存空间等资源</p></li><li><p>系统打开文件表的打开计数器 count减1,若count &#x3D; 0,则删刑除对应表项。</p></li></ol></li><li><p><strong>读文件</strong></p><p>进程使用read系统调用完成写操作。需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的索引号即可），还需要指明要读入多少数据、指明读入的数据要放在内存中的什么位置。</p><p>操作系统在处理read系统调用时，会从读指针指向的外存中，将用户指定大小的数据读入用户指定的内存区域中。</p></li><li><p><strong>写文件</strong></p><p>进程使用 write系统调用完成写操作，需要指明是哪个文件（在支持“打开文件”操作的系统中，只需要提供文件在打开文件表中的素引号即可），还需要指明要写出多少数据(如：写出1KB)、写回外存的数据放在内存中的什么位置。</p><p>操作系统在处理 write系统调用时，会从用户指定的内存区域中，将指定大小的数据写回写指针指向的外存</p></li></ul><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><ul><li><p><strong>基于索引节点的共享方式（硬链接）</strong></p><p>索引节点（文件目录的内容）：是一种文件目录的瘦身策略，因此检索文件时只需用到文件名，因此可以将除了文件名之外的其他信息放到索引节点中，这样目录项就只需包含文件名、索引节点指针。</p><p>共享方式：<strong>在索引节点中设置一个链接计数变量 count，用于表示链接到本索引节点上的用户目录项数。</strong></p><p>但用户要“删除”文件时，只把该用户目录中与该文件对应的目录项删除，且索引节点的count减1，只有count &#x3D; 0时，系统才会真的删除文件。</p></li><li><p><strong>基于符号链的共享方式（软链接）</strong></p><p>使用 Link类型的文件，记录了想要共享的文件的存放路径，用户进程的文件目录项指向该Link文件，会通过里面的路径，去找到共享的文件。</p><p>如：Windows的快捷方式</p></li></ul><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><ul><li><p><strong>口令保护</strong></p><p>为文件设置一个“口令”，用户请求访问该文件时必须提供“口令”。口令一般存放在文件对应的FCB或索引节点中。</p><ul><li>优点：保存口令的空间开销不多，验证口令的时间开销也很小；</li><li>缺点：口令被存放在系统内部，不够安全；</li></ul></li><li><p><strong>加密保护</strong></p><p>使用某个“密码”对文件进行加密，在访问文件时需要提供正确的“密码”才能对文件进行正确的解读。如：简单的加密算法——异或加密，使用同样的密码对原文件进行异或运算，可以实现加密和解密；</p><ul><li>优点：保密性强，不需要在系统中存储密码；</li><li>缺点：编码&#x2F;译码，即加密&#x2F;解密需要花费一定时间。</li></ul></li><li><p>访问控制</p><p>在文件的FCB或索引节点中增加一个访问控制表（ACL，Access-Control），表明用户可以对该文件执行哪些操作。</p><p>精简的访问控制表：以组为单位，标记各组 用户的权限。</p></li></ul><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731585.png" alt="image-20211223172034269"></p><p>对应关系：</p><p>用户接口——文件基本操作</p><p>文件目录系统——文件目录</p><p>存取控制模块——文件保护</p><p>逻辑文件系统与文件信息缓冲区——逻辑结构</p><p>物理文件系统——物理结构</p><p>辅助分配模块——存储空间管理</p><p>设备管理模块——磁盘管理</p><p>一个栗子：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204201458004.png" alt="image-20211223172459972"></p><h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="磁盘的结构"><a href="#磁盘的结构" class="headerlink" title="磁盘的结构"></a>磁盘的结构</h3><ul><li><strong>磁盘、磁道、扇区：</strong></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731173.png" alt="image-20211223173450194"></p><ul><li><p><strong>在磁盘中读&#x2F;写数据：</strong></p><p>需要把“磁头”移动到想到 读&#x2F;写 的扇区所在的磁道。磁盘会转起来，让目标扇区从磁头下面划过，才能完成对上去的读&#x2F;写操作。</p></li><li><p><strong>盘面、柱面：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731456.png" alt="image-20211223173946145"></p></li><li><p><strong>磁盘的物理地址：</strong></p><p>可用<strong>（柱面号，盘面号，扇区号）</strong>来定位任意一个<strong>“磁盘块”</strong>。在 “文件的物理结构” 小节中，提到文件数据存放在外存中的几号块，这个块号就可以转换成（柱面号，盘面号，扇区号）的地址形式。<br>可根据该地址读取一个“块”<br>①根据“柱面号”移动磁臂，让磁头指向指定柱面；<br>②激活指定盘面对应的磁头<br>③磁盘旋转的过程中，指定的扇区会从磁头下面划过，这样就完成了对指定扇区的读&#x2F;写。</p></li></ul><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>依次磁盘读&#x2F;写操作需要的时间：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731946.png" alt="image-20211223182654163"></p><p>操作系统只能影响寻道时间，其他两个受硬件影响的。</p><ul><li><p><strong>先来先服务算法（FCFS）</strong></p><p>根据进程请求访问磁盘的先后顺序进行调度。</p><ul><li>优点：公平</li><li>缺点：如果大量进程竞争磁盘，请求访问的磁道很分散，则FCFS性能很差。</li></ul></li><li><p><strong>最短寻找时间优先（SSTF）</strong></p><p>优先处理的磁道是当前磁头最近的磁道。可以保证每次的寻道时间最短，但并不能保证总的训道时间最短（贪心算法思想）。</p><ul><li>优点：性能较好，平均寻道时间短</li><li>缺点：可能产生饥饿现象（磁头可能只在一个小区域内移动）</li></ul></li><li><p><strong>扫描算法（SCAN）</strong></p><p>只有磁头移动到最外侧磁道时才能往内移动，移动到最内侧磁道时才能往外移动。（由于磁头移动方式很像电梯，也称电梯算法）</p><ul><li>优点：性能较好，平均寻道时间较短，不会产生饥饿现象；</li><li>缺点：只有到最边上的磁道时才能改变磁头移动方向；对各个位置磁道的响应频率不平均。</li></ul></li><li><p><strong>LOOK调度算法</strong></p><p>改善扫描算法（必须到最边上），当磁头移动方向上没有别的请求，就可以立即改变磁头移动方向（边移动边观察，所以叫LOOK）。</p></li><li><p><strong>循环扫描算法（S-SCAN）</strong></p><p>改善扫描算法（响应不平均），规定磁头朝某个特定方向移动时，才能处理磁道访问请求，而返回时直接快速移动至起始端而不处理任何请求。</p></li><li><p><strong>C-LOOK调度算法</strong></p><p>结合LOOK算法和S-SCAN算法，只朝特定方向移动时，才处理访问请求，且磁头方向上没有别的请求就可以立即返回，回到最靠近边缘的需要访问的磁道。</p></li></ul><blockquote><p>没有特殊说明时，认为SCAN就是LOOK，C-SCAN就是C-LOOK</p></blockquote><h3 id="减少磁盘延迟时间"><a href="#减少磁盘延迟时间" class="headerlink" title="减少磁盘延迟时间"></a>减少磁盘延迟时间</h3><p>因为磁头在读完一个扇区的信息后，需要一些准备时间，此时不能读取信息，但磁盘是不停旋转的，如果信息存储在相邻的扇区，那么磁头需要转一圈回来才能读取下一信息。</p><ul><li><p>交替编号：</p><p>让编号相邻的扇区在物理上不相邻；</p></li><li><p>错位命名：</p><p>让相邻盘面的扇区编号“错位”；</p></li></ul><p>为什么使用（柱面号，盘面号，扇区号）的结构？ 因为在读取地址连续的磁盘块时，不需要移动磁头。</p><h3 id="磁盘管理-1"><a href="#磁盘管理-1" class="headerlink" title="磁盘管理"></a>磁盘管理</h3><p><strong>磁盘初始化：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731811.png" alt="image-20211223190634414"></p><p><strong>引导快：</strong></p><p>计算机启动时需要运行初始化程序（自举程序）来完成初始化，在ROM中存放很小的自举装入程序，而完整的自举程序存放在初始化块（引导块）中。</p><p><strong>坏块的管理：</strong></p><p>简单的磁盘在逻辑格式化时会将坏块标记出来。</p><p>复杂的磁盘的磁盘控制器会维护一个坏块链，并管理备用扇区。</p><h1 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h1><p>I&#x2F;O设备：输入输出设备</p><p><strong>分类</strong></p><ul><li>按使用特性：<ul><li>人机交互类外部设备</li><li>存储设备</li><li>网络通信设备</li></ul></li><li>按传输速率分类：低速，中速，高速</li><li><strong>按信息交换的单位分类</strong>：<ul><li><strong>块设备</strong>（传输快，可寻址）</li><li><strong>字符设备</strong>（传输慢，不可寻址，常采用中断驱动方式）</li></ul></li></ul><h2 id="I-x2F-O控制器"><a href="#I-x2F-O控制器" class="headerlink" title="I&#x2F;O控制器"></a>I&#x2F;O控制器</h2><p>I&#x2F;O控制器用于帮助CPU对I&#x2F;O设备的控制，又称设备控制器。</p><p><strong>功能：</strong></p><ul><li><p><strong>接收和识别CPU发出的命令</strong>：</p><p>I&#x2F;O控制器会有相应的<strong>控制寄存器</strong>来存放命令和参数（如CPU发来的read&#x2F;weite命令）</p></li><li><p><strong>向CPU报告设备的状态</strong>：</p><p>I&#x2F;O控制器有相应的<strong>状态寄存器</strong>，用于记录I&#x2F;O设备当前状态，如：1表示空闲，0表示忙碌；</p></li><li><p><strong>数据交换</strong>：</p><p>有<strong>数据寄存器</strong>；输出时，数据寄存器能暂存CPU发来的数据，之后再由控制器传送给设备；输入时，数据寄存器用于暂存设备发来的数据，之后CPU从数据寄存器中取走数据。</p></li><li><p><strong>地址识别</strong>：</p><p>类似于内存的地址，为了区分I&#x2F;O控制器的各个寄存器，会为其设置一个特定的“地址”；I&#x2F;O控制器通过CPU提供的“地址”来判断CPU要读&#x2F;写的是哪个寄存器。</p></li></ul><p>组成：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731441.png" alt="image-20211224100021990"></p><p>注：</p><p>一个I&#x2F;O控制器可能会对应多个设备；</p><p>数据、控制、状态寄存器可能有多个，且都要有相应的地址；有的计算机会让这些寄存器占用内存地址的一部分，称为<strong>内存映像I&#x2F;O</strong>，另一些计算机则采用I&#x2F;O专用地址，即<strong>寄存器独立编制</strong>。</p><h2 id="I-x2F-O控制方式"><a href="#I-x2F-O控制方式" class="headerlink" title="I&#x2F;O控制方式"></a>I&#x2F;O控制方式</h2><ul><li><p><strong>程序直接控制方式</strong></p><ol><li>一次读&#x2F;写操作的流程：</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731893.png" alt="image-20211224104036572"></p><ol start="2"><li><p>CPU干预的频率：很频繁，I&#x2F;O操作开始前、完成之后需要CPU介入，并且在等待I&#x2F;O完成的过程中CPU需要不断地轮询检查。</p></li><li><p>数据传送的单位：每次读写一个字；</p></li><li><p>数据的流向：</p><p>读操作（输入）：I&#x2F;O设备—&gt;CPU—&gt;内存</p><p>写操作（输出）：内存—&gt;CPU—&gt;I&#x2F;O设备</p></li><li><p>优点：实现简单，在读写指令之后，加上实现循环检查的指令即可（因此被称为程序直接控制方式）</p><p>缺点：CPU和I&#x2F;O设备只能串行工作，CPU需要一直轮询检查，长期处于“忙等”状态，利用率低。</p></li></ol></li><li><p><strong>中断驱动方式</strong></p><p>引入中断机制。在CPU发出读写命令后，可将等待I&#x2F;O的进程阻塞，然后切换到别的进程执行。当I&#x2F;O完成后，控制器会向CPU发出一个中断信号，CPU检测到中断信号后，会先保存现场，然后转去执行中断处理程序，之后会恢复等待I&#x2F;O的进程的运行环境，使其继续执行。</p><blockquote><p>CPU会在每个指令周期末尾检查中断；中断处理过程需要保存、恢复进程的运行环境，有一定开销。</p></blockquote><ol><li><p>一次读写操作的流程：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731807.png" alt="image-20211224105240366"></p></li><li><p>CPU干预的频率：I&#x2F;O操作开始前、完成之后需要CPU介入；等待I&#x2F;O完成的过程中，CPU可以切换到别的进程执行。</p></li><li><p>数据传送的单位：每次读写一个字；</p></li><li><p>数据的流向：</p><p>读操作（输入）：I&#x2F;O设备—&gt;CPU—&gt;内存</p><p>写操作（输出）：内存—&gt;CPU—&gt;I&#x2F;O设备</p></li><li><p>优点：CPU不需要不断轮询，CPU和I&#x2F;O可并行工作，CPU利用率得到明显提升；</p><p>缺点：每个字在I&#x2F;O设备于内存之间的传输，都需要经过CPU，而频繁的中断处理会消耗不少CPU时间。</p></li></ol></li><li><p><strong>DMA方式</strong></p><p>Direct Memory Access，直接存储器存取</p><p>改进：</p><ul><li>数据的传送单位是“块”，不再是一个字地传送；</li><li>数据的流向是从设备直接放入内存，或从内存直接到设备，不需要CPU中转；</li><li>仅在传送数据块的开始和结束，才需要CPU干预；</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731613.png" alt="image-20211224110558917"></p><ol><li><p>一次读写操作的流程：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731935.png" alt="image-20211224110051104"></p></li><li><p>CPU干预频率：仅在传送数据的开始和结束，需要CPU干预；</p></li><li><p>数据传送单位：一个或说个块（每次读写的只能是连续的多个块）</p></li><li><p>数据的流向：不再需要经过CPU</p></li><li><p>优点：数据以“块”为单位，使CPU接入频率进一步降低，数据传输效率提高，所以CPU和I&#x2F;O设备的并行性得到提升。</p><p>缺点：一次读写的数据块只能是连续的。</p></li></ol></li><li><p><strong>通道控制方式</strong></p><p>通道：一种硬件，可以识别并执行一系列通道指令。通道可以执行的指令很单一，且通道程序是放在内存中的，也就是和CPU共享内存，所以通道可以理解为 ”弱化的CPU“，</p><ol><li><p>一次读写操作的流程：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731080.png" alt="image-20211224111407218"></p></li><li><p>CPU干预频率：极低，CPU可以让通道执行一系列读写操作，只有完成这组读写操作后才会发出中断信号，请求CPU干预；</p></li><li><p>数据传送的单位：一组数据块</p></li><li><p>数据的流向：在通道的控制下执行，在I&#x2F;O设备和内存之间</p></li><li><p>缺点：实现复杂，需要专门的通道硬件支持；</p><p>优点：CPU、通道、I&#x2F;O设备可并行工作，资源利用率很高。</p></li></ol></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731185.png" alt="image-20211224112004434"></p><h2 id="I-x2F-O软件层次结构"><a href="#I-x2F-O软件层次结构" class="headerlink" title="I&#x2F;O软件层次结构"></a>I&#x2F;O软件层次结构</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731421.png" alt="image-20211224112143179"></p><ul><li><p><strong>用户层软件</strong></p><p><strong>实现了与用户交互的接口</strong>，用户可直接使用该层提供的、与I&#x2F;O操作相关的<strong>库函数</strong>对设备进行操作。</p><p>用户层软件通过 “<strong>系统调用</strong>” 请求操作系统内核的服务。</p></li><li><p><strong>设备独立性软件</strong></p><p>又称设备无关性软件。与设备的硬件特性无关的功能几乎都在这一层实现。</p><p>功能：</p><ul><li>向上层提供统一的调用接口（如“系统调用”）；</li><li>设备保护（原理类似于文件保护，将设备看作特殊的文件，设置不同的访问权限）；</li><li>差错处理（对设备的一些错误进行处理）；</li><li>设备的分配与回收；</li><li>数据缓冲区管理（可以用于屏蔽设备间数据交换单位大小和传输速度的差异）；</li><li>建立逻辑设备名到物理设备名的映射关系，能根据设备类型选择调用相应的驱动程序（需要“逻辑设备表LUT来确定电脑逻辑设备对应的物理设备，并找到对应的设备驱动程序）；</li></ul><blockquote><p>为什么不同的设备需要不同的设备驱动程序？</p><p>因为不同厂家、不同型号的设备内部硬件特性不同，这些特性只有厂家知道，因此厂家必须提供相应的驱动程序、CPU执行驱动程序的指令序列，来完成设置设备寄存器，检查设备状态等工作。</p></blockquote></li><li><p><strong>设备驱动程序</strong></p><p>主要负责对硬件设备的具体控制，将上层发出的一系列命令转化成 特定设备能”听懂“ 的一系列操作，包括设置设备寄存器，检查设备状态等。</p><p>驱动程序一般会以一个独立进程的方式存在；</p></li><li><p><strong>中断处理程序</strong></p><p>当I&#x2F;O任务完成时，I&#x2F;O控制器会发送一个中断信号，系统会根据 中断信号类型 找到相应的 中断处理程序 并执行。</p><p>中断处理程序的执行流程：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731589.png" alt="image-20211225092619332"></p></li><li><p><strong>硬件</strong></p><p>不同的I&#x2F;O设备有不同的硬件特性。</p></li></ul><h2 id="I-x2F-O核心子系统"><a href="#I-x2F-O核心子系统" class="headerlink" title="I&#x2F;O核心子系统"></a>I&#x2F;O核心子系统</h2><p>I&#x2F;O系统，或称I&#x2F;O核心子系统： 属于操作系统的内核部分；即软件层次的中三层：设备独立性软件，设备驱动程序，中断处理程序。</p><p>（重点掌握 I&#x2F;O调度，设备保护，假脱机计数，设备分配与回收，缓冲区管理）</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191731829.png" alt="image-20211225093139197"></p><p>I&#x2F;O调度：用某种算法确定一个好的顺序来处理各个I&#x2F;O请求。（如：磁盘调度）</p><p>设备保护：将设备看作一种特殊的文件，设立不同的访问权限。</p><h2 id="假脱机技术"><a href="#假脱机技术" class="headerlink" title="假脱机技术"></a>假脱机技术</h2><ul><li>脱机：脱离主机的控制进行的输入&#x2F;输出操作。</li></ul><p>在批处理阶段引入了 脱机输入&#x2F;输出 技术（用磁带完成）：在外围控制机的控制下，慢速设备的数据先被输入到更快速的磁带上。之后主机可以从快速的磁带上读入数据，缓解速度矛盾。</p><ul><li><strong>假脱机技术（SPOOLing技术）：用软件的方式模拟脱机技术</strong></li></ul><p>在磁盘上开辟两个存储区域——输入井和输出井；</p><p>输入井：模拟脱机输入时的磁带，用于收容I&#x2F;O设备的输入数据；</p><p>输出井：模拟脱机输出时的磁带，用于收容用户进程输出的数据；</p><p>输入进程：模拟脱机输入时的外围控制机；</p><p>输出进程：模拟脱机输出时的外围控制机；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732450.png" alt="image-20211225094410741"></p><h2 id="设备的分配和回收"><a href="#设备的分配和回收" class="headerlink" title="设备的分配和回收"></a>设备的分配和回收</h2><p>从进程运行的安全性上考虑，设备分配有两种方式：</p><ul><li>安全分配方式：为进程分配一个设备后就将进程阻塞，本次&#x2F;O完成后才将进程唤醒。<br>（一个时段内每个进程只能使用一个设备）<br>优点：破坏了“请求和保持”条件，不会死锁；<br>缺点：对于一个进程来说，CPU和&#x2F;O设备只能串行工作；</li><li>不安全分配方式：进程发出I&#x2F;O请求后，系统为其分配&#x2F;O设备，进程可继续执行，之后还可以发出新的I&#x2F;O请求。只有某个&#x2F;O请求得不到满足时才将进程阻塞；<br>（进程可以同时使用多个设备）<br>优点：进程的计算任务和&#x2F;O任务可以并行处理，使进程迅速推进;<br>缺点：有可能发生死锁(死锁避免、死锁的检测和解除);</li></ul><p><strong>设备分配管理中的数据结构</strong>：</p><p><strong>设备控制表（DCT）</strong>：系统为每个设备配置了一张DCT，用于记录设备情况。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732235.png" alt="image-20211225100210496"></p><p><strong>控制器控制表（COCT）</strong>：每个设备控制器都有一张对应的COCT，操作系统会根据COCT的信息对控制器进行操作和管理；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732905.png" alt="image-20211225100342240"></p><p><strong>通道控制表（CHCT）</strong>：…..</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732952.png" alt="image-20211225100440690"></p><p>系统设备表（SDT）：记录了系统中全部设备的情况，每个设备对应一个表目；</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732460.png" alt="image-20211225100537634"></p><p><strong>设备分配步骤：</strong></p><p>①根据进程请求的物理设备名査找SDT（注：物理设备名是进程请求分配设备时提供的参数）；</p><p>②根据SDT找到DCT,若设备忙碌则将进程PCB挂到设备等待队列中，不忙碌则将设备分配给进程。</p><p>③根据DCT找到COCT,若控制器忙碌则将进程PCB挂到控制器等待队列中，不忙碌则将控制器分配<br>给进程。</p><p>④根据COT找到CHCT,若通道忙碌则将进程PCB挂到通道等待队列中，不忙碌则将通道分配给进<br>程。</p><p>（只有设备、控制器、通道三者都分配成功时，这次设备分配才算成功，之后就可以启用I&#x2F;O设备进行数据传送）</p><p>缺点：用户编程时必须提供物理设备名，不方便编程，且换了物理设备后，程序会无法运行；若进程请求的物理设备正在忙碌，则即使还有其它同类型的设备，进程也必须阻塞。</p><p>改进方法：建立逻辑设备名与物理设备名的映射机制，编程时只需提供逻辑设备名。</p><p>（改进后，只有第一次使用设备时需要 操作系统根据用户进程指定的设备 去查找系统设备表，找到一个空闲设备分配给进程，并在LUT中增加相应表项。 之后如果用户再次通过相同逻辑设备名请求使用设备，则系统可以直接根据LUT进行分配）</p><h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><p>缓冲区是一个存储区域，可以由专门的硬件寄存器组成，也可利用内存作为缓冲区。<br>使用<strong>硬件作为缓冲区的成本较高，容量也较小</strong>，一般仅用在对速度要求非常高的场合（如存储器<br>管理中所用的联想寄存器&#x2F;快表，由于对页表的访问频率极高，因此使用速度很快的联想寄存器来存放页表项的副本）</p><p>一般情况下，更多的是利用<strong>内存作为缓冲区</strong>，“设备独立性软件” 的缓冲区管理就是要组织管理好这些缓冲区</p><p><strong>缓冲区的作用：</strong></p><ul><li>缓和CPU与&#x2F;O设备之间速度不匹配的矛盾</li><li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li><li>解决数据粒度不匹配的问题</li><li>提高CPU与VO设备之间的并行性</li></ul><p><strong>单缓冲：</strong></p><p>采用单缓冲的策略，操作系统会在主存中为其分配一个缓冲区 (若题目中没有特别说明，一个缓冲区的大小就是一个块) 。</p><p>注意：当缓冲区数据非空时，不能往缓冲区冲入数据，只能从缓冲区把数据传出；当缓冲区为空时，<br>可以往缓冲区冲入数据，但必须把缓冲区充满以后，才能从缓冲区把数据传出。</p><blockquote><p>题：计算每处理一块数据平均需要多久？</p><p>技巧：假定一个初始状态，分析下次到达相同状态需要多少时间，这就是处理一块数据平均需要的时间。</p><p>如：单缓冲下，假设初始工作区满，缓冲区空，计算到下一个相同状态所用时间。</p></blockquote><p><strong>双缓冲：</strong></p><p>操作系统会在主存中为其分配两个缓冲区。</p><blockquote><p>单缓冲和双缓冲区别：</p><p>两个相互通信的机器只设置单缓冲区，则只能实现单项传输数据；设双缓冲，可以实现双向的数据传输。</p><p>注：管道 其实就是缓冲区。</p></blockquote><p><strong>循环缓冲区：</strong></p><p>将多个大小相等的缓冲区链接成一个循环队列。</p><p>设两个指针：in指针指向下一个可以冲入数据的空缓冲区，out指针指向下一个可以取出数据的满缓冲区。</p><p><strong>缓冲池：</strong></p><p>缓冲池由系统中共用的缓冲区组成。</p><p>这些缓冲区按使用状况可以分为：</p><ul><li>空缓冲队列；</li><li>装满输入数据的缓冲队列（输入队列）；</li><li>装满输出数据的缓冲队列（输出队列）；</li></ul><p>另外，根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：</p><ul><li>用于收容输入数据的工作缓冲区(hin)</li><li>用于提取输入数据的工作缓冲区(sin)</li><li>用于收容输出数据的工作缓冲区(hout)</li><li>用于提取输出数据的工作缓冲区(sout)</li></ul><h1 id="练习："><a href="#练习：" class="headerlink" title="练习："></a>练习：</h1><p><strong>网上试题：</strong></p><ol><li>操作系统具备处理并发活动的能力，其最重要的硬件支持是：中断技术</li><li>P操作可能使进程由运行状态变为：等待状态</li><li>并发进程失去封闭性特征，是指：并发进程共享公共变量</li><li>采用资源有序分配，是破坏了死锁的 环路条件</li><li>用户程序在用户态下使用特权指令所引起的中断属于 程序中断</li><li>为了实现进程从有到无的变化，操作系统应提供 进程撤销原语（考察：进程控制原语）</li></ol><p>（中断（时钟，访管），系统功能调用）</p><ol><li><p>在下列情况(    )，系统需要进行进程调度。</p><p>A. 某一进程正访问一临界资源</p><p>B．某一进程运行时因缺乏资源进入阻塞状态</p><p>C．某一进程处于运行状态，而另一进程处于自由状态</p><p>D．某一进程正在访问打印机，而另一进程处于就绪状态</p><blockquote><p>B</p></blockquote></li><li><p>如果要使装入内存的程序在内存中移动后仍能正常运行，必须要有( 动态重定位 )的支持。</p></li><li><p><u>分页</u> 存储管理方式能使内存碎片尽可能少，避免内存的整理。</p></li><li><p>采用 <u>分段式存储管理</u> 不会产生内部碎片。</p></li><li><p>在单处理机计算机系统中，<u>处理机的操作与通道的操作</u> 是可以并行操作的。</p></li><li><p>操作系统实现按名存取的关键在于解决 <u>文件的符号名与文件具体的存储地址的转换和映射</u> 。</p></li><li><p>不让死锁发生的策略可以分为静态和动态两种,死锁避免属于 <u>动态策略</u> 。</p><blockquote><p>静态策略：死锁预防——设计合适的资源分配算法，保证死锁不发生。</p><p>动态策略：死锁避免——根据资源分配过程和结果来决定是否分配。</p></blockquote></li><li><p>若使当前运行的进程总是优先级最高的进程,应选择 <u>剥夺式优先级</u> 进程调度算法。</p></li><li><p>画出进程三基态状态变化图，以及状态变化原因：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732143.png" alt="image-20220103094842974"></p></li><li><p>系统中有三个进程GET、PRO和PUT，共用两个缓冲区BUF1和BUF2。假设BUF1中最多可放11个信息，现已放入了两个信息；BUF2最多可放5个信息，目前为空。GET进程负责不断地将输入信息送入BUF1中，PRO进程负责从BUF1中取出信息进行处理，并将处理结果送到BUF2中，PUT进程负责从BUF2中读取结果并输出。试写出正确实现GET、PRO、PUT的同步与互斥的算法（要求：（1）用类C语言描述，条理清楚，注释恰当；（2）信号量原语统一使用wait和signal）。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732151.png" alt="image-20220103095327921"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732034.png" alt="image-20220103095346121"></p></li><li><p><u>操作接口</u>是操作系统为用户提供的使用计算机系统的手段之一，该接口是指 一组<u>操作控制命令</u>。</p><p><u>程序接口</u>，又称应用编程接口（API），由一组<u>系统调用组成</u>；供程序员在编制程序时以程序语句或指令的形式调用操作系统的功能。</p></li><li><p>基址寄存器和界限寄存器是属于 <u>控制寄存器</u>。</p></li><li><p>存储管理实际管理的是 主存储器中的用户区。</p></li><li><p>某文件共占用8个磁盘块B0~B7，磁盘每道有8个扇面，每个扇面可存放一个磁盘块，磁盘旋转一圈的时间是20ms，程序处理一个磁盘块的时间是4ms，B0～B7在一个磁道上优化分布，磁头目前在B0起点处。则把B0～B7全部读出的时间是？</p><blockquote><p> 答：(2.5+4)* 8 + 1* 7 - 4 &#x3D; 55.<br>因为磁头读取一个扇区需要2.5ms，但是处理一个记录需要4ms，超过了一个扇区的读取时间，而在处理数据时，磁盘不会停转，会继续旋转，于是当下达读取B2的指令时，磁头已经经过第2个扇区，并在第3个扇区中间了。这时，只有等磁盘转到下一个扇区，才能进行读操作。<br>也就是说要满足等待处理时间的要求，必须要让磁头空闲的时间大过处理时间，因此只有连续略掉第2和第3个扇区（这样有5ms的空闲时间），然后再将L2放到第4个扇区，才能保证在有足够处理时间的前提下，又能立刻读到下一条记录。但实际上，还是浪费了1ms的时间。七个扇区就是浪费7秒，而题目问的是“把B0～B7全部读出的时间” 所以不需要处理最后一条，就再减去4秒。</p></blockquote></li><li><p>如果一组并发进程是无关的，则他们 <u>可以包含相同的程序，但没有共享变量</u>。</p></li><li><p>进程控制块的管理信息包含 <u>队列指针</u> 和 <u>进程优先数</u>。</p></li><li></li></ol><p><strong>课程试题：</strong></p><ol><li><p>实时操作系统必须在（  ）内处理完来自外部的事件。</p><ul><li>A. 一个机器周期</li><li>B. 被控对象规定时间</li><li>C. 周转时间 </li><li>D. 时间片</li></ul><blockquote><p>B</p></blockquote></li><li><p>课本1-9：设一计算机系统有输入机一台、打印机两台，现有A、B两道程序同时投入运行，且A先运行，B后运行：</p><ul><li><p>程序A的运行轨迹为：计算50ms，打印信息100ms，再计算50ms，打印信息100ms，结束。</p></li><li><p>程序B运行的轨迹为：计算50ms，输入数据80ms，再计算100ms，结束。</p></li></ul><p>要求用图画出两道程序并发执行时的工作情况。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732600.png" alt="image-20220103165427922"></p></li><li><p>课本4-4： 图4.2标明程序段执行的先后次序。 其中，I表示输入操作、 C表示计算操作、 P 表示打印操作、下角标说明是对哪个作业进行上述操作。请指明：（1）哪些操作必须有先后次序，其原因是什么？ （2）哪些操作可以并发执行， 其原因又是什么？</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732160.png" alt="image-20220103170627033"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732001.png" alt="image-20220103170644646"></p></li><li><p>在UNIX中，下列选项中导致创建新进程的操作是（  ）I 用户成功登录II 设备分配III 启动程序执行</p><ul><li>A. 仅I和II</li><li>B. 仅Il和III</li><li>C. 仅I和III</li><li>D. I，II，III</li></ul><blockquote><p>C</p><p>当用户登录后，会启动命令解释程序(SHELL)。</p><p>设备分配实际说明已有进程申请设备。</p></blockquote></li><li><p>课本4-12： n 个并发进程共用一个公共变量 Q，写出用信号灯实现 n 个进程互斥时的程序描述，给出信号灯值的取值范围，并说明每个取值的物理意义。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732511.png" alt="image-20220103171010514"></p></li><li><p>在如图所示的进程流图中，有五个进程合作完成某一任务。说明这五个进程之间的同步关系，并用 P、V 操作实现之，要求写出程序描述。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732319.png" alt="image-20220103171118061"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732255.png" alt="image-20220103171309268"></p></li><li><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732864.png" alt="image-20220103171359877"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732213.png" alt="image-20220103171446932"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732078.png" alt="image-20220103171500115"></p></li><li><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732642.png" alt="image-20220103172018045"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732321.png" alt="image-20220103172047667"></p><blockquote><p>D</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191732571.png" alt="image-20220103172115017"></p></blockquote></li><li><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733862.png" alt="image-20220103172506105"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191733966.png" alt="image-20220103172445881"></p></li><li><p>操作系统具备处理并发活动的能力，其中最重要的硬件支持是 <u>中断</u>。</p></li><li><p>所谓操作系统虚拟机的概念，是指 在裸机上配置操作系统。</p></li><li><p>文件目录采用树型结构而不采用简单结构的最主要原因是 <u>解决重名问题</u>。</p></li><li><p>在请求分页系统中，为实现淘汰页面的功能，在页表中应增加 <u>引用位</u> 和 <u>改变位</u>。</p></li><li><p>在磁盘上可以建立的物理文件有：索引文件。</p></li><li><p>多道运行的特征之一是微观上串行，其含义是：多道程序分时，轮流地占用CPU。</p></li><li><p>在整个向量中断处理过程，硬件负责 中断响应过程。</p></li><li><p>进程的结构包括：程序段、数据段、进程控制块PCB。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言</title>
      <link href="/Notes/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
      <url>/Notes/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="一、访问寄存器和内存"><a href="#一、访问寄存器和内存" class="headerlink" title="一、访问寄存器和内存"></a>一、访问寄存器和内存</h1><p>前提：此汇编语言学习以 Intel 8086 CPU作为示例。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726634.png" alt="image-20211120210722555"></p><h2 id="1-寄存器和数据存储"><a href="#1-寄存器和数据存储" class="headerlink" title="1 寄存器和数据存储"></a>1 寄存器和数据存储</h2><p>寄存器是CPU内部的信息存储单元。</p><p>一个n位寄存器能存储一个n位的数据，通用寄存器常用X表示；</p><p>有时为了向下兼容，会把寄存器<strong>分为高低位</strong>，<strong>如AX 分为 AH,  AL</strong>； <strong>AH表示AX的高位，AL表示AX的低位</strong></p><p>（当AL中的数值大于AL所能表示的范围，AL会丢弃溢出位，而<strong>不会将溢出位加到AH上</strong>）</p><p>8086CPU有14个寄存器</p><p>通用寄存器：AX，BX，CX，DX（累加，基地址，计数，数据）</p><p>变址寄存器：SI，DI （源，目标）</p><p>指针寄存器：SP，BP（栈顶，基）</p><p>指令指针寄存器：IP</p><p>段寄存器：CS，SS，DS，ES（代码，数据，栈，附加）</p><p>标志寄存器：PSW</p><h2 id="2-mov和add指令"><a href="#2-mov和add指令" class="headerlink" title="2 mov和add指令"></a>2 mov和add指令</h2><p>示例：</p><blockquote><p>mov ax 18-将18放入寄存器AX中</p><p>add ax 8   -将寄存器AX中的值加上8</p><p>mov ax bx- 将BX中的值放入寄存器AX中</p><p>add ax bx - 将AX，BX中的值相加，结果放入AX中</p></blockquote><h2 id="3-确定物理地址的方法"><a href="#3-确定物理地址的方法" class="headerlink" title="3 确定物理地址的方法"></a>3 确定物理地址的方法</h2><p>物理地址：唯一表示每个内存单元在存储体中的地址。</p><p>CPU访问内存单元时要给出内存单元的地址，而所有的内存单元构成的存储空间是一个一维的线性空间。</p><p>问题：8086有<strong>20位地址总线，可传送20位地址，寻址能力有1M</strong>；但8086是<strong>16位结构的CPU，其所能处理的地址只有16位，即寻址能力只有64KB</strong>，这就与20位地址总线的1M寻址能力产生矛盾，如何解决？</p><p>解决方法：使用 <strong>地址加法器</strong> 可以<strong>将两个16位地址（段地址和偏移地址 ）合成为一个20位的物理地址。</strong></p><p><strong>物理地址 &#x3D; 段地址 * 16 + 偏移地址</strong></p><p>（乘16 是将段地址左移4位，同一个物理地址可以用不同的段地址和偏移地址表示）</p><p>然后 地址加法器 会通过内部总线将这20位物理地址送到 输入输出控制电路，再传到地址总线。</p><h2 id="4-内存的分段表示法"><a href="#4-内存的分段表示法" class="headerlink" title="4 内存的分段表示法"></a>4 内存的分段表示法</h2><p>内存中并没有分段，<strong>段的划分是由CPU进行的。</strong></p><p>对8086来看：</p><ol><li>段地址 * 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数；</li><li>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度为64k；</li></ol><p>段地址很重要，有专门的寄存器存放段地址：</p><p><strong>CS：代码段寄存器</strong></p><p><strong>DS：数据段寄存器</strong></p><p><strong>SS：栈段寄存器</strong></p><p><strong>ES：附加段寄存器</strong></p><h2 id="5-Debug的使用"><a href="#5-Debug的使用" class="headerlink" title="5 Debug的使用"></a>5 Debug的使用</h2><p><strong>-R</strong>：查看寄存器内容；</p><p><strong>-R 寄存器名 ：内容</strong>：改变CPU寄存器的内容；</p><p><strong>-D</strong>：查看预设地址内存处的128个字节的内容；</p><p><strong>-D 段地址 : 偏移地址</strong> ：列出内存中指定地址处的内容；</p><p><strong>-D 段地址 : 偏移地址  地址范围</strong>  ：列出内存中指定地址范围内的内容</p><p>**-E 段地址 : 偏移地址 数据1 数据2 …….**： 改变指定地址内存中的内容</p><p><strong>-E 段地址 : 偏移地址</strong> ：逐个询问式修改内容，使用空格表示接收，回车表示结束</p><p><strong>-U 段地址 : 偏移地址</strong>：查看数据，可以将内存中的机器指令翻译成汇编指令显示出来</p><p><strong>-A 段地址 : 偏移地址</strong> ：以汇编指令的格式在内存中写入机器指令</p><p><strong>-T</strong> ：逐条执行机器指令，从 CS : IP处开始</p><p><strong>-P</strong> ：类似于T命令，逐条执行指令，显示结果，但遇到子程序，中断等时，会直接执行，然后显示结果。</p><p><strong>-G</strong>：从地址开始处运行命令，直到遇到断点或程序正常结束。</p><p>。。。</p><h2 id="6-CS、IP与代码段"><a href="#6-CS、IP与代码段" class="headerlink" title="6 CS、IP与代码段"></a>6 CS、IP与代码段</h2><p>CS：代码段寄存器； <strong>IP：指令指针寄存器</strong></p><p><strong>CS : IP  —  CPU将内存中CS : IP 指向的内容当作指令执行。</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726636.png" alt="image-20211120211501383"></p><blockquote><p>内存中的数据， 应该用作一般数据，还是指令？</p><p>答：CPU会将CS:IP指向的内存单元中的内容看作指令（CPU根据指令周期的不同阶段，可以知道取出的是指令还是数据）</p></blockquote><h2 id="7-jmp指令"><a href="#7-jmp指令" class="headerlink" title="7 jmp指令"></a>7 jmp指令</h2><p><strong>CS:IP的内容</strong>不能通过mov修改，可以在Debug中用R命令修改（调试手段），而程序手段是可以<strong>用jmp指令进行跳转</strong>：</p><ul><li><p>同时修改CS : IP 的内容： <strong>jmp 段地址 : 偏移地址</strong>（根据给出的段地址修改CS，偏移地址修改IP）</p></li><li><p>仅修改IP的内容： <strong>jmp 某一合法寄存器</strong>，如 jmp ax，jmp bx</p></li></ul><h2 id="8-内存中字的存储"><a href="#8-内存中字的存储" class="headerlink" title="8 内存中字的存储"></a>8 内存中字的存储</h2><p>（对8086CPU，16位作为一个字 ）</p><p>字单元：由两个地址连续的内存单元组成，存放一个字型数据(16位)。</p><blockquote><p>在一个字单元中，低地址单元 存放 低位字节，高地址单元 存放 高位字节。</p></blockquote><h2 id="9-用DS和-address-实现字的传送"><a href="#9-用DS和-address-实现字的传送" class="headerlink" title="9 用DS和[address] 实现字的传送"></a>9 用DS和[address] 实现字的传送</h2><p>CPU要读取一个内存单元的时候，必须先知道这个内存单元的地址：</p><p>解决：DS 和 [address] 配合，DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p><blockquote><p>注：8086CPU不支持将数据直接送入段寄存器（硬件设计的问题），所以需要<strong>先将数据放入通用寄存器，再放入段寄存器</strong>：</p><p>mov bx 1000H</p><p>mov ds  bx </p></blockquote><p>字的传送：</p><p>8086CPU可以一次性传送一个字（16位的数据），例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx 1000H</span><br><span class="line">mov ds bx</span><br><span class="line">mov ax [0] ;1000:0处的字型数据送入ax</span><br><span class="line">mov [0] cx ;cx中的16位数据送入1000:0处</span><br></pre></td></tr></table></figure><h2 id="10-DS与数据段"><a href="#10-DS与数据段" class="headerlink" title="10 DS与数据段"></a>10 DS与数据段</h2><p>对于8086 PC机，可以根据需要将一组内存单元定义为一个段。将一组长度为N (N&lt;64K)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。</p><p><strong>DS : [address] —— 用DS存放数据段的段地址，用相关指令访问数据段中的具体单元，单元地址由[address]指出</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#累加数据段中的前 3个单元的数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov al, 0</span><br><span class="line">add al,[0]</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br><span class="line">#累加数据段中的前3个 字型数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0</span><br><span class="line">add ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4]</span><br></pre></td></tr></table></figure><h2 id="11-栈及栈操作的实现"><a href="#11-栈及栈操作的实现" class="headerlink" title="11 栈及栈操作的实现"></a>11 栈及栈操作的实现</h2><p>栈：只能在一端进行插入或删除操作的数据结构</p><p>栈的操作规则：LIFO（Last In First Out，后进先出）</p><p>CPU提供的栈机制：可以将一段内存当作栈来使用，支持用栈的方式访问内存空间。（对于栈溢出的问题，8086CPU不会检查是否越界，需要程序员自己预防栈溢出）</p><p>在8086CPU中，有两个与栈相关的寄存器：</p><ul><li><strong>栈段寄存器SS</strong>  ： 存放栈顶的段地址</li><li><strong>栈顶指针寄存器SP</strong>： 存放栈顶的偏移地址</li><li>任意时刻，<strong>SS:SP指向栈顶元素</strong></li></ul><p>PUSH（入栈）和POP（出栈）指令：</p><p><strong>push ax：将ax中的数据送入栈中（以字为单位对栈进行操作）</strong></p><ul><li>(1)SP&#x3D;SP-2；<br>(2)将ax中的内容送入SS : SP指向的内存单元处，SS : SP此时指向新栈顶。</li></ul><p><strong>pop ax：从栈顶取出数据 放到ax（以字为单位对栈进行操作）</strong></p><ul><li>(1)将 SS : SP指向的内存单元处的数据送入ax中；<br>(2)SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax#确定栈顶位置</span><br><span class="line">mov sp 0010H#确定栈底位置/栈空间大小</span><br><span class="line"></span><br><span class="line">mov ax,001AH</span><br><span class="line">mov bx,001BH</span><br><span class="line"></span><br><span class="line">push ax#存入位置从栈底开始</span><br><span class="line">push bx#bx的值最后放入</span><br><span class="line">pop ax#取出栈顶的值原来是bx的，现在把它放到ax中</span><br><span class="line">pop bx  #经过入栈出栈操作后，ax和bx中的值发生了交换</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726637.png" alt="image-20211121093822410"></p><h1 id="二、汇编语言程序"><a href="#二、汇编语言程序" class="headerlink" title="二、汇编语言程序"></a>二、汇编语言程序</h1><h2 id="1-汇编语言写的源程序"><a href="#1-汇编语言写的源程序" class="headerlink" title="1 汇编语言写的源程序"></a>1 汇编语言写的源程序</h2><p>汇编程序：包含汇编指令和伪指令的文本</p><ul><li><p><strong>伪指令</strong>：没有对应的机器码，最终是不会被CPU所执行；伪指令是由编译器来执行的，编译器根据伪指令来执行相关的编译工作。</p></li><li><p><strong>汇编指令</strong>：对应有机器码的指令，可以被编译为机器指令，最终被CPU执行。</p></li></ul><p>过程：汇编程序——编译器编译——机器码——计算机运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg#伪指令</span><br><span class="line">codesg segment#伪指令</span><br><span class="line">mov ax,0123H#汇编指令</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">#下面两句，用于程序返回(套路):程序结束运行后，将CPU控制器交还给调用自己的那个程序(常为DOS系统)。</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h#汇编指令</span><br><span class="line">codesg ends#伪指令</span><br><span class="line">end#伪指令</span><br></pre></td></tr></table></figure><hr><p>程序中的三种伪指令</p><ul><li><p><strong>段定义</strong></p><p>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#定义程序中的段：每个段都需要有段名</span><br><span class="line">段名 segment #段的开始</span><br><span class="line">...</span><br><span class="line">段名 ends#段的结束</span><br></pre></td></tr></table></figure></li><li><p><strong>end</strong> (不是ends)</p><p>汇编程序的结束标记。若程序结尾处不加end，编译器在编译程序时，不知道程序在何处结束。</p></li><li><p><strong>assume</strong> (假设)</p><p>让某一个 段寄存器 和程序中的某一个  用segment…ends定义的段 相关联</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使CS寄存器与codesg关联，将定义的codesg当作程序的代码段使用</span><br><span class="line">assume cs:codesg</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-由源程序到程序运行"><a href="#2-由源程序到程序运行" class="headerlink" title="2 由源程序到程序运行"></a>2 由源程序到程序运行</h2><p>源文件 ( .asm) ——编译——&gt; 目标文件( .obj ) ——连接——&gt; 可执行文件( .exe )</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：masm + 汇编文件名</p><p>编译过程产生的文件：</p><ul><li><p>目标文件（*.OBJ）**是对一个源程序进行编译后得到的最终结果；</p></li><li><p>列表文件（*.LST）是编译过程中产生的中间结果；</p></li><li><p>交叉引用文件（*.CRF）同样是编译过程产生的中间结果；</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726638.png" alt="image-20211121114115020"></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接命令：link + 文件名</p><p>连接过程产生的文件：</p><ul><li>**可执行文件(EXE)**是我们对一个程序进行连接要得到的最终结果。</li><li>映像文件(MAP)是连接程序将目标文件连接为可执行文件过程中产生的中间结果。</li><li>库文件( .LIB) 里包含了ー些可以调用的子程序，如果我们的程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和我们的目标文件连接到一起，生成可执行文件。</li><li>如果出现no stack segment，是一个“没有栈段”的警告错误，可以不理会这个错误。</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726639.png" alt="image-20211121115724936"></p><h2 id="3-用Debug跟踪程序执行"><a href="#3-用Debug跟踪程序执行" class="headerlink" title="3 用Debug跟踪程序执行"></a>3 用Debug跟踪程序执行</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726640.png" alt="image-20211121144425453"></p><h2 id="4-…-和-…"><a href="#4-…-和-…" class="headerlink" title="4 […] 和 (…)"></a>4 […] 和 (…)</h2><p><strong>[…]  ——表示一个内存单元（汇编语法规定）</strong></p><table><thead><tr><th>指令</th><th>段地址</th><th>偏移地址</th><th>操作单位</th></tr></thead><tbody><tr><td>mov ax，[0]</td><td>在DS中</td><td>在[0]中</td><td>字</td></tr><tr><td>mov al，[0]</td><td>在DS中</td><td>在[0]中</td><td>字节</td></tr><tr><td>mov ax，[bx]</td><td>在DS中</td><td>在[bx]中</td><td>字</td></tr><tr><td>mov al，[bx]</td><td>在DS中</td><td>在[bx]中</td><td>字节</td></tr></tbody></table><p><strong>(…) ——表示一个内存单元或寄存器中的内容（为学习交流方便做出的约定）</strong></p><table><thead><tr><th>描述对象</th><th>描述方法</th><th>描述对象</th><th>描述方法</th></tr></thead><tbody><tr><td>ax中的内容为0010H</td><td>(ax)&#x3D;0010H</td><td>2000: 1000处的内容为0010H</td><td>(21000H)&#x3D;0010H【20位地址描述只能用于寄存器和物理地址】</td></tr><tr><td>mov ax，[2]</td><td>(ax)&#x3D;((ds)*16+2)</td><td>mov [2], ax</td><td>((ds)*16+2)&#x3D;(ax)</td></tr><tr><td>add as，2</td><td>(ax)&#x3D;(ax)+2</td><td>add ax, bx</td><td>(ax)&#x3D;(ax)+(bx)</td></tr><tr><td>push ax</td><td>(sp)&#x3D;sp-2;   ((ss)*16+sp)&#x3D;(ax)</td><td>pop ax</td><td>(ax)&#x3D;((ss)*16+(sp))；                                    (sp)&#x3D;(sp)+2</td></tr></tbody></table><p>再约定：符号idata表示常量</p><p>例：mov ax，[idata] ——代表mov ax, [1]、 mov ax, [1] 等等</p><h2 id="5-Loop指令"><a href="#5-Loop指令" class="headerlink" title="5 Loop指令"></a>5 Loop指令</h2><p>Loop指令实现计数型循环，格式：<strong>loop 标号</strong></p><p>CPU执行loop指令时要进行的操作：</p><ul><li>(cx)&#x3D;(cx) - 1；</li><li>判断cx中的值，不为0则转至标号处执行程序，为0则向下执行</li></ul><p>注：要先<strong>定义一个标号，即指定循环开始的地方</strong>；<strong>cx中要提前存放循环次数</strong>，因为(cx) 影响loop指令的执行结果；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11#</span><br><span class="line">s:</span><br><span class="line">add ax,ax #</span><br><span class="line">loop s#</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="6-Loop指令使用例子"><a href="#6-Loop指令使用例子" class="headerlink" title="6 Loop指令使用例子"></a>6 Loop指令使用例子</h2><p>计算ffff:0000字节单元中的数乘以3，结果存储到dx中。（取出的是字节，而结果要作为字放进dx中）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#先将内存中数据取出，连加上次，即乘以3</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh#汇编程序中，数据不能以字母开头，所以要在ffff前加0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,6</span><br><span class="line">mov al,[bx]#</span><br><span class="line">mov ah,0#这两步相当于(ax)=((ds)*16+(bx))</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line">mov cx,3#设置循环次数</span><br><span class="line">s:</span><br><span class="line">add dx,ax#结果放在dx中</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>计算ffff:0 ~ ffff:b <strong>单元</strong>中的数据的和，结果存放在<strong>dx</strong>中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov dx,0</span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">mov al,[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">add dx,ax</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4x00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="7-段前缀的使用"><a href="#7-段前缀的使用" class="headerlink" title="7 段前缀的使用"></a>7 段前缀的使用</h2><p>在程序中，如果使用 mov al，[0] 意思应该是将DS:0存储单元的值传给al，但实际编译后，会变成mov al，0，即把常量0放到al里。为了避免这种情况，可以在 […] 前加上段前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al [0]   #同mov al, 0</span><br><span class="line">mov al ds:[0]#同(al)=((ds)*16+0)</span><br></pre></td></tr></table></figure><p>例题：</p><p>将内存 ffff:0 ~ ffff:b 中的数据拷贝到 0:200 ~ 0:20b 单元中中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffh</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,0020h</span><br><span class="line">mov es,ax#额外用一个寄存器放目标地址</span><br><span class="line"></span><br><span class="line">mov bx,0#初始偏移</span><br><span class="line">mov cx,12#循环次数</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">  mov dl,[bx]#默认的[bx]是ds:[bx]</span><br><span class="line">mov es:[bx],dl#将ds:[bx]的值拷贝到es:[bx]中去</span><br><span class="line">inc bx#bx自增1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="8-在代码段中使用数据"><a href="#8-在代码段中使用数据" class="headerlink" title="8 在代码段中使用数据"></a>8 在代码段中使用数据</h2><p>一般的，在程序中直接写地址是很危险的，因为可能会把数据写入到不该写的地方。</p><p>对策：可以在程序的段中存放数据，运行时有操作系统分配空间；（段的类别：数据段，代码段，栈段）</p><p>程序的一般框架：</p><p>当代码段前部 放的是数据而不是执行代码，应该用标号 表明代码开始的地方，不然编译器会把数据部分也当作执行代码来编译，从而造成错误。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">...</span><br><span class="line">数据</span><br><span class="line">...</span><br><span class="line">start:#定义一个标号，指示代码开始的位置</span><br><span class="line">...</span><br><span class="line">代码</span><br><span class="line">...</span><br><span class="line">code ends</span><br><span class="line">end start#end的作用：除了通知编译器程序结束外，还可以通知编译器 程序的入口在什么地方</span><br></pre></td></tr></table></figure><p>例题：编程计算以下8个数据的和，结果存在ax寄存器中<br>0123h，0456h，0789h，0abch，odefh，0fedh，0cbah，0987h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">#dw：define work，定义字型数据(2字节); db定义一个字节; dd定义一个双字(4字节)</span><br><span class="line">dw 0123h,0456h,0789h,0abch,odefh,0fedh,0cbah,0987h#在代码段中定义数据</span><br><span class="line">start:</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,8</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">add ax,cs:[bx]#代码段定义的数据是放在和该关联的寄存器中的，这里是cs</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="9-在代码段中使用栈"><a href="#9-在代码段中使用栈" class="headerlink" title="9 在代码段中使用栈"></a>9 在代码段中使用栈</h2><p>例题：将给定的数据逆序存放（使用栈，数据依次入栈，再依次出栈的数据就是逆序的了）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,098ZH#给定的数据</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0#留给栈的空余空间</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ss,ax#确定栈顶位置</span><br><span class="line">mov sp,30h#确定栈空间大小</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">push cs:[bx]#将cs:[bx]处的数据入栈</span><br><span class="line">add bx,2#数据是一个字，所以+2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,8</span><br><span class="line">s0:</span><br><span class="line">pop cs:[bx]#将栈中数据依次sh</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="10-将数据、代码、栈放入不同段"><a href="#10-将数据、代码、栈放入不同段" class="headerlink" title="10 将数据、代码、栈放入不同段"></a>10 将数据、代码、栈放入不同段</h2><p>为了不让程序显得混乱，可以将数据，栈，代码放在不同的段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#将代码，数据，栈放入不同段</span><br><span class="line">assume cs:code,ds:data,ss:ctack</span><br><span class="line"></span><br><span class="line">data segment#数据段</span><br><span class="line">dw 0123H0456H,0789H, 0abch, 0defh, 0fedh0cbah, 0987H</span><br><span class="line">deta ends</span><br><span class="line"></span><br><span class="line">stack segment#栈段</span><br><span class="line">dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment#代码段</span><br><span class="line">start:</span><br><span class="line">mov ax,stack#初始化各段寄存器</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20h</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0#入栈</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0#出栈</span><br><span class="line">mov cx,8</span><br><span class="line">s0:</span><br><span class="line">pop [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h1 id="三、内存寻址方式"><a href="#三、内存寻址方式" class="headerlink" title="三、内存寻址方式"></a>三、内存寻址方式</h1><h2 id="1-处理字符问题"><a href="#1-处理字符问题" class="headerlink" title="1 处理字符问题"></a>1 处理字符问题</h2><p>用 ‘ ’ 表明字符，</p><p>小写字母的ASCII码值比大写字母的ASCII码值大20H；所以：大写+20H &#x3D;&#x3D; 小写，小写-20H &#x3D;&#x3D; 大写 </p><p>问：大小写转换问题，将第一个字符串的小写字母转换为大写字母，将第二个字符串的大写字母转换为小写字母</p><p>（因为同一个字母大小写的ASCII码的区别只有高位第三位数不同，因此可以不用分支判断，而直接用 位运算 来变换大小写：<strong>转大写</strong>：将字母和<strong>11011111</strong>做<strong>与运算</strong>，<strong>转小写</strong>：将字母与<strong>00100000</strong>做<strong>或运算</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">s:</span><br><span class="line">mov al,[bx]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,5</span><br><span class="line">mov cx,11</span><br><span class="line">s0:</span><br><span class="line">mov al.[bx]</span><br><span class="line">or al,00100000b</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="2-bx-idata-方式寻址"><a href="#2-bx-idata-方式寻址" class="headerlink" title="2 [bx + idata] 方式寻址"></a>2 [bx + idata] 方式寻址</h2><p> [bx + idata] 表示一个内存单元，它的<strong>偏移地址为 (bx) + idata</strong>（是bx中的数值加上idata)</p><p>mov ax, [bx + 200] 的含义：将一个内存单元的内容送入ax，这个内存单元的段地址在ds中，偏移地址为bx的值加上200，*<em>数学化描述：(ax)&#x3D;( (ds)<em>16 + (bx) + 200 )</em></em></p><p>对上面的大小写转换问题，如果两个字符串长度相等，可以用[bx + idata] 进行代码简化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,5</span><br><span class="line">s:</span><br><span class="line">mov al,[bx]</span><br><span class="line">and al,11011111b</span><br><span class="line">mov [bx],al</span><br><span class="line"></span><br><span class="line">mov al.[bx+5]</span><br><span class="line">or al,00100000b</span><br><span class="line">mov [bx+5],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序就相当于C语言等高级语言的数组机制，实际上，[bx+idata]的方式为高级语言实现数组提供了便利机制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;BaSiC”</span></span><br><span class="line"><span class="string">char a[5] = &quot;</span>MinIX<span class="string">&quot;</span></span><br><span class="line"><span class="string">    int i = 0;</span></span><br><span class="line"><span class="string">    do&#123;</span></span><br><span class="line"><span class="string">        a[i]=a[i] &amp; 0xDF;</span></span><br><span class="line"><span class="string">        b[i]=b[i] | 0x20;</span></span><br><span class="line"><span class="string">        i++;</span></span><br><span class="line"><span class="string">    &#125;while(i &lt; 5)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="3-SI-和DI-寄存器"><a href="#3-SI-和DI-寄存器" class="headerlink" title="3 SI 和DI 寄存器"></a>3 SI 和DI 寄存器</h2><p> <strong>SI：source index ，源变址寄存器</strong></p><p><strong>DI：destination index ，目标变址寄存器</strong></p><p>（ SI和DI 是和BX功能相近的寄存器，区别：<strong>SI和DI不能分成两个8位寄存器来使用</strong>）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#下面三组指令实现的功能相同</span><br><span class="line">#1</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line">#1</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line">#1</span><br><span class="line">mov di,0 </span><br><span class="line">mov ax,[di+123]</span><br></pre></td></tr></table></figure><p>4 [bx + si] 和[bx + di] 方式寻址</p><p>5 [ bx + si + idata ] 和[ bx + di + idata ] 方式寻址</p><h2 id="6-不同的寻址方式的灵活应用"><a href="#6-不同的寻址方式的灵活应用" class="headerlink" title="6 不同的寻址方式的灵活应用"></a>6 不同的寻址方式的灵活应用</h2><table><thead><tr><th>形式</th><th>名称</th><th>特点</th><th>意义</th><th>示例</th></tr></thead><tbody><tr><td>[idata]</td><td>直接寻址</td><td>一个常量表示地址</td><td>直接定位一个内存单元</td><td>mov ax,[200]</td></tr><tr><td>[bx]</td><td>寄存器间接寻址</td><td>一个变量表示地址</td><td>间接定位一个内存单元</td><td>mov bx, 0        mov ax,[bx]</td></tr><tr><td>[bx+idata]</td><td>寄存器相对寻址</td><td>一个常量和变量表示地址</td><td>可在一个起始地址的基础上用变量间接定位一个内存单元</td><td>mov bx, 4        mov ax,[bx+200]</td></tr><tr><td>[bx+si]</td><td>基址变址寻址</td><td>两个变量表示地址</td><td></td><td>mov ax,[bx+si]</td></tr><tr><td>[bx+si+idata]</td><td>相对基址变址寻址</td><td>两个变量和一个常量表示地址</td><td></td><td>mov ax,[bx+si+200]</td></tr></tbody></table><p>7 不同寻址方式演示</p><h2 id="8-用于内存寻址的寄存器"><a href="#8-用于内存寻址的寄存器" class="headerlink" title="8 用于内存寻址的寄存器"></a>8 用于内存寻址的寄存器</h2><p><strong>只有bx，bp，si，di可以用在 […] 内对内存单元寻址，一般将bx，bp作为基址，si，di作为变址；</strong></p><p>bx以外的通用寄存器和段寄存器不可以用在[…]中</p><p><strong>bx、bp区别：bx默认在ds段上，bp默认在ss段上</strong></p><h2 id="9-数据在哪里？有多长？"><a href="#9-数据在哪里？有多长？" class="headerlink" title="9 数据在哪里？有多长？"></a>9 数据在哪里？有多长？</h2><p>数据位置的表达：</p><ol><li>立即数：直接包含在机器指令中的数据idata</li><li>寄存器：指令要处理的数据在寄存器中</li><li>内存：指令要处理的数据放在内存中，内存地址由段地址和偏移地址组合确定。</li></ol><p>处理的数据有多长：</p><ol><li>字word操作：利用整个寄存器，如ax</li><li>字节byte操作：寄存器拆开用，如al，ah</li><li>没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度：如：mov word ptr ds:[0]，1 指明了是字操作，而mov byte ptr ds:[0]，1指明了是字节操作</li></ol><p>10 寻址方式的综合应用</p><h2 id="11-用div指令实现除法"><a href="#11-用div指令实现除法" class="headerlink" title="11 用div指令实现除法"></a>11 用div指令实现除法</h2><p><strong>div是除法指令</strong>，使用div作除法时：</p><ul><li><p><strong>被除数：默认放在AX或 DX和AX中</strong></p></li><li><p><strong>除数：8位或16位，在寄存器或内存单元中</strong></p></li><li><table><thead><tr><th>被除数</th><th>AX</th><th>DX和AX</th></tr></thead><tbody><tr><td>除数</td><td><strong>8位</strong>内存&#x2F;寄存器</td><td><strong>16位</strong>内存&#x2F;寄存器</td></tr><tr><td>商</td><td><strong>AL</strong></td><td><strong>AX</strong></td></tr><tr><td>余数</td><td><strong>AH</strong></td><td><strong>DX</strong></td></tr></tbody></table></li></ul><p>div指令格式：div 寄存器&#x2F;内存单元</p><p><strong>切记：提前在默认寄存器中设置好被除数，且默认寄存器不作其他用途。</strong></p><p>示例：</p><table><thead><tr><th>指令</th><th>被除数</th><th>除数</th><th>商</th><th>余数</th></tr></thead><tbody><tr><td>div bl</td><td>(ax)</td><td>(bl)</td><td>(al)</td><td>(ah)</td></tr><tr><td>div byte ptr ds:[0]</td><td>(ax)</td><td>((ds)*16+0)</td><td>(al)</td><td>(ah)</td></tr><tr><td>div bx</td><td>(dx)*10000H+(ax)</td><td>(bx)</td><td>(ax)</td><td>(dx)</td></tr><tr><td>div word ptr es:[0]</td><td>(dx)*10000H+(ax)</td><td>((ds)*16+0)</td><td>(ax)</td><td>(dx)</td></tr></tbody></table><p>例子：利用除法指令计算 1000001&#x2F;100</p><p>分析：1000001D&#x3D;186A1H，需要进行16位的除法，所以用ax和dx联合存放186A1H，用bx存放除数 100D&#x3D;64H。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">dd 1000001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">date ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,ds:[0]</span><br><span class="line">mov dx,ds:[2]</span><br><span class="line">div word prt ds:[4]</span><br><span class="line">mov ds:[6],ax</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><h2 id="12-用dup-复制-设置内存空间"><a href="#12-用dup-复制-设置内存空间" class="headerlink" title="12 用dup(复制)设置内存空间"></a>12 用dup(复制)设置内存空间</h2><p>duplication(复制)</p><p><strong>功能：dup和db，dw，dd等数据定义伪指令配合，用于进行数据的重复</strong></p><p>如：</p><table><thead><tr><th>指令</th><th>功能</th><th>相当于</th></tr></thead><tbody><tr><td>bd 3 dup (0)</td><td>定义3个字节，值都为0</td><td>db 0,0,0</td></tr><tr><td>bd 3 dup (‘abc’,’ABC’)</td><td>定义了18个字节，有’abcABC’重复3次</td><td>db ‘abcABCabcABCabcABC’</td></tr></tbody></table><p>定义一个容量为200个字节的栈段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">db 200 dup (0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure><h1 id="四、流程转移与子程序"><a href="#四、流程转移与子程序" class="headerlink" title="四、流程转移与子程序"></a>四、流程转移与子程序</h1><h2 id="1-”转移“概述"><a href="#1-”转移“概述" class="headerlink" title="1 ”转移“概述"></a>1 ”转移“概述</h2><p> 一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程。</p><p>转移指令：</p><ul><li>可以控制CPU执行内存中某处代码的指令</li><li>可以修改IP，或同时修改CS和IP的指令</li></ul><p>转移指令的分类：</p><ul><li>按转移行为<ul><li><strong>段内转移：只修改IP</strong>，如jmp ax</li><li><strong>段间转移：同时修改CS和IP</strong>，如jmp 1000:0</li></ul></li><li>根据指令对IP修改的范围不同：<ul><li>段内短转移：IP修改范围为-128~127</li><li><strong>段内近转移</strong>：IP修改范围为-32768~32767</li></ul></li><li>按转移指令<ul><li>无条件转移指令，如jmp</li><li>条件转移指令，如jcxz</li><li>循环指令，如loop</li><li>过程调用</li><li>中断</li></ul></li></ul><h2 id="2-操作符offset"><a href="#2-操作符offset" class="headerlink" title="2 操作符offset"></a>2 操作符offset</h2><p>用<strong>offset可以取得标号的偏移地址</strong></p><p>格式：offset 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">start:</span><br><span class="line">mov ax,offset start#相当于mov ax,0</span><br><span class="line">s:</span><br><span class="line">mov ax,offset s#相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>例：使程序在运行时将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume sc:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">s:mov ax,bx</span><br><span class="line">mov si,offset s#获得s处的地址</span><br><span class="line">mov di,offset s0 #获得s0处的地址</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax#将s处的数据放入s0</span><br><span class="line">s0:nop#nop的机器码占一个字节，起”占位“作用</span><br><span class="line">codeseg ends</span><br><span class="line">ends</span><br></pre></td></tr></table></figure><h2 id="3-jmp指令"><a href="#3-jmp指令" class="headerlink" title="3 jmp指令"></a>3 jmp指令</h2><p>功能：<strong>无条件转移</strong>，可以只修改IP，也可以同时修改CS和IP</p><p>使用jmp要给出两种信息：</p><ul><li>转移的<strong>目的地址</strong>；</li><li>转移的<strong>距离</strong>：<ul><li><strong>段间转移（远转移）</strong>：<strong>jmp far ptr 标号</strong></li><li>段内<strong>短转移：jmp short 标号</strong>；IP的修改范围为-128~127，8位的位移</li><li>段内<strong>近转移：jmp near ptr 标号</strong>；IP的修改范围为-32768~32767，16位的位移</li></ul></li></ul><p>两种段内转移</p><ul><li><p><strong>短转移：jmp short 标号</strong></p><p>功能：(IP)&#x3D;(ip)+8位位移</p><p>原理：</p><ol><li>8位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li><li>short指明此处的位移为8位位移；</li><li>8位位移的范围为-128~127，用补码表示；</li><li>8位<strong>位移由编译器在编译时算出</strong>。</li></ol></li><li><p><strong>近转移：jmp near ptr 标号</strong></p><p>功能：(IP)&#x3D;(ip)+<strong>16位位移（相对于当前IP的转移位移）</strong></p><p>原理：</p><ol><li>16位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li><li><strong>near ptr指明此处的位移为16位位移；</strong></li><li>16位位移的范围为-32768~32767，用补码表示；</li><li>16位位移由编译器在编译时算出。</li></ol></li></ul><p><strong>远转移：jmp far ptr 标号；</strong></p><ul><li><strong>far ptr指明了跳转到的目的地址，即包含了标号的段地址CS和偏移地址IP</strong></li></ul><hr><p>转移地址放在<strong>寄存器中</strong>的jmp指令</p><p>格式：<strong>jmp 16位寄存器</strong></p><p>功能：IP &#x3D; (16位寄存器)    如：jmp bx</p><hr><p>转移地址在<strong>内存中</strong>的jmp地址</p><p>段内转移</p><ul><li><p><strong>jmp word ptr 内存单元地址</strong></p></li><li><p>功能：从内存单元地址处开始存放的<strong>一个字</strong>，作为转移的目的的<strong>偏移地址</strong></p></li><li><p>&#96;&#96;&#96;assembly<br>mov ax,0123H<br>mov ds:[0],ax<br>jmp word ptr ds:[0]  #执行后，(IP)&#x3D;0123H</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">段间转移</span><br><span class="line"></span><br><span class="line">* **jmp dword ptr 内存单元地址**</span><br><span class="line"></span><br><span class="line">* 功能：从内存单元地址开始处的**两个字**，**高地址的字**作为转移的目的**段地址**，**低地址**处是转移的目的**偏移地址**</span><br><span class="line"></span><br><span class="line">* ```assembly</span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov ds:[0],ax</span><br><span class="line">  mov word ptr ds:[2],0</span><br><span class="line">  jmp dword ptr ds:[0]   #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br><span class="line">  </span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov bx,ax</span><br><span class="line">  mov word ptr [bx+2],0</span><br><span class="line">  jmp dword ptr [bx]  #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br></pre></td></tr></table></figure></li></ul><hr><table><thead><tr><th>jmp指令格式</th><th>示例</th></tr></thead><tbody><tr><td>jmp 标号</td><td>—段间转移（远转移）：jmp far ptr 标号                                                                                        —段内短转移：jmp short 标号（8位的位移）                                                                                            —段内近转移：jmp near ptr 标号；16位的位移</td></tr><tr><td>jmp 寄存器</td><td>—jmp bx；16位的位移</td></tr><tr><td>jmp 内存单元(表示跳转到的地址)</td><td>—段内转移：jmp word ptr 内存单元地址；jmp word ptr [bx]      —段间转移：jmp dword ptr 内存单元地址；jmp dword ptr [bx]</td></tr></tbody></table><p>在源程序中，不能使用 jmp 2000:0100 的转移指令进行跳转，这是在Debug中使用的汇编指令，而编译器并不认识，会报错。</p><h2 id="4-其他转移指令"><a href="#4-其他转移指令" class="headerlink" title="4 其他转移指令"></a>4 其他转移指令</h2><p>所有的<strong>有条件转移都是短转移</strong>，对IP的修改范围都为-128~127。</p><p>位移：是指”相对“转移，好处是：无论s处的指令的实际地址是多少，loop等指令转移的相对位移都是不变的。这样，方便了程序段在内存中的浮动装配。</p><p> jcxz指令</p><ul><li><p>格式：<strong>jcxz 标号</strong>（条件转移）</p><p>功能：如果**(cx)&#x3D;0，则转移到标号处执行**；当(cx) !&#x3D; 0时，什么也不做（程序向下执行）</p></li></ul><p>loop指令</p><ul><li><p>格式：<strong>loop 标号</strong>（条件转移）</p><p>功能：(cx) &#x3D; (cx) - 1; 当**(cx) !&#x3D; 0时，则转移到标号处执行**，当(cx) &#x3D; 0时，程序向下执行（cx的值先减1，再判断）</p></li></ul><h2 id="5-call指令和ret指令"><a href="#5-call指令和ret指令" class="headerlink" title="5 call指令和ret指令"></a>5 call指令和ret指令</h2><p>模块化程序设计：调用子程序——call指令；返回——ret指令</p><p>实质：流程转移指令，都修改IP，或同时修改CS:IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">call s#调用子程序</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:add ax,1</span><br><span class="line">ret#返回</span><br></pre></td></tr></table></figure><p>call指令</p><ul><li><p>格式：</p><ol><li><strong>call 标号（段内转移）</strong>，</li><li><strong>call far ptr 标号（段间转移）</strong>，</li><li><strong>call 16位寄存器</strong>（转移地址放在寄存器中，段内转移），</li><li><strong>call word ptr 内存单元地址（单字，段内转移）；call dword ptr 内存单元地址（双字，段间转移）</strong></li></ol></li><li><p>CPU执行call指令，进行两步操作：</p><p>将当前的IP或CS和IP压入栈中；转移到标号处执行指令。</p></li></ul><p>ret，retf指令</p><ul><li>ret指令：<ul><li>功能：用栈中的数据，修改IP的内容，从而实现近转移；</li><li>相当pop IP</li></ul></li><li>retf指令( f 意思是far）：<ul><li>用栈中的数据，修改CS和IP的内容，从而实现远转移</li><li>相当于 pop IP, pop CS</li></ul></li></ul><h2 id="6-mul指令"><a href="#6-mul指令" class="headerlink" title="6 mul指令"></a>6 mul指令</h2><p>mul指令用于做乘法运算</p><p>格式：mul 寄存器  或者   mul 内存单元</p><table><thead><tr><th></th><th>8位乘法</th><th>16位乘法</th></tr></thead><tbody><tr><td>被除数(默认)</td><td>AL</td><td>AX</td></tr><tr><td>乘法</td><td>8位寄存器或内存字节单元</td><td>16位寄存器或内存字节单元</td></tr><tr><td>结果</td><td>AX</td><td>DX(高位)，AX(低位)</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,100#被除数先放到默认寄存器al中</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl  #结果：(ax)=1000</span><br><span class="line"></span><br><span class="line">mov ax,100#被除数先放到默认寄存器ax中</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx   #结果：(dx)=000FH,(ax)=4240H</span><br></pre></td></tr></table></figure><h2 id="7-汇编语言的模块化程序设计"><a href="#7-汇编语言的模块化程序设计" class="headerlink" title="7 汇编语言的模块化程序设计"></a>7 汇编语言的模块化程序设计</h2><p><strong>模块之间的参数和结果的传递</strong>：1. 用<strong>寄存器</strong>传递参数；2. 用<strong>内存单元</strong>进行参数传递；3. 用<strong>栈</strong>传递参数</p><p>用寄存器来存储参数和结果：最常用，但寄存器有限，所以参数不能太多；</p><p>用内存单元批量传递数据：将批量数据放在内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给所需的子程序；对于具有批量数据的返回结果，也可以用同样的方法。</p><p>用栈传递参数：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p><h2 id="8-寄存器冲突问题"><a href="#8-寄存器冲突问题" class="headerlink" title="8 寄存器冲突问题"></a>8 寄存器冲突问题</h2><p> 在调用的子程序中，如果用到了调用者已经在用的寄存器，可能会会使运行结果错误甚至程序崩溃。</p><p>为了不影响调用者在使用的寄存器的值，同时为了避免在编写程序时需时刻注意寄存器的使用这种麻烦情况，因此，制定了<strong>子程序的标准框架</strong>：</p><ul><li><strong>子程序开始时，将子程序会使用到的寄存器入栈</strong></li><li>子程序内容</li><li><strong>子程序使用的寄存器出栈（恢复寄存器中的数据）</strong></li><li>返回（ret，retf）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capital:</span><br><span class="line">push cx#假设用到了cx和si</span><br><span class="line">push si</span><br><span class="line">#子程序内容</span><br><span class="line">pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="9-标志寄存器"><a href="#9-标志寄存器" class="headerlink" title="9 标志寄存器"></a>9 标志寄存器</h2><p>结构：</p><ul><li>flag寄存器是<strong>按 位 起作用的</strong>，也就是说，它的每一位都有专门的含义，记录特定的信息。</li><li>8086CPU的16位flag寄存器没有使用1,3,5,12,13,14,15，这些位不具有任何含义</li></ul><p>作用：</p><ul><li>用来存储相关指令的某些执行结果（溢出，进位，是否为0…）</li><li>用来为CPU执行相关指令提供行为依据（如传送数据的方向…）</li><li>用来控制CPU的相关工作方式</li></ul><p>flag寄存器的值：</p><table><thead><tr><th>15</th><th>14</th><th>13</th><th>12</th><th>11</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th></th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td>OF</td><td>DF</td><td>IF</td><td>TF</td><td>SF</td><td>ZF</td><td></td><td>AF</td><td></td><td>PF</td><td></td><td>CF</td></tr></tbody></table><table><thead><tr><th>标志</th><th>值为1</th><th>值为0</th><th>意义</th></tr></thead><tbody><tr><td>OF (Overflow)</td><td>OV</td><td>NV</td><td>溢出</td></tr><tr><td>DF (Direction)</td><td>DN</td><td>UP</td><td>方向</td></tr><tr><td>SF (Sign)</td><td>NG</td><td>PL</td><td>符号</td></tr><tr><td>ZF (Zero)</td><td>ZR</td><td>NZ</td><td>零值</td></tr><tr><td>PF (parity)</td><td>PE</td><td>PO</td><td>奇偶</td></tr><tr><td>CF (Carry)</td><td>CY</td><td>NC</td><td>进位</td></tr></tbody></table><p>直接访问标志寄存器的方法：</p><ul><li>pushf：将标志寄存器的值压栈。</li><li>popf：从栈中弹出数据，送入标志寄存器中。</li></ul><p>指令影响：</p><ul><li>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，如：add，sub，mul，div，inc，or，and等，大都是运算指令，逻辑指令</li><li>有的指令的执行对标志寄存器没有影响，如：mov，push，pop等，大都是传送指令。</li></ul><hr><ul><li><p><strong>ZF—零标志</strong>（Zero Flag）</p><p>ZF&#x3D;<strong>1</strong>，表示 逻辑<strong>真</strong>；ZF&#x3D;<strong>0</strong>，表示逻辑<strong>假</strong></p></li><li><p><strong>PF—奇偶</strong>标志（Parity Flag）</p><p>PF记录指令执行后，结果的所有二进制位中<strong>1的个数</strong>；</p><p>1的个数为<strong>偶数</strong>，PF &#x3D; <strong>1</strong></p><p>1的个数为<strong>奇数</strong>，PF &#x3D; <strong>0</strong></p></li><li><p><strong>SF—符号标志</strong>（Sign Flag）</p><p>结果为<strong>负</strong>：SF &#x3D; <strong>1</strong></p><p>结果为<strong>非负</strong>：SF &#x3D; <strong>0</strong></p><p>（将数据当作有符号数来运算时，通过SF可知结果的正负；将数据当作无符号数来运算时，SF的值则没有意义，虽然相关的指令会影响它的值）</p></li><li><p><strong>CF—进位标志</strong>（Carry Flag）</p></li></ul><p>  在进行无符号数的运算时，CF记录了运算结果的 最高有效位 向更高位（这个更高位是假象的）的进位值。</p><p>  <strong>有进位或借位</strong>，CF &#x3D; <strong>1</strong></p><p>  <strong>无进位或借位</strong>，CF &#x3D; <strong>0</strong></p><ul><li><p><strong>OF—溢出标志</strong>（Overflow Flag）</p><p>在进行有符号数运算时，如果结果超过了机器所能表示的范围，称为溢出。</p><p><strong>有溢出</strong>，OF &#x3D; <strong>1</strong></p><p><strong>无溢出</strong>，OF &#x3D; <strong>0</strong></p></li></ul><h2 id="10-带进位的加减法"><a href="#10-带进位的加减法" class="headerlink" title="10 带进位的加减法"></a>10 带进位的加减法</h2><p><strong>adc—带进位加法指令</strong>，利用了CF位上记录的进位值。</p><p>格式：<strong>adc 操作对象1，操作对象2</strong></p><p>功能：<strong>操作对象1 &#x3D; 操作对象1 + 操作对象2 + CF值</strong></p><p>例：adc ax, bx 实现的功能：(ax) &#x3D; (ax) + (bx) + CF</p><p>应用：大数相加（先将低16位相加，然后将高16位和进位值相加）</p><hr><p><strong>sbb—带借位减法指令</strong></p><p>格式：<strong>sbb 操作对象1，操作对象2</strong></p><p>功能：<strong>操作对象1 &#x3D; 操作对象1 - 操作对象2 - CF值</strong></p><p>例：sbb ax, bx  实现的功能：(ax) &#x3D; (ax) - (bx) - CF</p><h2 id="11-cmp和条件转移指令"><a href="#11-cmp和条件转移指令" class="headerlink" title="11 cmp和条件转移指令"></a>11 cmp和条件转移指令</h2><p><strong>cmp</strong>指令是<strong>比较指令</strong>，功能<strong>相当于减法指令，只是不保存结果</strong>；cmp指令执行后，会对标志寄存器产生影响，可以<strong>根据标志寄存器来比较结果</strong>，而不影响原值。</p><p>格式： <strong>cmp 操作对象1，操作对象2</strong></p><p>功能：计算 操作对象1 - 操作对象2</p><hr><p><strong>无符号数比较</strong>以及标志位取值</p><table><thead><tr><th>比较关系</th><th>(ax)-(bx)特点</th><th>标志寄存器</th></tr></thead><tbody><tr><td>等于</td><td>(ax)-(bx) &#x3D; 0</td><td>ZF&#x3D;1</td></tr><tr><td>不等于</td><td>(ax)-(bx) !&#x3D; 0</td><td>ZF&#x3D;0</td></tr><tr><td>小于</td><td>(ax)-(bx) 产生借位</td><td>CF&#x3D;1</td></tr><tr><td>大于等于</td><td>(ax)-(bx) 不必借位</td><td>CF&#x3D;0</td></tr><tr><td>大于</td><td>(ax)-(bx) 即不借位，结果右不为0</td><td>CF&#x3D;0且ZF&#x3D;0</td></tr><tr><td>小于等于</td><td>(ax)-(bx) 借位 或者 结果为0</td><td>CF&#x3D;1或ZF&#x3D;1</td></tr></tbody></table><p> <strong>有符号数比较</strong>以及标志位取值（仅凭结果正负(SF)无法得出结论，需要配合是否溢出(OF)得到结论）</p><table><thead><tr><th>比较关系</th><th>(ax)-(bx)特点</th><th>标志寄存器</th></tr></thead><tbody><tr><td>等于</td><td>(ax)-(bx) &#x3D; 0</td><td>ZF&#x3D;1</td></tr><tr><td>不等于</td><td>(ax)-(bx) !&#x3D; 0</td><td>ZF&#x3D;0</td></tr><tr><td>小于</td><td>(ax)-(bx) 为负，且不溢出</td><td>SF&#x3D;1且OF&#x3D;0</td></tr><tr><td>大于等于</td><td>(ax)-(bx) 为负，且溢出</td><td>SF&#x3D;1且OF&#x3D;1</td></tr><tr><td>大于</td><td>(ax)-(bx) 为非负，且无溢出</td><td>SF&#x3D;0且OF&#x3D;0</td></tr><tr><td>小于等于</td><td>(ax)-(bx) 为非负，或有溢出</td><td>SF&#x3D;0或OF&#x3D;1</td></tr></tbody></table><hr><p> <strong>条件转移指令</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726641.png" alt="image-20211130203630863"></p><h2 id="12-DF标志和串传送指令，rep指令"><a href="#12-DF标志和串传送指令，rep指令" class="headerlink" title="12 DF标志和串传送指令，rep指令"></a>12 DF标志和串传送指令，rep指令</h2><p><strong>DF—方向标志位</strong>（Direction Flag）</p><ul><li><p>功能：在串处理指令中，控制每次操作后 si，di的增减</p><p><strong>DF &#x3D; 0，每次操作后 si，di 递增；</strong></p><p><strong>DF &#x3D; 1，每次操作后 si，di 递减；</strong></p></li><li><p>对DF位进行设置：</p><p><strong>cld 指令：将标志寄存器的DF位设为0 （clear）</strong></p><p><strong>std 指令：将标志寄存器的DF位设为1 （setup）</strong></p></li></ul><hr><p><strong>串传送指令：</strong></p><ul><li><p>movsb：以<strong>字节</strong>为单位传送</p><ul><li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )，复制字节</p></li><li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>1</strong>，(di) &#x3D; (di) + <strong>1</strong></p><p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 1，(di) &#x3D; (di) - 1</p></li></ul></li><li><p>movsw：以<strong>字</strong>为单位传送</p><ul><li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )</p></li><li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>2</strong>，(di) &#x3D; (di) + <strong>2</strong></p><p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 2，(di) &#x3D; (di) - 2</p></li></ul></li></ul><p>rep指令：</p><ul><li><p>功能：根据cx的值，重复执行后面的指令</p></li><li><p>用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">#上下两段代码是等价的</span><br><span class="line">s:movsb</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure></li></ul><h1 id="五、中断及外部设备操作"><a href="#五、中断及外部设备操作" class="headerlink" title="五、中断及外部设备操作"></a>五、中断及外部设备操作</h1><h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="1-移位指令"><a href="#1-移位指令" class="headerlink" title="1 移位指令"></a>1 移位指令</h3><p>其中OPR为操作数，CNT为位移位数</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726642.png" alt="image-20211201183648230"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注意点:移位位数大于1时，必须使用cl</span><br><span class="line">mov al,0101000001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl   #这里位数如果要写立即数，只能写1，即shl al,1</span><br></pre></td></tr></table></figure><p>常用法：<strong>将x逻辑左移一位，相当于x&#x3D;x*2；右移一位，相当于x&#x3D;x&#x2F;2</strong></p><h3 id="2-操作显存数据"><a href="#2-操作显存数据" class="headerlink" title="2 操作显存数据"></a>2 操作显存数据</h3><p>显存数据，即屏幕上显示的内容。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726643.png" alt="image-20211201184646183"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726644.png" alt="image-20211201190344885"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726645.png" alt="image-20211201190441592"></p><h3 id="3-描述内存单元的标号"><a href="#3-描述内存单元的标号" class="headerlink" title="3 描述内存单元的标号"></a>3 描述内存单元的标号</h3><p>地址标号：仅仅表示地址，标号后要加冒号</p><p>数据标号：标记了存储数据的单元的地址和长度。</p><p>注意：地址标号只能在代码段中使用，数据标号在代码段，数据段等都可以使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a ab 1,2,3,4,5,6#a为数据标号，标号后面不加冒号</span><br><span class="line">b bw 0</span><br><span class="line">start: mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,a[si]#数据标号 可以当作 地址值 用</span><br><span class="line">mov,ah,0</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line">....</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">#b代表地址为code:8,长度为字的内存单元</span><br><span class="line">#mov ax,b 相当于 mov ax,cx:[8]</span><br><span class="line">#mov b,2  相当于 mov word ptr cs:[8],2</span><br><span class="line">#inc b    相当于 inc word ptr cs:[8]</span><br><span class="line">#mov al,b (error!)</span><br></pre></td></tr></table></figure><h3 id="4-数据的直接定址表"><a href="#4-数据的直接定址表" class="headerlink" title="4 数据的直接定址表"></a>4 数据的直接定址表</h3><p>利用表，在两个数据集合之间建立一种映射关系，用查表的方法根据给出的数据得到另一集合中的对应数据。</p><p>例：计算sin(x)的值（x为有限个度数值），而计算过程需要多个乘除运算，代价颇高，所以可以考虑使用映射表。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726646.png" alt="image-20211201200817089"></p><p>5 代码的直接定址表</p><p>通过查表的方式，通过依据数据，直接计算出所要找的元素的位置。</p><p>如：要实现一个子程序，它提供四种功能，利用定址表的方案：将<strong>4个功能写成4个子程序，将这些功能子程序的入口地址存到一个表中</strong>，其对应关系：功能号*2&#x3D;对应的功能子程序在地址表中的偏移。这样就方便许多，不用很多分支选择</p><h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>1 中断及其处理</p><p>中断：CPU不再接着（刚执行完的指令）向下执行，而是转去处理中断信息。</p><p>内中断：由CPU内部发生的事件而引起的中断</p><p>外中断：由外部设备发生的事件而引起的中断</p><hr><p>内中断：</p><ul><li>除法错误：0（中断码）</li><li>单步执行：1</li><li>执行into指令：4</li><li>执行int n指令：立即数n为中断类型码</li></ul><hr><p>CPU接到中断信息后，会立即执行中断处理程序；</p><p>中断处理程序在哪里？中断信息和处理程序的入口地址之间有联系，CPU根据中断信息可查找中断向量表，找到要执行的处理程序。</p><p>中断向量表：中断类型码 与 中断处理程序地址入口 的映射表</p><hr><p>中断过程</p><p>中断过程由CPU的硬件自动完成，由中断类型码找到中断向量，并用它设置CS和IP</p><p>8086CPU的中断过程：</p><ol><li>从中断信息中取得中断类型码；</li><li>标志寄存器的值入栈：中断过程要改变标志寄存器的值，所以需要先行保护；</li><li>设置标志寄存器的第8位TF 和第9位IF的值为 0；</li><li>CS的内容入栈，IP的内容入栈（先行保护）</li><li>从中断向量表读取处理程序的入口地址，设置IP和CS</li></ol><p>2 编制中断处理程序</p><ul><li>CPU随时可能检测到中断信息，所以中断处理程序必须常驻内存中。</li><li>中断处理程序的入口地址，即中断向量，必须存储在对应的 中断向量表中（入口地址为IP和CS应该修改的值）。</li></ul><p>如果是自己编制的中断处理程序，应该放在内存的确定位置，且不破坏系统（向操作系统申请获得存放 程序的内存空间）；</p><p>3 单步中断</p><p>从Debug中断的t命令，即让CPU能执行一条指令就停下来：</p><ul><li>Debug利用了CPU提供的单步中断功能；</li><li>使用t命令，Debug将TF标志设为1，使CPU工作在单步中断方式下。</li></ul><p>两个和中断相关的寄存器标志位：</p><ul><li>TF—陷阱标志（Trap flag）：用于调试时的单步方式操作。<ul><li>当TF&#x3D;1时，每条指令执行完后产生陷阱，由系统控制计算机；</li><li>当TF&#x3D;0时，CPU正常工作，不产生陷阱。</li></ul></li><li>IF—中断标志（Interrupt flag）：<ul><li>当IF&#x3D;1时，允许CPU响应可屏蔽中断请求；</li><li>当IF&#x3D;0时，关闭中断。</li><li>设置IP的指令：sti，置IF&#x3D;1；cli，置IF&#x3D;0。</li></ul></li></ul><p>单步中断过程：</p><p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断（中断类型码为1）：</p><ol><li><p>取得中断类型码1；</p></li><li><p>标志寄存器入栈，TF和IF设置为0；</p><blockquote><p>为什么TF要设置为0？</p><p>因为中断处理程序也由一条条指令组成。如果在执行中断处理程序之前，TF&#x3D;1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令….这样会陷入一个死循环，CPU一直在执行单步中断处理程序的第一条指令。所以，在进入中断处理程序前，设置TF为0。</p></blockquote></li><li><p>CS，IP入栈；</p></li><li><p>设置CS，IP的值，使CPU执行中断处理程序；</p></li></ol><hr><p>中断不响应的情况：</p><p>一般来说，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，当有些情况下，CPU不会响应中断：</p><p>例：在执行完向ss寄存器传送数据的指令后，即使发生中断，CPU也不会响应。</p><blockquote><p>原因：因为ss:sp是联合指向栈顶，而对它们的设置应该连续完成，依次保证对栈的正确操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置ss寄存器后的下一条指令会连续执行，不会单步执行，所以正确操作是将 设置ss和sp寄存器的两条指令放在一起</span><br><span class="line">mov ax,1000</span><br><span class="line">mov ss,ax</span><br><span class="line">....#不要在设置ss和sp的指令中将插入其他操作</span><br><span class="line">mov sp,10</span><br></pre></td></tr></table></figure></blockquote><p>4 由int指令引发的中断</p><p>格式：int n （n为中断类型码）</p><p>功能：引发特定中断过程。int指令的功能和call指令相似，都是调用一段程序，一般来说，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p><p>应用：因为int指令可以调用子程序（中断处理程序&#x2F;中断例程），所以可以自定义中断例程，由int调用，实现特定功能。</p><p>5 BIOS和DOS中断处理</p><p>BIOS和DOS在所提供的中断例程中包含了许多编程时可以用到的功能子程序。</p><p>BIOS——基本输入输出系统，存放在系统板的ROM中。</p><p>BIOS功能：</p><ul><li>硬件系统的检测和初始化程序；</li><li>外部中断和内部中断的中断例程；</li><li>用于对硬件设备进行I&#x2F;O操作的中断例程；</li><li>其他和硬件系统相关的中断例程。</li></ul><p>意义：使用BIOS功能调用，程序员就不用了解硬件操作细节，直接使用指令设置参数，并使用BIOS的中断例程，即可完成工作。更方便编程，写处简洁，可读性号，易于移植的程序。</p><p>具体的BIOS和DOS中断例程可以查看手册。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726647.png" alt="image-20211202172321228"></p><p>DOS中断</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726648.png" alt="image-20211202172548837"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726649.png" alt="image-20211202172452826"></p><h2 id="端口及外设控制"><a href="#端口及外设控制" class="headerlink" title="端口及外设控制"></a>端口及外设控制</h2><p>1 端口的读写</p><p>CPU可以直接读写3个地方的数据：CPU内寄存器，内存单元，端口。（端口指各种接口卡，网卡，显卡，主板的接口芯片等等）</p><p>端口的地址：各种芯片工作时，芯片上的一些寄存器由CPU读写，即CPU将这些寄存器当作端口并统一编址。</p><p>指令格式：in：CPU从端口读取数据；out：CPU往端口写入数据</p><p>端口的读写：</p><blockquote><p>例 ：in al，60h   从60h号端口读入一个字节</p><p>执行时相关的操作：</p><ol><li>CPU通过地址线将地址信息60h发出；</li><li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知要从中读取数据；</li><li>端口所在的芯片将60H对应端口中的数据通过数据总线送入CPU</li></ol></blockquote><p>端口读写规定：</p><ul><li>对0~255以内的端口进行读写，端口号用立即数给出</li><li>对256~65535的端口进行读写，端口号放在dx中</li><li>在in和out指令中，只能使用ax或al来存放从端口中读入的数或要发送到端口中的数据：访问8位端口上时用al，访问16位端口时用ax。</li></ul><p>2 操作CMOS RAM芯片</p><p>CMOS RAM芯片：包含一个实时时钟和一个128个存储单元的RAM存储器。</p><ul><li>128个字节的RAM存储器包含：内部实时钟，系统配置信息，相关的程序（用于开机时配置系统信息）</li><li>CMOS RAM芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。</li><li>芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个读写CMOS RAM。<ul><li>70h地址端口：存放要访问的CMOS RAM单元的地址；</li><li>71h数据端口：存放从选定的单元中读取的数据，或要写入到其中的数据。</li></ul></li></ul><p>读取CMOS RAM：将要读取的单元地址送入70h地址端口，再从71h数据端口读出指定单元的内容。</p><p>3 外设连接与中断</p><p>CPU在执行指令过程中，可以检测到端口(外设)发送过来的中断信息，引发中断过程，处理外设的输入。</p><p>外中断：由外部设备发生的事件引起的中断。</p><p>可屏蔽中断：</p><ul><li>可屏蔽中断是CPU可以不响应的外中断。</li><li>CPU是否响应可屏蔽中断，要看标志寄存器的IF位：IF&#x3D;1时，执行完当前指令后引发中断过程；IF&#x3D;0时，不响应中断。</li><li>几乎所有由外设引发的外中断，都是可屏蔽中断。</li></ul><p>不可屏蔽中断：</p><ul><li>不可屏蔽中断是CPU必须响应的外中断。</li><li>8086CPU不可屏蔽中断的中断类型码固定为2。</li><li>不可屏蔽中断在 系统中有必须畜栏里的经济情况发生时 用来通知CPU的中断信息，如：突然掉电时，进行保护性工作。</li></ul><p>9 磁盘读写</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726650.png" alt="image-20211202195502858"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726651.png" alt="image-20211202195721926"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726652.png" alt="image-20211202195822939"></p><h1 id="六、高级汇编语言技术"><a href="#六、高级汇编语言技术" class="headerlink" title="六、高级汇编语言技术"></a>六、高级汇编语言技术</h1><h2 id="8086拓展"><a href="#8086拓展" class="headerlink" title="8086拓展"></a>8086拓展</h2><p>子程序的<strong>可读性更好的写法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#相当于高级语言中对子程序的包装：&#123; &#125;</span><br><span class="line">名称 proc</span><br><span class="line">.... #内容</span><br><span class="line">(ret)</span><br><span class="line">名称 endp</span><br></pre></td></tr></table></figure><hr><p><strong>程序的多文件组织</strong>：</p><p>可以将程序放到不同地方，再进行连接编译，调用者需要声明调用了其他程序，被调用程序需要声明为共有的；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#调用者</span><br><span class="line">extrn 被调用程序的名称:far  #神明有子程序来自外部</span><br><span class="line">程序....</span><br><span class="line"></span><br><span class="line">#被调用者</span><br><span class="line">public 被调用程序的名称    #声明为共有的，允许外部调用</span><br><span class="line">子程序....</span><br></pre></td></tr></table></figure><h2 id="8086总结"><a href="#8086总结" class="headerlink" title="8086总结"></a>8086总结</h2><h3 id="一些名词缩写"><a href="#一些名词缩写" class="headerlink" title="一些名词缩写"></a>一些名词缩写</h3><blockquote><p>reg：寄存器</p><p>src：标号</p><p>opr：操作数</p><p>flags：标志寄存器</p></blockquote><h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><ul><li><p>通用数据传送指令：mov，push，pop，xchg</p><blockquote><p>xchg是交换指令：xchg  操作数1 操作数2 ——将两个操作数作交换</p><p>注：不影响标志位，不允许使用段寄存器</p></blockquote></li><li><p>累加器专用传送指令：in，out，xlat</p><blockquote><ul><li><p>in，out是用于端口读写的指令</p></li><li><p>xlat是换码指令：xlat 或者 xlat 操作数</p><p>执行的操作是： (al) &lt;— ( (bx) + (al) )</p><p>用法：bx放一个数据段的首地址，al放偏移量，根据基地址和偏移地址，取出对应位置的数据，放到al里。一开始 al 放偏移量，最后 al 放数据。</p><p>注：不影响标志位，只用于字节表格(长度不超过256)，执行指令前需要先把首地址放进bx中，位移量放进al中</p></li></ul></blockquote></li><li><p>地址传送指令：lea，lds，les</p><blockquote><ul><li><p>lea：有效地址送寄存器指令</p><p>lea 寄存器  标号 ，将标号的偏移地址放入寄存器中</p></li><li><p>lds：指针送寄存器和DS指令</p><p>lds 寄存器 标号 ，将代表标号处的4字节地址取出，低2字节放入寄存器，高2字节放入DS中</p></li><li><p>les：指针送寄存器和ES指令（与lds类似）</p></li></ul></blockquote></li><li><p>标志寄存器传送指令：lahf，sahf，pushf，popf</p><blockquote><p>lahf：标志送ah指令（l 指load，ah是ah寄存器，f是标志寄存器），效果：将 标志寄存器的低字节送入ah中。</p><p>sahf：ah送标志寄存器指令（s指 send），效果：将ah的内容送入标志寄存器的低字节。</p></blockquote></li><li><p>类型转换指令：cbw，cwd</p><blockquote><p>c指change，转换的意思，b指byte，w指word(单字)，d是双字</p><p>cbw：将一个字节数据转换为字数据—— al —&gt; ax </p><p>cwd：将一个字数据转换为双字数据—— ax —&gt; (dx,ax)</p><p>注：是无操作数指令，隐含对al或ax进行符号拓展，执行指令前先把数据放入al或ax中，不影响条件标志位</p></blockquote></li></ul><h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><ul><li><p>加法指令：add，adc，inc</p><blockquote><p>adc：带进位加法； inc：加1操作</p></blockquote></li><li><p>减法指令：sub，sbb，dec，neg，cmp</p><blockquote><p>sbb：带借位减法； dec：减1操作；</p><p>neg：取负的； cmp：比较大小(用的是减法操作)</p></blockquote></li><li><p>乘法指令：mul，imul</p><blockquote><p>带 i 表示有符号的</p></blockquote></li><li><p>除法指令：div，idiv</p></li><li><p>十进制调整指令：daa，das，aaa，aas，aam，aad</p><blockquote><p>BCD码：用二进制编码的十进制数</p><ul><li><p>压缩的BCD码：用4位二进制数表示1位十进制数</p><p>如： (59)<del>10</del> &#x3D; ( 0101 1001)<del>BCD</del></p></li><li><p>非压缩的BCD码：用8位二进制数表示1位十进制数</p><p>如：(59)<del>10</del> &#x3D; ( 0000 0101   0000 1001)<del>BCD</del></p></li></ul><p>当BCD码进行算术运算时，可能会出现错位，借位等问题，所以需要进行调整。</p><ol><li>压缩的BCD码调整指令：<ul><li>DAA：加法的十进制调整指令</li><li>DAS：减法的十进制调整指令</li></ul></li><li>非压缩的BCD码调整指令：<ul><li>AAA：加法的ASCII码调整指令</li><li>AAS：减法的ASCII码调整指令</li><li>AAM：乘法的ASCII码调整指令</li><li>AAD：除法的ASCII码调整指令</li></ul></li></ol></blockquote></li></ul><h4 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h4><ul><li><p>逻辑运算指令：and，or，not，xor，test</p><blockquote><p>xor——异或；</p><p>test——测试，做 与运算，但不保存结果，只影响标志位；</p></blockquote></li><li><p>移位指令：shl，shr，sal，sar，rol，ror，rcl，rcr</p><blockquote><p>shl——逻辑左移</p><p>shr——逻辑右移</p><p>sal——算术左移</p><p>sar——算术右移</p><p>rol——循环左移</p><p>ror——循环右移</p><p>rcl——带进位循环左移</p><p>rcr——带进位循环右移</p></blockquote></li></ul><h4 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h4><ul><li>设置方向标志指令：cld，std</li><li>串处理指令：movsb&#x2F;movsw，stosb&#x2F;stosw，lodsb&#x2F;lodsw，cmpsb&#x2F;cmpsw，scasb&#x2F;scasw</li></ul><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul><li>无条件转移指令：jmp</li><li>条件转移指令：jz，je，js，jo，jp，jb，jl，jbe，jle，jcxz</li><li>循环指令：loop，loopz，loopnz</li><li>子程序调用和返回指令：call，ret</li><li>中断与中断返回指令：int，into，iret</li></ul><p>处理机控制与杂项操作指令</p><ul><li>标志处理指令：clc，stc，cmc，cld，std，cli，sti</li><li>其他：<ul><li>nop（无操作，占位1字节）</li><li>hlt（暂停机，等待一次外中断，之后继续执行程序）</li><li>wait（等待，等待外中断，之后仍继续等待）</li><li>esc（换码）</li><li>lock（封锁，维持总线的锁存信号，直到其他的指令执行完）</li></ul></li></ul><h3 id="伪操作"><a href="#伪操作" class="headerlink" title="伪操作"></a>伪操作</h3><p>汇编指令是指：与机器指令一一对应，在程序运行期间由计算机执行。</p><p>伪操作是指：在汇编程序对源程序汇编期间，由汇编程序处理的操作&#x2F;指令（只在汇编期间其作用，伪指令不会产生机器码），可以完成如数据定义，分配存储区，指示程序结束等功能。</p><p>处理器选择伪操作，段定义伪操作，程序开始和结束伪操作，数据定义及存储器分配伪操作，表达式赋值伪操作，地址计数器与对准伪操作，基数控制伪操作</p><p>（具体的暂略）</p><p>操作符</p><p>操作符：用于操作数中，通过操作符，将常数，寄存器，标号，变量等，组合成表达式，实现求值的目的（还是将汇编期间进行的）。</p><p>算术操作符：+，-，*，&#x2F;，mod</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726653.png" alt="image-20211206181250064"></p><p>逻辑和移位操作符：and，or，xor，not，shl，shr</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726654.png" alt="image-20211206181409612"></p><p>关系操作符：eq，nf，lt，le，gt，ge</p><p>数值回送操作符：offset，seg，type，length，size</p><p>属性操作符：ptr，段操作符，short，this，high，low，highword，lowword</p><h3 id="宏汇编"><a href="#宏汇编" class="headerlink" title="宏汇编"></a>宏汇编</h3><p>汇编过程：有两次汇编</p><ul><li>第一次汇编：确定地址，翻译成各条机器码，字符标号原样写出；</li><li>第二次汇编：标号代真，将字符标号用计算出的地址值或偏移量代换。</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191726655.png" alt="image-20211206184340760"></p><p>32位汇编</p><p>实用技术</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/Notes/2022/04/14/linux/"/>
      <url>/Notes/2022/04/14/linux/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>linux是一个开源、兔费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多企业级的项目(c&#x2F;c++&#x2F;php&#x2F;python&#x2F;java&#x2F;go) 都会部署到Linux&#x2F;unix系统上。</p><p>![O</p><blockquote><p>常见的操作系统(windows、IOS、Android、MacOS、Linux、Unix)</p><p>linux之父：Linus Torvalds，他开发了linux0.01版源码，也是Git创作者。</p></blockquote><hr><p><strong>Linux主要发行版本</strong></p><p><strong>Ubuntu</strong>（乌班图），<strong>RedHat</strong>（红帽子），<strong>CentOS</strong>，Debain，Fedora，SuSE，OpenSUSE</p><hr><h3 id="应用领域"><a href="#应用领域" class="headerlink" title="应用领域"></a>应用领域</h3><ul><li><p>linux在&#x3D;&#x3D;服务器领域&#x3D;&#x3D;的应用是最好的，有免费，稳定，高效的特点。</p></li><li><p>在嵌入式领域，linux运行稳定，对网络有良好支持，且低成本，能根据需求进行软件裁剪，内核最小可到几百kb。</p><p>如：机顶盒、数字电视、网络电话、远程交换机、手机、PDA、智能家居等 物联网应用。</p></li></ul><hr><h3 id="Linux和Unix的关系"><a href="#Linux和Unix的关系" class="headerlink" title="Linux和Unix的关系"></a>Linux和Unix的关系</h3><p>Unix只针对大型主机或服务器，后来在GNU计划（自由软件 集体协作计划）倡导下，Linus Torvalds基于Unix的轻量版Minix上开发出了Linux内核。</p><hr><h3 id="linux网络连接的三种模式"><a href="#linux网络连接的三种模式" class="headerlink" title="linux网络连接的三种模式"></a>linux网络连接的三种模式</h3><ul><li>桥接模式，虚拟系统可以和外部系统通讯，但是容易造成IP冲突；</li><li>NAT模式，网络地址转换模式虚拟系统可以和外部系统通讯，不造成IP冲突；</li><li>主机模式：独立的系统；</li></ul><hr><h3 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h3><p>VMware提供了快照管理，它能使虚拟机系统回到原先某个正常运行的状态。</p><p>在选项“虚拟机”下的“快照”处使用快照。</p><p>调分辨率：xrandr -s 1</p><hr><h3 id="共享文件夹"><a href="#共享文件夹" class="headerlink" title="共享文件夹"></a>共享文件夹</h3><p>在vmWare的“虚拟机”选项中设置共享的文件夹在主机中的路径，设置好后，可以在centos的主文件夹——其他位置——计算机——mnt——hgfs下找到共享的文件。</p><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>因为linux服务器是开发小组共享，正式上线的项目是运行在公网的。因此程序员需要远程登录到Liux进行项目管理或者开发。</p><blockquote><p>远程登录客户端：可以用Xshell</p><p>远程传输文件：可以用Xftp</p><p>其他工具大同小异。</p></blockquote><h1 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h1><p>linux的文件系统是采用<strong>级层式</strong>的&#x3D;&#x3D;树状目录结构&#x3D;&#x3D;，在此结构中的最上层是根目录 “ &#x3D;&#x3D;&#x2F;&#x3D;&#x3D; ”，然后在此目录下再创建其他的目录。</p><blockquote><p>在linux中，一切皆文件。</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204081725703.png" alt="image-20220408172505611"></p><hr><p><strong>具体目录结构：</strong></p><ul><li><p>&#x2F;bin【常用】 (&#x2F;usr&#x2F;bin &#x2F;usr&#x2F;local&#x2F;bin)<br>是Binary [ˈbaɪnəri] (二进制) 的缩写，这个目录存放着最经常使用的命令。</p></li><li><p>&#x2F;sbin               (&#x2F;usr&#x2F;sbin &#x2F;usr&#x2F;local&#x2F;sbin)<br>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。</p></li><li><p>home【常用】<br>存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名。</p></li><li><p>&#x2F;root【常用】<br>该目录为系统管理员，也称作超级权限者的用户主目录。</p></li><li><p>&#x2F;Iib</p><p>系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</p></li><li><p>&#x2F;Iost+found</p><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p></li><li><p>&#x2F;etc【常用】<br>所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库 my.conf。</p></li><li><p>&#x2F;usr【常用】<br>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。</p></li><li><p>&#x2F;boot【常用】</p><p>存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件。</p></li><li><p>&#x2F;proc【不能动】 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p></li><li><p>&#x2F;srv【不能动】service缩写，该目录存放一些服务启动之后需要提取的数据。</p></li><li><p>&#x2F;sys【不能动】这是liux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs&#x3D;》【别动】</p></li><li><p>&#x2F;tmp      这个目录是用来存放一些临时文件的。</p></li><li><p>&#x2F;dev<br>类似于windows的设备管理器，把所有的硬件用文件的形式存储。</p></li><li><p>&#x2F;media【常用】</p><p>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p></li><li><p>&#x2F;mnt 【常用】系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在&#x2F;mnt&#x2F;上，然后进入该目录就可以查看里的内容了。 如：和主机的共享文件夹。</p></li><li><p>&#x2F;opt<br>这是给主机额外安装软件所存放的目录。如安装 oracle数据库就可放到该目录下。默认为空。</p></li><li><p>&#x2F;usr&#x2F;local【常用】<br>这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。</p></li><li><p>&#x2F;var 【常用】<br>这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p></li><li><p>selinux [security-enhanced linux]<br>SELinux 是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置。</p></li></ul><h1 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h1><p>linux内置 vim文本编辑器，具有程序编辑能力。</p><p><strong>三种模式：</strong></p><ul><li><strong>一般模式</strong>：用vim打开文档时直接进入的是一般模式，可以使用 [上下左右]键来移动光标，用 [删除字符]或 [删除整行] 来处理文档，也可以使用复制粘贴。</li><li><strong>编辑模式</strong>：按下 i，o，a，r任意字母之后可以进入编辑模式。一般都是按 i 键。</li><li><strong>命令行模式</strong>：在一般模式下输入 ：或 &#x2F; 后可进入，在此模式下，可以使用相关指令：读取、存盘、替换、离开vim、显示行号等。</li></ul><p><strong>模式间的切换：</strong></p><blockquote><p>命令行下： # &#x3D;&#x3D;vim&#x3D;&#x3D; xxx 进入一般模式</p><p>一般模式下： &#x3D;&#x3D;i&#x3D;&#x3D; 进入编辑模式， &#x3D;&#x3D;:&#x3D;&#x3D; 或 &#x3D;&#x3D;&#x2F;&#x3D;&#x3D; 进入命令行模式</p><p>编辑模式和命令行模式下： 按&#x3D;&#x3D;esc&#x3D;&#x3D;退出到一般模式</p><p>命令行模式下： &#x3D;&#x3D;wq&#x3D;&#x3D; 保存退出，q 退出 ，q！强制退出，不保存</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204082035048.png" alt="image-20220408203535866"></p><hr><h3 id="vim快捷键"><a href="#vim快捷键" class="headerlink" title="vim快捷键"></a>vim快捷键</h3><p>在一般模式下：</p><p>拷贝当前行：<strong>yy</strong>， 如果要拷贝当前向下的5行，则 5yy，然后粘贴（输入p）；</p><p>删除当前行：<strong>dd</strong>，如果要删除当前向下的5行，则 5dd；</p><p>撤销： <strong>u</strong></p><p>定位到文档的末行和首行： <strong>G</strong> 到末行， <strong>gg</strong> 到首行；</p><p>定位到文档的某一行：先输入 <strong>行号</strong>，再按 <strong>shift + g</strong></p><hr><p>在命令行模式下：</p><p>查找： <strong>&#x2F;关键字</strong> ，然后按回车查找，按n查找下一个</p><p>设置文件的行号： <strong>:set nu</strong></p><p>取消文件的行号： <strong>:set nonu</strong></p><hr><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204082049378.png" alt="image-20220408204927118"></p><h1 id="Linux指令"><a href="#Linux指令" class="headerlink" title="Linux指令"></a>Linux指令</h1><blockquote><p>在命令末尾或sql语句末尾加上  &#x3D;&#x3D;&#x2F;G&#x3D;&#x3D;，表示将显示结果按行打印，提高显示效果。</p><p>运行文件时，末尾加“&amp;”，表示后台运行，如：.&#x2F;hello.java &amp;</p></blockquote><h3 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机&amp;重启"></a>关机&amp;重启</h3><p>立即关机： shutdown -h now  或  halt</p><p>立即重启：shutdown -r now  或  reboot</p><p>一分钟后关机： shutdown -h 1  </p><p>将内存的数据同步到磁盘：sync</p><blockquote><p>关机和重启的命令执行前，默认会执行一次同步命令sync。</p></blockquote><hr><h3 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h3><p>切换用户(可以切换到管理员身份)： su - 用户名</p><p>注销用户&#x2F;退出登录&#x2F;返回原来用户：logout </p><blockquote><p>由于系统管理员有最大权限，为避免误操作，平时登录时尽量少用root账号登录。可以先登录普通用户，再用“su - 用户名”切换管理员身份；</p><p>logout 只能在提示符下使用，在图形运行终端处 和 运行级别3以下 使用无效。</p></blockquote><hr><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>添加用户： useradd 用户名</p><blockquote><p>当创建用户成功后，会自动在home目录下创建和用户同名的家目录，也可以通过 “ useradd -d 指定目录 新用户名” 在创建新用户时指定 家目录。</p></blockquote><p>修改密码：passwd 用户名</p><blockquote><p>注意：如果用户名中有大写字母的话，在输入命令，要换成小写。</p></blockquote><p>删除用户： userdel 用户名</p><blockquote><p>” userdel 用户名“会保留家目录，如果要删除用户及其用户主目录，用 ”userdel -r 用户名“</p></blockquote><p>查询用户信息： id 用户名</p><p>查看当前用户：whoami </p><p>查看登录用户：who am i</p><blockquote><p>用户组：系统可以将 拥有共性&#x2F;权限的多个用户进行分组，以方便进行管理。</p></blockquote><p>新增组：groupadd 组名</p><p>删除组：groupdel 组名</p><p>新增用户时直接加入组：useradd -g 用户组 用户名</p><p>修改用户的组别：usermod -g 用户组 用户名</p><blockquote><p>用户 和 组 的相关文件：</p><ul><li><p>&#x2F;etc&#x2F;passwd  ——  用户user的配置文件，记录用户的各种信息；</p><p>每行的含义：用户名：口令：用户标识号：组标识号：注释性描述：主目录：登录Shell</p><p>如：valcanozz : x:1000:1000:ValcanoZz:&#x2F;home&#x2F;valcanozz:&#x2F;bin&#x2F;bash</p></li><li><p>&#x2F;etc&#x2F;shadow  —— 口令的配置文件</p><p>每行的含义：登录名：加密口令：最后一次修改时间：最小时间间隔：最大时间间隔：警告时间：不活动时间：失效时间：标志</p></li><li><p>&#x2F;etc&#x2F;group  —— 组group的配置文件，记录Linux包含的组的信息；</p><p>每行的含义：组名：口令：组标识号：组内用户列表</p></li></ul></blockquote><hr><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><p>切换运行级别： init  [0123456]</p><p>显示默认运行级别：systemctl  get-default</p><blockquote><p>运行级别：</p><p>0: 关机<br>1: 单用户【找回丢失密码】，root权限，用于系统维护，禁止远程登录<br>2: 多用户状态，没有网络服务<br>3: 完全的多用户状态，有网络服务，无界面<br>4: 系统未使用，保留给用户<br>5: 图形界面<br>6: 系统重启<br>常用运行级别是3和5，也可以指定默认运行级别。</p><p>设置默认运行级别：systemctl set-default 运行级别；  如：systemctl  set-default  multi-user.target 切换默认级别为3；</p><table><thead><tr><th>init级别</th><th>systemctl target</th></tr></thead><tbody><tr><td>0</td><td>shutdown.target</td></tr><tr><td>1</td><td>emergency.target</td></tr><tr><td>2</td><td>rescure.target</td></tr><tr><td>3</td><td>multi-user.target</td></tr><tr><td>4</td><td>无</td></tr><tr><td>5</td><td>graphical.target</td></tr><tr><td>6</td><td>无</td></tr></tbody></table></blockquote><hr><p><strong>开机流程：</strong></p><p>开机 —— BIOS —— &#x2F;boot —— systemd进程1 —— 运行级别 —— 运行级对应的服务</p><hr><h3 id="帮助指令"><a href="#帮助指令" class="headerlink" title="帮助指令"></a>帮助指令</h3><p>获取帮助信息： man 命令或配置文件，如：man ls 查看ls命令的帮助信息；</p><blockquote><p>man可以获取 命令的使用说明，是中文文档，在man下，按空格显示下一页，按q退出</p></blockquote><p>获取shell内置命令的帮助信息：help 命令</p><blockquote><p>显示出的是英文文档。</p></blockquote><hr><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p>显示当前工作目录的绝对路径：pwd</p><p>显示当前目录下的文件： ls</p><p>显示指定目录下的文件： ls  目录路径</p><ul><li>ls的常用选项： -a 显示所有文件包括隐藏文件，-l 以列表形式显示信息</li></ul><p>切换目录： cd  路径</p><ul><li>cd 的常用法：<ul><li>cd~ 或cd： —— 回到自己的家目录，比如你是root, 则cd~ 就是到 &#x2F;root</li><li>cd..   —— 回到上一级目录</li></ul></li></ul><blockquote><p>在linux下，隐藏文件是以 . 开头；</p><p>命令的选项可以组合使用，比如 ls -a 和 ls -l 可以组合：ls -al 或 ls -la</p></blockquote><p>创建目录： mkdir  新目录名</p><ul><li>mkdir常用选项： -p  创建多级目录（没加-p就只能创建一级目录）<ul><li>如：mkdir  &#x2F;home&#x2F;dog<br>    mkdir  -p   &#x2F;home&#x2F;animal&#x2F;tiger</li></ul></li></ul><p>删除空目录：rmdir  空目录</p><p>删除非空目录： rmdir  -rf  目录</p><p>创建空文件：touch 文件名</p><p>拷贝文件： cp  源文件  目标文件(夹)</p><p>拷贝整个文件夹： cp  -r  源文件夹  目标文件夹</p><blockquote><p>如果想强制覆盖不提示，可以在cp命令前加”\“ ，如：\cp  -r  &#x2F;home&#x2F;hello.txt  &#x2F;opt</p></blockquote><p>删除文件或目录：rm  文件或目录名</p><ul><li>常用选项： -r   递归删除整个文件夹 ； -f  强制删除不提示</li></ul><p>文件重命名：mv  旧文件名  新文件名</p><p>文件移动：mv  旧文件路径  新文件路径</p><p>查看文件：cat  文件名</p><ul><li>常用选项： -n  显示行号</li></ul><blockquote><p>cat 命令只能浏览文件，不能修改文件；</p><p>一般为了浏览方便，会带上管道命令： |  ，管道命令就是将上一个命令的结果交给下一个命令处理，如： car -n &#x2F;etc&#x2F;profile | more，就是将查看文件的内容 用more命令查看</p></blockquote><p>more指令：是一个基于VI编辑器的文本过滤器，它以按页方式显示文本内容；</p><ul><li><p>语法：more  文件名</p></li><li><p>more模式下的按键：</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>空格</td><td>向下翻一页</td></tr><tr><td>回车</td><td>向下翻一行</td></tr><tr><td>q</td><td>离开more</td></tr><tr><td>Ctrl + F</td><td>向下滚动一个屏幕</td></tr><tr><td>Ctrl + B</td><td>返回上一屏幕</td></tr><tr><td>&#x3D;</td><td>输出当前行的行号</td></tr><tr><td>:f</td><td>输出文件名和当前行号</td></tr></tbody></table></li></ul><p>less指令：采用分屏方式查看文件内容，功能与more类似，但比more更强大，支持各种终端。</p><ul><li><p>语法：less  文件名</p></li><li><p>less模式下的按键：</p><table><thead><tr><th>操作</th><th>说明</th></tr></thead><tbody><tr><td>空格 或 [pagedown]</td><td>向下翻一页</td></tr><tr><td>[pageup]</td><td>向上翻一页</td></tr><tr><td>&#x2F;字串</td><td>向下搜索 字串，n：向下找，N：向上找</td></tr><tr><td>?字串</td><td>向上搜索 字串，n：向下找，N：向上找</td></tr><tr><td>q</td><td>离开less</td></tr></tbody></table></li></ul><p>输出内容到控制台： echo  内容   （内容可以是环境变量，如 $PATH，$HOSTNAME）</p><p>显示文件开头内容： head 文件名</p><ul><li>默认显示头10行，使用 head -n  5 文件名 ，可以显示头5行。</li></ul><p>显示文件末尾内容：tail  文件</p><ul><li>默认显示末10行，使用 tail -n 5 文件名，可以显示末5行，  </li><li>tail -f  文件名，可以实时监控文件。</li></ul><p>.   &gt;指令 和 &gt;&gt; 指令</p><ul><li><p>前者是覆盖，后者是追加</p><p>如：</p><p>ls  -l  &gt;  文件(将列表的内容写入文件a.txt中（覆盖写））<br>ls  -al  &gt;&gt;  文件(将列表的内容追加到文件aa.txt的末尾)<br>cat  文件1  &gt;  文件2(将文件1的内容覆盖到文件2)<br>echo  “内容”  &gt;&gt;  文件（追加）</p></li></ul><p>软链接： ln  -s  原文件或目录  软链接名  ，如： ln  -s  &#x2F;root  &#x2F;home&#x2F;myroot   在&#x2F;home下创建一个软链接，指向&#x2F;root；</p><p>查看历史命令： history</p><ul><li>查看最近的10条命令：history  10； 执行历史编号为5的命令： !5</li></ul><hr><h3 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h3><p>显示日期：</p><p>date显示当前时间<br>date +%Y显示当前年份<br>date +%m显示当前月份<br>date +%d显示当前是哪一大<br>date “+%Y-%m-%d%H:%M:%S”显示年月日时分秒</p><p>设置日期： date  -s  字符串时间  ，如：date  -s  “2022-04-09 18:54:10”</p><p>查看当月日历：cal         查看2020年日历：cal  2020</p><hr><h3 id="搜索查找"><a href="#搜索查找" class="headerlink" title="搜索查找"></a>搜索查找</h3><p>查看ip ： ifconfig </p><p>查找指定文件： find   目录范围  选项 [ -option ] [ -exec  命令  {}  \ ]</p><blockquote><p> -exec  命令  {}  \  表示要对找到的文件进行的操作</p></blockquote><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-name  …</td><td>查找指定文件名</td></tr><tr><td>-user  …</td><td>查找属于某用户的所有文件</td></tr><tr><td>-size  …</td><td>按照指定文件大小查找</td></tr><tr><td>-atime …</td><td>填 +n 表示超过 n 天被读取过的文件， -n 表示 n天内被读取过的文件 （-ctime 文件创建时间   -mtime  文件修改时间）</td></tr></tbody></table><blockquote><p>如：</p><p>按文件名：根据名称查找&#x2F;home目录下的hello.txt文件——  find  &#x2F;home  -name  hello.txt<br>按拥有者：查找&#x2F;opt目录下，用户名称为nobody的文件—— find  &#x2F;opt  -user  nobody<br>查找整个liux系统下大于200M的文件(+n大于n小于n等于，单位有k,M,G)—— find  &#x2F;-size  +200M</p></blockquote><p>基于数据库查询文件： locate  文件</p><p>由于locate指令基于数据库进行查询，所以第一次运行前，需 使用 updatedb 指令创建 locate数据库。</p><blockquote><p>locate指令可以快速定位文件路径。locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。</p><p>Locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻</p></blockquote><p>查看指令在哪个目录下： which  指令</p><p>过滤查找：grep  [选项]  查找内容  源文件</p><ul><li>-n   显示匹配行及行号</li><li>-i   忽略字母大小写</li></ul><blockquote><p>如：在hello.txt文件中，查找”yes”所在行，并且显示行号<br>写法1: cat  &#x2F;home&#x2F;hello.txt  |  grep  -n  “yes”<br>写法2: grep  -n  “yes”  home&#x2F;hello.txt</p></blockquote><p>注：grep后的查找内容 支持正则表达式，如 ls -l &#x2F;opt | grep “^d”   表示查看&#x2F;opt文件夹下 的目录，”^d”表示以d开头。</p><hr><h3 id="压缩解压"><a href="#压缩解压" class="headerlink" title="压缩解压"></a>压缩解压</h3><p>将文件压缩为 .gz文件： gzip  文件</p><p>解压缩 .gz文件： gunzip  文件.gz</p><p>压缩文件或目录： zip  [选项]   xxx.zip   文件或目录</p><ul><li>-r   递归压缩，即压缩目录</li></ul><p>解压缩文件： unzip  [选项]  压缩文件</p><ul><li>-d  目录      —— 指定解压后文件的存放目录</li></ul><p>打包文件： tar  [选项]   xxx.tar.gz  打包的内容</p><ul><li>-c产生.tar打包文件</li><li>-v    显示详细信息</li><li>-f    指定压缩后的文件名</li><li>-z    打包同时压缩</li><li>-x    解包 .tar文件</li></ul><blockquote><p>如：</p><p>压缩多个文件，将&#x2F;home&#x2F;pig.txt和&#x2F;home&#x2F;cat.txt压缩成pc.tar.gz<br>    tar  -zcvf   pc.tar.gz  &#x2F;home&#x2F;pig.txt   &#x2F;home&#x2F;cat.txt</p><p>将home的文件夹压缩成myhome.tar.gz<br>    tar  -zcvf   myhome.tar.gz   &#x2F;home&#x2F;</p><p>将pc.tar.gz 解压到当前目录<br>    tar  -zxvf   pc.tar.gz</p><p>将myhome.tar.gz解压到&#x2F;opt&#x2F;tmp2目录下<br>    tar  -zxvf   &#x2F;home&#x2F;myhome.tar.gz-C   &#x2F;opt&#x2F;tmp2</p></blockquote><h1 id="组管理-和-权限管理"><a href="#组管理-和-权限管理" class="headerlink" title="组管理 和 权限管理"></a>组管理 和 权限管理</h1><p>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有 所有者、所在组、其它组的概念。</p><ul><li><p>所有者</p><p>一般是指 文件的创建者，谁创建了该文件，就自然的成为该文件的所有者。</p><ul><li><p>查看所有文件的所有者： ls  -ahl</p></li><li><p>修改文件所有者： chown  用户名[:所在组]  文件名  （-r  如果是目录，则使其下的子文件和目录递归生效）</p></li></ul></li><li><p>所在组</p><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组（默认）。</p><ul><li><p>修改文件&#x2F;目录 所在的组： chgrp  组名  文件名</p></li><li><p>新增组：groupadd 组名</p></li><li><p>删除组：groupdel 组名</p></li><li><p>新增用户时直接加入组：useradd -g 用户组 用户名</p></li><li><p>修改用户的组别：usermod -g 用户组 用户名</p></li></ul></li><li><p>其他组</p><p>除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组。</p></li></ul><blockquote><p>在root用户下，可以改变用户的组别：</p><p>usermod  -g  新组名  用户名<br>usermod  -d  目录名  用户名   ——  改变该用户登陆的初始目录。说明：用户需要有进入到新目录的权限。</p></blockquote><p><strong>权限：</strong></p><p>使用 ls -l 显示出的信息首部，有  -rwxrw-r–.  类似的列表，它代表不同不同用户对该文件的 权限。</p><ul><li><ul><li>r  代表可读（read），</li><li>w 代表可写 (修改文件，或该目录内创建删除重命名目录)， </li><li>x 代表可执行 (执行文件，或进入目录）；</li></ul></li><li>权限列表 0~9位：<ul><li>第0位：确定文件类型—— l 是链接，d 是目录 ， c 是 字符设备文件, 如鼠标,键盘，b 是块设备, 如硬盘，- 是普通文件，</li><li>第1~3位： 所有者的权限</li><li>第4~6位：所属组的权限（和所有者同一组的其他用户）</li><li>第7~9位：其他组的用户的权限</li></ul></li></ul><blockquote><p>-rw-r–r–.  1  root  root  143  4月  8  21:22  hello.java</p><p>分别代表的含义： 权限  (文件)硬链接数&#x2F;(目录)子目录数  用户名  组名  文件&#x2F;目录大小   最后修改日期   文件名</p></blockquote><ul><li><p><strong>修改权限</strong>： chmod</p><ul><li><p>通过 + - &#x3D; 变更权限：</p><p>chmod   u&#x3D;rwx,g&#x3D;rw,o&#x3D;x文件目录名</p><p>chmod   o+w文件目录名</p><p>chmod   a-x文件目录名</p><blockquote><p>u: 所有者g：所有组o：其他人a：所有人（u，g，o的总和）</p></blockquote></li><li><p>通过 数字变更权限：</p><p>chmod   751   文件目录名</p><p>相当于  chmod   u&#x3D;rwx,g&#x3D;rw,o&#x3D;x文件目录名</p><blockquote><p>r &#x3D; 4，w &#x3D; 2， x &#x3D; 1， 所以rwx &#x3D; 4+2+1 &#x3D; 7，rx &#x3D; 4 + 1 &#x3D; 5</p></blockquote></li></ul></li></ul><h1 id="定时任务调度"><a href="#定时任务调度" class="headerlink" title="定时任务调度"></a>定时任务调度</h1><p>任务调度：是指系统在某个时间执行的特定的命令或程序。</p><p>任务调度分类：</p><ul><li>系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等；</li><li>个别用户工作：个别用户可能希望执行某些程序，比如对 mysql数据库的备份；</li></ul><p>指令：&#x3D;&#x3D;crontab  [选项]&#x3D;&#x3D;</p><ul><li>-e编辑定时任务</li><li>-l     查询crontab任务</li><li>-r     删除当前用户所有的crontab任务（终止任务调度）</li><li>service crond restart   重启任务调度</li></ul><blockquote><p>执行  crontab -e  ，进入任务编辑界面；</p><p>输入任务，如： *&#x2F;2 * * * *  ls -l  &#x2F;etc&#x2F;  &#x2F;tmp&#x2F;to.txt<br>意思是：每2分钟执行一次 ls -l  &#x2F;etc&#x2F;  &#x2F;tmp&#x2F;to.txt</p></blockquote><p>定时用的 五个 * 占位符：</p><table><thead><tr><th></th><th>含义</th><th>范围</th></tr></thead><tbody><tr><td>第一个 *</td><td>一小时中的第几分钟</td><td>0~59</td></tr><tr><td>第二个 *</td><td>一天中的第几小时</td><td>0~23</td></tr><tr><td>第三个 *</td><td>一月中的第几天</td><td>1~31</td></tr><tr><td>第四个 *</td><td>一年中的第几月</td><td>1~12</td></tr><tr><td>第五个 *</td><td>一周中的星期几</td><td>0~7 (0和7都是周日)</td></tr></tbody></table><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>代表每个单位时间，如第一个*指一小时的每分钟都执行一次</td></tr><tr><td>，</td><td>代表不连续时间，如“0 8,12,16 * * * 命令” 指每天的8点，12点，16点都执行一次命令</td></tr><tr><td>-</td><td>代表连续时间，如“0 5 * * 1-6 命令” 指周一到周六的5点0分执行都执行一次命令</td></tr><tr><td>*&#x2F;n</td><td>代表间隔多久执行一次</td></tr></tbody></table><hr><p>指令：&#x3D;&#x3D;at [选项] [时间]&#x3D;&#x3D;    一次性定时计划任务</p><blockquote><p>at的守护进程std会在后台运行，检查作业队列来运行；</p><p>默认情况下，atd守护进程每60秒检查作业队列。</p><p>在使用at命令时，一定要保证atd进程的启动，使用 ps -ef | grep atd  检测atd是否在运行。</p><p>按下Crel + D 结束at命令的输入</p><p>atrm  4   将编号为4的任务删除</p><p>atq   查看at任务</p></blockquote><p>选项：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>当指定任务完成，将给用户发送邮件</td></tr><tr><td>-I  （是大写i )</td><td>atq的别名</td></tr><tr><td>-d</td><td>atrm的别名</td></tr><tr><td>-v</td><td>显示任务将被执行的时间</td></tr><tr><td>-c</td><td>打印任务的内容到标准输出</td></tr><tr><td>-V</td><td>显示版本信息</td></tr><tr><td>-q 队列</td><td>使用指定的队列</td></tr><tr><td>-f  文件</td><td>从指定文件读入任务，而不是从标准输入读入</td></tr><tr><td>-t  时间参数</td><td>以时间参数的形式提交要运行的任务</td></tr></tbody></table><blockquote><p>at 的时间定义：</p><ul><li>当天的时间：  hh:mm，如果时间过去了，就放到第二天执行；</li><li>12小时计时，后加am或pm，如11pm；</li><li>具体日期： yy-mm-dd  或 mm&#x2F;dd&#x2F;yy  或  dd.mm,yy，如：04:00 2022-03-1；</li><li>相对计时法，格式为： now + 时间单位；</li><li>直接用 today ，tomorrow 来指定时间；</li></ul><p>例：</p><ul><li><p>2天后的下午5点执行&#x2F;bin&#x2F;1 s &#x2F;home<br>#at  5pm  + 2 days<br>at&gt; &#x2F;bin&#x2F;ls  &#x2F;home</p></li><li><p>明天17点钟，输出时间到指定文件内  比如root&#x2F;datel100.log<br>#at  5pm  tomorrow<br>at&gt; data &gt; &#x2F;root&#x2F;date100.log</p></li><li><p>2分钟后，输出时间到指定文件内比如root&#x2F;date200.log<br>#at  now  + 2  minutes<br>at&gt; data &gt; &#x2F;root&#x2F;date200.log</p></li></ul></blockquote><h1 id="磁盘分区、挂载"><a href="#磁盘分区、挂载" class="headerlink" title="磁盘分区、挂载"></a>磁盘分区、挂载</h1><p>linux中，硬盘的分区需要挂载到 目录才能使用，这种处理方式叫“载入”，使一个分区和一个目录联系起来。</p><p>Linux硬盘分为 IDE 和 SCSI 两种，目前基本都用SCSI硬盘；</p><ul><li><p>IDE硬盘：</p><p>驱动器标识符为“hdx~”</p><ul><li>“hd” 表示分区所在的设备为IDE硬盘；</li><li>“x”为盘号：a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘；</li><li>“~” 代表分区，用数字表示，前4个分区为主分区或拓展分区，从5开始是逻辑分区；</li></ul></li><li><p>SCSI硬盘：</p><p>驱动器标识符为“sdx~”</p><ul><li>“sd” 表示分区所在的设备为IDE硬盘；</li><li>“x”为盘号：a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘；</li><li>“~” 代表分区，用数字表示，前4个分区为主分区或拓展分区，从5开始是逻辑分区；</li></ul></li></ul><p>相关指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看设备挂载情况</span><br><span class="line">lsblk</span><br><span class="line">lsblk -f</span><br><span class="line">// 查看系统整体磁盘使用情况</span><br><span class="line">df -h</span><br><span class="line">//查看指定目录的磁盘使用情况</span><br><span class="line">du -h 目录</span><br><span class="line">选项: </span><br><span class="line">-s指定目录占用大小汇总</span><br><span class="line">-h带计量单位</span><br><span class="line">-a含文件</span><br><span class="line">-max-depth=l子目录深度</span><br><span class="line">-c列出明细的同时，增加汇总值</span><br><span class="line">如: du -hac --max-depth=1 /opt</span><br></pre></td></tr></table></figure><h1 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h1><p>windows中查看网络配置：ipconfig</p><p>linux中查看网络配置：ifconfig</p><p>测试主机间网络连通性： ping  目的主机</p><hr><p>将主机的ip修改为静态ip：</p><ul><li><p>进入配置文件：vi  &#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</p></li><li><p>修改文件：</p><p>BOOTPROTO&#x3D;static#[none|static |bootp|dhcp] (引导时不使用协议|静态分配IP|BOOTP协议|DHCP协议)<br>IPADDR&#x3D;192.168.205.129#指定ip地址<br>GATEWAY&#x3D;192.168.205.2#网关<br>DNS1&#x3D;192.168.205.2#域名解析器</p></li><li><p>修改VMware的虚拟网络编辑器</p></li><li><p>重启网络服务：service network restart</p></li></ul><hr><p>查看主机名：hostname</p><p>修改主机名文件： vim  &#x2F;etc&#x2F;hostname修改后重启生效</p><p>设置hosts映射（可以通过别名代替ip地址）：</p><ul><li>windows：在 C:\Windows\System32\drivers\etc\hosts 指定即可；</li><li>linux：在 &#x2F;etc&#x2F;hosts  文件指定</li></ul><blockquote><p>主机名解析机制：</p><ul><li>浏览器先检查浏览器缓存中有没有该域名解析P地址，有就先调用这个IP完成解析；如果没有，就检查DNS解析器缓存，如果有直接返回P完成解析。这两个缓存，可以理解为本地解析器缓存。<ul><li>一般来说，当电脑第一次成功访问某一网站后，在一定时间内，浏览器或操作系统会缓存他的IP地址（DNS解析记<br>录）。如在cmd窗口中输入<br>ipconfig &#x2F;displaydns &#x2F;&#x2F;DNS域名解析缓存<br>ipconfig &#x2F;flushdns&#x2F;&#x2F;手动清理dns缓存</li></ul></li><li>如果本地解析器缓存没有找到对应映射，检查系统中hosts文件中有没有配置对应的域名IP映射，如果有，则完成解析并返回。</li><li>如果本地DNS解析器缓存和hosts文件中均没有找到对应的IP,则到域名服务DNS进行解析域</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204120936007.png" alt="image-20220412093654757"></p></blockquote><h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><p>在LINUX中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号 (pid,进程号)。</p><blockquote><p>程序是可运行的代码，是静态的，进程是已经运行在内存中，是动态的；</p><p>每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。</p><p>一般系统的服务都是以后台进程的方式存在，而且都会常驻在系统中。直到关机才才结束。</p></blockquote><p><strong>查看进程：  ps  [选项]</strong></p><ul><li>ps -a显示当前终端的所有进程信息</li><li>ps -u        以用户的格式显示进程信息</li><li>ps -x        显示后台进程运行的参数</li><li>如：ps  -aux  |  grep  xxx</li></ul><blockquote><p>ps显示字段说明：</p><ul><li>System V展示风格</li><li>USER：用户名称</li><li>PID：进程号</li><li>%CPU：进程占用CPU的百分比</li><li>%MEM：进程占用物理内存的百分比</li><li>VSZ：进程占用的虚拟内存大小(单位：KB)</li><li>RSS：进程占用的物理内存大小(单位：KB)</li><li>TT：终端名称，缩写</li><li>STAT：进程状态，其中S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等</li><li>START：进程的启动时间</li><li>TIME：CPU时间，即进程使用CPU的总时间</li><li>COMMAND：启动进程所用的命令和参数，如果过长会被截断显示</li></ul></blockquote><p><strong>终止进程：</strong></p><ul><li><strong>kill  [选项]  进程号</strong>通过进程号杀死&#x2F;终止进程<ul><li>-9       表示强迫进程立即停止</li></ul></li><li><strong>killall    进程名称</strong>           通过进程名称杀死进程，也支持通配符(这在系统因负载过大而变得很慢时很有用)</li></ul><blockquote><p>如：</p><p>终止远程登录服务sshd： kill  sshd对应的进程号；</p><p>再次启动sshd服务：&#x2F;bin&#x2F;systemctl  start  sshd.service</p></blockquote><p><strong>查看进程树：pstree   [选项]</strong>       （-p：显示pid， -u：显示所属用户）</p><hr><h3 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h3><p>服务(service)<strong>本质就是进程</strong>，但是服务是运行在<strong>后台</strong>的，通常都会监听某个端口，等待其它程序的请求，比如（mysqld,sshd,防火墙等），因此又被称为<strong>守护进程</strong>。</p><p><strong>service管理指令： servicce  服务名   [start|stop|restart|reload|status]</strong></p><blockquote><p>在CentOS7.0之后，很多服务不再使用service，而是改为systemctl；</p><p>现在还在使用service指令的服务，可以在 &#x2F;etc&#x2F;init.d 查看，有：functions，netconsole，network，README，vmware-tools</p><p>例：  service  network  status   查看网络服务状态</p></blockquote><p><strong>查看服务名：</strong> 输入 setup ，然后选择“系统服务” 即可查看全部服务。</p><p>服务的运行级别</p><p><strong>给不同运行级别设置自启动的服务：</strong> chkconfig</p><ul><li><strong>查看服务：chkconfig  –list</strong> </li><li><strong>修改自启动&#x2F;关闭：chkconfig  –level  5  服务名  on&#x2F;off</strong></li></ul><blockquote><p>chkconfig重新设置后，要重启才生效。</p><p>在CentOS7.0之后，很多服务改为systemctl进行管理，chkconfig管理的范围和service一样[?]；</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204121119405.png" alt="image-20220412111942205"></p><hr><p><strong>systemctl 管理指令：</strong></p><p>语法： <strong>systemctl  [start|stop|restart|status]  服务名</strong></p><p>查看ysytemctl管理的范围：在 &#x2F;usr&#x2F;lib&#x2F;systemd&#x2F;system中查看 </p><ul><li>查看服务的自启动状态： systemctl list-unit-files </li><li>设置服务开机启动&#x2F;关闭：systemctl enable&#x2F;disable 服务名</li><li>查看服务是否是自启动：systemctl  is-enabled 服务名</li></ul><blockquote><p>systemctl  start&#x2F;stop  服务名   只是当前生效，重启后仍按设置来；</p><p>想要自启动 永久生效，要更改设置，即systemctl enable&#x2F;disable 服务名</p></blockquote><hr><p><strong>设置防火墙：firewall指令</strong></p><ul><li><p>打开端口：firewall-cmd  –permanent  –add-port&#x3D;端口号&#x2F;协议</p></li><li><p>关闭端口：firewall-cmd  –permanent  –remove-port&#x3D;端口号&#x2F;协议</p></li><li><p>重新载入防火墙，使设置生效：firewall-cmd  –reload</p></li><li><p>查询端口是否生效：firewall-cmd  -query-port&#x3D;端口&#x2F;协议</p></li></ul><p>**动态监控进程： top [选项] **</p><ul><li>-d  秒数      指定top命令每隔几秒更新，默认是3秒；</li><li>-i                 使top不显示闲置和僵死的进程；</li><li>-p                通过指定ID来监控某个进程的状态；</li></ul><p>top界面交互：</p><ul><li>P    以CPU使用率排序，默认；</li><li>M    以内存使用率排序；</li><li>N    以PID排序；</li><li>u     再输入用户名，监控指定用户的进程；</li><li>k     再输入进程ID号，结束进程；</li><li>q    退出top</li></ul><p><strong>监控网络状态： netstat  [选项]</strong></p><ul><li>-an     按一定顺序排列输出；</li><li>-p     显示哪个进程在调用；</li></ul><p><strong>检测主机连接命令： ping  对方ip</strong></p><h1 id="RPM与YUM"><a href="#RPM与YUM" class="headerlink" title="RPM与YUM"></a>RPM与YUM</h1><p>RPM</p><p>rpm用于互联网下载包的打包及安装工具，它包含在某些Linux分发版中。它生成具有 .RPM扩展名的文件。RPM是RedHat Package Manager (RedHat软件包管理工具) 的缩写，类似windows的setup.exe,这一文件格式名称虽然打上了RedHat的标志，但理念是通用的。<br>Linux的分发版本都有采用(suse,redhat,.centos等等)，可以算是公认的行业标准。</p><blockquote><p>rpm包名格式：</p><p>firefox-60.2.2-1.el7.centos.x86 64</p><ul><li>名称：firefox</li><li>版本号：60.2.2-1</li><li>使用操作系统：el7.centos.x86 64</li></ul></blockquote><p>指令：</p><ul><li>查询已安装的rpm列表： rpm  -qa | grep  xxx</li><li>查询软件包是否安装：rpm   -q   软件名</li><li>查询软件包信息： rpm   -qi   软件名</li><li>查询软件包中的文件：rpm  -ql   软件名</li><li>查询文件所属的软件包：rpm  -qf   目录&#x2F;文件</li><li>卸载软件包：rpm  -e   软件名<ul><li>如果其他软件依赖于将要删除的软件包，则卸载时会产生错误信息，可以加上参数 –nodeps  来强制删除，一般不推荐这么做。</li></ul></li><li>安装rpm包： rpm  -ivh   rpm包全路径名<ul><li>i    install 安装</li><li>v    verbose 提示</li><li>h    hash 进度条</li></ul></li></ul><hr><p>yum</p><p>Yum是一个Shell前端软件包管理器。基于RPM包管理，能够从指定的服务器自动<br>下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。</p><p>指令：</p><ul><li><p>查询yum服务器是否有需要安装的软件：yum list | grep  软件名</p></li><li><p>安装yum包： yum install  xxxx</p></li></ul><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><blockquote><p>需求：</p><p>Linuxi运维工程师在进行服务器集群管理时，需要编写Shell程序来进行服务器管理。<br>对于JavaEE和Python程序员来说，工作的需要，可能需要编写一些Shell脚本进行程序或者服务器的维护，比如编写一个定时备份数据库的脚本。<br>对于大数据程序员来说，需要编写Shell程序来管理集群。</p></blockquote><p>Shel是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Sheel来启动、挂起、停止甚至是编写一些程序。</p><p>脚本格式要求:</p><ul><li>脚本以  &#x3D;&#x3D;#!&#x2F;bin&#x2F;bash&#x3D;&#x3D;  开头</li></ul><p>执行：</p><p>方式1 不用权限，直接用sh命令执行文件： sh  xxx.sh</p><p>方式2  需要权限，使用绝对或相对路径执行： .&#x2F;xxx.sh</p><blockquote><p>权限不够，可用 chmod u+x  xxx.sh 赋予执行权限；</p></blockquote><hr><h3 id="Shell变量"><a href="#Shell变量" class="headerlink" title="Shell变量"></a>Shell变量</h3><p>显示shell中所有变量：set</p><ul><li><p>系统变量：</p></li><li><p>用户自定义变量：</p><ul><li><p>定义方式：变量名&#x3D;值     如：A&#x3D;100</p></li><li><p>撤销变量： unset  变量</p></li><li><p>声明静态变量：readonly  变量       ——注：静态变量不能unset</p></li></ul><blockquote><p>注：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">A=100</span><br><span class="line">echo A=$A        #输出变量时，前面要带$，以作区分</span><br><span class="line">echo &quot;A=$A&quot;</span><br><span class="line">unset A</span><br><span class="line"></span><br><span class="line">readonly B=2</span><br><span class="line">echo B=$B</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将指令返回的结果赋值给变量,使用 `` 或 $()</span> </span><br><span class="line">C=`date`</span><br><span class="line">D=`$(date)`</span><br></pre></td></tr></table></figure></blockquote></li></ul><p>变量定义的规范：</p><ul><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。如：5A&#x3D;200  是错的；</li><li>等号两侧不能有空格；</li><li>变量名称一般习惯为大写；</li></ul><blockquote><p>输出变量时，前面要带&#x3D;&#x3D;$&#x3D;&#x3D;，不然会被识别为字符；</p><p>将指令返回的结果赋值给变量，使用 &#x3D;&#x3D;&#96;&#96;&#x3D;&#x3D; 或 &#x3D;&#x3D;$()&#x3D;&#x3D;   ；</p></blockquote><p>设置环境变量：</p><ul><li>在环境变量的配置文件中，用 “export 变量名&#x3D;变量值”   设置环境变量&#x2F;全局变量</li><li>刷新配置文件  ：source 配置文件</li><li>查询环境变量的值： echo $ 变量名</li></ul><blockquote><p>环境变量的配置文件在：&#x2F;etc&#x2F;profile</p></blockquote><hr><p>shell脚本的多行注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;!</span><br><span class="line">内容</span><br><span class="line">!</span><br></pre></td></tr></table></figure><hr><p><strong>位置参数变量：</strong></p><p>当我们执行一个shell脚本时，如果希望获取到命令行的参数信息，就可以使用到位置参数变量。</p><p>语法：</p><ul><li>$n   ——   n为数字，$0代表命令本身，$1 ~ $9代表第1到第9个参数，10以上的参数，10以上的参数需要用大括号包含，如 ${10}   </li><li>$*   ——   这个变量代表命令行中所有的参数，$* 把所有的参数看成一个整体</li><li>$@  ——   这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区分对待</li><li>$#  ——   这个变量代表命令行中所有参数的个数</li></ul><p>如：在 hello.sh文件中，写入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;执行命令为$0   第一个参数为$1  第一个参数为$2&quot;</span><br><span class="line">echo &quot;所有的参数为 $*&quot;</span><br><span class="line">echo &quot;$@&quot;</span><br><span class="line">echo &quot;参数个数为 $#&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如执行指令:  ./hello.sh 100 200, 会输出:</span></span><br><span class="line">执行命令为./hello.sh   第一个参数为100  第一个参数为200</span><br><span class="line">所有的参数为 100 200</span><br><span class="line">100 200</span><br><span class="line">参数个数为 2</span><br></pre></td></tr></table></figure><hr><p><strong>预定义变量：</strong></p><p>$$   ——   当前进程的进程号（PID)<br>$!   ——   后台运行的最后一个进程的进程号（PID)<br>$？——  最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0  (具体是哪个数，由命令自己来决定)，则证明上一个命令执行不正确。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;当前执行的进程id=$$&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以后台的方式运行一个脚本，并获取他的进程号</span></span><br><span class="line">root/shcode/myshell.sh &amp;</span><br><span class="line">echo &quot;最后一个后台方式运行的进程id=$!&quot;</span><br><span class="line">echo &quot;执行的结果是=$?&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>三种使用格式：</p><ul><li>$((运算式)) </li><li>$[运算式]</li><li>expr m + n  &#x2F;&#x2F;expression表达式<ul><li>注意expr运算符间要有空格，如果希望将expr的结果赋给某个变量，要加反引号 &#96;&#96;</li></ul></li></ul><p>运算符：和其他的一样，但乘号要加 “ \ “，如   \ *</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：计算(2+3)X4的值</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第一种方式</span></span><br><span class="line">RES1=$(((2+3)*4))</span><br><span class="line">echo &quot;res1=SRES1&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第二种方式，推荐使用</span></span><br><span class="line">RES2=$[(2+3)*4]</span><br><span class="line">echo &quot;res2=SRES2&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用第三种方式<span class="built_in">expr</span></span></span><br><span class="line">TEMP=`expr 2 + 3`</span><br><span class="line">RES4=`expr $STEMP \* 4`</span><br><span class="line">echo &quot;res4=SRES4&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2：请求出命令行的两个参数[整数]的和 20 50</span></span><br><span class="line">SUM=$S[$1+$2]</span><br><span class="line">echo &quot;sum=$SUM&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>判断符号：</p><ul><li>字符串比较： &#x3D;</li><li>两个整数比较：<ul><li>-lt   小于</li><li>-le   小于等于 little equal</li><li>-eq   等于   equal</li><li>-gt    大于</li><li>-ge    大于等于  greater  equal</li><li>-ne    不等于</li></ul></li><li>按照文件权限进行判断：<ul><li>-r    有读的权限</li><li>-w   有写的权限</li><li>-x    有执行的权限</li></ul></li><li>按照文件类型进行判断：<ul><li>-f    文件存在，且是一个常规文件</li><li>-e    文件存在</li><li>-d    文件存在并是一个目录</li></ul></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例1：<span class="string">&quot;ok&quot;</span>是否等于<span class="string">&quot;ok&quot;</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用 =</span></span><br><span class="line">1f [ &quot;ok&quot;=&quot;ok&quot; ]</span><br><span class="line">then</span><br><span class="line">echo &quot;equal&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例2:23是否大于等于22</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用~ge</span></span><br><span class="line">if [ 23 -ge 22 ]</span><br><span class="line">then</span><br><span class="line">echo &quot;大于&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">案例3:/root/shcode,/aaa.txt目录中的文件是否存在</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">判断语句：使用-f</span></span><br><span class="line">if [ -f /root/shcode/aaa.txt ]</span><br><span class="line">then</span><br><span class="line">echo&quot;存在&quot;</span><br><span class="line">fi</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">看几个案例</span></span><br><span class="line">if hspedu</span><br><span class="line">then</span><br><span class="line">echo &quot;hello,hspedu&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>流程控制：</strong></p><p><strong>if 判断</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>if…else if…else 判断</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span> </span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">elif</span> [ 条件判断 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>for循环</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">for((初始值;循环控制条件;变量变化))</span><br><span class="line">do </span><br><span class="line">...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="keyword">for</span> 变量名 int 参数列表</span></span><br><span class="line">do </span><br><span class="line">...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：反复输出 命令行输入的参数</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">这里 <span class="variable">$@</span> 会分多次输出， $* 会一次性输出</span></span><br><span class="line">for loop int $@</span><br><span class="line">do </span><br><span class="line">echo &quot;the value is: $loop&quot;</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例：<span class="built_in">sum</span> 从1累加到100</span></span><br><span class="line">SUM=0</span><br><span class="line">for(( i=1; i&lt;=100; i++))</span><br><span class="line">do</span><br><span class="line">SUM=$[$SUM+$i]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>while语句</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while [ 条件判断 ]</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="keyword">while</span> ((条件判断))</span></span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>无限循环：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="keyword">for</span> (( ; ; ))</span><br></pre></td></tr></table></figure><p><strong>until循环</strong></p><p>until 会一直循环到 条件为ture 为止，与while正好相反；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ 条件判断 ]</span><br><span class="line">do</span><br><span class="line">...</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p><strong>case….esac 多选择语句</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">case 变量 in</span><br><span class="line">值1)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">值2)</span><br><span class="line">...</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>跳出循环：  break   和   continue</p><hr><h3 id="read输入"><a href="#read输入" class="headerlink" title="read输入"></a>read输入</h3><p>read  选项  参数</p><ul><li>选项： -p   输出读取时的提示符     -t   指定读取时等待的时间（秒），超时则继续往下执行代码。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -t 10 -p &quot;请输入一个数NUM1=&quot; NUM1</span><br><span class="line">echo &quot;你输入的NUM1=$NUM1&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>系统函数：</p><ul><li><p><strong>basename  文件路径名  [文件后缀]</strong></p><p>取出前缀路径，获取文件名；</p><p>如果指定了文件后缀，也可以同时去掉文件后缀；</p></li><li><p><strong>dirname  文件路径名</strong></p><p>去掉文件名，获取路径部分</p></li></ul><p>自定义函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[function] 函数名()&#123;</span><br><span class="line">....</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/</span></span><br><span class="line">function getSum()&#123;</span><br><span class="line">SUM=$[$n1+$n2]</span><br><span class="line">echo &quot;和是$SUM&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;请输入n1=&quot; n1</span><br><span class="line">read -p &quot;请输入n2=&quot; n2</span><br><span class="line">getSum $n1 $n2</span><br></pre></td></tr></table></figure><h3 id="案例-定时备份"><a href="#案例-定时备份" class="headerlink" title="案例: 定时备份"></a>案例: 定时备份</h3><p>定时备份数据库：</p><ul><li>每天2: 30 备份数据库zzc 到 &#x2F;data&#x2F;backup&#x2F;bd；</li><li>备份开始和备份结束能够给出相应的提示信息；</li><li>备份后的文件以备份时间为文件名，打包为 .tar.gz 的形式；</li><li>如果存在10天前备份的数据库文件，将其删除。</li></ul><blockquote><p>首先创建脚本，在 &#x2F;usr&#x2F;sbin 下创建名为mysql_db_backup.sh 的脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">备份目录</span></span><br><span class="line">BACKUP=/data/backup/db</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">当前时间</span></span><br><span class="line">DATETIME=$(date +%Y-%m-%d_%H%M%S)</span><br><span class="line">echo $DATETIME</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库的地址</span></span><br><span class="line">HOST=localhost</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库用户名</span></span><br><span class="line">DB_USER=root</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">数据库密码</span></span><br><span class="line">DB_PW=zzc</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份的数据库名</span></span><br><span class="line">DATABASE=zzc</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建备份目录，如果不存在，就创建</span></span><br><span class="line">[ ! -d &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot; ] &amp;&amp; mkdir -p &quot;$&#123;BACKUP&#125;/$&#123;DATETIME&#125;&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">备份数据库</span></span><br><span class="line">mysqldump -u$&#123;DB_USER&#125; -p$&#123;DB_PW&#125; --host=$&#123;HOST&#125; -q -R --databases $&#123;DATABASE&#125; | gzip &gt; $&#123;BACKUP&#125;/$&#123;DATETIME&#125;/$DATETIME.sql.gz</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将文件处理为 tar.gz</span></span><br><span class="line">cd $&#123;BACKUP&#125;</span><br><span class="line">tar -zcvf $DATETIME.tar.gz $&#123;DATETIME&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除对应的备份目录</span></span><br><span class="line">rm -rf $&#123;BACKUP&#125;/$&#123;DATETIME&#125;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除10天前备份的文件</span></span><br><span class="line">find $&#123;BACKUP&#125; -atime +10 -name &quot;*.tar.gz&quot; -exec rm -rf &#123;&#125; \;</span><br><span class="line">echo &quot;备份数据 $&#123;DATABASE&#125; 成功&quot;</span><br></pre></td></tr></table></figure><p>然后使用命令 crontab -e  设置定时任务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 2 * * * /usr/sbin/mysql_db_backup.sh</span><br></pre></td></tr></table></figure></blockquote><h1 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h1><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>日志文件是重要的系统信息文件，其中记录了许多重要的系统事件，包括用户的登录信息、系统的启动信息、系统的安全信息、邮件相关信息、各种服务相关信息等。</p><p>日志对于安全来说也很重要，它记录了系统每天发生的各种事情，通过日志来检查错误发生的原因，或者受到攻击时攻击者留下的痕迹。</p><p>可以这样理解 日志是用来记录重大事件的工具。</p><ul><li><p>系统日志文件的保存位置： &#x2F;var&#x2F;log&#x2F;</p></li><li><p>系统常用的日志：</p><table><thead><tr><th>日志文件</th><th>说明</th></tr></thead><tbody><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>boot.log</strong></td><td>系统启动日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>cron</strong></td><td>系统定时任务的相关日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;cups</td><td>打印信息的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;dmesg</td><td>系统开机内核自检的信息，可以直接用dmesg命令直接查看信息。</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;btmp</td><td>记录错误登录的日志；是二进制文件，要使用lastb命令查看</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>lasllog</strong></td><td>记录所有用户最后一次登录时间的日志；是二进制文件，要使用lastlog命令查看</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>mailog</strong></td><td>记录邮件信息的日志</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>message</strong></td><td>记录系统大部分重要信息的日志，如系统出问题，首先要检查的应该就是这个文件</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>secure</strong></td><td>记录验证和授权方面的信息，涉及账户和密码的程序都会记录</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;wtmp</td><td>永久记录所有用户的登录、注销信息，系统的后动、重启、关机事件；是二进制文件，要使用last命令查看</td></tr><tr><td>&#x2F;var&#x2F;log&#x2F;<strong>ulmp</strong></td><td>记录当前已经登录的用户的信息。使用w、who、users等命令查看</td></tr></tbody></table></li></ul><hr><h3 id="日志管理服务-rsyslogd"><a href="#日志管理服务-rsyslogd" class="headerlink" title="日志管理服务 rsyslogd"></a>日志管理服务 rsyslogd</h3><p>CentOS7.6 日志服务是 rsyslogd，而centos6.x的日志服务是syslogd；rsyslogd兼容syslogd。</p><ul><li>查看 rsyslogd服务是否启动： ps aux | grep “rsyslog” | grep -v “grep”</li><li>查看 rsyslogd服务是否自启动：systemctl list-unit-files | grep rsyslog</li></ul><p><strong>配置文件： &#x2F;etc&#x2F;rsyslog.conf</strong></p><ul><li><p>编辑文件时的格式为     *** . *         日志文件名**</p><p>其中第一 * 代表日志类型，第二个代表 日志级别</p></li><li><p>日志类型：</p><ul><li>auth  ——  pam产生的日志</li><li>authpriv ——  ssh、ftp 等登录信息的验证信息</li><li>corn ——  时间任务相关</li><li>kern —— 内核</li><li>lpr ——  打印</li><li>mail  ——  邮件</li><li>mark(syslog)-rsyslog ——  服务内部的信息，时间标识</li><li>news —— 新闻组</li><li>user ——  用户程序产生的相关信息</li><li>uucp ——  unix to unxi copy，即主机之间相关的通信</li><li>local 1~7 —— 自定义的日志设备</li></ul></li><li><p>日志级别：（从上到下，级别从低到高，记录信息越少）</p><ul><li>debug —— 有调试信息，日志通信最多</li><li>info —— 一般信息日志，最常用</li><li>notice —— 最具有重要性的普通条件的信息</li><li>warning —— 警告级别</li><li>err —— 错误级别，阻止某个功能或者模块不能正常工作的信息</li><li>crit —— 严重级别，阻止整个系统或者整个软件不能正常工作的信息</li><li>alert —— 需要立刻修改的信息</li><li>emerg —— 内核崩溃等重要信息</li><li>none —— 什么都不记录</li></ul></li></ul><blockquote><p>日志文件格式主要包含以下4列：</p><ul><li><p>事件产生的时间</p></li><li><p>产生事件的服务器的主机名</p></li><li><p>产生事件的服务名或程序名</p></li><li><p>事件的具体信息</p></li></ul></blockquote><hr><h3 id="日志轮替"><a href="#日志轮替" class="headerlink" title="日志轮替"></a>日志轮替</h3><p>日志轮替，就是把旧的日志文件移动并改名，同时建立新的空日志文件，而旧日志文件在超过保存的范围就会被删除。</p><blockquote><p>旧的日志文件 依靠 &#x2F;etc&#x2F;logrotate.conf 配置文件中的“dateext”参数 来改名，日志会用日期来作为日志文件的后缀，如 “secure-20220416” ，这样日志文件名不会重叠，就不需要再改名了，只需要指定最多保存的日志个数，删除多余的日志文件即可。</p><p>如果配置文件没有“dateext”参数，那么日志文件就需要进行改名了。当第一次进行日志轮替时，当前的 “secure” 日志会自动改名为“secure.1”，然后新建“secure”日志，用来保存新的日志；当第二次进行日志轮替时， “secure.1” 会自动改名为 “secure.2”，当前的“secure”日志会自动改名为“secure.1”，然后也会新建 “secure”日志，用来保存新的日志；以此类推。</p></blockquote><p>logrotate.conf 配置文件的参数：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>daily</td><td>日志的轮替周期是毎天</td></tr><tr><td>weekly</td><td>日志的轮替周期是每周</td></tr><tr><td>monthly</td><td>日志的轮控周期是每月</td></tr><tr><td>rotate 数宇</td><td>保留的日志文件的个数。0指没有备份</td></tr><tr><td>compress</td><td>当进行日志轮替时，对旧的日志进行压缩</td></tr><tr><td>create mode owner group</td><td>建立新日志，同时指定新日志的权限与所有者和所属组. 如create 0600 root utmp</td></tr><tr><td>mail address</td><td>当进行日志轮替时.输出内存通过邮件发送到指定的邮件地址</td></tr><tr><td>missingok</td><td>如果日志不存在，则忽略该日志的警告信息</td></tr><tr><td>nolifempty</td><td>如果曰志为空文件，則不进行日志轮替</td></tr><tr><td>minsize 大小</td><td>日志轮替的最小值。也就是日志一定要达到这个最小值才会进行轮持，否则就算时间达到也不进行轮替</td></tr><tr><td>size 大小</td><td>日志只有大于指定大小才进行日志轮替，而不是按照时间轮替，如size 100k</td></tr><tr><td>dateext</td><td>使用日期作为日志轮替文件的后缀，如secure-20130605</td></tr><tr><td>sharedscripts</td><td>在此关键宇之后的脚本只执行一次</td></tr><tr><td>prerotate&#x2F;cndscript</td><td>在曰志轮替之前执行脚本命令。endscript标识prerotate脚本结束</td></tr><tr><td>postrolaie&#x2F;endscripl</td><td>在日志轮替之后执行脚本命令。endscripi 标识 postrotate脚本结束</td></tr></tbody></table><p>logrotate.conf 配置文件内容：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># see &quot;man logrotate&quot; for details</span></span><br><span class="line"><span class="comment"># rotate log files weekly 每周轮替一次</span></span><br><span class="line"><span class="string">weekly</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># keep 4 weeks worth of backlogs 保存4个文件</span></span><br><span class="line"><span class="string">rotate</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># create new (empty) log files after rotating old ones  在轮替时创建新的日志文件</span></span><br><span class="line"><span class="string">create</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use date as a suffix of the rotated file   使用日期作为日志轮替文件的后缀</span></span><br><span class="line"><span class="string">dateext</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># uncomment this if you want your log files compressed  日志文件是否压缩</span></span><br><span class="line"><span class="comment">#compress</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以上配置为默认配置，如果轮替文件配置了独立参数，则以独立参数为准</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RPM packages drop log rotation information into this directory  将这个目录的所有子配置文件读取进来，进行日志轮替</span></span><br><span class="line"><span class="string">include</span> <span class="string">/etc/logrotate.d</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># no packages own wtmp and btmp -- we&#x27;ll rotate them here   以下日志有自己的独立参数，如果和默认参数冲突了，就以独立参数为准</span></span><br><span class="line"><span class="string">/var/log/wtmp</span> &#123;</span><br><span class="line">    <span class="string">monthly</span></span><br><span class="line">    <span class="string">create</span> <span class="number">0664 </span><span class="string">root</span> <span class="string">utmp</span><span class="comment"># 建立的新日志，权限是0664，所有者是root，所属组是utmp组</span></span><br><span class="line"><span class="string">minsize</span> <span class="string">1M</span><span class="comment">#轮替大小最小是1M</span></span><br><span class="line">    <span class="string">rotate</span> <span class="number">1</span><span class="comment"># 仅保留一个日志备份</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">/var/log/btmp</span> &#123;</span><br><span class="line">    <span class="string">missingok</span><span class="comment"># 如果日志不存在，则忽略该日志的警告信息</span></span><br><span class="line">    <span class="string">monthly</span></span><br><span class="line">    <span class="string">create</span> <span class="number">0600 </span><span class="string">root</span> <span class="string">utmp</span></span><br><span class="line">    <span class="string">rotate</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># system-specific logs may be also be configured here.</span></span><br></pre></td></tr></table></figure><p><strong>将自己的日志加入日志轮替：</strong></p><ul><li>方法一：直接在 &#x2F;etc&#x2F;logtotate.conf 配置文件中写入该日志的轮替策略；</li><li>方法二：在 &#x2F;etc&#x2F;logrotate.d&#x2F; 目录中新建立该日志的轮替文件；</li></ul><blockquote><p>推荐使用第二种方法，因为系统的需要轮替的文件很多，如果将轮替策略全写入 &#x2F;etc&#x2F;logtotate.conf  文件中，会使这个文件变的难以管理，不利于维护。</p></blockquote><p><strong>日志轮替的机制原理：</strong></p><p>日志轮替依赖于 系统定时任务，在 &#x2F;etc&#x2F;cron.daily&#x2F; 目录，其中有可执行的 logrotate文件，这个文件会读取日志轮替的配置文件，日志轮替 就是通过这个文件依赖定时任务执行的。</p><hr><h3 id="查看内存日志"><a href="#查看内存日志" class="headerlink" title="查看内存日志"></a>查看内存日志</h3><p>一些日志是时时变化的，如与内核相关的，所以会先写到内存日志中；内存日志在重启后会清空。</p><p>journalctl 指令可以查看内存日志，如：</p><ul><li><p>journalctl —— 查看全部</p></li><li><p>journalctl -n 3 ——  查看最新3条</p></li><li><p>journalctl  –since ”起始时间“  –until  ”截止时间” ——查看起始时间到结束时间的日志，可加日期</p></li><li><p>journalctl  -p err —— 报错日志</p></li><li><p>journalctl -o verbose —— 日志详细内容</p></li><li><p>journalctl_PID&#x3D;1245   _COMM&#x3D;sshd ——  查看包含这些参数的日志（在详细日志查看）</p><p>或者 journalctl | grep sshd</p></li></ul><h1 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h1><p>使用dump 和restore 命令</p><blockquote><p>使用 yum -y install dump 安装备份工具</p></blockquote><p>dump支持 分卷 和 增量备份。（增量备份是指上次备份后，修改&#x2F;增加过的文件，也称差异备份）</p><p>格式： </p><p>dump  [-cu]  [ -f &lt;备份后文件名&gt;]  [ -T &lt;日期&gt;]  [目录或文件系统]</p><p>dump [-w或W]</p><ul><li>-c  ——  c位置填一个0到9的数字，作用是创建新的归档文件，并将一个或多个文件参数所指定的内容写入归档文件的开头；<ul><li>0123456789   ——  备份的层级。0为最完整备份，会备份所有文件。若指定0以上的层级，则备份至上一次备份以来修改或新增的文件，到9后，可以再次轮替。</li></ul></li><li>-f &lt;备份后文件名&gt;  —— 指定备份后的文件名</li><li>-j    ——  调用bzlib库压缩备份文件，也就是将备份后的文件压缩成bz2格式，让文件更小</li><li>-T &lt;日期&gt;   ——  指定开始备份的时间与日期</li><li>-u —— 备份完毕后，在&#x2F;etc&#x2F;dumpdares中记录备份的文件系统，层级，日期与时间等。<br>-t  ——  指定文件名，若该文件已存在备份文件中，则列出名称<br>-W  ——  显示需要备份的文件及其最后一次备份的层级，时间，日期。<br>-w   ——  与-W类似，但仅显示需要备份的文件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例如： 将 /boot 分区备份到 /opt/boot.bak0.bz2 文件中，备份层级为0</span><br><span class="line">dump -0uj -f /opt/boot.bak0.bz2 /boot</span><br><span class="line"></span><br><span class="line"># 在/boot 目录下拷贝一个文件，备份层级为1，</span><br><span class="line">dump -1uj -f /opt/boot.bak1.bz2 /boot</span><br></pre></td></tr></table></figure><blockquote><p>使用dump和crontab 实现定时备份；</p><p>&#x2F;etc&#x2F;dumpdates 是备份时间文件</p><p>注：备份分区是支持增量备份的，但备份文件或目录 是不支持增量备份的，即只能使用0级备份。</p></blockquote><hr><p>格式： restore  [模式选项]  [选项]</p><ul><li>模式：<ul><li>-C  ——  使用对比模式，将备份的文件与已存在的文件相互对比；</li><li>-i  ——  使用交互模式，在进行还原操作时，restors指令将依序询问用户；</li><li>-r  ——  进行还原模式；</li><li>-t  ——  查看模式，看备份文件有哪些文件；</li></ul></li><li>选项：<br>-f &lt;备份设备&gt;  ——  从指定的文件中读取备份数据，进行还原操作；</li></ul><blockquote><p>如果有增量备份，需要按顺序恢复，即从0层级开始恢复。</p></blockquote><h1 id="可视化管理-webmin-和-bt-运维工具"><a href="#可视化管理-webmin-和-bt-运维工具" class="headerlink" title="可视化管理 webmin 和 bt 运维工具"></a>可视化管理 webmin 和 bt 运维工具</h1><p>webmin</p><ul><li>重置密码<br>&#x2F;usr&#x2F;libexec&#x2F;webmin&#x2F;changepass.pl &#x2F;etc&#x2F;webmin root test<br>(root是webmin的用户名，不是OS的，这里就是把webmin的root用户密码改成了test)</li><li>修改webmin服务的端口号(默认是l0000出于安全目的)<br>vim &#x2F;etc&#x2F;webmin&#x2F;miniserv.conf<br>#修改端口<br>将port-10000修改为其他端口号，如port&#x3D;9999</li><li>重启webmin<br>&#x2F;etc&#x2F;webmin&#x2F;restart#重启<br>&#x2F;etc&#x2F;webmin&#x2F;start#启动<br>&#x2F;etc&#x2F;webmin&#x2F;stop#停止</li><li>防火墙放开对应端口，如9999<br>firewall-cmd-zone&#x3D;public-add-port&#x3D;9999&#x2F;tcp-permanent     #配置防火墙开放9999端口<br>firewall-cmd-reload     #更新防火墙配置<br>firewall–cmd-zone-public-list-ports     #查看已经开放的端口号</li></ul><p>宝塔：</p><p>安装： yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; sh install.sh ed8484bec</p><blockquote><p>外网面板地址: <a href="http://219.135.154.95:8888/96a2b652">http://219.135.154.95:8888/96a2b652</a><br>内网面板地址: <a href="http://192.168.205.129:8888/96a2b652">http://192.168.205.129:8888/96a2b652</a><br>username: tohahwlr<br>password: f452b723</p></blockquote><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>找回root密码：</p><ul><li>首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面。</li><li>进入编辑界面，使用键盘上的上下键把光标往下移动，找到以“fi” “Linux16”开头内容所在的行数”，在行的最后面输入：init&#x3D;&#x2F;bin&#x2F;sh。</li><li>输入完成后，直接按快捷键：Ctrl+x 进入 单用户模式。</li><li>进入后，在光标闪烁的位置中输入：mount -o remount,rw &#x2F;</li><li>在新的一行最后面输入：passwd   按回车键。之后就可以输入新密码，以及确认密码。</li><li>密码修改后，会显示passwd…..的样式，即修改成功；</li><li>接着输入：touch  &#x2F;.autorelabel 回车，再输入：exec &#x2F;sbin&#x2F;init  回车，然后等待系统修改密码（过程时间可能有点长），并自动重启即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql</title>
      <link href="/Notes/2022/04/14/MySQL/"/>
      <url>/Notes/2022/04/14/MySQL/</url>
      
        <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>SQL分类：</p><ul><li><p><strong>DDL：数据定义语言</strong></p><p>Data Definition Language，负责数据结构定义与数据库对象定义的语言，由<strong>CREATE</strong>、<strong>ALTER</strong>与<strong>DROP</strong>三个语法所组成。</p></li><li><p><strong>DML：数据操作语言</strong></p><p>Data Manipulation Language，负责对数据库对象运行数据访问工作的指令集，以 <strong>INSERT</strong>、<strong>UPDATE</strong>、<strong>DELETE</strong>三种指令为核心，分别代表插入、更新与删除。</p></li><li><p><strong>DQL：数据查询语言</strong></p><p>Data Query Language，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字<strong>SELECT</strong>是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有<strong>FROM</strong>，<strong>WHERE</strong>，<strong>GROUP BY</strong>，<strong>HAVING</strong>和<strong>ORDER BY</strong>。</p></li><li><p><strong>DCL：数据控制语言</strong></p><p>Data Control Language，是一种可对数据访问权进行控制的指令，它可以控制特定用户账户对数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权。由 <strong>GRANT</strong> 和 <strong>REVOKE</strong> 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。</p></li></ul><p>连接MySQL的指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h 127.0.0.1 -P 3306 -u root -p密码</span><br></pre></td></tr></table></figure><p>-p密码不要有空格；</p><p>-h 后没有写ip地址，默认就是主机</p><p>-P 后没有写端口，默认就是3306</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 用户名 -p密码  //直接进默认的MySQL？</span><br></pre></td></tr></table></figure><p>启动mysql服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br></pre></td></tr></table></figure><blockquote><p>进入mysql </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p</span><br><span class="line">输入密码 zzc</span><br></pre></td></tr></table></figure></blockquote><p>快捷键：</p><p>注释：shift + ctrl + c ； 注销注释：shift + ctrl + r</p><blockquote><p>注：</p><p>MySQL在&#x3D;&#x3D;Linux下&#x3D;&#x3D;数据库名、表名、列名、别名大小写规则是这样的：</p><ul><li>&#x3D;&#x3D;数据库名、表名、表的别名、变量名是严格区分大小写的&#x3D;&#x3D;；</li><li>关键字、函数名称在 SQL 中不区分大小写； </li><li>列名（或字段名）与列的别名（或字段别名）在所有的情况下均是忽略大小写的；</li></ul><p>MySQL在Windows的环境下全部不区分大小写</p></blockquote><blockquote><p>utf8mb4 能使用1~ 4个字节表示字符，utf8是utf8mb3的别名，能使用1 ~ 3个字节表示字符；</p><p>MySQL中有4个级别的字符集和计较规则：</p><ul><li>服务器级别 </li><li>数据库级别 </li><li>表级别 </li><li>列级别</li></ul><p>执行如下SQL语句： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;character%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>会得到一些信息：</p><p>character_set_server：服务器级别的字符集<br>character_set_database：当前数据库的字符集<br>character_set_client：服务器解码请求时使用的字符集<br>character_set_connection：服务器处理请求时会把请求字符串从character_set_client转为character_set_connection<br>character_set_results：服务器向客户端返回数据时使用的字符集</p></blockquote><h1 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h1><p>创建与删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#删除数据库指令</span><br><span class="line"><span class="keyword">DROP</span> DATABASE 数据库名</span><br><span class="line"><span class="keyword">DROP</span> DATABASE IF <span class="keyword">EXISTS</span> 数据库名 <span class="comment">-- 推荐</span></span><br><span class="line">    </span><br><span class="line">#创建数据库指令</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名</span><br><span class="line"># 判断数据库是否已经存在，不存在则创建数据库（推荐）</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> 数据库名;</span><br><span class="line"></span><br><span class="line">#创建一个使用utf8字符集的数据库</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8</span><br><span class="line">#创建一个使用utf8字符集，并带校对规则的数据库 </span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin</span><br><span class="line">#校对规则 utf8_bin区分大小写，默认utf8_general_ci 不区分大小写</span><br></pre></td></tr></table></figure><blockquote><p>注：DATABASE不能改名，一些可视化工具可以改名，是新建一个库，把所有表复制过去，再删旧库完成。</p></blockquote><p>查看数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#查看当前数据库服务器中的所有数据库</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br><span class="line">#查看当前正在使用的数据库，使用的一个mysql的全局函数</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE()</span><br><span class="line"></span><br><span class="line"># 查看指定库下所有的表</span><br><span class="line"><span class="keyword">SHOW</span> TABLES <span class="keyword">FROM</span> 数据库名</span><br><span class="line"></span><br><span class="line">#查看前面创建的zzc_db01数据库的定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> DATABASE zzc_db01</span><br><span class="line"></span><br><span class="line"># 切换数据库</span><br><span class="line">USE 数据库名</span><br></pre></td></tr></table></figure><p>修改数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> DATABASE 数据库名 <span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集</span><br></pre></td></tr></table></figure><p>使用反引号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#在创建数据库，表时，为了规避关键字，可以使用反引号解决,删除的时候也要带反引号</span><br><span class="line">#平时用的时候，带反引号更安全</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE `<span class="keyword">CREATE</span>`</span><br></pre></td></tr></table></figure><p>备份与恢复</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#备份数据库（注意：在DOS执行; 这个备份的文件就是对应的<span class="keyword">sql</span>语句）:</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p m <span class="operator">-</span>B 数据库<span class="number">1</span> 数据库<span class="number">2</span> 数据库n <span class="operator">&gt;</span> 文件路径名.spl</span><br><span class="line">#备份一个数据库中的若干表 (在DOS下执行)</span><br><span class="line">mysqldump <span class="operator">-</span>u 用户名 <span class="operator">-</span>p 数据库 表<span class="number">1</span> 表<span class="number">2</span> 表n <span class="operator">&gt;</span> 文件路径名.<span class="keyword">sql</span></span><br><span class="line">    </span><br><span class="line">#恢复数据库（注意：进入Mysql命令行再执行）：Source 文件路径名.<span class="keyword">sql</span></span><br><span class="line">source 文件路径名.<span class="keyword">sql</span></span><br><span class="line">#第二个恢复办法：将整个备份文件的内容放到查询编辑器中 执行一遍</span><br></pre></td></tr></table></figure><p>数据库CRUD</p><p>create，read，update，delete</p><hr><h1 id="表"><a href="#表" class="headerlink" title="表"></a>表</h1><h2 id="表操作"><a href="#表操作" class="headerlink" title="表操作"></a>表操作</h2><blockquote><p>DUAL表是一个虚拟的表，很特殊，是建立数据库的时候随数据字典创建而建立的，它是单行单列的一个表，一般称为“哑表、虚表等”，列名DUMMY，类型VARCHAR2(1)，值为’X’，</p></blockquote><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p> creat table 表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] 表名</span><br><span class="line">(</span><br><span class="line">field1 datatype,</span><br><span class="line">field2 datatype</span><br><span class="line">)<span class="type">CHARACTER</span> <span class="keyword">SET</span> 字符集 <span class="keyword">COLLATE</span> 校对规则 ENGINE 存储引擎</span><br><span class="line">#field : 指定列名datatype : 指定列类型（字段类型）</span><br><span class="line">#<span class="type">character</span> <span class="keyword">set</span> : 如果没有指定，则默认为所在数据库的字符集</span><br><span class="line">#<span class="keyword">collate</span> : 如果没有指定，则默认为所在数据库的校对规则</span><br><span class="line">#engine : 引擎</span><br><span class="line">#加上了IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>关键字，则表示：如果当前数据库中不存在要创建的数据表，则创建数据表；如果当前数据库中已经存在要创建的数据表，则忽略建表语句，不再创建数据表。</span><br><span class="line"></span><br><span class="line"># 将其他表的查询结果集作为新表</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">AS</span> 查询语句</span><br><span class="line"></span><br><span class="line"># 查看表的数据结构</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#示例：</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t2`(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT, #自增</span><br><span class="line">`name` <span class="type">VARCHAR</span>(<span class="number">255</span>), #name和password是关键字，要用反引号包起来</span><br><span class="line">`password` <span class="type">VARCHAR</span>(<span class="number">255</span>),</span><br><span class="line">birthday <span class="type">DATE</span></span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (id)  #主键</span><br><span class="line">)<span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_bin ENGINE INNODB;</span><br></pre></td></tr></table></figure><blockquote><p>创建表——方式2，基于现有的表创建</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">AS</span> 其他表<span class="operator">/</span>结果集</span><br><span class="line"></span><br><span class="line">#例子:</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> myemp</span><br><span class="line"><span class="keyword">AS</span> </span><br><span class="line"><span class="keyword">SELECT</span> employee_id,name,salary <span class="keyword">FROM</span> employees;</span><br></pre></td></tr></table></figure><p>mysql8新特性：计算列 </p><p>—— 列名 generated always 公式 virtual</p><p>可以在create table 和 alter teble中使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb1(</span><br><span class="line">a <span class="type">INT</span>,</span><br><span class="line">b <span class="type">INT</span>,</span><br><span class="line">c <span class="type">INT</span> GENERATED ALWAYS <span class="keyword">AS</span> (a <span class="operator">+</span> b) VIRTUAL<span class="comment">-- 字段c为计算列</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure></blockquote><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>drop table 表名</p><p>drop是删除整个表，包括表的结构，约束，索引等。并释放掉所占的空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><p>删除表的数据 : delete from 表名</p><p>delete不会减少表或索引占用的空间。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t7 </span><br><span class="line"><span class="keyword">WHERE</span> `<span class="keyword">day</span>` <span class="operator">=</span> <span class="number">1988</span>#删除哪一行</span><br><span class="line">#如果没有<span class="keyword">where</span>语句，则删除表中的所有记录，<span class="keyword">delete</span>语句不会删除表本身</span><br><span class="line">#只能删行，不能删列（删列操作时<span class="keyword">alter</span> <span class="keyword">table</span>..drop..）</span><br></pre></td></tr></table></figure><p>TRUNCATE TABLE： truncate table语句删除表中所有的数据，重置表的自增值，会保留表结构及其约束，索引等。并使表和索引占用的空间恢复到初始大小。</p><h3 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h3><p> **insert into 表名 (可选列名) values (数据)，(数据) **</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t6`(<span class="comment">--创建表</span></span><br><span class="line">birthday <span class="type">DATE</span>,</span><br><span class="line">job_time DATETIME,</span><br><span class="line">login_time <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span><span class="comment">--自动更新时间戳为登陆时间</span></span><br><span class="line">     <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span>);</span><br><span class="line">     </span><br><span class="line">#添加数据：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `t6`(birthday, job_time)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;2020-11-11&#x27;</span>,<span class="string">&#x27;2022-12-12 12:12:12&#x27;</span>),(....),(...);<span class="comment">--往表中添加数据,可以一次添加多条数据，字符串类型和日期类应该用单引号包起来</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果是将查询结果插入表中，则不必写values：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表名 (可选列名) <span class="keyword">SELECT</span> ...</span><br><span class="line">#子查询中的列表应与<span class="keyword">INSERT</span>句中的列名对应</span><br></pre></td></tr></table></figure></blockquote><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><p><strong>select , desc</strong> </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">select</span> 查询；<span class="operator">*</span> 表示所有字段，可改为具体的多个列名； <span class="keyword">FROM</span> 从哪个表；<span class="keyword">WHERE</span> 从哪个字段(按条件查询)； </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1` <span class="keyword">WHERE</span> 列名 <span class="operator">=</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">#查询整张表</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `t1`</span><br><span class="line"></span><br><span class="line"># <span class="keyword">distinct</span>用于去重</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> 列名 <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件 </span><br><span class="line"></span><br><span class="line">#<span class="keyword">order</span> <span class="keyword">by</span> : 可以指定列名按值升序<span class="keyword">asc</span>或降序<span class="keyword">desc</span>排列</span><br><span class="line">#<span class="keyword">asc</span>：ascending <span class="keyword">order</span> 升序; <span class="keyword">desc</span>：descending <span class="keyword">order</span> 降序</span><br><span class="line"><span class="keyword">SELECT</span> 列名，运算表达式 <span class="keyword">FROM</span> 表m <span class="keyword">ORDER</span> <span class="keyword">BY</span> 列名<span class="operator">/</span>表达式<span class="operator">/</span>别名 <span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span> #没写，默认升序</span><br><span class="line"></span><br><span class="line">#使用表达式对查询的列进行运算，可以用<span class="keyword">as</span>为列名和表达式换上别名，<span class="keyword">as</span>可以省略，直接后接别名</span><br><span class="line"><span class="keyword">SELECT</span> 列名 <span class="keyword">AS</span> 列别名, 运算表达式 <span class="keyword">AS</span> 表达式别名 <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#查看表结构，可以看所有列</span><br><span class="line"><span class="keyword">DESC</span> 表名</span><br></pre></td></tr></table></figure><p>where子语句中常用的</p><ul><li><p>比较运算符： <strong>&gt;&lt; &lt;&#x3D;&gt;&#x3D;&#x3D;&lt;&gt; 或 !&#x3D;</strong> (不等于，两种写法)**between…and…**（显示在某一区间的值）<strong>in(set)<strong>（显示在int列表中的值，如：in(10,20,30)）<strong>like ‘赵%’    not like ‘赵%’</strong> （模糊查询：</strong>%匹配0到多个字符，_ 单个下划线匹配单个字符</strong>）  <strong>is null</strong>（判断是否为空）<br><strong>exists</strong> 指定一个子查询，检测 行 的存在。该子查询实际上并不返回任何数据，而是返回值True或False。</p></li><li><p>xx  <strong>all</strong> ( … )： all前的xx数据要大于括号内的所有数据，相当于 xx &gt; max ( … )</p><p>xx  <strong>any</strong> ( … )： all前的xx数据只要大于括号内的任一数据，相当于 xx &gt; min ( … )</p></li><li><p>逻辑运算符：<strong>and</strong>（多个条件同时成立）    <strong>or</strong>（多个条件任一成立）     <strong>not</strong>（条件需不成立）</p></li></ul><blockquote><p><strong>exists 练习</strong></p><p>有 学生表student（学号，姓名） ，课程表course（课程号，课程名），成绩表sc（学号，课程号，成绩）</p><p>（1）查询选修了所有课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#由于<span class="keyword">SQL</span>中没有全称量词，所以一旦涉及到“全部”这个概念，就要用双重否定，这道题要考虑的是，对于 课程表里所有课程，查询这样的学生，没有一门课程是他不选修的。</span><br><span class="line"># 所以，将每个学生选修的课程一一列出与课程表所有课程进行比较！首先找出课程表中，每个学生没有选修的课；然后再挑出没有选修课为空集的学生返回即可。</span><br><span class="line"><span class="keyword">SELECT</span> s.姓名 <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> course c <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">   (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc <span class="keyword">WHERE</span> sc.学号 <span class="operator">=</span> s.学号 <span class="keyword">AND</span> sc.课程号 <span class="operator">=</span> c.课程号));</span><br></pre></td></tr></table></figure><p>（2）使用嵌套查询，查询选修了学生S2所有课程的学生姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 首先要查找的学生选修课程包含了学生S2选修的全部课程。即要找到的:不存在哪一门课，学生S2选了，符合条件的学生没有选</span><br><span class="line"># 所以，将每个学生选修的课程一一列出与学生S2选修课程进行比较！首先找出S2课程表中，每个学生没有选修的课；然后再挑出没有选修课为空集的学生返回即可。</span><br><span class="line"><span class="keyword">SELECT</span> s.SNAME <span class="keyword">FROM</span> student s <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">  (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc x <span class="keyword">WHERE</span> x.SNO <span class="operator">=</span> &quot;S2&quot; <span class="keyword">AND</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span></span><br><span class="line">    (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> sc y <span class="keyword">WHERE</span> y.SNO <span class="operator">=</span> s.SNO <span class="keyword">AND</span> x.CNO <span class="operator">=</span> y.CNO));</span><br></pre></td></tr></table></figure></blockquote><hr><blockquote><p>注意：列的别名不能在where中使用。</p><p>因为select语句的执行顺序：</p><p>1.from语句<br>2.where语句（结合条件）<br>3.start with语句<br>4.connect by语句<br>6.group byi语句<br>7.having语句<br>8.model语句<br>9.select语句<br>10.union、ninus、intersect等集合演算演算<br>11.order by语句</p><p>12.limit语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">#查询结构:</span><br><span class="line">方式<span class="number">1</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ...,...,....</span><br><span class="line"><span class="keyword">WHERE</span> 多表的连接条件</span><br><span class="line"><span class="keyword">AND</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line">#方式<span class="number">2</span>：</span><br><span class="line"><span class="keyword">SELECT</span> ...,....,...</span><br><span class="line"><span class="keyword">FROM</span> ... </span><br><span class="line"><span class="keyword">JOIN</span> ... <span class="keyword">ON</span> 多表的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> ... <span class="keyword">ON</span> ...</span><br><span class="line"><span class="keyword">WHERE</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">AND</span><span class="operator">/</span><span class="keyword">OR</span> 不包含组函数的过滤条件</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> ...,...</span><br><span class="line"><span class="keyword">HAVING</span> 包含组函数的过滤条件</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> ... <span class="keyword">ASC</span><span class="operator">/</span><span class="keyword">DESC</span></span><br><span class="line">LIMIT ...,...</span><br><span class="line">#其中：</span><br><span class="line">#（<span class="number">1</span>）<span class="keyword">from</span>：从哪些表中筛选</span><br><span class="line">#（<span class="number">2</span>）<span class="keyword">on</span>：关联多表查询时，去除笛卡尔积</span><br><span class="line">#（<span class="number">3</span>）<span class="keyword">where</span>：从表中筛选的条件</span><br><span class="line">#（<span class="number">4</span>）<span class="keyword">group</span> <span class="keyword">by</span>：分组依据</span><br><span class="line">#（<span class="number">5</span>）<span class="keyword">having</span>：在统计结果中再次筛选</span><br><span class="line">#（<span class="number">6</span>）<span class="keyword">order</span> <span class="keyword">by</span>：排序</span><br><span class="line">#（<span class="number">7</span>）limit：分页</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203192147883.png" alt="image-20220319214731765"></p></blockquote><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">select</span> ... limit <span class="keyword">start</span>, <span class="keyword">rows</span> </span><br><span class="line">#表示从<span class="keyword">start</span><span class="operator">+</span><span class="number">1</span>行开始取，取出<span class="keyword">rows</span>行，<span class="keyword">start</span>从<span class="number">0</span>开始计算</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 列</span><br><span class="line">LIMIT <span class="keyword">start</span>, <span class="keyword">rows</span></span><br></pre></td></tr></table></figure><p>select语句中如果包含了group by，having，order by，limit：则<strong>书写顺序为group by，having，order by，limit</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1, column2... <span class="keyword">FROM</span> <span class="keyword">table</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">column</span></span><br><span class="line">LIMIT <span class="keyword">start</span>,<span class="keyword">rows</span>;</span><br></pre></td></tr></table></figure><h3 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h3><p><strong>多表查询</strong>是基于两个或以上的表的查询，查询所规定的条件不能少于表的个数-1，否则会出现笛卡尔集</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ename,sal,dname,emp.deptno</span><br><span class="line"><span class="keyword">FROM</span> emp, dept<span class="comment">-- 查询两张表</span></span><br><span class="line"><span class="keyword">WHERE</span> emp.deptno <span class="operator">=</span> dept.deptno <span class="keyword">AND</span> emp.deptno <span class="operator">=</span> <span class="number">10</span><span class="comment">-- 不同表的列有同一名称时，要说明所属：表名.列名</span></span><br></pre></td></tr></table></figure><blockquote><p>表连接的约束条件可以有三种方式：WHERE, ON, USING</p></blockquote><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>自连接是指在同一张表的连接查询：将同一张表看作两张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 给同一张表起不同别名，以达到自连接的目的</span><br><span class="line"><span class="keyword">SELECT</span> worker.ename, boss.ename </span><br><span class="line"><span class="keyword">FROM</span> emp worker, emp boss  <span class="comment">-- 同一张表起不同的别名</span></span><br><span class="line"><span class="keyword">WHERE</span> worker.mgr <span class="operator">=</span> boss.empno</span><br><span class="line">#也可使用 <span class="keyword">inner</span> <span class="keyword">join</span></span><br><span class="line"><span class="keyword">SELECT</span> 字段列表</span><br><span class="line"><span class="keyword">FROM</span> A表 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B表</span><br><span class="line"><span class="keyword">ON</span> 关联条件</span><br><span class="line"><span class="keyword">WHERE</span> 等其他子句;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h4><p>使用多表查询时，会根据关联条件显示匹配记录，而那些没有匹配到的记录则不会显示，如果在多表查询中至少需要显示表的全部内容，就要用到外连接。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">JOIN</span> 表<span class="number">2</span> <span class="keyword">ON</span> 表<span class="number">1</span> 和 表<span class="number">2</span> 的连接条件</span><br><span class="line"><span class="keyword">JOIN</span> 表<span class="number">3</span> <span class="keyword">ON</span> 表<span class="number">2</span> 和 表<span class="number">3</span> 的连接条件</span><br></pre></td></tr></table></figure><p>左外连接：让左侧的表完全显示，即左表为主表；</p><p>右外连接：让右侧的表完全显示；即右表为主表；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#左外连接</span><br><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line"><span class="keyword">ON</span> 条件</span><br><span class="line">#右外连接</span><br><span class="line"><span class="keyword">SELECT</span> ... </span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span> <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> 表<span class="number">2</span> </span><br><span class="line"><span class="keyword">ON</span> 条件</span><br></pre></td></tr></table></figure><p>或者使用符号 (+) </p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191935503.png" alt="image-20220319193504406"></p><blockquote><p>满外连接 FULL JOIN</p><p>满外连接的结果 &#x3D; 左右表匹配的数据 + 左表没有匹配到的数据 + 右表没有匹配到的数据。</p></blockquote><blockquote><p>各种关系的实现：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191951879.png" alt="image-20220319195143639"></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">#中图：内连接 A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#左上图：左外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#右上图：右外连接</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#左中图：A <span class="operator">-</span> A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#右中图：B<span class="operator">-</span>A∩B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"></span><br><span class="line">#左下图：满外连接</span><br><span class="line"># 左中图 <span class="operator">+</span> 右上图 A∪B</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span> #没有去重操作，效率高</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`;</span><br><span class="line"></span><br><span class="line">#右下图</span><br><span class="line">#左中图 <span class="operator">+</span> 右中图 A ∪B<span class="operator">-</span> A∩B 或者 (A <span class="operator">-</span> A∩B) ∪ （B <span class="operator">-</span> A∩B）</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> d.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">WHERE</span> e.`department_id` <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><p>natural join 用来表示自然连接。我们可以把 自然连接理解为 SQL92 中的等值连接。它会帮你自动查询两张连接表中 所有相同的字段 ，然后进行 等值连接 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#在SQL92中</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">ON</span> e.`department_id` <span class="operator">=</span> d.`department_id`</span><br><span class="line"><span class="keyword">AND</span> e.`manager_id` <span class="operator">=</span> d.`manager_id`;</span><br><span class="line">#使用自然连接:</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">NATURAL</span> <span class="keyword">JOIN</span> departments d;</span><br></pre></td></tr></table></figure><blockquote><p>USING</p><p>SQL99还支持使用 USING 指定数据表里的 同名字段 进行等值连接。但是只能配合JOIN一起使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e <span class="keyword">JOIN</span> departments d</span><br><span class="line"><span class="keyword">USING</span> (department_id);</span><br><span class="line">#等值于</span><br><span class="line"><span class="keyword">SELECT</span> employee_id,last_name,department_name</span><br><span class="line"><span class="keyword">FROM</span> employees e ,departments d</span><br><span class="line"><span class="keyword">WHERE</span> e.department_id <span class="operator">=</span> d.department_id;</span><br></pre></td></tr></table></figure></blockquote><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>子查询是指嵌入其他sql语句中的select语句，也叫嵌套查询</p><p>单行子查询：只返回一行数据的子查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 单行子查询：只返回一行数据的子查询语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> </span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno <span class="operator">=</span> (   <span class="comment">-- 只返回一行数据</span></span><br><span class="line"><span class="keyword">SELECT</span> deptno</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> ename <span class="operator">=</span> <span class="string">&#x27;SMITH&#x27;</span> )</span><br><span class="line"></span><br><span class="line"># 多行子查询：返回多行数据的子查询语句</span><br><span class="line"><span class="keyword">select</span> ename, job, sal, deptno</span><br><span class="line"><span class="keyword">from</span> emp</span><br><span class="line"><span class="keyword">where</span> job <span class="keyword">in</span> (<span class="comment">-- 返回了多行数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> job</span><br><span class="line"><span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">WHERE</span> deptno <span class="operator">=</span> <span class="number">10</span></span><br><span class="line">) <span class="keyword">and</span> deptno <span class="operator">!=</span> <span class="number">10</span></span><br></pre></td></tr></table></figure><p>还可以把子查询当作一张临时表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> goods_id, ecs_goods.cat_id, goods_name, shop_price</span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line"><span class="keyword">SELECT</span> cat_id , <span class="built_in">MAX</span>(shop_price) <span class="keyword">as</span> max_price<span class="comment">-- 子查询结果被当作临时表</span></span><br><span class="line"><span class="keyword">FROM</span> ecs_goods </span><br><span class="line">        <span class="keyword">GROUP</span> <span class="keyword">BY</span> cat_id</span><br><span class="line">) temp , ecs_goods<span class="comment">-- 其他表</span></span><br><span class="line"><span class="keyword">where</span> temp.cat_id <span class="operator">=</span> ecs_goods.cat_id <span class="keyword">and</span> temp.max_price <span class="operator">=</span> ecs_goods.shop_priceQ</span><br></pre></td></tr></table></figure><blockquote><p>空值问题：</p><p>如果子查询的表中有NULL值，则使用NOT IN筛选子表时会出现问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> last_name</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span> manager_id</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line">        <span class="comment">-- WHERE manager_id is not  NULL</span></span><br><span class="line">);</span><br><span class="line"># 结果应该是排除子表筛出来的元素，但因为子表的结果集有<span class="keyword">NULL</span>值，所以最后结果是什么都没筛出来。</span><br></pre></td></tr></table></figure></blockquote><h4 id="合并查询"><a href="#合并查询" class="headerlink" title="合并查询"></a>合并查询</h4><p>操作符 union，union all 可以取得两个结果集的并集；</p><p>其中 union all 不会去重， union 会去重</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> `name`, id <span class="keyword">FROM</span> table01 <span class="keyword">WHERE</span> id <span class="operator">&gt;</span> <span class="number">2500</span> </span><br><span class="line"><span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line"><span class="keyword">SELECT</span> `name`, id <span class="keyword">FROM</span> table01 <span class="keyword">WHERE</span> `name`<span class="operator">=</span><span class="string">&#x27;abab&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="表复制"><a href="#表复制" class="headerlink" title="表复制"></a>表复制</h3><p>表的复制</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#将表<span class="number">1</span>的数据复制添加到表<span class="number">2</span>，如果两表相同，则相当于自我复制</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line">#只复制部分数据：</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span></span><br><span class="line">(列，列 ...)</span><br><span class="line"><span class="keyword">SELECT</span> 列，列... <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"></span><br><span class="line">#删除表<span class="number">1</span>中的重复记录</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表<span class="number">2</span> <span class="keyword">LIKE</span> 表<span class="number">1</span><span class="comment">-- 创建临时表2，于表1有相同的结构</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">2</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">1</span>; <span class="comment">-- 将表1的数据复制到表2，同时去重(不重复添加)</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表<span class="number">1</span>;<span class="comment">-- 删除表1的全部数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表<span class="number">2</span>; <span class="comment">-- 将表2去重后的数据复制到表1</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表<span class="number">2</span>; <span class="comment">-- 删除临时表</span></span><br></pre></td></tr></table></figure><h3 id="修改列属性"><a href="#修改列属性" class="headerlink" title="修改列属性"></a>修改列属性</h3><p><strong>alter table</strong> 表名 <strong>add</strong> 内容 <strong>after</strong> 在哪之后&#x2F; <strong>modify</strong> 列名 属性更改&#x2F; <strong>drop</strong> 列名 &#x2F; <strong>character</strong> 字符集 &#x2F; <strong>change</strong> 旧名 新名 属性更改 ； <strong>rename</strong> 表名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#添加列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6` <span class="comment">--往表t6中添加</span></span><br><span class="line"><span class="keyword">ADD</span> `name` <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span><span class="comment">--添加列名：name，类型：VARCHAR，不允许为NULL，默认为&#x27;&#x27;</span></span><br><span class="line">AFTER birthday<span class="comment">--在列名birthday之后</span></span><br><span class="line">#修改列（的属性）</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6`</span><br><span class="line">MODIFY `name` <span class="type">VARCHAR</span>(<span class="number">60</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span><span class="comment">--修改name</span></span><br><span class="line">#删除列</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `t6`</span><br><span class="line"><span class="keyword">DROP</span> `name`<span class="comment">--删去name</span></span><br><span class="line">#修改表名</span><br><span class="line">RENAME <span class="keyword">TABLE</span> t6 <span class="keyword">TO</span> t7<span class="comment">--表明t6改为t7</span></span><br><span class="line">#修改表的字符集为utf8</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t7 </span><br><span class="line"><span class="type">CHARACTER</span> utf8</span><br><span class="line">#列名birthday修改为<span class="keyword">day</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> t7 </span><br><span class="line">CHANGE birthday `<span class="keyword">day</span>` <span class="type">VARCHAR</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除表 （不能回滚）</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">#清空表   （<span class="keyword">truncate</span>不能回滚，用<span class="keyword">delete</span>语句删除数据就可以回滚）</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名</span><br></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><p>update  表名 set 修改内容 where  位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> t7 </span><br><span class="line"><span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">1000</span>#<span class="keyword">set</span>后接要更新的数据，可以有多个，用逗号分隔</span><br><span class="line"><span class="keyword">WHERE</span> `name` <span class="operator">=</span> <span class="string">&#x27;aaa&#x27;</span>#<span class="keyword">where</span>用于指定位置</span><br><span class="line">#如果没有<span class="keyword">where</span>语句,则更新所有的行(记录)</span><br></pre></td></tr></table></figure><blockquote><p>如果需要回滚数据，需要保证在DML前进行设置：set autocommit &#x3D; false;</p></blockquote><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><p>delete from 表名 where …</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> departments</span><br><span class="line"><span class="keyword">WHERE</span> department_id <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">#如果没有<span class="keyword">where</span>语句，则删除表中全部数据</span><br></pre></td></tr></table></figure><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束用于确保数据库的数据满足特定的商业规则；为保证数据完整性，一般从以下四个方面考虑限制：</p><ul><li><p>实体完整性（Entity Integrity） </p><p>例如：同一个表中，不能存在两条完全相同无法区分的记录 </p></li><li><p>域完整性（Domain Integrity） </p><p>例如：年龄范围0-120，性别范围“男&#x2F;女” </p></li><li><p>引用完整性（Referential Integrity） </p><p>例如：员工所在部门，在部门表中要能找到这个部门 </p></li><li><p>用户自定义完整性（User-defined Integrity） </p><p>例如：用户名唯一、密码不能为空等，本部门经理的工资不得高于本部门职工的平均工资的5倍。</p></li></ul><p>mysq的约束包括：</p><ul><li>not null，非空约束，规定某字段不能为空</li><li>unique，唯一约束，规定某字段在表中唯一</li><li>primary key， 主键约束（非空且唯一）</li><li>foreign key，外键约束</li><li>check，检查约束</li><li>default，默认值约束</li></ul><blockquote><p>查看某个表已有的约束：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints</span><br><span class="line"><span class="keyword">WHERE</span> table_name <span class="operator">=</span> &quot;表名&quot;;</span><br><span class="line"># information_schema 系统库</span><br><span class="line"># table_constraints 专门存储各表的约束</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>注：MySQL不支持check约束，可以用，但没效果。</p></blockquote><h4 id="primary-key-主键"><a href="#primary-key-主键" class="headerlink" title="primary key (主键)"></a>primary key (主键)</h4><p>用于唯一的标识表行的数据，当定义主键约束后，该列不能重复；</p><ul><li>primary key约束列的数据不能重复，且不能为null</li><li>一张表最多只能有一个主键，但可以是复合主键：比如有列：name和id，可以将两者用一个主键约束，单个name或id可以重复，但name+id的组合不能有重复；</li><li>主键的指定方式有两种：<ul><li>在列定义 后指定：列定义  primary key</li><li>在表定义最后写 ：primary key (列名)</li></ul></li><li>主键名总是PRIMAR，对主键定义约束名没用；</li><li>使用desc 表名，可以看到primary key的情况；</li><li>开发中，每个表往往会设计一个主键，且建议不要修改主键字段的值，否则有破坏数据完整性的危险；</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#字段后 定义主键</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line">#表定义末尾 定义主键    </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t1(</span><br><span class="line">    id <span class="type">INT</span>,</span><br><span class="line">    `name` <span class="type">VARCHAR</span>(<span class="number">32</span>)</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id,`name`)</span><br><span class="line">);    </span><br><span class="line"># 建表后</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名称 <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> KEY (字段列表); </span><br></pre></td></tr></table></figure><p>删除主键约束：</p><p>删除主键时，不需指定主键名，因为一个表只有一个主键；删除主键约束后，非空约束会存在。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">drop</span> <span class="keyword">primary</span> key；</span><br></pre></td></tr></table></figure><p><strong>自增列 auto_increment</strong></p><ul><li><p>一个表最多只能有一个自增列；</p></li><li><p>自增列约束的必须是键列（主键列、唯一键列，即 primary key 或 unique ）；</p></li><li><p>自增列约束的列的数据类型必须是整数类型；</p></li><li><p>默认从1开始，也可用：alter table 表名auto_increment &#x3D; 新的开始值；</p><p>如果自增列指定了 0 和 null，会在当前基础上继续自增，如果指定了具体值，直接赋值为具体值。</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 设置自增列</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key auto_increment,</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 auto_increment;</span><br><span class="line"></span><br><span class="line"># 删除自增列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型; #修改有自增列的字段，不加auto_increment就相当于删除</span><br></pre></td></tr></table></figure><h4 id="not-null-非空"><a href="#not-null-非空" class="headerlink" title="not null (非空)"></a>not null (非空)</h4><p>在列上定义了not null，那么当插入数据时，必须为列提供数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 建表时</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">id <span class="type">INT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">sex <span class="type">CHAR</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"># 建表后 </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> emp</span><br><span class="line">MODIFY sex <span class="type">VARCHAR</span>(<span class="number">30</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除非空约束</span><br><span class="line"># 去掉<span class="keyword">not</span> <span class="keyword">null</span>，相当于修改某个非注解字段，该字段允许为空</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型;</span><br></pre></td></tr></table></figure><h4 id="unique-唯一"><a href="#unique-唯一" class="headerlink" title="unique (唯一)"></a>unique (唯一)</h4><p>当定义了唯一约束后，该列的数据不能重复。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字段名 字段类型 <span class="keyword">UNIQUE</span></span><br></pre></td></tr></table></figure><ul><li>没有指定not null时，unique字段允许有多个null；</li><li>如果一个列， 约束了 unique not null ，则使用效果类似主键 primary key；</li><li>MySQL会给唯一约束的列上默认创建一个唯一索引。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 建表时</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span>,</span><br><span class="line">字段名 数据类型 <span class="keyword">unique</span> key,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">[<span class="keyword">constraint</span> 约束名] <span class="keyword">unique</span>(字段名)</span><br><span class="line">);</span><br><span class="line">#建表后</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 <span class="keyword">add</span> <span class="keyword">unique</span> (字段列表);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 字段类型 <span class="keyword">unique</span>；</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 复合唯一约束</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line">字段名 数据类型,</span><br><span class="line"><span class="keyword">unique</span> key(字段列表) #字段列表中写的是多个字段名，多个字段名用逗号分隔，表示那么是复合唯一，即多个字段的组合是唯一的</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除唯一约束：</p><p>删除时需要指定唯一索引名（唯一索引名 和 唯一约束名一样，如果是复合约束且没有指定约束名，则默认为组合里的第一列的名）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">DROP</span> INDEX 唯一索引名</span><br></pre></td></tr></table></figure><h4 id="foreign-key-外键"><a href="#foreign-key-外键" class="headerlink" title="foreign key (外键)"></a>foreign key (外键)</h4><p>用于定义主表和从表之间的关系：’</p><p>外键约束主要定义在从表上，主表则必须具有主键约束或unique约束，当定义外键约束后，要求 外键列的数据必须在主表的主键列存在 或为null；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">foreign</span> key(...) <span class="keyword">references</span> 主表(...)</span><br><span class="line"><span class="keyword">FOREIGN</span> KEY(本表列名) <span class="keyword">REFERENCES</span> 主表名(主键名<span class="operator">/</span><span class="keyword">unique</span>字段名)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 主表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> class (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , <span class="comment">-- 班级编号</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 从表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> stuent (</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY , </span><br><span class="line">    class_id <span class="type">INT</span> , <span class="comment">-- 学生所在班级的编号</span></span><br><span class="line"><span class="keyword">FOREIGN</span> KEY (class_id) <span class="keyword">REFERENCES</span> class(id)<span class="comment">-- 指定外键关系</span></span><br><span class="line">) </span><br><span class="line"></span><br><span class="line"># 建表后</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">ADD</span> [<span class="keyword">CONSTRAINT</span> 约束名] <span class="keyword">FOREIGN</span> KEY (从表的字段) <span class="keyword">REFERENCES</span> 主表名(被引用字段) [<span class="keyword">on</span> <span class="keyword">update</span> xx][<span class="keyword">on</span> <span class="keyword">delete</span> xx];</span><br></pre></td></tr></table></figure><ul><li>表的类型需要是innodb，这样的表才支持外键；一个表可以有多个 外键；</li><li>外键列的类型要和主键列的类型一致(长度可以不同)；</li><li>一旦建立主外键关系，主键列数据就不能随意删除，需要先删除依赖该记录的数据，即对应外键列的所有同一数据，才能删除主键的这一数据。</li><li>当创建外键约束时，系统会默认在所在的列上建立对应的普通索引，索引名是外键的约束名（根据外键查询效率很高）；删除外键约束后，必须手动删除对应的索引。</li></ul><p><strong>约束等级：</strong></p><ul><li>Cascade方式 ：在父表上update&#x2F;delete记录时，同步update&#x2F;delete子表的匹配记录 </li><li>Set null方式 ：在父表上update&#x2F;delete记录时，将子表上匹配记录的列设为null，但是要注意子 表的外键列不能为not null </li><li>No action方式 ：如果子表中有匹配的记录，则不允许对父表对应候选键进行update&#x2F;delete操作 </li><li>Restrict方式 ：同no action， 都是立即检查外键约束 </li><li>Set default方式（在可视化工具SQLyog中可能显示空白）：父表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别。</li></ul><blockquote><p>对于外键约束，最好是采用: on update cascade on delete restrict 的方式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> dept(</span><br><span class="line">did <span class="type">int</span> <span class="keyword">primary</span> key, #部门编号</span><br><span class="line">dname <span class="type">varchar</span>(<span class="number">50</span>) #部门名称</span><br><span class="line">);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp(</span><br><span class="line">eid <span class="type">int</span> <span class="keyword">primary</span> key, #员工编号</span><br><span class="line">ename <span class="type">varchar</span>(<span class="number">5</span>), #员工姓名</span><br><span class="line">deptid <span class="type">int</span>, #员工所在的部门</span><br><span class="line"><span class="keyword">foreign</span> key (deptid) <span class="keyword">references</span> dept(did) <span class="keyword">on</span> <span class="keyword">update</span> cascade <span class="keyword">on</span> <span class="keyword">delete</span> restrict#把修改操作设置为级联修改等级，把删除操作设置为restrict等级</span><br><span class="line">);</span><br></pre></td></tr></table></figure></blockquote><p>删除外键约束： </p><p>查看约束名——删除外键约束——查看索引名——删除外键索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第一步先查看约束名和删除外键约束</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.table_constraints <span class="keyword">WHERE</span> table_name <span class="operator">=</span> <span class="string">&#x27;表名称&#x27;</span>; #查看某个表的约束名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> <span class="keyword">FOREIGN</span> KEY 外键约束名;</span><br><span class="line"># 第二步查看索引名和删除索引。（注意，只能手动删除）</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名称;  #查看某个表的索引名</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 从表名 <span class="keyword">DROP</span> INDEX 索引名;</span><br></pre></td></tr></table></figure><blockquote><p>外键约束是用于保证数据的参照完整性的，因此主表与从表的存储引擎需要一致。</p><p>建不建外键约束和查询有没有关系。</p><blockquote><p>在 MySQL 里，外键约束是有成本的，需要消耗系统资源。对于大并发的 SQL 操作，有可能会不适 合。比如大型网站的中央数据库，可能会因为外键约束的系统开销而变得非常慢 。</p><p>所以，MySQL 允许不使用系统自带的外键约束，在应用层面完成检查数据一致性的逻辑。</p></blockquote><p><strong>阿里开发规范：不得使用外键与级联，一切外键概念必须在应用层解决。</strong></p><blockquote><p>级联更新：主键更新，外键跟着更新；</p><p>外键与级联更新 适用于单机低并发 ，不适合 分布式 、 高并发集群 ；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度 。</p></blockquote></blockquote><p>​                  </p><h4 id="check"><a href="#check" class="headerlink" title="check"></a>check</h4><p>用于强制数据必须满足的条件</p><p>（oracle和sql server支持check，mysql8.0才支持check）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列名 类型 <span class="keyword">CHECK</span>(<span class="keyword">check</span>条件)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> temp(</span><br><span class="line">id <span class="type">INT</span> AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">INT</span> <span class="keyword">CHECK</span>(age <span class="operator">&gt;</span> <span class="number">20</span>),</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="default"><a href="#default" class="headerlink" title="default"></a>default</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认值一般不加在唯一键和主键列上</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名称(</span><br><span class="line">字段名 数据类型 <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> 默认值,</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名称 modify 字段名 数据类型 <span class="keyword">default</span> 默认值; #如果字段原来有非空约束，并且要保留，需要在此句加上<span class="keyword">not</span> <span class="keyword">null</span>，否则非空约束会被删除</span><br></pre></td></tr></table></figure><blockquote><p>建表时，通常会加 not null default ‘’ 或  default 0，因为：</p><ul><li>null是特殊的值，比较时只能用专门的 is null 和 is not null 来比较。碰到运算符，通 常返回null。 </li><li>效率不高，影响提高索引效果。</li></ul></blockquote><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引可以极大加快查询的速度；</p><ul><li><p>使用索引会为该列形成一个索引的数据结构，如索引二叉树；</p></li><li><p>代价：额外占用磁盘空间；对dml语句(update, delete, insert) 的效率有影响，因为数据变动时需要重新维护索引结构</p></li><li><p>一般使用中，查询操作比增删改操作要多很多，因此索引很有必要</p></li></ul><p>索引的类型：</p><ul><li>主键索引：主键就是一个索引</li><li>唯一索引（unique）</li><li>普通索引（index）</li><li>全文索引：不适用mysql自带的fulltext，而是使用全文搜索Solr和ElasticSearch（ES）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#为列创建索引：</span><br><span class="line"><span class="comment">-- create index .. on ..</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> INDEX 索引名 <span class="keyword">ON</span> 表(列) <span class="comment">-- 唯一索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX 索引名 <span class="keyword">ON</span> 表(列) <span class="comment">-- 普通索引</span></span><br><span class="line"><span class="comment">-- alter table .. add index ..</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表 <span class="keyword">ADD</span> INDEX 索引名(列)</span><br><span class="line"></span><br><span class="line">#删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX 索引名 <span class="keyword">ON</span> 表</span><br><span class="line">#删除主键索引</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表 <span class="keyword">DROP</span> <span class="keyword">PRIMARY</span> KEY</span><br><span class="line"></span><br><span class="line">#修改索引：先删除，再修改</span><br><span class="line"></span><br><span class="line">#查询索引</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">SHOW</span> INDEXES <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">SHOW</span> KEYS <span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">DESC</span> 表</span><br></pre></td></tr></table></figure><p>索引使用：</p><p>频繁的作为查询条件的字段应创建索引；</p><p>唯一性太差的字段不适合单独创建索引，即使频繁查询；更新很频繁的字段也不适合创建索引（因为维护索引结构需要额外开销）；不会或极少作为查询条件出现的字段也不用创建索引</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务用于保证数据的一致性，事务期间的操作要么全部成，要么全部失败。</p><p>当执行事务操作时（dml语句），mysql会在表上加锁，防止其他用户修改表；</p><p>mysql的事务机制需要设置innodb的存储引擎才能使用</p><p><strong>事务ACID特性</strong>：</p><ul><li><strong>原子性（Atomicity）</strong>：原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生；</li><li><strong>一致性（Consistency）</strong>：事务必须使数据库从一个一致性状态变换到另一个一致性状态</li><li><strong>隔离性（Isolation）</strong>：事务的隔离性使多个用户并发访问数据库时，数据库未每个用户开启的事务不能被其他事务的操作所干扰，多个并发事务之间要相互隔离；</li><li><strong>持久性（Durability）</strong>：持久性是指一个事务一旦被提交，它对数据库中数据的改变是永久性的，即使数据库发生故障也不应该对其有影响</li></ul><h4 id="事务操作"><a href="#事务操作" class="headerlink" title="事务操作"></a>事务操作</h4><ul><li><p><strong>start transaction</strong> ：开启一个事务 （或者：set autocommit &#x3D; off ，即关闭自动提交）</p></li><li><p><strong>savepoint</strong>：设置保存点</p></li><li><p><strong>rollback to</strong> ：回退到某个保存点，回退后，会删除此保存点 以及 在其之后设置的保存点</p></li><li><p><strong>rollback</strong> ：回退全部事务，即回到事务开始的时候</p></li><li><p><strong>commit</strong>：提交事务，所有操作生效，不能再回退（确认事务的变化—结束事务—删除保存点—释放锁—数据生效）</p></li></ul><blockquote><p>DDL和DML的说明：</p><ul><li>DDL的操作一旦执行，就不可回滚；</li><li>DML的操作默认情况也不可回滚；想要回滚，需要在操作前设置：SET autocommit &#x3D; FALSE；</li></ul></blockquote><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th><th>加锁读</th></tr></thead><tbody><tr><td>读未提交(Read uncommitted)</td><td>Y</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>读已提交(Read committed)</td><td>N</td><td>Y</td><td>Y</td><td>不加锁</td></tr><tr><td>可重复读(Repeatable read)</td><td>N</td><td>N</td><td>Y</td><td>不加锁</td></tr><tr><td>可串行化(Serializable)</td><td>N</td><td>N</td><td>N</td><td>加锁</td></tr></tbody></table><p>脏读：当一个事务读取另一个事务还未提交的改变时，产生脏读</p><p>不可重复读：由于其他事务所提交的修改或删除操作，致使在同一事务中的同一查询返回不同结果，即发生不可重复读</p><p>幻读：由于其他事务所提交的插入操作，致使在同一事务中的同一查询返回不同结果，即发生幻读</p><p><strong>事务隔离级别操作：</strong></p><ul><li><p>设置当前会话隔离级别：</p><p><code>set session transaction isolation level &lt;u&gt;repeattable read&lt;/u&gt;;</code></p><p>设置系统当前隔离级别：</p><p><code>set global transaction isolation level &lt;u&gt;repeattable read&lt;/u&gt;;</code></p></li><li><p>查看当前会话隔离级别：</p><p><code>select @@tx_isolation;</code></p><p>查看系统当前隔离级别：</p><p><code>select @@global.tx_isolation;</code></p></li><li><p>mysql默认的事务隔离级别是repeatable read，一般都用，无需修改；</p></li><li><p>全局修改：直接修改my.ini配置文件，在末尾加上：</p><p><code>#可选参数有：READ-UNCOMMITTED, READ-COMMITTED, REPEATABLE-READ, SERIALIZABLE</code></p><p><code>[mysqld]</code></p><p><code>transaction-isolation = REPEATABLE-READ</code></p></li></ul><h2 id="表类型-x2F-存储引擎"><a href="#表类型-x2F-存储引擎" class="headerlink" title="表类型&#x2F;存储引擎"></a>表类型&#x2F;存储引擎</h2><p>mysql的表类型由存储引擎（Storage Engines）决定，</p><p>MySQL数据表主要支持六种类型：CSV，Memory，ARCHIVE，MRG_MYISAM，MYISAM，InnoDB；</p><p>其中<strong>InnoDB为事务安全型</strong>，其他五种为非事务安全型；</p><p>MYISAM：不支持事务，不支持外键，但访问速度快</p><p>InnoDB：支持事务安全，但读写的处理效率相比MYISAM差一些，且会占用更多的磁盘空间以保留数据和索引；</p><p>MEMORY：使用存在内存中的内容来创建表，每个MEMORY表实际对应一个磁盘文件。MEMORY类型的表访问非常快，因为它的数据放在内存中，且默认使用hash索引；但如果MySQL服务关闭，表中的数据就会丢失，而表的结构还在</p><p>修改存储引擎：</p><p><code>alter table 表名 engine = 存储引擎</code></p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是一个虚拟表，其内容由查询定义，同真实的表一样，视图包括列，其数据来自对应的基表（可以是多个基表）。通过视图可以修改基表的数据，基表的改变也会影响视图的数据。（视图中可以再使用视图，数据仍来自基表）</p><p>操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#创建：</span><br><span class="line">creat <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span> 语句</span><br><span class="line"></span><br><span class="line">#修改：</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名 <span class="keyword">as</span> <span class="keyword">select</span></span><br><span class="line"></span><br><span class="line">#显示创建视图的指令：</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">view</span> 视图名</span><br><span class="line"></span><br><span class="line">#删除视图：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> 视图名<span class="number">1</span>,视图名<span class="number">2</span></span><br></pre></td></tr></table></figure><p>视图的好处：</p><ul><li>安全：可以只让用户查询到需要的字段，一些保密的字段不能查看。</li><li>性能：视图存储的是查询语句，本身并不占用数据存储资源，减少了数据冗余。</li><li>灵活：可以在旧表上建立一张视图，然后映射到新表上，达到升级数据表的目的。</li></ul><p>视图的不足：</p><p>如果实际数据表的结构变更了，我们就需要及时对相关的视图进行相应的维护。特别是嵌套的视图（就是在视图的基础上创建视图），维护会变得比较复杂， 可读性不好 ，容易变成系统的潜在隐患。</p><p>实际项目中，如果视图过多，会导致数据库维护成本的问题。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查看视图</span><br><span class="line"># 查看数据库的表对象、视图对象</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"></span><br><span class="line"># 查看视图的结构</span><br><span class="line"><span class="keyword">DESC</span> 视图名;</span><br><span class="line"></span><br><span class="line"># 查看视图的属性信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLE</span> STATUS <span class="keyword">LIKE</span> <span class="string">&#x27;视图名&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看视图的详细定义信息</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 更新视图，跟更新表一样</span><br><span class="line"><span class="keyword">update</span> 视图名 <span class="keyword">set</span> 更新内容 <span class="keyword">where</span> ...</span><br><span class="line"></span><br><span class="line"># 删除数据，跟删除表数据一样</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 视图名 <span class="keyword">where</span> ...</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">view</span> 视图名 <span class="keyword">as</span> 查询语句</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">view</span> 视图名称 <span class="keyword">as</span> 查询语句</span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> if <span class="keyword">exists</span> 视图<span class="number">1</span>，视图<span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><p>视图作为虚拟表，主要用于 方便查询，不建议更新视图数据。</p></li><li><p>对视图数据的更改，都是通过对实际数据表的更新来完成。</p></li></ul><blockquote><p>一些不可更新的视图：</p><p>要使视图可更新，视图中的行和底层基本表中的行之间必须存在 一对一 的关系。</p><p>另外当视图定义出现如下情况时，视图不支持更新操作：</p><ul><li>在定义视图的时候指定了“ALGORITHM &#x3D; TEMPTABLE”，视图将不支持INSERT和DELETE操作； </li><li>视图中不包含基表中所有被定义为非空又未指定默认值的列，视图将不支持INSERT操作；</li><li>在定义视图的SELECT语句中使用了 JOIN联合查询 ，视图将不支持INSERT和DELETE操作； </li><li>在定义视图的SELECT语句后的字段列表中使用了 数学表达式 或 子查询 ，视图将不支持INSERT，也不支持UPDATE使用了数学表达式、子查询的字段值； </li><li>在定义视图的SELECT语句后的字段列表中使用 DISTINCT 、 聚合函数 、 GROUP BY 、 HAVING 、 UNION 等，视图将不支持INSERT、UPDATE、DELETE；</li><li>在定义视图的SELECT语句中包含了子查询，而子查询中引用了FROM后面的表，视图将不支持 INSERT、UPDATE、DELETE； </li><li>视图定义基于一个 不可更新视图 ； </li><li>常量视图。</li></ul></blockquote><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>mysql的用户，都存储在系统数据库mysql中的user表中;</p><p>user表的重要字段说明：</p><ul><li><strong>host</strong>：允许登录的“位置”&#x2F;IP，可以指定ip地址登录；其中localhost表示该用户只允许本机登录；</li><li><strong>user</strong>：用户名；</li><li><strong>authentication_string</strong>：密码，用mysql的password()函数加密过的密码字段</li></ul><p><strong>操作：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#创建用户，并指定密码：</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;允许登录位置&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span></span><br><span class="line"><span class="comment">-- 指定host时，可以写 % ，表示所有IP都有连接权限;IP也可以写成 192.168.1.% , 表示某用户的ip为 192.168.1.% z</span></span><br><span class="line"></span><br><span class="line">#删除用户：</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;允许登录位置&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#修改密码：</span><br><span class="line"><span class="comment">-- 修改自己的密码：</span></span><br><span class="line"><span class="keyword">set</span> password <span class="operator">=</span> password(<span class="string">&#x27;密码&#x27;</span>);</span><br><span class="line"><span class="comment">-- 修改他人的密码(需要有修改用户密码的权限):</span></span><br><span class="line"><span class="keyword">set</span> password <span class="keyword">for</span> <span class="string">&#x27;用户名&#x27;</span> @<span class="string">&#x27;登录位置&#x27;</span> <span class="operator">=</span> password(<span class="string">&#x27;密码&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>用户权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 给用户权限：</span><br><span class="line"><span class="keyword">grant</span> 权限列表 <span class="keyword">on</span> 库.对象名 <span class="keyword">to</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;登录位置&#x27;</span> [identified <span class="keyword">by</span> <span class="string">&#x27;密码&#x27;</span>]</span><br><span class="line"><span class="comment">-- 说明：权限列表写all表示赋予该用户在该对象上的所有权限</span></span><br><span class="line"><span class="comment">-- 库.对象名 写成 *.* : 代表系统中的所有数据库的所有对象(表，视图，存储过程); 写成 库.* : 代表某个数据库的所有数据对象(表，视图，存储过程);</span></span><br><span class="line"><span class="comment">-- identified by 可以省略，1.如果用户存在，就是修改该用户的密码; 2.如果该用户不存在，就是创建该用户;</span></span><br><span class="line"></span><br><span class="line">#回收用户权限：</span><br><span class="line"><span class="keyword">revoke</span> 权限列表 <span class="keyword">on</span> 库.对象名 <span class="keyword">from</span> <span class="string">&#x27;用户名&#x27;</span>@<span class="string">&#x27;登录位置&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#权限生效指令(如果权限没有生效，可以执行此命令)</span><br><span class="line">flush privileges</span><br></pre></td></tr></table></figure><hr><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><p>不同DBMS采用的函数有所不同，因此使用了SQL函数的代码，往往可移植性较差。</p></blockquote><h2 id="统计函数"><a href="#统计函数" class="headerlink" title="统计函数"></a>统计函数</h2><p>count, sum, avg, max, min</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#<span class="built_in">count</span>(<span class="operator">*</span>)会返回满足条件的记录的个数，<span class="built_in">count</span>(列名)同样返回满足条件的列的个数，但会排除为<span class="keyword">null</span>的情况</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> 表名 <span class="keyword">WHERE</span> 条件</span><br><span class="line"></span><br><span class="line">#<span class="built_in">sum</span>(列)返回满足条件的列的所有数值的总和(sum仅对数值起作用，对字符等没有意义; 对多列求和，逗号不能少)</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(列名)，<span class="built_in">SUM</span>(列名)...<span class="keyword">FROM</span> 表明；</span><br><span class="line"></span><br><span class="line">#avg返回满足条件的列的平均值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#max<span class="operator">/</span>min 返回满足列的最高值<span class="operator">/</span>最低值</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MIN</span>(列名) <span class="keyword">FROM</span> 表名</span><br></pre></td></tr></table></figure><blockquote><p>where 不能使用统计函数。</p></blockquote><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>group by .. having …. （having可对分组后结果进行过滤）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列, 列(可以是函数), 分组的列名 <span class="keyword">FROM</span> 表名 </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组的列名 <span class="keyword">HAVING</span> 过滤条件</span><br></pre></td></tr></table></figure><p>对比where和having：</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>WHERE</td><td>先筛选数据再关联，执行效率高</td><td>不能使用分组中的计算函数进行筛选</td></tr><tr><td>HAVING</td><td>可以使用分组中的计算函数</td><td>在最后的结果集中进行筛选，执行效率较低</td></tr></tbody></table><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#charset(str) 返回字串的字符集</span><br><span class="line"><span class="keyword">SELECT</span> CHARSET(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#concat(string1,string2...) 连接字符，可将多个列拼接成一列</span><br><span class="line"><span class="keyword">SELECT</span> CONCAT(列名,<span class="string">&#x27;string&#x27;</span>,列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#instr(stirng, substring) 返回substring在string中出现的位置，没有则放回<span class="number">0</span></span><br><span class="line"><span class="keyword">SELECT</span> INSTR(<span class="string">&#x27;STRING&#x27;</span>,<span class="string">&#x27;RING&#x27;</span>) <span class="keyword">FROM</span> DUAL  #dual 亚元表，是系统表，可用于测试表使用</span><br><span class="line"></span><br><span class="line">#ucase(stirng) 转换成大写</span><br><span class="line">#lcase(stirng) 转换成小写</span><br><span class="line"><span class="keyword">SELECT</span> UCASE(列名) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#<span class="keyword">left</span>(string, length) 从string中的左边起取length个字符</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">LEFT</span>(列名，<span class="number">2</span>) <span class="keyword">FROM</span> 表名</span><br><span class="line"></span><br><span class="line">#length(string) 返回string长度(按字节算)</span><br><span class="line"></span><br><span class="line">#replace(str, search_str, replace_str) 在str中用replace_str替换search_str</span><br><span class="line"><span class="keyword">SELECT</span> 列名<span class="number">1</span>， REPLACE(列名<span class="number">2</span>，<span class="string">&#x27;search_str&#x27;</span>,<span class="string">&#x27;replace_str&#x27;</span>) <span class="keyword">FROM</span> 表名 </span><br><span class="line"><span class="comment">/*搜索列名1，如果每行的列名2中有search_str，就用replace_str替换*/</span></span><br><span class="line"></span><br><span class="line">#strcmp(srting1, string2) 逐字符比较两字符大小</span><br><span class="line"></span><br><span class="line">#<span class="built_in">substring</span>(str, position, length) 从str的position开始(从<span class="number">1</span>开始计算)，取length个字符</span><br><span class="line"></span><br><span class="line">#ltrim(string) <span class="operator">/</span> rtrim(string) 取出前端空格<span class="operator">/</span>后端空格</span><br></pre></td></tr></table></figure><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- abs(num) 绝对值</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">ABS</span>(<span class="number">-10</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- bin(decimal_number )十进制转二进制</span></span><br><span class="line"><span class="keyword">SELECT</span> BIN(<span class="number">10</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- hex(DecimalNumber ) 转十六进制</span></span><br><span class="line"><span class="comment">-- oct(DecimalNumber ) 转八进制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- ceiling(number2 ) 向上取整, 得到比 num2 大的最小整数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CEILING</span>(<span class="number">-1.1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- floor(number2 ) 向下取整,得到比 num2 小的最大数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">FLOOR</span>(<span class="number">-1.1</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- conv(number2,from_base,to_base) 进制转换</span></span><br><span class="line"><span class="comment">-- 下面的含义是: 8 是十进制的, 转成 二进制输出</span></span><br><span class="line"><span class="keyword">SELECT</span> CONV(<span class="number">8</span>, <span class="number">10</span>, <span class="number">2</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="comment">-- 下面的含义是: 8 是 16 进制的, 转成 十进制输出</span></span><br><span class="line"><span class="keyword">SELECT</span> CONV(<span class="number">16</span>, <span class="number">16</span>, <span class="number">10</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- format(number,decimal_places ) 保留小数位数(四舍五入)</span></span><br><span class="line"><span class="keyword">SELECT</span> FORMAT(<span class="number">78.125458</span>,<span class="number">2</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- least(number , number2 [,..]) 求最小值</span></span><br><span class="line"><span class="keyword">SELECT</span> LEAST(<span class="number">0</span>,<span class="number">1</span>, <span class="number">-10</span>, <span class="number">4</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- mod(numerator ,denominator)  求余</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MOD</span>(<span class="number">10</span>, <span class="number">3</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- rand([seed]) RAND([seed]) 返回随机数 其范围为 0 ≤ v ≤ 1.0</span></span><br><span class="line"><span class="comment">-- 1. 如果使用 rand(), 每次返回不同的随机数 ，在 0 ≤ v ≤ 1.0</span></span><br><span class="line"><span class="comment">-- 2. 如果使用 rand(seed) 返回随机数, 范围 0 ≤ v ≤ 1.0, 如果seed不变，该随机数也不变(固定了)</span></span><br><span class="line"><span class="keyword">SELECT</span> RAND() <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- CURRENT_DATE ( ) 当前日期</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_DATE</span>() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- CURRENT_TIME ( )当前时间</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIME</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- CURRENT_TIMESTAMP ( ) 当前时间戳</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">CURRENT_TIMESTAMP</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line">#NOW() 返回当前时间</span><br><span class="line"><span class="keyword">SELECT</span> NOW() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line">#date_add(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中加上日期或时间</span><br><span class="line">#<span class="type">interval</span> 后可以是 <span class="keyword">year</span>，<span class="keyword">minute</span>，<span class="keyword">second</span>，<span class="keyword">day</span>等</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> DATE_ADD(send_time, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>) <span class="operator">&gt;=</span> NOW()</span><br><span class="line">#date_sub(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中减去日期或时间</span><br><span class="line">#<span class="type">interval</span> 后可以是 <span class="keyword">year</span>，<span class="keyword">minute</span>，<span class="keyword">second</span>，<span class="keyword">hour</span>，<span class="keyword">day</span>等</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> send_time <span class="operator">&gt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>)</span><br><span class="line"></span><br><span class="line">#datediff(date1, date2) 两个日期差(天)</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2011-11-11&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- YEAR|Month|DAY| DATE (datetime )</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">YEAR</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DAY</span>(NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MONTH</span>(<span class="string">&#x27;2013-11-10&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- unix_timestamp() : 返回的是 1970-1-1 到现在的秒数</span></span><br><span class="line"><span class="keyword">SELECT</span> UNIX_TIMESTAMP() <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 格式化日期</span></span><br><span class="line">DATE_FORMAT(<span class="type">date</span>,fmt) <span class="comment">-- 按照字符串fmt格式化日期date值</span></span><br><span class="line">TIME_FORMAT(<span class="type">time</span>,fmt) <span class="comment">-- 按照字符串fmt格式化时间time值</span></span><br><span class="line">GET_FORMAT(date_type,format_type) <span class="comment">-- 返回日期字符串的显示格式</span></span><br><span class="line">STR_TO_DATE(str, fmt) <span class="comment">-- 按照字符串fmt对str进行解析，解析为一个日期</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>常用格式符:</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203192048867.png" alt="image-20220319204809732"></p><p>常用取值：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203192049029.png" alt="image-20220319204902891"></p></blockquote><p>例子：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建测试表 信息表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mes(</span><br><span class="line">    id <span class="type">INT</span> ,</span><br><span class="line">    content <span class="type">VARCHAR</span>(<span class="number">30</span>), </span><br><span class="line">    send_time DATETIME</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加一条记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;北京新闻&#x27;</span>, <span class="built_in">CURRENT_TIMESTAMP</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">&#x27;上海新闻&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> mes <span class="keyword">VALUES</span>(<span class="number">3</span>, <span class="string">&#x27;广州新闻&#x27;</span>, NOW());</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示所有新闻信息，发布日期只显示 日期，不用显示时间. </span></span><br><span class="line"><span class="keyword">SELECT</span> id, content, <span class="type">DATE</span>(send_time) <span class="keyword">FROM</span> mes; </span><br><span class="line"><span class="comment">-- 查询在 10 分钟内发布的新闻</span></span><br><span class="line">#date_add(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中加上日期或时间</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> DATE_ADD(send_time, <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>) <span class="operator">&gt;=</span> NOW()</span><br><span class="line">#date_sub(data,<span class="type">interval</span> d_value d_type) 在<span class="type">date</span>中减去日期或时间</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mes <span class="keyword">WHERE</span> send_time <span class="operator">&gt;=</span> DATE_SUB(NOW(), <span class="type">INTERVAL</span> <span class="number">10</span> <span class="keyword">MINUTE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求出 2011-11-11 和 1990-1-1 相差多少天</span></span><br><span class="line">#datediff(date1, date2) 两个日期差(天)</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(<span class="string">&#x27;2011-11-11&#x27;</span>, <span class="string">&#x27;1990-01-01&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"><span class="comment">-- 求出你活了多少天? (假如1986-11-11 出生)</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(NOW(), <span class="string">&#x27;1986-11-11&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 如果你能活 80 岁，求出你还能活多少天. (1986-11-11 出生)</span></span><br><span class="line"><span class="comment">-- 先求出活 80 岁 时, 是什么日期 X</span></span><br><span class="line"><span class="comment">-- 然后在使用 datediff(x, now()); 1986-11-11-&gt;datetime</span></span><br><span class="line"><span class="comment">-- INTERVAL 80 YEAR ： YEAR 可以是 年月日，时分秒</span></span><br><span class="line"><span class="comment">-- &#x27;1986-11-11&#x27; 可以 date,datetime timestamp</span></span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(DATE_ADD(<span class="string">&#x27;1986-11-11&#x27;</span>, <span class="type">INTERVAL</span> <span class="number">80</span> <span class="keyword">YEAR</span>), NOW()) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> TIMEDIFF(<span class="string">&#x27;10:11:11&#x27;</span>, <span class="string">&#x27;06:10:10&#x27;</span>) <span class="keyword">FROM</span> DUAL; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- FROM_UNIXTIME() : 可以把一个 unix_timestamp 秒数[时间戳]，转成指定格式的日期</span></span><br><span class="line"><span class="comment">-- %Y-%m-%d 格式是规定好的，表示年月日</span></span><br><span class="line"><span class="comment">-- 意义：在开发中，可以存放一个整数，然后表示时间，通过 FROM_UNIXTIME 转换</span></span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1618483484</span>, <span class="string">&#x27;%Y-%m-%d&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"><span class="keyword">SELECT</span> FROM_UNIXTIME(<span class="number">1618483100</span>, <span class="string">&#x27;%Y-%m-%d %H:%i:%s&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br></pre></td></tr></table></figure><h2 id="加密函数"><a href="#加密函数" class="headerlink" title="加密函数"></a>加密函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">user</span>() 查询用户，可以查看登录到mysql的有哪些用户，以及登录的IP</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">USER</span>() <span class="keyword">FROM</span> DUAL;</span><br><span class="line">#database()查询当前使用的数据库名称</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br><span class="line"># MD5(str) 为字符串算出一个MD5(<span class="number">32</span>位)字符串，常用于(用户密码)加密</span><br><span class="line"># 在数据库中存放的应该是加密后的密码</span><br><span class="line"><span class="keyword">SELECT</span> MD5(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># SHA(STR),根据密码str计算并返回加密后的密码字符串，当参数为<span class="keyword">NULL</span>时，返回<span class="keyword">NULL</span>;</span><br><span class="line"># SHA加密算法比MD5更加安全 。</span><br><span class="line"><span class="keyword">SELECT</span> SHA(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># password(str)根据密码str计算并返回密码字符串，常用于数据库的用户密码加密</span><br><span class="line"><span class="keyword">SELECT</span> PASSWORD(<span class="string">&#x27;zzc&#x27;</span>) <span class="keyword">FROM</span> DUAL</span><br><span class="line"></span><br><span class="line"># encode(v,p):返回使用password_seed作为加密密码 加密<span class="keyword">value</span></span><br><span class="line">ENCODE(<span class="keyword">value</span>,password_seed) </span><br><span class="line">#返回使用password_seed作为加密密码 解密<span class="keyword">value</span></span><br><span class="line">DECODE(<span class="keyword">value</span>,password_seed) 返回使用password_seed作为加密密码解密<span class="keyword">value</span></span><br></pre></td></tr></table></figure><h2 id="流程函数"><a href="#流程函数" class="headerlink" title="流程函数"></a>流程函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># IF(expr1,expr2,expr3) 如果 expr1 为 <span class="literal">True</span> ,则返回 expr2 否则返回 expr3</span><br><span class="line"><span class="keyword">SELECT</span> IF(<span class="literal">TRUE</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># IFNULL(expr1,expr2) 如果expr1不为空,返回expr1, 否则返回expr2</span><br><span class="line"><span class="keyword">SELECT</span> IFNULL( <span class="keyword">NULL</span>, <span class="string">&#x27;mysql学习&#x27;</span>) <span class="keyword">FROM</span> DUAL;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">case</span> <span class="keyword">when</span> 条件<span class="number">1</span> <span class="keyword">then</span> 结果<span class="number">1</span> <span class="keyword">when</span> 条件<span class="number">2</span> <span class="keyword">then</span> 结果<span class="number">2</span> <span class="keyword">else</span> 结果<span class="number">3</span> <span class="keyword">end</span>; [类似多重分支.]</span><br><span class="line"># 类似: if...else if...else..</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;CLERK&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;职员&#x27;</span></span><br><span class="line">   <span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;经理&#x27;</span> </span><br><span class="line">    <span class="keyword">WHEN</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span> <span class="keyword">THEN</span> <span class="string">&#x27;销售人员&#x27;</span>   </span><br><span class="line">    <span class="keyword">ELSE</span> job <span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"># <span class="keyword">case</span> expr <span class="keyword">when</span> 常量<span class="number">1</span> <span class="keyword">then</span> 值<span class="number">1</span> <span class="keyword">when</span> 常量<span class="number">2</span> <span class="keyword">then</span> 值<span class="number">2</span> <span class="keyword">else</span> 值<span class="number">3</span> <span class="keyword">end</span>; </span><br><span class="line"># 类似: switch...case...</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span> x</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;我是1&#x27;</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span> <span class="string">&#x27;我是2&#x27;</span></span><br><span class="line"><span class="keyword">ELSE</span> <span class="string">&#x27;你是谁&#x27;</span></span><br></pre></td></tr></table></figure><h2 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FORMAT(<span class="keyword">value</span>,n) <span class="comment">-- 返回对数字value进行格式化后的结果数据。n表示 四舍五入 后保留到小数点后n位</span></span><br><span class="line">CONV(<span class="keyword">value</span>,<span class="keyword">from</span>,<span class="keyword">to</span>) <span class="comment">-- 将value的值进行不同进制之间的转换</span></span><br><span class="line">INET_ATON(ipvalue) <span class="comment">-- inet_aton(i): 将以点分隔的IP地址转化为一个数字</span></span><br><span class="line">INET_NTOA(<span class="keyword">value</span>) <span class="comment">-- inet_ntoa(v): 将数字形式的IP地址转化为以点分隔的IP地址</span></span><br><span class="line">BENCHMARK(n,expr) <span class="comment">-- benchmark(n,e): 将表达式expr重复执行n次。用于测试MySQL处理expr表达式所耗费的时间</span></span><br><span class="line"><span class="keyword">CONVERT</span>(<span class="keyword">value</span> <span class="keyword">USING</span> char_code) <span class="comment">-- 将value所使用的字符编码修改为char_code</span></span><br></pre></td></tr></table></figure><h1 id="存储过程和存储函数"><a href="#存储过程和存储函数" class="headerlink" title="存储过程和存储函数"></a>存储过程和存储函数</h1><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程 就是将一组经过预先编译的SQL语句封装。</p><p>执行流程：存储过程预先存储在mysql服务器上，用户需要的时候，只需要向服务器发出调用存储过程的命令，就像调用一个封装的方法一样，之后服务器就可以把预先存储好的这一系列SQL语句全部执行。</p><p>好处：</p><ul><li>简化操作，提高sql语言的重用性；</li><li>减少失误；</li><li>减少网络传输量，用户只需使用存储过程的名字即可；</li><li>减少sql语句暴露在网络上的风险，也提高数据查询的安全性；</li></ul><p>不足：</p><ul><li><p>可移植性差：</p><p>存储过程程不能跨数据库移植，比如在 MySQL、Oracle 和 SQL Server 里编写的存储过程，在换成其他数据库时都需要重新编写。</p></li><li><p>调试困难：</p><p>只有少数 DBMS 支持存储过程的调试。对于复杂的存储过程来说，开发和维护都不容 易。</p></li><li><p>版本管理困难：</p><p>比如数据表索引发生变化了，可能会导致存储过程失效。在开发软件的时候往往需要进行版本管理，但是存储过程本身没有版本控制，版本迭代更新的时候很麻烦。</p></li><li><p>不适合高并发：</p><p>高并发的场景需要减少数据库的压力，有时数据库会采用分库分表的方式，而且对可扩展性要求很高，在这种情况下，存储过程会变得难以维护，增加数据库的压力，显然就 不适用了。</p></li></ul><p>分类：</p><p>存储过程的参数有：IN，OUT，INOUT</p><ul><li>没有参数（无参数无返回）</li><li>仅带IN（有参数无返回）</li><li>仅带OUT（无参数有返回）</li><li>带IN，OUT（有参数有返回）</li><li>带INOUT（有参数有返回）</li></ul><blockquote><p>注：IN、OUT、INOUT 都可以在一个存储过程中带多个。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 创建 </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> 存储过程名 (<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型, ....) </span><br><span class="line">[charcateristics...]</span><br><span class="line"><span class="keyword">begin</span> </span><br><span class="line">存储过程体</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">call</span> 存储过程名(实参列表)</span><br><span class="line"># 调用<span class="keyword">in</span>模式的参数</span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="string">&#x27;值&#x27;</span>);</span><br><span class="line"># 调用<span class="keyword">out</span>模式的参数</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span>;</span><br><span class="line"><span class="keyword">CALL</span> SPQ(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br><span class="line">#调用<span class="keyword">inout</span>模式的参数</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@name</span><span class="operator">=</span>值;</span><br><span class="line"><span class="keyword">CALL</span> sp1(<span class="variable">@name</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@name</span>;</span><br></pre></td></tr></table></figure><p>因为mysql默认的语句结束符号为分号 ‘；‘，为了避免与存储过程的sql语句冲突，需要使用delimiter改变存储过程的结束符；</p><blockquote><p>如果使用的Navicat工具，那么在编写存储过程时，Navicat会自动设置 DELIMITER ，不需要自己再额外设置了。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> 存储过程名(<span class="keyword">IN</span><span class="operator">|</span><span class="keyword">OUT</span><span class="operator">|</span><span class="keyword">INOUT</span> 参数名 参数类型,...)</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">sql</span>语句<span class="number">1</span>;</span><br><span class="line"><span class="keyword">sql</span>语句<span class="number">2</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><blockquote><p>IN：当前函数为输入参数；存储过程只是读取这个参数的值。没有定义参数种类时，默认为IN；</p><p>OUT：当前参数为输出参数；执行完毕后，执行调用的客户端可以读取这个这个参数返回的值。</p><p>INOUT：当前参数即可为输入参数，也可为输出参数；</p><p>characteristics：表示创建存储过程时指定的对存储过程的约束条件，取值如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">language</span> <span class="keyword">sql</span></span><br><span class="line"><span class="operator">|</span> [<span class="keyword">not</span>] <span class="keyword">deterministic</span></span><br><span class="line"><span class="operator">|</span> &#123;<span class="keyword">contains</span> <span class="keyword">sql</span> <span class="operator">|</span> <span class="keyword">no</span> <span class="keyword">sql</span> <span class="operator">|</span> <span class="keyword">reads</span> <span class="keyword">sql</span> data <span class="operator">|</span> <span class="keyword">modifies</span> <span class="keyword">sql</span> data&#125;</span><br><span class="line"><span class="operator">|</span> <span class="keyword">sql</span> security &#123; definer <span class="operator">|</span> invoker &#125;</span><br><span class="line"><span class="operator">|</span> comment <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>LANGUAGE SQL ：说明存储过程执行体是由SQL语句组成的，当前系统支持的语言为SQL。</p><p>[NOT] DETERMINISTIC ：指明存储过程执行的结果是否确定。DETERMINISTIC表示结果是确定 的。每次执行存储过程时，相同的输入会得到相同的输出。NOT DETERMINISTIC表示结果是不确定的，相同的输入可能得到不同的输出。如果没有指定任意一个值，默认为NOT DETERMINISTIC。</p><p>{ CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA } ：指明子程序使 用SQL语句的限制。</p><ul><li>CONTAINS SQL表示当前存储过程的子程序包含SQL语句，但是并不包含读写数据的SQL语句； </li><li>NO SQL表示当前存储过程的子程序中不包含任何SQL语句； </li><li>READS SQL DATA表示当前存储过程的子程序中包含读数据的SQL语句； </li><li>MODIFIES SQL DATA表示当前存储过程的子程序中包含写数据的SQL语句。 </li><li>默认情况下，系统会指定为CONTAINS SQL。</li></ul><p>SQL SECURITY { DEFINER | INVOKER } ：执行当前存储过程的权限，即指明哪些用户能够执 行当前存储过程。</p><ul><li>DEFINER 表示只有当前存储过程的创建者或者定义者才能执行当前存储过程； </li><li>INVOKER 表示拥有当前存储过程的访问权限的用户能够执行当前存储过程。 </li><li>如果没有设置相关的值，则MySQL默认指定值为DEFINER。</li></ul><p>COMMENT ‘string’ ：注释信息，可以用来描述存储过程。</p></blockquote><h2 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h2><p>mysql允许自定义函数，调用方式与调用mysql的系统函数一样。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> 函数名(参数名 参数类型, ...)</span><br><span class="line"><span class="keyword">returns</span> 返回值类型</span><br><span class="line">[characteristics ...]</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">函数体</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"># <span class="keyword">returns</span>对函数而言是强制的，函数体必须包含一个<span class="keyword">RETURN</span> <span class="keyword">value</span>语句；</span><br><span class="line"># characteristic是创建函数时指定的对函数的约束。取值与创建存储过程时相同。</span><br></pre></td></tr></table></figure><p>调用：与调用mysql内部函数是一样的 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 函数名(实参列表)</span><br></pre></td></tr></table></figure><p>例子：</p><p>创建存储函数count_by_id()，参数传入dept_id，该函数查询dept_id部门的员工人数，并返回，数据类型 为整型。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> count_by_id(dept_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> <span class="type">INT</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">DETERMINISTIC</span></span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> DATA</span><br><span class="line"><span class="keyword">SQL</span> SECURITY DEFINER</span><br><span class="line">COMMENT <span class="string">&#x27;查询部门平均工资&#x27;</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">RETURN</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> department_id <span class="operator">=</span> dept_id);</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@dept</span>_id <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line"><span class="keyword">SELECT</span> count_by_id(<span class="variable">@dept</span>_id);</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th>关键字</th><th>调用语法</th><th>返回值</th><th>应用场景</th></tr></thead><tbody><tr><td>存储过程</td><td>procedure</td><td>call 存储过程()</td><td>0个或多个</td><td>一般用于更新</td></tr><tr><td>存储函数</td><td>function</td><td>select 函数()</td><td>只能一个</td><td>一般用于查询结果为一个值并返回时</td></tr></tbody></table><p><strong>查看存储过程和存储函数的</strong></p><p><strong>创建信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> &#123;<span class="keyword">procedure</span> <span class="operator">|</span> <span class="keyword">function</span>&#125; 存储过程名或函数名</span><br></pre></td></tr></table></figure><p><strong>状态信息：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 返回子程序的特征，如数据库，名字，类型，创建者，创建、修改日期</span><br><span class="line"><span class="keyword">show</span> &#123;<span class="keyword">procedure</span> <span class="operator">|</span> <span class="keyword">function</span>&#125; status [<span class="keyword">like</span> <span class="string">&#x27;pattern&#x27;</span>]</span><br><span class="line"># [<span class="keyword">LIKE</span> <span class="string">&#x27;pattern&#x27;</span>] 匹配存储过程或函数的名称，可省略。省略时，列出数据库中存在的所有存储过程和函数的信息。</span><br></pre></td></tr></table></figure><p><strong>存储信息：</strong></p><p>MySQL中存储过程和函数的信息放在 infornation_schema 数据库下的 Routines 表中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.Routines</span><br><span class="line"><span class="keyword">WHERE</span> ROUTINE_NAME<span class="operator">=</span><span class="string">&#x27;存储过程或函数名&#x27;</span> [<span class="keyword">AND</span> ROUNTINE_TYPE <span class="operator">=</span> &#123;<span class="string">&#x27;PROCEDURE | FUNCTION&#x27;</span>&#125;];</span><br><span class="line"># 如果存储过程和函数有同名的情况，可以指定routine_type来指明查的是存储过程还是函数。</span><br></pre></td></tr></table></figure><p><strong>修改：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; 存储过程或函数的名 [characteristic]</span><br></pre></td></tr></table></figure><blockquote><p>characteristic指定存储过程或函数的特性，其取值信息与创建存储过程、函数时的取值信息略有不同。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">CONTAINS</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">NO</span> <span class="keyword">SQL</span> <span class="operator">|</span> <span class="keyword">READS</span> <span class="keyword">SQL</span> DATA <span class="operator">|</span> <span class="keyword">MODIFIES</span> <span class="keyword">SQL</span> DATA &#125; </span><br><span class="line"><span class="operator">|</span> <span class="keyword">SQL</span> SECURITY &#123; DEFINER <span class="operator">|</span> INVOKER &#125;</span><br><span class="line"><span class="operator">|</span> COMMENT <span class="string">&#x27;string&#x27;</span></span><br></pre></td></tr></table></figure><p>CONTAINS SQL ，表示子程序包含SQL语句，但不包含读或写数据的语句。</p><p>NO SQL ，表示子程序中不包含SQL语句。 </p><p>READS SQL DATA ，表示子程序中包含读数据的语句。 </p><p>MODIFIES SQL DATA ，表示子程序中包含写数据的语句。 </p><p>SQL SECURITY { DEFINER | INVOKER } ，指明谁有权限来执行。</p><ul><li>DEFINER ，表示只有定义者自己才能够执行。</li><li>INVOKER ，表示调用者可以执行。</li></ul><p>COMMENT ‘string’ ，表示注释信息。</p></blockquote><p><strong>删除：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> &#123;<span class="keyword">PROCEDURE</span> <span class="operator">|</span> <span class="keyword">FUNCTION</span>&#125; [IF <span class="keyword">EXISTS</span>] 存储过程或函数的名</span><br></pre></td></tr></table></figure><blockquote><p>IF EXISTS：如果程序或函数不存储，它可以防止发生错误，产生一个用SHOW WARNINGS查看的警告。</p></blockquote><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>MySQL常用列类型(数据类型)</p><ul><li>数值类型<ul><li>整型：tinyint（1个字节）smallint（2个字节）mediumint（3个字节）<strong>int</strong>（4个字节）bigint（8个字节）decimal[M, 0]（数值长度为M）</li><li>小数类型：float（单精度4字节）<strong>double</strong>（双精度8字节）**decimal[M,D]**（数值长度M，小数部分长度D；M最大65，D最大30；M被省略则默认为10，D被省略则默认为0)</li></ul></li><li>文本类型（字符串类型）<ul><li><strong>char</strong> （0~255字符，固定长）</li><li><strong>varchar</strong> （0<del>65535 即 最大放0</del>2^16 - 1字节，可变长，实际占用空间看存放多少数据，varchar本身需要占用1~3个字节来记录存放内容的长度）<ul><li>查询速度：char &gt; varchar</li><li>varchar 存放大小的单位写的仍是字符，但存放上下限是按字节算的</li></ul></li><li><strong>text</strong>  （0~ 2^16 - 1）</li><li>longtext （0~2^32 - 1）</li></ul></li><li>二进制数据类型<ul><li>blob （0~2^16 - 1）</li><li>longblob （0~2^32 - 1）</li></ul></li><li>日期类型<ul><li>date （日期 年月日   3字节）</li><li>time （时间 时分秒   3字节）</li><li><strong>datetime</strong> （年月日 时分秒  YYYY-MM-DD HH:mm:ss    8字节）</li><li><strong>timestamp</strong> （时间戳，会自动更新   4字节）<ul><li>自动更新时间戳为当前时间：login_time（列名） TIMESTAMP（数据类型：时间戳） NOT NULL DEFAULT CURRENT_TIMESTAMP  ON UPDATE CURRENT_TIMESTAMP</li></ul></li><li>year (年   1字节)</li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203211046909.png" alt="image-20220321104640615"></p><p>常用的类型介绍：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203211047881.png" alt="image-20220321104728683"></p><blockquote><p>MySQL在执行建表语句时，将id字段的类型默认设置为int(11)，这里的11是指int类型的显示宽度，默认的显示宽度为11。</p></blockquote><p>使用建议：</p><ul><li><p>任何字段如果为非负数，应该加unsigned</p></li><li><p>整数：int</p></li><li><p>小数：decimal，如果存储的数据范围超过，建议将数据拆成整数和小数并分开存储。</p></li><li><p>日期时间：datetime</p></li><li><p>字符串：</p><ul><li>如果存储的字符串长度几乎相等，使用char定长字符串类型；</li><li>varchar不预先分配存储空间，长度不要超过5000，如果超过，应该定义为text，并独立出来一张表，用主键来对应，避免影响其他字段索引效率。</li></ul></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>变量由系统定义，属于服务器层面。启动MySQL服务，生成MySQL服务实例期间， MySQL将为MySQL服务器内存中的系统变量赋值，这些系统变量定义了当前MySQL服务实例的属性、特征。</p><blockquote><p>系统变量的值大都是 编译MySQL时参数的默认值，或配置文件(如 .ini)中的参数值。</p></blockquote><ul><li><p><strong>global 全局系统变量</strong>，也简称全局变量</p></li><li><p><strong>session 会话系统变量</strong>，也可称 local变量，</p></li></ul><blockquote><p>如果没有加global关键字，则默认为会话级别。</p><p>静态变量属于特殊的全局系统变量。</p></blockquote><p>每个客户机功连接MySQL服务器后，都会产生与之对应的会话。</p><p>会话期间，MySQL服务实例 会在MySQL服务器内存中生成与该会话对应的会话系统变量，这些会话系统变量的初始值是全局系统变量值的复制。</p><ul><li>全局系统变量针对于所有会话（连接）有效，但不能 跨重启 (即重启服务);</li><li>修改会话变量仅影响当前的会话&#x2F;连接， 不会影响其他会话的同一会话系统变量的值。</li><li>修改全局系统变量的值会导致 同一会话系统的其他会话 的全局系统变量改变。</li></ul><p>查看系统变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 查看所有全局变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES;</span><br><span class="line"># 查看所有会话变量</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES;</span><br><span class="line"><span class="keyword">SHOW</span> VARIABLES;</span><br><span class="line"></span><br><span class="line"># 查看满足条件的系统<span class="operator">/</span>会话变量</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span>;</span><br><span class="line"><span class="keyword">SHOW</span> SESSION VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;%标识符%&#x27;</span></span><br><span class="line"># 例如:</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GLOBAL</span> VARIABLES <span class="keyword">LIKE</span> <span class="string">&#x27;ADMIN_%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 查看指定的系统变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.变量名;</span><br><span class="line"></span><br><span class="line"># 查看指定的会话变量的值</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@session</span>.变量名;</span><br><span class="line"><span class="keyword">SELECT</span> @@变量名;</span><br></pre></td></tr></table></figure><p>修改系统变量的值：</p><p>方法1：修改MySQL配置文件，继而修改MySQL系统变量的值（需要重启MySQL服务）</p><p>方法2：使用 set命令 重新设置系统变量的值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#为某个系统变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@global</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line">#为某个会话变量赋值</span><br><span class="line"><span class="keyword">SET</span> @<span class="variable">@session</span>.变量名<span class="operator">=</span>变量值;</span><br><span class="line"><span class="keyword">SET</span> SESSION 变量名<span class="operator">=</span>变量值;</span><br><span class="line"></span><br><span class="line"># 例如：</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.autocommit;</span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> max_connections<span class="operator">=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">SELECT</span> @<span class="variable">@global</span>.max_connections;</span><br></pre></td></tr></table></figure><hr><p>MySQL8.0新特性：全局变量的持久化</p><p>使用 set global 语句设置的变量值只会 临时生效，数据库重启后又变成默认值。</p><p>而使用 set persist 命令，会将该命令的配置保存到数据目录下的musql-auto.cnf文件中，下次数据库重启时会读取该文件，用其中的配置来覆盖默认的配置文件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 例：设服务器最大连接数为1000</span></span><br><span class="line"><span class="keyword">SET</span> PERSIST <span class="keyword">global</span> max_connections <span class="operator">=</span> <span class="number">1000</span>;</span><br></pre></td></tr></table></figure><h2 id="用户变量"><a href="#用户变量" class="headerlink" title="用户变量"></a>用户变量</h2><p>mysql中的用户变量以 一个 @ 开头，分为 会话用户变量和局部变量。</p><ul><li>会话用户变量：作用域和会话变量一样，只对 当前连接 会话有效。</li><li>局部变量：只在 BEGIN 和 END 语句块中有效。局部变量只能在 存储过程和函数 中使用。</li></ul><table><thead><tr><th></th><th>作用域</th><th>定义位置</th><th>语法</th></tr></thead><tbody><tr><td>会话用户变量</td><td>当前会话</td><td>会话的任何地方</td><td>加@符号，不用指定类型</td></tr><tr><td>局部变量</td><td>定义它的begin end中</td><td>begin end的第一句话</td><td>一般不加@，需指定类型</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 会话用户变量的定义</span><br><span class="line">#方式<span class="number">1</span>：“<span class="operator">=</span>”或“:<span class="operator">=</span>”</span><br><span class="line"><span class="keyword">SET</span> @用户变量 <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> @用户变量 :<span class="operator">=</span> 值;</span><br><span class="line"></span><br><span class="line">#方式<span class="number">2</span>：“:<span class="operator">=</span>” 或 <span class="keyword">INTO</span>关键字</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量 :<span class="operator">=</span> 表达式 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"><span class="keyword">SELECT</span> 表达式 <span class="keyword">INTO</span> @用户变量 [<span class="keyword">FROM</span> 等子句];</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line"><span class="keyword">SELECT</span> @用户变量</span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@a</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@num</span> :<span class="operator">=</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@num</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> <span class="variable">@avgSalary</span> <span class="keyword">FROM</span> employee;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@avgSalary</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="variable">@big</span>;   <span class="comment">-- 查看未声明变量时，得到NULL值</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 局部变量 的定义 <span class="keyword">declare</span>只能放在begin...end中的第一句</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"># 声明</span><br><span class="line"><span class="keyword">DECLARE</span> 变量<span class="number">1</span> 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];  <span class="comment">-- 默认初始值是NULL</span></span><br><span class="line"><span class="keyword">DECLARE</span> 变量<span class="number">2</span>,变量<span class="number">3</span>,... 变量数据类型 [<span class="keyword">DEFAULT</span> 变量默认值];</span><br><span class="line"></span><br><span class="line"># 赋值</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">1</span> <span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SET</span> 变量名<span class="number">1</span> :<span class="operator">=</span> 值;</span><br><span class="line"><span class="keyword">SELECT</span> 值 <span class="keyword">INTO</span> 变量名<span class="number">2</span> [<span class="keyword">FROM</span> 子句];</span><br><span class="line"><span class="keyword">SELECT</span> 字段名或表达式 <span class="keyword">INTO</span> 变量名<span class="number">2</span> <span class="keyword">FROM</span> 表;</span><br><span class="line"></span><br><span class="line"># 查看</span><br><span class="line"><span class="keyword">SELECT</span> 变量<span class="number">1</span>,变量<span class="number">2</span>,变量<span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> set_value()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> emp_name <span class="type">VARCHAR</span>(<span class="number">25</span>);</span><br><span class="line"><span class="keyword">DECLARE</span> sal <span class="keyword">DOUBLE</span>(<span class="number">10</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> last_name,salary <span class="keyword">INTO</span> emp_name,sal</span><br><span class="line"><span class="keyword">FROM</span> employees</span><br><span class="line"><span class="keyword">WHERE</span> employee_id <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> emp_name,sal;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure><h1 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h1><p><strong>定义条件</strong>：事先定义程序执行过程中可能遇到的问题；</p><p><strong>处理程序</strong>：定义了在遇到问题时应当采取的处理方式，并且保证存储过程或函数在遇到警告或错误时能继续执行。——增强了处理问题的能力，避免程序异常停止运行。</p><blockquote><p>定义条件和处理程序在存储过程、存储函数中都是支持的。</p></blockquote><p>在存储过程中未定义条件和处理程序，且当存储过程中执行的SQL语句报错时，MySQL数据库会抛出错误，并退出当前SQL逻辑， 不再向下继续执行。</p><h3 id="定义条件"><a href="#定义条件" class="headerlink" title="定义条件"></a>定义条件</h3><p>定义条件就是给MySQL中的错误码 命名，它将一个错误名字和指定的错误条件关联起来。这个名字随后被用在定义处理程序的 declare handler 语句中。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> 错误名称 <span class="keyword">condition</span> <span class="keyword">for</span> 错误码(或错误条件)</span><br></pre></td></tr></table></figure><blockquote><p>错误码的说明：</p><p>MySQL_error_code 和 sqlstate_value 都可以表示MySQL的错误。</p><ul><li>MySQL_error_code是数值类型错误代码。 </li><li>sqlstate_value是长度为5的字符串类型错误代码。</li></ul><p>例如：</p><p>在ERROR 1418 (HY000)中，1418是MySQL_error_code，’HY000’是sqlstate_value。 </p><p>在ERROR 1142（42000）中，1142是MySQL_error_code，’42000’是sqlstate_value。</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 例: 给违反非空约束的错误类型“ERROR <span class="number">1048</span>(<span class="number">23000</span>)”定义</span><br><span class="line">#使用MySQL_error_code</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1048</span>;</span><br><span class="line">#使用sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> Field_Not_Be_NULL <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="定义处理程序"><a href="#定义处理程序" class="headerlink" title="定义处理程序"></a>定义处理程序</h3><p>为SQL执行过程中发生的某种类型的错误定义特殊的处理程序。</p><p>语法格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DECLARE</span> 处理方式 HANDLER <span class="keyword">FOR</span> 错误类型 处理语句</span><br></pre></td></tr></table></figure><p>处理方式有三种：continue，exit，undo</p><ul><li>CONTINUE：遇到错误不处理，继续执行；</li><li>EXIT：遇到错误马上退出；</li><li>UNDO：遇到错误后撤回之前的操作，MySQL中暂时不支持。</li></ul><p>错误类型：</p><ul><li>SQLSTATE ‘字符串错误码’ ：表示长度为5的sqlstate_value类型的错误代码； </li><li>MySQL_error_code ：匹配数值类型错误代码； </li><li>错误名称 ：表示DECLARE … CONDITION定义的错误条件名称。 </li><li>SQLWARNING ：匹配所有以01开头的SQLSTATE错误代码； </li><li>NOT FOUND ：匹配所有以02开头的SQLSTATE错误代码； </li><li>SQLEXCEPTION ：匹配所有没有被SQLWARNING或NOT FOUND捕获的SQLSTATE错误代码；</li></ul><p>处理语句：可以是“set 变量 &#x3D; 值”这样简单的语句，也可以是使用“begin….end”的复合语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 定义处理程序的几种方式举例：</span><br><span class="line">#方法<span class="number">1</span>：捕获sqlstate_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;42S02&#x27;</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">2</span>：捕获mysql_error_value</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> <span class="number">1146</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">3</span>：先定义条件，再调用</span><br><span class="line"><span class="keyword">DECLARE</span> no_such_table <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="number">1146</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE HANDLER <span class="keyword">FOR</span> NO_SUCH_TABLE <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">4</span>：使用<span class="keyword">SQLWARNING</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLWARNING</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">5</span>：使用<span class="keyword">NOT</span> FOUND</span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">NOT</span> FOUND <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;NO_SUCH_TABLE&#x27;</span>;</span><br><span class="line"></span><br><span class="line">#方法<span class="number">6</span>：使用<span class="keyword">SQLEXCEPTION</span></span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> <span class="keyword">SQLEXCEPTION</span> <span class="keyword">SET</span> <span class="variable">@info</span> <span class="operator">=</span> <span class="string">&#x27;ERROR&#x27;</span>;</span><br></pre></td></tr></table></figure><p>示例：</p><p>创建一个名称为“InsertDataWithCondition”的存储过程：在存储过程中，定义处理程序，捕获sqlstate_value值，当遇到sqlstate_value值为23000（重复条目错误）时，执行EXIT操 作，并且将@proc_value的值设置为-1。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> InsertDataWithCondition()</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> duplicate_entry <span class="keyword">CONDITION</span> <span class="keyword">FOR</span> <span class="keyword">SQLSTATE</span> <span class="string">&#x27;23000&#x27;</span> ;</span><br><span class="line"><span class="keyword">DECLARE</span> EXIT HANDLER <span class="keyword">FOR</span> duplicate_entry <span class="keyword">SET</span> <span class="variable">@proc</span>_value <span class="operator">=</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> departments(department_name) <span class="keyword">VALUES</span>(<span class="string">&#x27;测试&#x27;</span>);</span><br><span class="line"><span class="keyword">SET</span> <span class="variable">@x</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1 id="流程控制与游标"><a href="#流程控制与游标" class="headerlink" title="流程控制与游标"></a>流程控制与游标</h1><p>流程控制：控制存储过程中sql语句的执行顺序。分别有三大类：顺序结构，分支结构，循环结构。</p><p>流程控制语句（只能用于存储程序）：</p><ul><li>条件判断语句：if 和 case语句</li><li>循环语句：loop，while，repeat语句</li><li>跳转语句：iterate 和 leave语句</li></ul><p><strong>分支结构—— IF</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># if</span><br><span class="line">IF 表达式<span class="number">1</span> <span class="keyword">THEN</span> 操作<span class="number">1</span></span><br><span class="line">[ELSEIF 表达式<span class="number">2</span> <span class="keyword">THEN</span> 操作<span class="number">2</span>]....</span><br><span class="line">[<span class="keyword">ELSE</span> 操作n]</span><br><span class="line"><span class="keyword">END</span> IF</span><br><span class="line"></span><br><span class="line"># 例：</span><br><span class="line">IF val <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="keyword">SELECT</span> <span class="string">&#x27;val is null&#x27;</span>;</span><br><span class="line"><span class="keyword">ELSE</span> <span class="keyword">SELECT</span> <span class="string">&#x27;val is not null&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line">#</span><br><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_by_eid2(<span class="keyword">IN</span> emp_id <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> emp_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> hire_year <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> emp_salary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">SELECT</span> DATEDIFF(CURDATE(),hire_date)<span class="operator">/</span><span class="number">365</span> <span class="keyword">INTO</span> hire_year <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;<span class="comment">-- DATEDIFF()判断日期差，curdate()获取当前日期</span></span><br><span class="line">IF emp_salary <span class="operator">&lt;</span> <span class="number">8000</span> <span class="keyword">AND</span> hire_year <span class="operator">&gt;</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">THEN</span> <span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">500</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span></span><br><span class="line">emp_id;</span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> emp_id;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>分支结构——CASE</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">case</span></span><br><span class="line"># <span class="number">1.</span>类似于switch</span><br><span class="line"><span class="keyword">CASE</span> 表达式</span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">WHEN</span> 值<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>] <span class="comment">-- 如果是放在begin end中需要加上case，如果放在select后面不需要</span></span><br><span class="line"></span><br><span class="line"># <span class="number">2.</span>类似于多重if</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span>或语句<span class="number">1</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span>或语句<span class="number">2</span> <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ELSE</span> 结果n或语句n <span class="comment">-- 如果是语句，需要加分号</span></span><br><span class="line"><span class="keyword">END</span> [<span class="keyword">case</span>] <span class="comment">-- 如果是放在begin end中需要加上case，如果放在select后面不需要</span></span><br></pre></td></tr></table></figure><p><strong>循环结构——LOOP</strong></p><p>LOOP内的语句一直重复执行直到循环被退出（使用LEAVE子句）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[loop_label:] LOOP</span><br><span class="line">循环执行的语句</span><br><span class="line"><span class="keyword">END</span> LOOP [loop_label]</span><br><span class="line"><span class="comment">-- loop_label表示LOOP语句的标注名称，参数可省略。</span></span><br></pre></td></tr></table></figure><p>示例：</p><p>涨工资—— 声明存储过程 “update_salary_loop()”，声明OUT参数num，输出循环次数。存储过程中实现循环给大家涨薪，薪资涨为 原来的1.1倍。直到全公司的平均薪资达到12000结束。并统计循环次数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> update_salary_loop(<span class="keyword">OUT</span> num <span class="type">INT</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> avg_salary <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> loop_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line"></span><br><span class="line">label_loop:LOOP</span><br><span class="line">IF avg_salary <span class="operator">&gt;=</span> <span class="number">12000</span> <span class="keyword">THEN</span> LEAVE label_loop;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> employees <span class="keyword">SET</span> salary <span class="operator">=</span> salary <span class="operator">*</span> <span class="number">1.1</span>;</span><br><span class="line"><span class="keyword">SET</span> loop_count <span class="operator">=</span> loop_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(salary) <span class="keyword">INTO</span> avg_salary <span class="keyword">FROM</span> employees;</span><br><span class="line"><span class="keyword">END</span> LOOP label_loop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> num <span class="operator">=</span> loop_count;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p><strong>循环结构——WHILE</strong></p><p>WHILE语句创建一个带条件判断的循环过程。WHILE在执行语句执行时，先对指定的表达式进行判断，如 果为真，就执行循环内的语句，否则退出循环。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[while_label:] WHILE 循环条件 DO</span><br><span class="line">循环体</span><br><span class="line"><span class="keyword">END</span> WHILE [while_label];</span><br></pre></td></tr></table></figure><p><strong>循环结构——REPEAT</strong></p><p>REPEAT语句创建一个带条件判断的循环过程。与WHILE循环不同的是，REPEAT 循环首先会执行一次循环，然后在 UNTIL 中进行表达式的判断，如果满足条件就退出 。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[repeat_label:] REPEAT</span><br><span class="line">循环体</span><br><span class="line">UNTIL 结束循环的条件表达式</span><br><span class="line"><span class="keyword">END</span> REPEAT [repeat_label]</span><br></pre></td></tr></table></figure><blockquote><p>三种循环的对比：</p><ul><li><p>都可以省略名称，但如果循环中添加了循环控制语句（LEAVE或ITERATE）则必须添加名称。</p></li><li><p>LOOP：一般用于实现简单的”死”循环 </p><p>WHILE：先判断后执行 </p><p>REPEAT：先执行后判断，无条件至少执行一次</p></li></ul></blockquote><p><strong>跳转语句——LEAVE</strong></p><p>LEAVE语句：可以用在循环语句内，或者以 BEGIN 和 END 包裹起来的程序体内，表示跳出循环或者跳出 程序体的操作。(类似于编程语言的break)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LEAVE 标记名</span><br></pre></td></tr></table></figure><p><strong>跳转语句——ITERATE</strong></p><p>iterate语句只能用在循环语句（LOOP、REPEAT和WHILE语句）内，表示重新开始循环，将执行顺序转到语句段开头处。（类似于编程语言的continue）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ITERATE label</span><br></pre></td></tr></table></figure><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标提供一种灵活的操作方式，能够对结果集中的每一条记录 进行定位，并对指向的记录中的数据进行操作的数据结构。</p><blockquote><p>在SQL中，游标是一种临时的数据库对象，可以指向存储在数据库表中的数据行指针。即<strong>充当了指针的作用</strong>。</p><p>游标让 面向集合的SQL语言有了面向过程开发的能力。</p></blockquote><blockquote><p>一些性能问题：</p><p>游标可以在存储程序中使用，效率高，程序也更加简洁，比在应用层实现相同的功能要好。</p><p>但在使用游标的过程中，会对数据行进行 加锁 ，这样在业务并发量大的时候，不仅会影响业务之间的效率，还会消耗系统资源 ，造成内存不足，这是因为游标是在内存中进 行的处理。</p><p>所以要在用完后及时关闭，这样才能提高系统整体效率。</p></blockquote><p>使用步骤：</p><p>游标必须在 声明处理程序之前 被声明，且 变量和条件必须在声明游标&#x2F;处理程序之前 被声明。</p><ul><li><p>第一步：声明游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 适用于MySQL,<span class="keyword">SQL</span> Server,DB2 和 MariaDB</span><br><span class="line"><span class="keyword">DECLARE</span> 游标名 <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> 查询语句<span class="operator">/</span>结果集</span><br><span class="line"></span><br><span class="line"># 适用于Oricle,PostgreSQL</span><br><span class="line"><span class="keyword">DECLARE</span> 有标明 <span class="keyword">CURSOR</span> <span class="keyword">IS</span> 查询语句<span class="operator">/</span>结果集</span><br></pre></td></tr></table></figure></li><li><p>第二步：打开游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> 游标名</span><br></pre></td></tr></table></figure><p>打开游标时， SELECT 语句的查询结果集就会送到游标工作区，为后面游标的 <u>逐条读取</u> 结果集中的记录做准备。</p></li><li><p>第三步：使用游标（从游标中取得数据）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FETCH</span> 游标名 <span class="keyword">INTO</span> 变量名[,变量名...]</span><br></pre></td></tr></table></figure><p>将游标读取到的行数据 保存到变量名中，然后指针指向下一行。</p><blockquote><p>查询结果集的字段数，必须与into后的变量数一致。</p></blockquote></li><li><p>第四步：关闭游标</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CLOSE</span> 游标名</span><br></pre></td></tr></table></figure><p>游标会占用系统资源，不关闭的话，会保持到存储过程结束。</p></li></ul><p>示例：</p><p>创建存储过程“get_count_by_limit_total_salary()”，声明IN参数 limit_total_salary，DOUBLE类型；声明OUT参数total_count，INT类型。函数的功能可以实现累加薪资最高的几个员工的薪资值，直到薪资总和 达到limit_total_salary参数的值，返回累加的人数给total_count。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> get_count_by_limit_total_salary(<span class="keyword">IN</span> limit_total_salary <span class="keyword">DOUBLE</span>,<span class="keyword">OUT</span></span><br><span class="line">total_count <span class="type">INT</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> sum_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录累加的总工资</span><br><span class="line"><span class="keyword">DECLARE</span> cursor_salary <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录某一个工资值</span><br><span class="line"><span class="keyword">DECLARE</span> emp_count <span class="type">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>; #记录循环个数</span><br><span class="line">#定义游标</span><br><span class="line"><span class="keyword">DECLARE</span> emp_cursor <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> salary <span class="keyword">FROM</span> employees <span class="keyword">ORDER</span> <span class="keyword">BY</span> salary <span class="keyword">DESC</span>;</span><br><span class="line">#打开游标</span><br><span class="line"><span class="keyword">OPEN</span> emp_cursor;</span><br><span class="line"></span><br><span class="line">REPEAT</span><br><span class="line">#使用游标（从游标中获取数据）</span><br><span class="line"><span class="keyword">FETCH</span> emp_cursor <span class="keyword">INTO</span> cursor_salary;</span><br><span class="line"><span class="keyword">SET</span> sum_salary <span class="operator">=</span> sum_salary <span class="operator">+</span> cursor_salary;</span><br><span class="line"><span class="keyword">SET</span> emp_count <span class="operator">=</span> emp_count <span class="operator">+</span> <span class="number">1</span>;</span><br><span class="line">UNTIL sum_salary <span class="operator">&gt;=</span> limit_total_salary</span><br><span class="line"><span class="keyword">END</span> REPEAT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> total_count <span class="operator">=</span> emp_count;</span><br><span class="line">#关闭游标</span><br><span class="line"><span class="keyword">CLOSE</span> emp_cursor;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器是由事件 来触发某个操作，这些事件包括 INSERT 、 UPDATE 、 DELETE 事件。</p><p>如果定义了触发程序，当数据库执行这些语句时候，就相当于事件发生 了，就会 自动 激发触发器执行相应的操作。</p><p>当对数据表中的数据执行插入、更新和删除操作，需要自动执行一些数据库逻辑时，可以使用触发器来 实现。</p><p>优点：</p><ul><li>可以确保数据的完整性；—— 比如一张表的修改会影响其他表的数据，则使用触发器就可以同步多个表了。</li><li>可以记录操作日志；—— 利用触发器，可以具体记录什么时间发生了什么。</li><li>操作数据前对数据进行合法性检查；</li></ul><p>缺点：</p><ul><li>可读性差；—— 因为 触发器存储在数据库中，且由事件驱动，这意味着触发器可以不受应用层的控制。使得触发器发生错误时可能难以发现。</li><li>相关数据的变更，可能导致触发器出错；—— 特别是表结构的变更，都可能导致触发器的出错。</li></ul><p><strong>创建：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名称</span><br><span class="line">&#123;BEFORE<span class="operator">|</span>AFTER&#125; &#123;<span class="keyword">INSERT</span><span class="operator">|</span><span class="keyword">UPDATE</span><span class="operator">|</span><span class="keyword">DELETE</span>&#125; <span class="keyword">ON</span> 表名</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line">触发器执行的语句快;</span><br><span class="line"> <span class="comment">-- 表名：是触发器监控的对象;  </span></span><br><span class="line"> <span class="comment">-- before|after:触发的事件，before指在事件之前触发，after指在事件之后触发</span></span><br><span class="line"> <span class="comment">-- INSERT|UPDATE|DELETE ：表示触发的事件。</span></span><br><span class="line"> <span class="comment">-- INSERT 表示插入记录时触发；</span></span><br><span class="line"><span class="comment">-- UPDATE 表示更新记录时触发；</span></span><br><span class="line"> <span class="comment">-- DELETE 表示删除记录时触发。 </span></span><br><span class="line"> <span class="comment">-- 触发器执行的语句块：可以是单条SQL语句，也可以是由BEGIN…END结构组成的复合语句块。</span></span><br></pre></td></tr></table></figure><p>示例：</p><p>定义触发器“salary_check_trigger”，基于员表“employees”的INSERT事件，在INSERT之前检查 将要添加的新员工薪资是否大于他领导的薪资，如果大于领导薪资，则报sqlstate_value为’HY000’的错 误，从而使得添加失败。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> salary_check_trigger</span><br><span class="line">BEFORE <span class="keyword">INSERT</span> <span class="keyword">ON</span> employees <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> mgrsalary <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> salary <span class="keyword">INTO</span> mgrsalary <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> employee_id <span class="operator">=</span> NEW.manager_id;</span><br><span class="line"></span><br><span class="line">IF NEW.salary <span class="operator">&gt;</span> mgrsalary <span class="keyword">THEN</span></span><br><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;薪资高于领导薪资错误&#x27;</span>;</span><br><span class="line"><span class="keyword">END</span> IF;</span><br><span class="line"><span class="keyword">END</span> <span class="operator">/</span><span class="operator">/</span></span><br><span class="line"></span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><blockquote><p>在触发器的执行语句块中，可以使用 NEW. 指代被监听的表发生添加或修改的那条记录；</p><p>要自定义错误，则使用以下格式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SIGNAL <span class="keyword">SQLSTATE</span> <span class="string">&#x27;HY000&#x27;</span> <span class="keyword">SET</span> MESSAGE_TEXT <span class="operator">=</span> <span class="string">&#x27;...&#x27;</span>;</span><br></pre></td></tr></table></figure></blockquote><p><strong>查看：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 语句结尾不加；加\G，数据显示较清晰直观，但SQLyog不识别</span></span><br><span class="line"># 查看当前数据库的所有触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> TRIGGERS</span><br><span class="line"></span><br><span class="line"># 查看当前数据库中某个触发器的定义</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> 触发器名</span><br><span class="line"></span><br><span class="line"># 从系统库information_schema的TRIGGERS表中查询所有触发器的信息</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> information_schema.TRIGGERS;</span><br></pre></td></tr></table></figure><p><strong>删除：</strong></p><p>触发器也是数据库对象，所以也用DROP语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> IF <span class="keyword">EXISTS</span> 触发器名称;</span><br></pre></td></tr></table></figure><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><p>JDBC是java提供的一套用于数据库操作的接口API，不同的数据库厂商会针对这套接口，提供不同实现。</p><p>JDBC 为访问不同的数据库提供了统一的接口，为使用者屏蔽了细节问题（JDBC统一和规范了应用程序和数据库的连接，执行SQL语句，并得到返回结果等操作）；</p><p>使用JDBC可以连接任何提供了JDBC驱动程序的数据库系。</p><h3 id="JDBC程序编写步骤"><a href="#JDBC程序编写步骤" class="headerlink" title="JDBC程序编写步骤"></a>JDBC程序编写步骤</h3><ol><li>注册驱动 – 加载Driver类</li><li>获取连接 – 得到Connection</li><li>执行增删改查 – 发送SQL给mysql执行</li><li>释放资源 – 关闭相关连接</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">       <span class="comment">// 前置工作: 在项目下创建一个文件夹比如 libs</span></span><br><span class="line">       <span class="comment">// 将 mysql.jar 拷贝到该目录下，并将其添加为库</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//1. 注册驱动</span></span><br><span class="line">       <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>();</span><br><span class="line"></span><br><span class="line">       <span class="comment">//2. 得到连接:</span></span><br><span class="line">       <span class="comment">// jdbc:mysql:// 规定好协议，通过jdbc方式连接mysql</span></span><br><span class="line">       <span class="comment">// localhost  指主机，可以是ip地址</span></span><br><span class="line">       <span class="comment">// 3306 表示mysql监听的端口</span></span><br><span class="line">       <span class="comment">// zzc_db02 连接到mysql的哪个数据库</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/zzc_db02&quot;</span>;</span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">       properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>);</span><br><span class="line">       <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3. 执行sql</span></span><br><span class="line">       <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from actor where id = 1&quot;</span>;</span><br><span class="line">       <span class="comment">//statement 用于执行静态SQL语句并返回其生成的结果的对象</span></span><br><span class="line">       <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connect.createStatement();</span><br><span class="line">       <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> statement.executeUpdate(sql);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4. 关闭连接资源</span></span><br><span class="line">       statement.close();</span><br><span class="line">       connect.close();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="获取数据库连接"><a href="#获取数据库连接" class="headerlink" title="获取数据库连接"></a>获取数据库连接</h3><p>获取数据库连接的5种方法，常用方法4，5：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect01</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Driver</span>(); <span class="comment">//创建 driver 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="comment">//将 用户名和密码放入到 Properties 对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    System.out.println(connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, SQLException &#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver 类 , 动态加载，更加的灵活，减少依赖性</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="comment">//将 用户名和密码放入到 Properties 对象</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//说明 user 和 password 是规定好，后面的值根据实际情况写</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;root&quot;</span>);<span class="comment">// 用户</span></span><br><span class="line">    properties.setProperty(<span class="string">&quot;password&quot;</span>, <span class="string">&quot;zzc&quot;</span>); <span class="comment">//密码</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connect</span> <span class="operator">=</span> driver.connect(url, properties);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 2=&quot;</span> + connect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 3 使用 DriverManager 替代 driver 进行统一管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect03</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">//使用反射加载 Driver</span></span><br><span class="line">    Class&lt;?&gt; aClass = Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="type">Driver</span> <span class="variable">driver</span> <span class="operator">=</span> (Driver) aClass.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;zzc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册 Driver 驱动</span></span><br><span class="line">    DriverManager.registerDriver(driver);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第三种方式=&quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 4: 使用 Class.forName 自动完成注册驱动，简化代码</span></span><br><span class="line"><span class="comment">//这种方式获取连接是使用的最多，推荐使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect04</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">// 使用反射加载了 Driver 类</span></span><br><span class="line">    <span class="comment">// 在加载 Driver 类时，完成注册</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    源码:</span></span><br><span class="line"><span class="comment">    1. 静态代码块，在类加载时，会执行一次.</span></span><br><span class="line"><span class="comment">    2. DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">    3. 因此注册 driver 的工作已经完成</span></span><br><span class="line"><span class="comment">        static &#123;</span></span><br><span class="line"><span class="comment">            try &#123;</span></span><br><span class="line"><span class="comment">                DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">            &#125; catch (SQLException var1) &#123;</span></span><br><span class="line"><span class="comment">                throw new RuntimeException(&quot;Can&#x27;t register driver!&quot;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//创建 url 和 user 和 password</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:mysql://localhost:3306/hsp_db02&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> <span class="string">&quot;root&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> <span class="string">&quot;zzc&quot;</span>;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;第 4 种方式~ &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 5 , 在方式 4 的基础上改进，增加配置文件，让连接 mysql 更加灵活</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">connect05</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, SQLException &#123;</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    System.out.println(<span class="string">&quot;方式 5 &quot;</span> + connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JDBC-API"><a href="#JDBC-API" class="headerlink" title="JDBC API"></a>JDBC API</h3><h4 id="DriverManger"><a href="#DriverManger" class="headerlink" title="DriverManger"></a>DriverManger</h4><p>驱动管理类</p><p><strong>getConnection(url, user, pwd)</strong> : 获取到连接</p><hr><h4 id="Connection-接口"><a href="#Connection-接口" class="headerlink" title="Connection 接口"></a>Connection 接口</h4><p><strong>createStatement()</strong> ：创建Statement对象</p><hr><h4 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h4><p>Statement对象用于执行静态SQL语句并返回其生成的结果的对象；</p><p>但使用Statement存在SQL注入的风险：SQL注入是利用利用某些系统没有对用户输入数据进行充分检查，而在输入数据中注入非法的SQL语句，恶意攻击数据库；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM admin</span><br><span class="line">WHERE NAME = &#x27;1&#x27; OR&#x27; AND pwd = &#x27;OR &#x27;1&#x27;= &#x27;1&#x27;</span><br><span class="line"># SQL注入例子：万能密码 or &#x27;1&#x27;= &#x27;1</span><br><span class="line"># 后面的 &#x27;1&#x27;=&#x27;1&#x27; 必定为真，且前面都是OR，所以这条语句查询的内容在数据库中没有，但它依然能通过</span><br></pre></td></tr></table></figure><p>推荐使用<strong>PreparedStatement取代</strong>Statement，可以防止SQL注入；</p><p>方法：</p><p><strong>executeUpdate(sql)</strong> ：执行dml语句，返回影响的行数；</p><p>**executeQuery(sql)**：执行查询，返回ResultSet对象；</p><p>**execute(sql)**：执行任意的sql，返回布尔值；</p><p>Statement使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Statement01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="comment">//让用户输入管理员名和密码</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>); <span class="comment">//</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">admin_name</span> <span class="operator">=</span> scanner.nextLine(); <span class="comment">//如果希望看到SQL注入，这里需要用 nextLine; 因为用next():当接收到 空格或者 &#x27;就是表示结束</span></span><br><span class="line">        System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">admin_pwd</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//获取相关的值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 注册驱动</span></span><br><span class="line">        Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">        <span class="comment">//2. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="comment">//3. 得到 Statement</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">        <span class="comment">//4. 组织 SqL</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name , pwd from admin where name =&#x27;&quot;</span> </span><br><span class="line">                + admin_name + <span class="string">&quot;&#x27; and pwd = &#x27;&quot;</span> + admin_pwd + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">if</span> (resultSet.next()) &#123; <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">            System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭连接</span></span><br><span class="line">        resultSet.close();</span><br><span class="line">        statement.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h4><p>PreparedStatement 执行的SQL语句中的参数用问号(?)来表示；</p><p>调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数， .setXxx() 方法有两个参数，第一个参数是SQL语句中的参数的索引（从1开始，第几个问号），第二个参数是设置的 SQL语句中的参数的值；</p><p>方法：</p><p><strong>executeUpdate(sql)</strong> ：执行dml语句，返回影响的行数；</p><p>**executeQuery(sql)**：执行查询，返回ResultSet对象；</p><p>**execute(sql)**：执行任意的sql，返回布尔值；</p><p>**setXxx(占位符索引，占位符的值)**：将指定位置的参数设置为给定值（解决了SQL注入）</p><p>**setObject(占位符索引，占位符的值)**：将指定位置的参数设置为给定的对象</p><p>PreparedStatement使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preparedStatement</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//让用户输入管理员名和密码</span></span><br><span class="line">    System.out.print(<span class="string">&quot;请输入管理员的名字: &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">admin_name</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    System.out.print(<span class="string">&quot;请输入管理员的密码: &quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">admin_pwd</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line"></span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">//3. 得到 PreparedStatement</span></span><br><span class="line">    <span class="comment">//3.1 组织SqL, 其中，Sql语句的 ? 就相当于占位符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name , pwd from admin where name =? and pwd = ?&quot;</span>;</span><br><span class="line">    <span class="comment">//3.2 preparedStatement 对象实现了 PreparedStatement 接口的实现类的对象</span></span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line">    <span class="comment">//3.3 给 ? 赋值</span></span><br><span class="line">    preparedStatement.setString(<span class="number">1</span>, admin_name);</span><br><span class="line">    preparedStatement.setString(<span class="number">2</span>, admin_pwd);</span><br><span class="line">    <span class="comment">//4. 执行 select 语句使用 executeQuery</span></span><br><span class="line">    <span class="comment">// 如果执行的是 dml(update, insert ,delete) executeUpdate()</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> preparedStatement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">if</span> (resultSet.next()) &#123;     <span class="comment">//如果查询到一条记录，则说明该管理存在</span></span><br><span class="line">        System.out.println(<span class="string">&quot;恭喜， 登录成功&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对不起，登录失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    preparedStatement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ResultSet"><a href="#ResultSet" class="headerlink" title="ResultSet"></a>ResultSet</h4><p>ResultSet是结果集，表示数据库结果集的数据表，通常通过执行查询数据库的语句生成；</p><p>ResultSet对象保持一个光标指向当前的数据行，最初，光标位于第一行之前，next方法将光标移到下一行，且在ResultSet对象中没有更多行时返回false，因此可以在while循环中用来遍历结果集</p><p>方法：</p><p>**next()**：向下移动一行，如果没有下一行，返回false；</p><p>**previous()**：向上移动一行，如果没有上一行，返回false；</p><p><strong>getXxx( 列的索引 &#x2F; 列名)</strong> ：返回对应列的值，接收类型是Xxx</p><p><strong>getObject(列的索引&#x2F; 列名)</strong> ：返回索引对应的值，接收类型为Object</p><p>ResultSet使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ResultSet01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//通过 Properties 对象获取配置文件的信息</span></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">    <span class="comment">//获取相关的值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">    <span class="comment">//1. 注册驱动</span></span><br><span class="line">    Class.forName(driver);<span class="comment">//建议写上</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 得到连接</span></span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    <span class="comment">//3. 得到 Statement</span></span><br><span class="line">    <span class="type">Statement</span> <span class="variable">statement</span> <span class="operator">=</span> connection.createStatement();</span><br><span class="line">    <span class="comment">//4. 组织 SqL</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name , sex, borndate from actor&quot;</span>;</span><br><span class="line">    <span class="comment">//执行给定的 SQL 语句，该语句返回单个 ResultSet 对象</span></span><br><span class="line">    <span class="type">ResultSet</span> <span class="variable">resultSet</span> <span class="operator">=</span> statement.executeQuery(sql);</span><br><span class="line">    <span class="comment">//5. 使用 while 取出数据</span></span><br><span class="line">    <span class="keyword">while</span> (resultSet.next()) &#123; <span class="comment">// 让光标向后移动，如果没有更多行，则返回 false</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> resultSet.getInt(<span class="number">1</span>); <span class="comment">//获取该行的第 1 列</span></span><br><span class="line">        <span class="comment">//int id1 = resultSet.getInt(&quot;id&quot;); 通过列名来获取值, 推荐</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> resultSet.getString(<span class="number">2</span>);<span class="comment">//获取该行的第 2 列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> resultSet.getString(<span class="number">3</span>);</span><br><span class="line">        <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> resultSet.getDate(<span class="number">4</span>);</span><br><span class="line">        System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + date);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6. 关闭连接</span></span><br><span class="line">    resultSet.close();</span><br><span class="line">    statement.close();</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="JDBCUtils-封装"><a href="#JDBCUtils-封装" class="headerlink" title="JDBCUtils(封装)"></a>JDBCUtils(封装)</h3><p>在jdbc操作中，获取连接和释放资源 是经常使用到的，可以将其封装到  JDBC连接的工具类JDBCUtils中。</p><p>JDBCUtils 实现示例 以及 使用 ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDBCUtils实现实例:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtils</span> &#123;</span><br><span class="line">    <span class="comment">//定义相关的属性(4个), 因为只需要一份，因此，我们做出 static</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password; <span class="comment">//密码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url; <span class="comment">//url</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver; <span class="comment">//驱动名</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//在static代码块中进行初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">            <span class="comment">//读取相关的属性值</span></span><br><span class="line">            user = properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            url = properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            driver = properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//在实际开发中，我们可以这样处理</span></span><br><span class="line">            <span class="comment">//1. 将编译异常转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者 可以选择捕获该异常，也可以选择默认处理该异常，比较方便.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接数据库, 返回 Connection</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//1. 将编译异常转成 运行异常</span></span><br><span class="line">            <span class="comment">//2. 调用者，可以选择捕获该异常，也可以选择默认处理该异常，比较方便.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭相关资源</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. ResultSet 结果集</span></span><br><span class="line"><span class="comment">    2. Statement 或者 PreparedStatement</span></span><br><span class="line"><span class="comment">    3. Connection</span></span><br><span class="line"><span class="comment">    4. 如果需要关闭资源，就传入对象，否则传入 null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet set, Statement statement, Connection connection)</span> &#123;</span><br><span class="line">        <span class="comment">//判断是否为 null</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (set != <span class="literal">null</span>) &#123;</span><br><span class="line">                set.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">//将编译异常转成运行异常抛出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用实例:</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JDBCUtils_Use</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2. 组织一个 sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 创建 PreparedStatement 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtils.getConnection();</span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, <span class="number">5</span>);<span class="comment">//给?号赋值</span></span><br><span class="line">            <span class="comment">//执行, 得到结果集</span></span><br><span class="line">            set = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">//遍历该结果集</span></span><br><span class="line">            <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> set.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> set.getString(<span class="string">&quot;sex&quot;</span>);</span><br><span class="line">                <span class="type">Date</span> <span class="variable">borndate</span> <span class="operator">=</span> set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + borndate + <span class="string">&quot;\t&quot;</span> + phone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtils.close(set, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Druid实现JDBCUtils</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用Druid实现JDBCUtils</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在静态代码块完成 ds 初始化</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">            ds = DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编写 getConnection 方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭连接, 注意：在数据库连接池技术中，close不是真的断掉连接，而是把使用的 Connection 对象放回连接池</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(ResultSet resultSet, Statement statement, Connection connection)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultSet != <span class="literal">null</span>) &#123;</span><br><span class="line">                resultSet.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (statement != <span class="literal">null</span>) &#123;</span><br><span class="line">                statement.close();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (connection != <span class="literal">null</span>) &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JDBCUtilsByDruid_USE</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelect</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 得到连接</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//2. 组织一个 sql</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//3. 创建 PreparedStatement 对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="comment">// System.out.println(connection.getClass());  运行类型 com.alibaba.druid.pool.DruidPooledConnection</span></span><br><span class="line">            preparedStatement = connection.prepareStatement(sql);</span><br><span class="line">            preparedStatement.setInt(<span class="number">1</span>, <span class="number">1</span>);<span class="comment">//给问号赋值</span></span><br><span class="line">            <span class="comment">//执行, 得到结果集</span></span><br><span class="line">            set = preparedStatement.executeQuery();</span><br><span class="line">            <span class="comment">//遍历该结果集</span></span><br><span class="line">            <span class="keyword">while</span> (set.next()) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> set.getInt(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> set.getString(<span class="string">&quot;name&quot;</span>);<span class="comment">//getName()</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> set.getString(<span class="string">&quot;sex&quot;</span>);<span class="comment">//getSex()</span></span><br><span class="line">                <span class="type">Date</span> <span class="variable">borndate</span> <span class="operator">=</span> set.getDate(<span class="string">&quot;borndate&quot;</span>);</span><br><span class="line">                <span class="type">String</span> <span class="variable">phone</span> <span class="operator">=</span> set.getString(<span class="string">&quot;phone&quot;</span>);</span><br><span class="line">                System.out.println(id + <span class="string">&quot;\t&quot;</span> + name + <span class="string">&quot;\t&quot;</span> + sex + <span class="string">&quot;\t&quot;</span> + borndate + <span class="string">&quot;\t&quot;</span> + phone);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//关闭资源</span></span><br><span class="line">            JDBCUtilsByDruid.close(set, preparedStatement, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h3><p>JDBC程序中当一个Connection对象创建时，默认是自动提交事务的（语句执行成功，就会向数据库自动提交，而不能回滚）。</p><p>JDBC 使用事务：</p><ul><li>使用Connection的setAutoCommit (false) 可以取消自动提交事务；</li><li>在所有sql语句成功执行后，调用Connection的commit() 方法提交事务；</li><li>当其中某个操作失败或出现异常，调用Connection的rollback() 方法回滚事务；</li></ul><blockquote><p>在异常捕获中，可以将 setAutoCommit (false) 方法和 commit() 方法放在try语句块中，将 rollback() 方法放在catch中，当出现异常时，就可以进行回滚</p></blockquote><h3 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。</p><p>JDBC连接MySQL时，如果要使用批处理功能，要在url中加参数： <strong>rewriteBatchedStatements&#x3D;true</strong></p><p>批处理往往和PreparedStatement搭配使用，可以减少编译次数，运行次数，提高效率；</p><p>方法：</p><p>addBatch() ：添加需要批量处理的SQL语句或参数；</p><p>executeBatch() ：执行批量处理语句；</p><p>clearBatch() ：清空批处理包的语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">batch</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtils.getConnection();</span><br><span class="line">    <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;insert into admin2 values(null, ?, ?)&quot;</span>;</span><br><span class="line">    <span class="type">PreparedStatement</span> <span class="variable">preparedStatement</span> <span class="operator">=</span> connection.prepareStatement(sql);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;    <span class="comment">//5000次执行</span></span><br><span class="line">        preparedStatement.setString(<span class="number">1</span>, <span class="string">&quot;jack&quot;</span> + i);</span><br><span class="line">        preparedStatement.setString(<span class="number">2</span>, <span class="string">&quot;666&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        //addBatch源码:</span></span><br><span class="line"><span class="comment">        public void addBatch () throws SQLException &#123;</span></span><br><span class="line"><span class="comment">            synchronized (this.checkClosed().getConnectionMutex()) &#123;</span></span><br><span class="line"><span class="comment">                if (this.batchedArgs == null) &#123;</span></span><br><span class="line"><span class="comment">                    this.batchedArgs = new ArrayList();</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                for (int i = 0; i &lt; this.parameterValues.length; ++i) &#123;</span></span><br><span class="line"><span class="comment">                    this.checkAllParametersSet(this.parameterValues[i], this.parameterStreams[i], i);</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">                this.batchedArgs.add(new PreparedStatement.BatchParams(this.parameterValues, this.parameterStreams, this.isStream, this.streamLengths, this.isNull));</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        preparedStatement.addBatch();</span><br><span class="line">        <span class="comment">//当有 1000 条记录时，再批量执行，并清空批处理包</span></span><br><span class="line">        <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">1000</span> == <span class="number">0</span>) &#123;<span class="comment">//满 1000 条 sql</span></span><br><span class="line">            preparedStatement.executeBatch();</span><br><span class="line">            preparedStatement.clearBatch();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭连接</span></span><br><span class="line">    JDBCUtils.close(<span class="literal">null</span>, preparedStatement, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>传统的 JDBC数据库使用DriverManager来获取连接的弊端：</p><ul><li>每次向数据库建立连接都要将Connection加载到内存中，再验证IP地址，用户名和密码(0.05~1s)。</li><li>频繁的进行数据库连接操作将占用很多的系统资源，容易造成服务器崩溃。</li><li>每一次数据库连接，使用完后都得断开，如果程序出现异常而未能关闭，将导致数据库内存泄漏。</li><li>不能控制连接的方式，不能控制创建的连接数量，如果连接过多，会导致内存泄漏，MySQL崩溃。</li></ul><p>因此有了数据库连接池技术（connection pool）。</p><p>JDBC的数据库连接池使用javax.sql.DataSource来表示， DataSource只是一个接口，该接口通常由第三方提供实现；</p><ul><li><strong>C3P0</strong> 数据库连接池：速度相对较慢，稳定性不错；</li><li>DBCP 数据库连接池：速度较C3P0快，但不稳定；</li><li>Proxool 数据库连接池：有监控连接池状态的功能，稳定性较C3P0差一些；</li><li>BoneCp 数据库连接池：速度快；</li><li>**Druid(德鲁伊)**是阿里提供的数据库连接池，集DBCP，C3P0，Proxool有点于一身的数据库连接池；</li></ul><h4 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式 1： 相关参数，在程序中指定 user, url , password 等</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0_01</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 创建一个数据源对象</span></span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>();</span><br><span class="line">        <span class="comment">//2. 通过配置文件 mysql.properties 获取相关连接的信息</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">        <span class="comment">//读取相关的属性值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">driver</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;driver&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//给数据源 comboPooledDataSource 设置相关的参数</span></span><br><span class="line">        <span class="comment">//注意：连接管理是由 comboPooledDataSource 来管理</span></span><br><span class="line">        comboPooledDataSource.setDriverClass(driver);</span><br><span class="line">        comboPooledDataSource.setJdbcUrl(url);</span><br><span class="line">        comboPooledDataSource.setUser(user);</span><br><span class="line">        comboPooledDataSource.setPassword(password);</span><br><span class="line">        <span class="comment">//设置初始化连接数</span></span><br><span class="line">        comboPooledDataSource.setInitialPoolSize(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//最大连接数</span></span><br><span class="line">        comboPooledDataSource.setMaxPoolSize(<span class="number">50</span>);</span><br><span class="line">        <span class="comment">//测试连接池的效率, 测试对 mysql 5000 次操作</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection(); <span class="comment">//这个方法就是从 DataSource 接口实现的</span></span><br><span class="line">            <span class="comment">//其他操作略</span></span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;c3p0 5000 连接 mysql 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二种方式 使用配置文件模板来完成</span></span><br><span class="line">    <span class="comment">//1. 将 c3p0 提供的 c3p0.config.xml 拷贝到 src 目录下</span></span><br><span class="line">    <span class="comment">//2. 该文件指定了连接数据库和连接池的相关参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testC3P0_02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ComboPooledDataSource</span> <span class="variable">comboPooledDataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ComboPooledDataSource</span>(<span class="string">&quot;hsp_edu&quot;</span>);</span><br><span class="line">        <span class="comment">//测试 5000 次连接 mysql</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;开始执行....&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">            <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> comboPooledDataSource.getConnection();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;c3p0 的第二种方式(500000) 耗时=&quot;</span> + (end - start));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruid</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="comment">//1. 加入 Druid.jar 包</span></span><br><span class="line">       <span class="comment">//2. 加入 配置文件 druid.properties (将该文件拷贝项目的src目录)</span></span><br><span class="line">       <span class="comment">//3. 创建 Properties 对象, 读取配置文件</span></span><br><span class="line">       <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">       properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\druid.properties&quot;</span>));</span><br><span class="line">       <span class="comment">//4. 创建一个指定参数的数据库连接池, Druid 连接池</span></span><br><span class="line">       <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> DruidDataSourceFactory.createDataSource(properties);</span><br><span class="line">       <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500000</span>; i++) &#123;</span><br><span class="line">           <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">           <span class="comment">//其他操作</span></span><br><span class="line">           connection.close();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">       System.out.println(<span class="string">&quot;druid 连接池 操作 500000 耗时=&quot;</span> + (end - start));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h3><p>DBUtils是对JDBC的封装，使用dbutils可以极大简化jdbc的编码的工作量。</p><p>DBUtils类：</p><ul><li><strong>QueryRunner</strong>类：该类封装了SQL的执行，是线程安全的。可以实现 增，删，改，查，批处理；</li><li><strong>ResultSetHandler</strong>接口：该接口用于处理java.sql.ResultSet，将数据按要求转换为另一种形式；<ul><li>ArrayHandler：把结果集中的第一行转成对象数组；</li><li>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中；</li><li>BeanHandler：把结果集中的第一行数据封装到一个对应的 JavaBean实例中；</li><li>BeanListHandler：把结果集中的每一行数据封装到一个对应的 JavaBean实例中，存放到List里；</li><li>ColumnListHandler：将结果集中某一列的数据存放到List中；</li><li>KeyedHandler(name)：将结果集中的每一行数据都封装到Map里，再把这些map再存到一个map里，其key为指定的key；</li><li>MapHandler：将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值；</li><li>MapListHandler：将结果集中的每一行数据都封装到一个Map里，再存放到list</li></ul></li></ul><p>DBUtils和Druid搭配使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DBUtils_USE</span> &#123;</span><br><span class="line">    <span class="comment">//使用 apache-DBUtils 工具类 + druid 完成对表的 crud 操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQueryMany</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123; <span class="comment">//返回结果是多行的情况</span></span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回 ArrayList 结果集</span></span><br><span class="line">        <span class="comment">//String sql = &quot;select * from actor where id &gt;= ?&quot;;</span></span><br><span class="line">        <span class="comment">// 注意: sql 语句也可以查询部分列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select id, name from actor where id &gt;= ?&quot;</span>;</span><br><span class="line">        <span class="comment">//(1) query 方法就是执行 sql 语句，得到 resultset ---封装到 --&gt; ArrayList 集合中</span></span><br><span class="line">        <span class="comment">//(2) 返回集合</span></span><br><span class="line">        <span class="comment">//(3) connection: 连接</span></span><br><span class="line">        <span class="comment">//(4) sql : 执行的 sql 语句</span></span><br><span class="line">        <span class="comment">//(5) new BeanListHandler&lt;&gt;(Actor.class): 在将 resultset -&gt; Actor 对象 -&gt; 封装到 ArrayList</span></span><br><span class="line">        <span class="comment">// 底层使用反射机制 去获取 Actor 类的属性，然后进行封装</span></span><br><span class="line">        <span class="comment">//(6) 1 就是给 sql 语句中的第一个 ? 赋值，可以有多个值，因为此处是可变参数 Object... params</span></span><br><span class="line">        <span class="comment">//(7) PreparedStatment, 以及底层得到的 resultset ,会在 query 中关闭, 所以最后只需关闭连接connection就行</span></span><br><span class="line">        List&lt;Actor&gt; list = queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;&gt;(Actor.class), <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;输出集合的信息&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Actor actor : list) &#123;</span><br><span class="line">            System.out.print(actor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成 返回的结果是单行记录(单个对象)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testQuerySingle</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回单个对象</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select * from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 因为我们返回的单行记录&lt;---&gt;单个对象 , 使用的 Hander 是 BeanHandler</span></span><br><span class="line">        <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;&gt;(Actor.class), <span class="number">10</span>);</span><br><span class="line">        System.out.println(actor);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成查询结果是单行单列-返回的就是 object</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScalar</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//2. 使用 DBUtils 类和接口 , 先引入 DBUtils 相关的 jar , 加入到本 Project</span></span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 就可以执行相关的方法，返回单行单列 , 返回的就是 Object</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;select name from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">// 因为返回的是一个对象, 使用的 handler 就是 ScalarHandler</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> queryRunner.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), <span class="number">4</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//演示 apache-dbutils + druid 完成 dml (update, insert ,delete)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDML</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 连接 (druid)</span></span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> JDBCUtilsByDruid.getConnection();</span><br><span class="line">        <span class="comment">//3. 创建 QueryRunner</span></span><br><span class="line">        <span class="type">QueryRunner</span> <span class="variable">queryRunner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line">        <span class="comment">//4. 这里组织 sql 完成 update, insert delete</span></span><br><span class="line">        <span class="comment">//String sql = &quot;update actor set name = ? where id = ?&quot;;</span></span><br><span class="line">        <span class="comment">//String sql = &quot;insert into actor values(null, ?, ?, ?, ?)&quot;;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;delete from actor where id = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//(1) 执行 dml 操作是 queryRunner.update()</span></span><br><span class="line">        <span class="comment">//(2) 返回的值是受影响的行数 (affected: 受影响)</span></span><br><span class="line">        <span class="comment">//int affectedRow = queryRunner.update(connection, sql, &quot;林青霞&quot;, &quot;116&quot;);</span></span><br><span class="line">        <span class="comment">//int affectedRow = queryRunner.update(connection, sql, &quot;林青霞&quot;, &quot;女&quot;, &quot;1966-10-10&quot;, &quot;116&quot;);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">affectedRow</span> <span class="operator">=</span> queryRunner.update(connection, sql, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(affectedRow &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响到表&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DAO"><a href="#DAO" class="headerlink" title="DAO"></a>DAO</h3><p>DAO：data access object 数据访问对象</p><p>这样的通用类，称为BasicDao，是专门和数据库交互的，即完成对数据库(表)的crud操作；</p><p>编写DAO的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BasicDAO</span>&lt;T&gt; &#123; <span class="comment">//泛型指定具体类型</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">QueryRunner</span> <span class="variable">qr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryRunner</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开发通用的 dml 方法, 针对任意的表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">update</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> qr.update(connection, sql, parameters);</span><br><span class="line">            <span class="keyword">return</span> update;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回多个对象(即查询的结果是多行), 针对任意表</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;T&gt; <span class="title function_">queryMulti</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanListHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行结果 的通用方法</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">querySingle</span><span class="params">(String sql, Class&lt;T&gt; clazz, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">BeanHandler</span>&lt;T&gt;(clazz), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询单行单列的方法,即返回单值的方法</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">queryScalar</span><span class="params">(String sql, Object... parameters)</span> &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connection = JDBCUtilsByDruid.getConnection();</span><br><span class="line">            <span class="keyword">return</span> qr.query(connection, sql, <span class="keyword">new</span> <span class="title class_">ScalarHandler</span>(), parameters);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e); <span class="comment">//将编译异常-&gt;运行异常 ,抛出</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtilsByDruid.close(<span class="literal">null</span>, <span class="literal">null</span>, connection);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ActorDAO</span> <span class="keyword">extends</span> <span class="title class_">BasicDAO</span>&lt;Actor&gt; &#123;</span><br><span class="line">    <span class="comment">// 根据业务需求，可以编写特有的方法. </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestDAO</span> &#123;</span><br><span class="line">        <span class="comment">//测试 ActorDAO 对 actor 表 crud 操作</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testActorDAO</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">ActorDAO</span> <span class="variable">actorDAO</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ActorDAO</span>();</span><br><span class="line">            <span class="comment">//1. 查询</span></span><br><span class="line">            List&lt;Actor&gt; actors = actorDAO.queryMulti(<span class="string">&quot;select * from actor where id &gt;= ?&quot;</span>, Actor.class, <span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===查询结果===&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (Actor actor : actors) &#123;</span><br><span class="line">                System.out.println(actor);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2. 查询单行记录</span></span><br><span class="line">            <span class="type">Actor</span> <span class="variable">actor</span> <span class="operator">=</span> actorDAO.querySingle(<span class="string">&quot;select * from actor where id = ?&quot;</span>, Actor.class, <span class="number">6</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;====查询单行结果====&quot;</span>);</span><br><span class="line">            System.out.println(actor);</span><br><span class="line">            <span class="comment">//3. 查询单行单列</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> actorDAO.queryScalar(<span class="string">&quot;select name from actor where id = ?&quot;</span>, <span class="number">6</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;====查询单行单列值===&quot;</span>);</span><br><span class="line">            System.out.println(o);</span><br><span class="line">            <span class="comment">//4. dml 操作 insert ,update, delete</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">update</span> <span class="operator">=</span> actorDAO.update(<span class="string">&quot;insert into actor values(null, ?, ?, ?, ?)&quot;</span>, <span class="string">&quot;张无忌&quot;</span>, <span class="string">&quot;男&quot;</span>, <span class="string">&quot;2000-11-11&quot;</span>, <span class="string">&quot;999&quot;</span>);</span><br><span class="line">            System.out.println(update &gt; <span class="number">0</span> ? <span class="string">&quot;执行成功&quot;</span> : <span class="string">&quot;执行没有影响表&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h2 id="MySQL的数据目录"><a href="#MySQL的数据目录" class="headerlink" title="MySQL的数据目录"></a>MySQL的数据目录</h2><p>MySQL数据库文件的存放路径：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;</p><p>相关命令目录：&#x2F;usr&#x2F;bin 和 &#x2F;usr&#x2F;sbin。</p><p>配置文件目录：&#x2F;usr&#x2F;share&#x2F;mysql-8.0（命令及配置文件），&#x2F;etc&#x2F;mysql（如my.cnf）</p><hr><p><strong>数据库和文件系统的关系：</strong></p><p>MySQL有4个自带的系统数据库：mysql，information_schema，performance_schema，sys</p><ul><li><p><strong>mysql</strong></p><p>MySQL 系统自带的核心数据库，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过程中产生的日志信息，一些帮助信息以及时区信息等。</p></li><li><p><strong>information_schema</strong></p><p>保存mysql服务器维护其他所有数据库的信息，比如有哪些表，哪些触发器等等，是一些描述性信息，称之为元数据。</p><p>information_schema还提供了一些以innodb_sys开头的表，用于表示内部系统表。</p></li><li><p><strong>performance_schema</strong></p><p>保存MySQL服务器运行过程中的一些状态信息，可以用来 监控 MySQL 服务的各类性能指标 。包括统计最近执行了哪些语句，在执行过程的每个阶段都 花费了多长时间，内存的使用情况等信息。</p></li><li><p><strong>sys</strong></p><p>这个数据库主要是通过 视图 的形式把 information_schema 和 performance_schema 结合起来，帮助系统管理员和开发人员监控 MySQL 的技术性能。</p></li></ul><hr><p><strong>表在文件系统中的表示：</strong></p><ul><li><p>InnoDB存储引擎模式：</p><ul><li><p><strong>表结构</strong>：</p><p>为了保存表结构， InnoDB 在 数据目录 下对应的数据库子目录下创建了一个专门用于 <code>描述表结构的文件</code> ，文件名是这样：<strong>表名.frm</strong></p></li><li><p><strong>表的数据和索引</strong>：</p><ul><li><p>系统表空间（5.6.6版本以前）</p><p>默认情况下，InnoDB会在数据目录下创建一个名为 ibdata1 、大小为 12M 的文件，这个文件就是对应 的 系统表空间 在文件系统上的表示。它是一个自扩展文件。</p></li><li><p>独立表空间（5.6.6版本以后）</p><p>InnoDB 为每一个表建立一个独立表空间 ，表现为：在该表所属数据库对应的子目录下创建一个表示该独立表空间的文件，文件名和表名相同，为：<strong>表名.ibd</strong></p></li></ul></li></ul></li><li><p>MyISAM存储引擎模式：</p><ul><li><p>表结构：</p><p>（同InnoDB一样）</p></li><li><p>表数据和索引：</p><p>在MyISAM中的索引全部都是 <u>二级索引</u> ，该存储引擎的 数据和索引是<u>分开存放</u> 的。所以在文件系统中也是 使用不同的文件来存储数据文件和索引文件，同时表数据都存放在对应的数据库子目录下。</p><p>MyISAM存储引擎 会在 表所在数据库对应的 atguigu 目录下 创建这三个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">表名.frm 存储表结构</span><br><span class="line">表名.MYD 存储数据 (MYData)</span><br><span class="line">表名.MYI 存储索引 (MYIndex)</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="用户与权限管理"><a href="#用户与权限管理" class="headerlink" title="用户与权限管理"></a>用户与权限管理</h2><h2 id="逻辑架构"><a href="#逻辑架构" class="headerlink" title="逻辑架构"></a>逻辑架构</h2><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h1 id="索引调优"><a href="#索引调优" class="headerlink" title="索引调优"></a>索引调优</h1><h2 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h2><h2 id="InnoDB数据存储结构"><a href="#InnoDB数据存储结构" class="headerlink" title="InnoDB数据存储结构"></a>InnoDB数据存储结构</h2><h2 id="索引的创建与设计原则"><a href="#索引的创建与设计原则" class="headerlink" title="索引的创建与设计原则"></a>索引的创建与设计原则</h2><h2 id="性能分析工具的使用"><a href="#性能分析工具的使用" class="headerlink" title="性能分析工具的使用"></a>性能分析工具的使用</h2><h2 id="索引优化与查询优化"><a href="#索引优化与查询优化" class="headerlink" title="索引优化与查询优化"></a>索引优化与查询优化</h2><h2 id="数据库的设计规范"><a href="#数据库的设计规范" class="headerlink" title="数据库的设计规范"></a>数据库的设计规范</h2><h2 id="数据库其他调优策略"><a href="#数据库其他调优策略" class="headerlink" title="数据库其他调优策略"></a>数据库其他调优策略</h2><h1 id="事务-2"><a href="#事务-2" class="headerlink" title="事务"></a>事务</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h2 id="MySQL事务日志"><a href="#MySQL事务日志" class="headerlink" title="MySQL事务日志"></a>MySQL事务日志</h2><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h2 id="多版本并发控制-MVCC"><a href="#多版本并发控制-MVCC" class="headerlink" title="多版本并发控制(MVCC)"></a>多版本并发控制(MVCC)</h2><h1 id="日志与备份"><a href="#日志与备份" class="headerlink" title="日志与备份"></a>日志与备份</h1>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法题</title>
      <link href="/Notes/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/"/>
      <url>/Notes/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="2-两数相加-M"><a href="#2-两数相加-M" class="headerlink" title="2.两数相加(M)"></a>2.两数相加(M)</h1><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>要注意的点：</p><p>节点和大于9，要注意进位；</p><p>最后一个节点进位要额外新加一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">         <span class="type">ListNode</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">            list.val %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> list;</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val + l2.val);</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1 != <span class="literal">null</span> ? l1.val : l2.val);</span><br><span class="line">                l1 = l1 != <span class="literal">null</span> ? l1.next : l1;</span><br><span class="line">                l2 = l2 != <span class="literal">null</span> ? l2.next : l2;</span><br><span class="line">            &#125;</span><br><span class="line">            list = list.next;</span><br><span class="line">            <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">                list.val++;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (list.val &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                list.val %= <span class="number">10</span>;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            list.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-无重复字符的最长子串-M"><a href="#3-无重复字符的最长子串-M" class="headerlink" title="3.无重复字符的最长子串(M)"></a>3.无重复字符的最长子串(M)</h1><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: s = <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">输出: <span class="number">3</span></span><br><span class="line">解释: 因为无重复字符的最长子串是 <span class="string">&quot;wke&quot;</span>，所以其长度为 <span class="number">3</span>。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，<span class="string">&quot;pwke&quot;</span> 是一个子序列，不是子串。</span><br><span class="line"></span><br><span class="line">输入: s = <span class="string">&quot;&quot;</span></span><br><span class="line">输出: <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h3><p>思路：</p><p>使用滑动窗口：每一步的操作中，我们会将左指针向右移动一格，表示 <strong>我们开始枚举下一个字符作为起始位置</strong>，然后我们可以不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着 <strong>以左指针开始的，不包含重复字符的最长子串</strong>。我们记录下这个子串的长度；</p><p>使用哈希集合判断是否有字符重复</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        HashSet&lt;Character&gt; set= <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, r = -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span>)&#123;</span><br><span class="line">                set.remove(s.charAt(i - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(r + <span class="number">1</span>&lt; n &amp;&amp; !set.contains(s.charAt(r + <span class="number">1</span>)))&#123;</span><br><span class="line">                set.add(s.charAt(r + <span class="number">1</span>));</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, r - i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-寻找两个正序数组的中位数-D"><a href="#4-寻找两个正序数组的中位数-D" class="headerlink" title="4.寻找两个正序数组的中位数(D)"></a>4.寻找两个正序数组的中位数(<strong>D</strong>)</h1><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [<span class="number">1</span>,<span class="number">3</span>], nums2 = [<span class="number">2</span>]</span><br><span class="line">输出：<span class="number">2.00000</span></span><br><span class="line">解释：合并数组 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] ，中位数 <span class="number">2</span></span><br></pre></td></tr></table></figure><p>方法一：</p><p>暴力法：直接将两个数组加入到一个新数组，排序，再求中位数</p><p>时间复杂度：O（(m+n)*log(m+n) )；空间：O（m+n）</p><p>将两个数组的值从小到大 合并到新数组，再求中位数</p><p>时间复杂度：O（m+n )；空间：O（m+n）</p><p>方法二：</p><p>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 00 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。</p><p>时间复杂度：O（m+n )；空间：O（1）</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><p>这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)&#x2F;2 或 (m+n)&#x2F;2+1。</p><p>找到第 k 个元素，我们可以比较 A[k&#x2F;2-1] 和B[k&#x2F;2-1]，</p><p>可以归纳出三种情况：</p><ul><li><p>如果 A[k&#x2F;2-1] &lt; B[k&#x2F;2-1]，则比 A[k&#x2F;2−1] 小的数最多只有 A 的前 k&#x2F;2−1 个数和 B 的前 k&#x2F;2−1 个数，即比 A[k&#x2F;2−1] 小的数最多只有 k-2 个，因此 A[k&#x2F;2−1] 不可能是第 k 个数，A[0] 到 A[k&#x2F;2−1] 也都不可能是第 k 个数，可以全部排除。</p></li><li><p>如果 A[k&#x2F;2−1]&gt;B[k&#x2F;2−1]，则可以排除 B[0] 到 B[k&#x2F;2−1]。</p></li><li><p>如果 A[k&#x2F;2−1]&#x3D;B[k&#x2F;2−1]，则可以归入第一种情况处理。</p></li></ul><p>可以看到，比较 A[k&#x2F;2−1] 和 B[k&#x2F;2−1] 之后，可以排除 k&#x2F;2k&#x2F;2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p><p>有以下三种情况需要特殊处理：</p><ul><li><p>如果 A[k&#x2F;2−1] 或者B[k&#x2F;2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k&#x2F;2。</p></li><li><p>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</p></li><li><p>如果 k&#x3D;1，我们只要返回两个数组首元素的最小值即可。</p></li></ul><p>用一个例子说明：</p><p>A: 1 3 <strong>4</strong> 9<br>B: 1 2 <strong>3</strong> 4 5 6 7 8 9</p><blockquote><p>k &#x3D; (4 + 9 ) &#x2F; 2 + 1 &#x3D; 7;</p><p>比较两个数组下标为k &#x2F; 2 - 1 &#x3D; 2的数，即A[2] 和B[2]</p><p>由于A[2] &gt; B[2] ，所以排除B[0] 到B[2]，数组B的下标偏移变为3，同时更新k的值：K &#x3D; K - K &#x2F; 2 &#x3D; 4;</p><p>下一步寻找，比较下标为 K &#x2F; 2 - 1 &#x3D; 1的数，即A[1] 和B[4] </p></blockquote><p>A: 1 <strong>3</strong> 4 9<br>B: <del>1 2 3</del> 4 <strong>5</strong> 6 7 8 9</p><blockquote><p>由于 A[1] &lt; B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k &#x3D; k - k&#x2F;2&#x3D;2。</p><p>下一步寻找，比较两个有序数组中下标为 k&#x2F;2-1&#x3D;0 的数，即比较 A[2] 和 B[3]</p></blockquote><p>A: <del>1 3</del> <strong>4</strong> 9<br>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p><blockquote><p>由于A[2]&#x3D;B[3]，根据之前的规则，排除A 中的元素，因此排除 A[2]，即数组 A 的下标偏移变为 3，同时更新 k 的值： k&#x3D;k-k&#x2F;2&#x3D;1。</p><p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3] &gt; B[3]，因此第 k 个数是 B[3]&#x3D;4。</p></blockquote><p>A: <del>1 3 4</del> <strong>9</strong> </p><p>B: <del>1 2 3</del> <strong>4</strong> 5 6 7 8 9</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLength</span> <span class="operator">=</span> length1 + length2;</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> getKthElement(nums1, nums2, midIndex + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">midIndex1</span> <span class="operator">=</span> totalLength / <span class="number">2</span> - <span class="number">1</span>, midIndex2 = totalLength / <span class="number">2</span>;</span><br><span class="line">            <span class="type">double</span> <span class="variable">median</span> <span class="operator">=</span> (getKthElement(nums1, nums2, midIndex1 + <span class="number">1</span>) + getKthElement(nums1, nums2, midIndex2 + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">            <span class="keyword">return</span> median;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getKthElement</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length1</span> <span class="operator">=</span> nums1.length, length2 = nums2.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">kthElement</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == length1) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == length2) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.min(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">half</span> <span class="operator">=</span> k / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex1</span> <span class="operator">=</span> Math.min(index1 + half, length1) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newIndex2</span> <span class="operator">=</span> Math.min(index2 + half, length2) - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pivot1</span> <span class="operator">=</span> nums1[newIndex1], pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= (newIndex1 - index1 + <span class="number">1</span>);</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= (newIndex2 - index2 + <span class="number">1</span>);</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（log(m+n) )；空间：O（1）</p><h3 id="划分数组"><a href="#划分数组" class="headerlink" title="划分数组"></a><strong>划分数组</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedianSortedArrays</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLength</span> <span class="operator">=</span> nums1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLength</span> <span class="operator">=</span> nums2.length;</span><br><span class="line">        <span class="comment">// 为了保证第一个数组比第二个数组小(或者相等)</span></span><br><span class="line">        <span class="keyword">if</span> (leftLength &gt; rightLength) &#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分割线左边的所有元素需要满足的个数 m + (n - m + 1) / 2;</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为偶数时，当在长度之和上+1时，由于整除是向下取整，所以不会改变结果</span></span><br><span class="line">        <span class="comment">// 两个数组长度之和为奇数时，按照分割线的左边比右边多一个元素的要求，此时在长度之和上+1，就会被2整除，会在原来的数</span></span><br><span class="line">        <span class="comment">//的基础上+1，于是多出来的那个1就是左边比右边多出来的一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">totalLeft</span> <span class="operator">=</span> (leftLength + rightLength + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 在 nums1 的区间 [0, leftLength] 里查找恰当的分割线，</span></span><br><span class="line">        <span class="comment">// 使得 nums1[i - 1] &lt;= nums2[j] &amp;&amp; nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> leftLength;</span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j]</span></span><br><span class="line">        <span class="comment">//  此处要求第一个数组中分割线的左边的值 不大于(小于等于) 第二个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i]</span></span><br><span class="line">        <span class="comment">//  此处要求第二个数组中分割线的左边的值 不大于(小于等于) 第一个数组中分割线的右边的值</span></span><br><span class="line">        <span class="comment">// 循环条件结束的条件为指针重合，即分割线已找到</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 二分查找，此处为取第一个数组中左右指针下标的中位数，决定起始位置</span></span><br><span class="line">            <span class="comment">// 此处+1首先是为了不出现死循环，即left永远小于right的情况</span></span><br><span class="line">            <span class="comment">// left和right最小差距是1，此时下面的计算结果如果不加1会出现i一直=left的情况，而+1之后i才会=right</span></span><br><span class="line">            <span class="comment">// 于是在left=i的时候可以破坏循环条件，其次下标+1还会保证下标不会越界，因为+1之后向上取整，保证了</span></span><br><span class="line">            <span class="comment">// i不会取到0值，即i-1不会小于0(另一说法：此处+1是为了避免出现死循环，同时+1后，不会出现下标越界的情况)</span></span><br><span class="line">            <span class="comment">// 此时i也代表着在一个数组中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 第一个数组中左边的元素个数确定后，用左边元素的总和-第一个数组中元素的总和=第二个元素中左边的元素的总和</span></span><br><span class="line">            <span class="comment">// 此时j就是第二个元素中左边的元素的个数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">            <span class="comment">// 此处用了nums1[i - 1] &lt;= nums2[j]的取反，当第一个数组中分割线的左边的值大于第二个数组中分割线的右边的值</span></span><br><span class="line">            <span class="comment">// 说明又指针应该左移，即-1</span></span><br><span class="line">            <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j]) &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [left, i - 1]</span></span><br><span class="line">                right = i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 此时说明条件满足，应当将左指针右移到i的位置，至于为什么是右移，请看i的定义</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 下一轮搜索的区间 [i, right]</span></span><br><span class="line">                left = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 退出循环时left一定等于right，所以此时等于left和right都可以</span></span><br><span class="line">        <span class="comment">// 为什么left一定不会大于right?因为left=i。</span></span><br><span class="line">        <span class="comment">// 此时i代表分割线在第一个数组中所在的位置</span></span><br><span class="line">        <span class="comment">// nums1[i]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums[i-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="comment">// 此时j代表分割线在第二个数组中的位置</span></span><br><span class="line">        <span class="comment">// nums2[j]为第一个数组中分割线右边的第一个值</span></span><br><span class="line">        <span class="comment">// nums2[j-1]即第一个数组中分割线左边的第一个值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> totalLeft - i;</span><br><span class="line">        <span class="comment">// 当i=0时，说明第一个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1LeftMax</span> <span class="operator">=</span> i == <span class="number">0</span> ? Integer.MIN_VALUE : nums1[i - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等i=第一个数组的长度时，说明第一个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums1RightMin</span> <span class="operator">=</span> i == leftLength ? Integer.MAX_VALUE : nums1[i];</span><br><span class="line">        <span class="comment">// 当j=0时，说明第二个数组分割线左边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums2[j - 1] &lt;= nums1[i] 和 Math.max(nums1LeftMax, nums2LeftMax)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2LeftMax</span> <span class="operator">=</span> j == <span class="number">0</span> ? Integer.MIN_VALUE : nums2[j - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 等j=第二个数组的长度时，说明第二个数组分割线右边没有值，为了不影响</span></span><br><span class="line">        <span class="comment">// nums1[i - 1] &lt;= nums2[j] 和 Math.min(nums1RightMin, nums2RightMin)</span></span><br><span class="line">        <span class="comment">// 的判断，所以将它设置为int的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">nums2RightMin</span> <span class="operator">=</span> j == rightLength ? Integer.MAX_VALUE : nums2[j];</span><br><span class="line">        <span class="comment">// 如果两个数组的长度之和为奇数，直接返回两个数组在分割线左边的最大值即可</span></span><br><span class="line">        <span class="keyword">if</span> (((leftLength + rightLength) % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums1LeftMax, nums2LeftMax);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果两个数组的长度之和为偶数，返回的是两个数组在左边的最大值和两个数组在右边的最小值的和的二分之一</span></span><br><span class="line">            <span class="comment">// 此处不能被向下取整，所以要强制转换为double类型</span></span><br><span class="line">            <span class="keyword">return</span> (<span class="type">double</span>) ((Math.max(nums1LeftMax, nums2LeftMax) + Math.min(nums1RightMin, nums2RightMin))) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（log min(m+n) )；空间：O（1）</p><h1 id="5-最长回文子串-M"><a href="#5-最长回文子串-M" class="headerlink" title="5.最长回文子串(M)"></a>5.最长回文子串(M)</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span>：</span><br><span class="line">输入：s = <span class="string">&quot;babad&quot;</span></span><br><span class="line">输出：<span class="string">&quot;bab&quot;</span></span><br><span class="line">解释：<span class="string">&quot;aba&quot;</span> 同样是符合题意的答案。</span><br><span class="line">示例<span class="number">2</span>：</span><br><span class="line">输入：s = <span class="string">&quot;ac&quot;</span></span><br><span class="line">输出：<span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure><h3 id="中心扩散"><a href="#中心扩散" class="headerlink" title="中心扩散"></a>中心扩散</h3><p>从每一个位置出发，向两边扩散即可。遇到不是回文的时候结束。</p><ul><li>首先往左寻找与当期位置相同的字符，直到遇到不相等为止。</li><li>然后往右寻找与当期位置相同的字符，直到遇到不相等为止。</li><li>最后左右双向扩散，直到左和右不相等。</li></ul><p>每个位置向两边扩散都会出现一个窗口大小（templen）。如果 templen &gt; maxLen，则更新 maxLen 的值。<br>因为我们最后要返回的是具体子串，而不是长度，因此，还需要记录一下 maxLen 时的起始，结尾位置（也可以只记录初始位置，结尾位置 &#x3D; 初始位置 + maxlen - 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span> &amp;&amp; s.charAt(<span class="number">0</span>) == s.charAt(<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxlen</span> <span class="operator">=</span> <span class="number">0</span>, templen = <span class="number">0</span>, lIndex = <span class="number">0</span>, rIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">1</span>; mid &lt; n - <span class="number">1</span>; mid++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> mid - <span class="number">1</span>, j = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == s.charAt(mid))&#123;</span><br><span class="line">                i--;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp;s.charAt(j) == s.charAt(mid))&#123;</span><br><span class="line">                j++;</span><br><span class="line">                templen++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                    templen += <span class="number">2</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxlen &lt; templen)&#123;</span><br><span class="line">                maxlen = templen;</span><br><span class="line">                lIndex = i + <span class="number">1</span>;</span><br><span class="line">                rIndex = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            templen = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(lIndex, rIndex + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（n^2）空间复杂度： O（1）</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。</p><p><strong>边界条件：</strong>子串长度小于2 时一定为回文串，即 ： j - 1 - ( i + 1 ) + 1 &lt; 2 ,整理得 <strong>j - i &#x3D; 3</strong> </p><p><strong>状态转移方程：</strong></p><p><strong>dp[ i ] [ j ] &#x3D; ( s [ i ] &#x3D;&#x3D; s [ j ] ) and ( j - i &lt; 3 or dp[ i + 1] [j - 1] )</strong></p><p>由于dp [ i ] [ j ] 参考它左下方的值，所以应该<strong>按列升序</strong>填写</p><p>例如： </p><table><thead><tr><th>字符</th><th>b</th><th>a</th><th>b</th><th>a</th><th>b</th></tr></thead><tbody><tr><td>下标</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><table><thead><tr><th></th><th>子串右边界</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead><tbody><tr><td>子串左边界</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>0</td><td></td><td>true</td><td>false</td><td><strong>true</strong></td><td>false</td><td><strong>true</strong></td></tr><tr><td>1</td><td></td><td></td><td>true</td><td>false</td><td><strong>true</strong></td><td>false</td></tr><tr><td>2</td><td></td><td></td><td></td><td>true</td><td>false</td><td><strong>true</strong></td></tr><tr><td>3</td><td></td><td></td><td></td><td></td><td>true</td><td>flase</td></tr><tr><td>4</td><td></td><td></td><td></td><td></td><td></td><td>true</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示 s[i..j] 是否是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="comment">// 初始化：所有长度为 1 的子串都是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始</span></span><br><span class="line">        <span class="comment">// 先枚举子串长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">2</span>; L &lt;= len; L++) &#123;</span><br><span class="line">            <span class="comment">// 枚举左边界，左边界的上限设置可以宽松一些</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="comment">// 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> L + i - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 如果右边界越界，就可以退出当前循环</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (charArray[i] != charArray[j]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - i &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（n^2）空间复杂度： O（n^2）</p><h3 id="Manacher-马拉车-算法"><a href="#Manacher-马拉车-算法" class="headerlink" title="Manacher (马拉车)算法"></a>Manacher (马拉车)算法</h3><p>专门用于查找最长回文子串的算法，时间复杂度：O（n）</p><h1 id="10-正则表达式匹配-D"><a href="#10-正则表达式匹配-D" class="headerlink" title="10.正则表达式匹配(D)"></a>10.正则表达式匹配(D)</h1><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘ . ‘ 和 ‘ * ‘ 的正则表达式匹配。</p><p>‘ . ‘ 匹配任意单个字符<br>‘ * ‘ 匹配零个或多个前面的那一个元素</p><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><h3 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h3><p>从左往右扫的话</p><ul><li>字符后面是否跟着星号会影响结果，分析起来有点复杂。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/073085fa67286871f76e8e9daa162bdb291a101b4314666c75379a7b0441cad6-image.png" alt="image.png"></li></ul><p>所以选择从右往左扫描：</p><ul><li>星号的前面肯定有一个字符，星号也只影响这一个字符，它就像一个拷贝器。</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/5e7b1748039a2a779d7378bebc4926ef3e584e88cc22b67f3a4e18c0590bcc55-image.png" alt="image.png"></p><ul><li>s、p 串是否匹配，取决于：最右端是否匹配、剩余的子串是否匹配。</li><li>只是最右端可能是特殊符号，需要分情况讨论而已。</li></ul><p><strong>通用地表示出子问题：</strong></p><ul><li>大子串是否匹配，和剩余子串是否匹配，是规模不一样的同一问题。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/e1bcac2ad07a3a5c959bf0fe5c8ceea9bbd033c3066e7ec7f384aedd98cd95aa-image.png" alt="image.png"></li></ul><p>*<em>情况1：s[i-1] 和 <em>p</em>[<em>j</em>−1] 是匹配的</em>*</p><ul><li>最右端的字符是匹配的，那么，大问题的答案 &#x3D; 剩余子串是否匹配。<br><img src="https://pic.leetcode-cn.com/f817caaa40b0c39fc3ddabfa1383a8218ab364b8e49b30e5ce85cb30a3cdc503-image.png" alt="image.png"></li></ul><p><strong>情况2：s[i-1] 和 p[j-1] 是不匹配的</strong></p><ul><li>右端不匹配，还不能判死刑——可能是 p[j-1]<em>p</em>[<em>j</em>−1] 为星号造成的不匹配，星号不是真实字符，它不匹配不算数。</li><li>如果 p[j-1]<em>p</em>[<em>j</em>−1] 不是星号，那就真的不匹配了。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/fe763378879a0a52e9f17171e3bc1db18cfc83bf59f14efcd31ec9edb37adfac-image.png" alt="image.png"></li></ul><p><strong>p[j-1] &#x3D;&#x3D;”∗”，且 s[i-1] 和 p[j-2] 匹配</strong></p><ul><li>p[j-1]<em>p</em>[<em>j</em>−1]是星号，并且 s[i-1] 和 p[j-2] 匹配，要考虑三种情况：<ul><li>p[j-1] 星号可以让 p[j-2]在 p 串中消失、出现 1 次、出现 &gt;&#x3D;2 次。</li><li>只要其中一种使得剩余子串能匹配，那就能匹配，见下图 a1、a2、a3。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/a1cc0caf806f7d7f5419d820e0e7be7a364c96656a98ca4d7f351661d6a62aa6-image.png" alt="image.png"></li><li>a3 情况：假设 s 的右端是一个 a，p 的右端是a* ，* 让 a 重复 &gt;&#x3D; 2 次<ul><li>星号不是真实字符，s、p是否匹配，要看 s 去掉末尾的 a，p 去掉末尾一个 a，剩下的是否匹配。</li><li>星号拷贝了 &gt;&#x3D;2 个 a，拿掉一个，剩下 &gt;&#x3D;1 个a，p 末端依旧是 a* 没变。</li><li>s 末尾的 a 被抵消了，继续考察 s(0,i-2) 和 p(0,i-1) 是否匹配。</li></ul></li></ul></li></ul><p>p[j-1] &#x3D;&#x3D; “∗”，但 s[i-1] 和 p[j-2] 不匹配</p><ul><li>s[i-1] 和 p[j−2] 不匹配，还有救，p[j−1] 星号可以干掉 p[j−2]，继续考察 s(0 , i-1) 和 p(0 , j-3)。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/dabf2195c460052e2719340de8f2d22f791694d4443424478201be3b5d601fe1-image.png" alt="image.png"></li></ul><p>注意：</p><ul><li>p为空串，s不为空串，肯定不匹配。</li><li>s为空串，但p不为空串，要想匹配，只可能是右端是星号，它干掉一个字符后，把 p 变为空串。</li><li>s、p都为空串，肯定匹配。<br><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/140597adfd5f03dd481e136163d98e7160cce4761c7cb8227010d828f24b7498-image.png" alt="image.png"></li></ul><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;  </span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();    </span><br><span class="line">        <span class="type">char</span>[] cp = p.toCharArray();    </span><br><span class="line">        <span class="comment">// dp[i][j]:表示s的前i个字符，p的前j个字符是否能够匹配  </span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[cs.length + <span class="number">1</span>][cp.length + <span class="number">1</span>];   </span><br><span class="line">        <span class="comment">// 初期值  </span></span><br><span class="line">        <span class="comment">// s为空，p为空，能匹配上 </span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">// p为空，s不为空，必为false(boolean数组默认值为false，无需处理) </span></span><br><span class="line">        <span class="comment">// s为空，p不为空，由于*可以匹配0个字符，所以有可能为true     </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;   </span><br><span class="line">                dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];   </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 填格子   </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cs.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= cp.length; j++) &#123;  </span><br><span class="line">                <span class="comment">// 文本串和模式串末位字符能匹配上  </span></span><br><span class="line">                <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">1</span>] || cp[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;    </span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];     </span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123; <span class="comment">// 模式串末位是*  </span></span><br><span class="line">                    <span class="comment">// 模式串*的前一个字符能够跟文本串的末位匹配上    </span></span><br><span class="line">                    <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">2</span>] || cp[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;     </span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>]      <span class="comment">// *匹配0次的情况   </span></span><br><span class="line">                            || dp[i - <span class="number">1</span>][j];     <span class="comment">// *匹配1次或多次的情况  </span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 模式串*的前一个字符不能够跟文本串的末位匹配     </span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];     <span class="comment">// *只能匹配0次     </span></span><br><span class="line">                    &#125;          </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> dp[cs.length][cp.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="29-两数相除-M"><a href="#29-两数相除-M" class="headerlink" title="29.两数相除(M)"></a>29.两数相除(M)</h1><p>给定两个整数，被除数 dividend 和除数 divisor。将两数相除，<strong>要求不使用乘法、除法和 mod 运算符</strong>。</p><p><strong>返回</strong> 被除数 dividend 除以 除数 divisor 得到的<strong>商</strong>。</p><p>整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) &#x3D; 8 以及 truncate(-2.7335) &#x3D; -2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入: dividend = 7, divisor = -3输出: -2解释: 7/-3 = truncate(-2.33333..) = -2</span><br></pre></td></tr></table></figure><p>提示：</p><blockquote><p>被除数和除数均为 32 位有符号整数。<br>除数不为 0。<br>假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231,  231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。</p></blockquote><p>指数递增</p><p>由于题目规定只能存储32位整数，所以<strong>只能使用int</strong>，要考虑除法结果溢出。</p><p>对于<strong>溢出或容易出错的边界</strong>情况：</p><ul><li>当<strong>被除数</strong>是32位有符号数的<strong>最小值-2的31次方</strong>时：<ul><li>如果除数为1，那么直接返回答案-2的31次方；</li><li>如果除数为-1，那么答案为2的31次方，产生了溢出。</li></ul></li><li>当<strong>除数</strong>为32位有符号整数的<strong>最小值-2的31次方</strong>：<ul><li>如果被除数同样为-2的31次方，那么直接返回答案1；</li><li>对于其余情况，直接返回0；</li></ul></li><li>当被除数为0时，直接返回答案0；</li></ul><p>对于<strong>除数和被除数的符号</strong>，需要考虑4种情况，为了方便，使 除数和被除数符号 符号相同，这样就只需考虑一种符号的情况，由于都取整数的话可能会溢出，因此将除数和被除数<strong>都取为负数</strong>。</p><p>方法一：二分法</p><h3 id="指数递增步长"><a href="#指数递增步长" class="headerlink" title="指数递增步长"></a>指数递增步长</h3><p>方法二：<strong>指数递增步长</strong>（类二分查找，快速加）：</p><ul><li>我们首先不断地将 Y 乘以 2（通过加法运算实现），并将这些结果放入数组中，其中数组的<strong>第 i 项</strong>就等于 <strong>Y * 2的 i 次方</strong>；这一过程直到 Y 的两倍严格小于 X 为止。</li><li>对数组进行逆序遍历。当遍历到第 i 项时，如果大于等于X， 就将答案增加2的 i 次方，并且将X减去这一项的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;        <span class="comment">// 考虑被除数为最小值的情况     </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE) &#123;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == <span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MIN_VALUE;            </span><br><span class="line">            &#125;            </span><br><span class="line">            <span class="keyword">if</span> (divisor == -<span class="number">1</span>) &#123;                </span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;            </span><br><span class="line">            &#125;        </span><br><span class="line">    &#125;        </span><br><span class="line">        <span class="comment">// 考虑除数为最小值的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (divisor == Integer.MIN_VALUE) &#123;           </span><br><span class="line">            <span class="type">return</span> <span class="variable">dividend</span> <span class="operator">=</span>= Integer.MIN_VALUE ? <span class="number">1</span> : <span class="number">0</span>;      </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="comment">// 考虑被除数为 0 的情况        </span></span><br><span class="line">        <span class="keyword">if</span> (dividend == <span class="number">0</span>) &#123;            </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;        </span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="comment">// 一般情况，使用类二分查找       </span></span><br><span class="line">        <span class="comment">// 将所有的正数取相反数，这样就只需要考虑一种情况       </span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">rev</span> <span class="operator">=</span> <span class="literal">false</span>;       </span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;           </span><br><span class="line">            dividend = -dividend;       </span><br><span class="line">            rev = !rev;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">            divisor = -divisor;    </span><br><span class="line">            rev = !rev;     </span><br><span class="line">        &#125;       </span><br><span class="line">        List&lt;Integer&gt; candidates = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();       </span><br><span class="line">        candidates.add(divisor);   </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="comment">//填充数组，第i项相当于Y*2的i次方（Y为除数）;     </span></span><br><span class="line">        <span class="comment">// 注意溢出:判断A+B是否小于C时，A+B可能溢出，因此改为A&lt;C-B   </span></span><br><span class="line">        <span class="comment">// (任意两个负数的差一定在[-2的31次方+1,2的31次方-1]范围内)      </span></span><br><span class="line">        <span class="keyword">while</span> (candidates.get(index) &gt;= dividend - candidates.get(index)) &#123;     </span><br><span class="line">            candidates.add(candidates.get(index) + candidates.get(index));        </span><br><span class="line">            ++index;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> candidates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;    </span><br><span class="line">            <span class="keyword">if</span> (candidates.get(i) &gt;= dividend) &#123;      </span><br><span class="line">                ans += <span class="number">1</span> &lt;&lt; i;          </span><br><span class="line">                dividend -= candidates.get(i);    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> rev ? -ans : ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="166-分数到小数-M"><a href="#166-分数到小数-M" class="headerlink" title="166.分数到小数(M)"></a>166.分数到小数(M)</h1><p>给定两个整数，分别表示分数的<strong>分子 numerator</strong> 和<strong>分母 denominator</strong>，以 字符串形式返回小数 。</p><p>如果小数部分为循环小数，则<strong>将循环的部分括在括号内</strong>。</p><p>如果存在多个答案，只需返回任意一个 。</p><p>对于所有给定的输入，保证答案字符串的长度小于104。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：numerator = <span class="number">4</span>, denominator = <span class="number">333</span>输出：<span class="string">&quot;0.(012)&quot;</span></span><br></pre></td></tr></table></figure><h3 id="模拟长除法"><a href="#模拟长除法" class="headerlink" title="模拟长除法"></a>模拟长除法</h3><p>计算分子和分母相除的结果，可能有：整数，有限小数，无限循环小数；</p><p>如果分子可以被分母整除，则结果为整数</p><p>如果分子不能被分母整除，则为有限&#x2F;无限循环小数，需用模拟长除法 的方式来计算：</p><ol><li>先根据分子，分母的正负 决定结果的正负，并将分子，分母都转为正数；</li><li>先计算整数部分，并将整数部分和小数点拼接到结果中；</li><li>再计算小数部分：每次将余数乘以 10，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成 0 或者找到循环节。<ul><li>如果余数为0，则结果为有限小数</li><li>如果找到循环节，则在循环节开始和结束位置加上括号；</li><li>判断循环节：因为相同的余数，计算得到的小数的下一位数字一定相同，所以如果有余数在之前已经出现过，则认为找到循环节；（用哈希表存储每个余数第一次出现的下标）</li></ul></li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/2.png" alt="fig2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fractionToDecimal</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> &#123;  </span><br><span class="line">        <span class="type">long</span> <span class="variable">numeratorLong</span> <span class="operator">=</span> (<span class="type">long</span>) numerator;    </span><br><span class="line">        <span class="type">long</span> <span class="variable">denominatorLong</span> <span class="operator">=</span> (<span class="type">long</span>) denominator;    </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong % denominatorLong == <span class="number">0</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> String.valueOf(numeratorLong / denominatorLong);  </span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();     </span><br><span class="line">        <span class="keyword">if</span> (numeratorLong &lt; <span class="number">0</span> ^ denominatorLong &lt; <span class="number">0</span>) &#123;   </span><br><span class="line">            sb.append(<span class="string">&#x27;-&#x27;</span>);        </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="comment">//整数部分  </span></span><br><span class="line">        numeratorLong = Math.abs(numeratorLong); </span><br><span class="line">        denominatorLong = Math.abs(denominatorLong);    </span><br><span class="line">        <span class="type">long</span> <span class="variable">integerPart</span> <span class="operator">=</span> numeratorLong / denominatorLong;     </span><br><span class="line">        sb.append(integerPart);  </span><br><span class="line">        sb.append(<span class="string">&#x27;.&#x27;</span>);    </span><br><span class="line">        <span class="comment">//小数部分    </span></span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">fractionPart</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">        Map&lt;Long, Integer&gt; remainderIndexMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Long, Integer&gt;();   </span><br><span class="line">        <span class="type">long</span> <span class="variable">remainder</span> <span class="operator">=</span> numeratorLong % denominatorLong;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (remainder != <span class="number">0</span> &amp;&amp; !remainderIndexMap.containsKey(remainder)) &#123;   </span><br><span class="line">            remainderIndexMap.put(remainder, index);   </span><br><span class="line">            remainder *= <span class="number">10</span>;     </span><br><span class="line">            fractionPart.append(remainder / denominatorLong); </span><br><span class="line">            remainder %= denominator;   </span><br><span class="line">            index++;     </span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;   <span class="comment">//有循环节      </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">insertIndex</span> <span class="operator">=</span> remainderIndexMap.get(remainder); </span><br><span class="line">            fractionPart.insert(insertIndex, <span class="string">&#x27;(&#x27;</span>);     </span><br><span class="line">            fractionPart.append(<span class="string">&#x27;)&#x27;</span>);    </span><br><span class="line">        &#125;     </span><br><span class="line">        sb.append(fractionPart.toString());  </span><br><span class="line">        <span class="keyword">return</span> sb.toString();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="187-重复的DNA序列（M"><a href="#187-重复的DNA序列（M" class="headerlink" title="187.重复的DNA序列（M)"></a>187.重复的DNA序列（M)</h1><p>所有 DNA 都由一系列缩写为 ‘A’，’C’，’G’ 和 ‘T’ 的核苷酸组成，例如：”ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。</p><p>编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：s = <span class="string">&quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;</span>输出：[<span class="string">&quot;AAAAACCCCC&quot;</span>,<span class="string">&quot;CCCCCAAAAA&quot;</span>]</span><br></pre></td></tr></table></figure><h3 id="滑动窗口-哈希表"><a href="#滑动窗口-哈希表" class="headerlink" title="滑动窗口+哈希表"></a>滑动窗口+哈希表</h3><p>从左到右处理字符串 ss，使用滑动窗口得到每个以 s[i]s[i] 为结尾且长度为 1010 的子串，同时使用哈希表记录每个子串的出现次数，如果该子串出现次数超过一次，则加入答案。</p><p>时间复杂度：O(NL)，其中 N 是字符串 s 的长度，L&#x3D;10即目标子串的长度。</p><p>空间复杂度：O(NL)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;    </span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    </span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();     </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i + <span class="number">10</span> &lt;= n; i++)&#123;     </span><br><span class="line">            <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> s.substring(i, i + <span class="number">10</span>);  </span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.getOrDefault(cur, <span class="number">0</span>);    </span><br><span class="line">            <span class="keyword">if</span>(cnt == <span class="number">1</span>) list.add(cur);     </span><br><span class="line">            map.put(cur, cnt + <span class="number">1</span>);    </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> list;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="位运算-滑动窗口-哈希表"><a href="#位运算-滑动窗口-哈希表" class="headerlink" title="位运算+滑动窗口+哈希表"></a>位运算+滑动窗口+哈希表</h3><p>因为只有4种字符，所以可以将<strong>每个字符用2个比特表示</strong>，即：</p><p>A：00C：01G：10T：11</p><p>这样，长为10个字符的字符串就可以用20个比特表示，这里<strong>用 int整数（有32）的低20位</strong>来表示它，</p><p>如果我们对每个长为 10 的子串都单独计算其整数表示，那么时间复杂度仍然和方法一一样为 O(NL)。为了优化时间复杂度，我们可以用一个大小固定为 10 的滑动窗口来计算子串的整数表示。</p><p>设当前滑动窗口对应的整数表示为 x，当我们要计算下一个子串时，就将滑动窗口向右移动一位，此时会有一个新的字符进入窗口，以及窗口最左边的字符离开窗口，这些操作对应的位运算，按计算顺序表示如下：</p><ul><li>滑动窗口向右移动一位：x &#x3D; x &lt;&lt; 2，由于每个字符用 2 个比特表示，所以要左移 2 位；</li><li>一个新的字符 ch 进入窗口：x &#x3D; x | bin[ch]，这里 bin[ch] 为字符 ch 的对应二进制；</li><li>窗口最左边的字符离开窗口：x &#x3D; x &amp; ((1 &lt;&lt; 20) - 1)，由于我们只考虑 x 的低 20 位比特，需要将其余位置零，即与上 (1 &lt;&lt; 20) - 1。</li></ul><p>上面三步合并，就可以用O（1）的时间算出下一个子串的整数表示，即 x &#x3D; ((x &lt;&lt; 2) | bin[ch]) &amp; ((1 &lt;&lt; 20) - 1)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> <span class="number">10</span>;  </span><br><span class="line">    Map&lt;Character, Integer&gt; bin = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;() &#123;</span><br><span class="line">        &#123;      </span><br><span class="line">            put(<span class="string">&#x27;A&#x27;</span>, <span class="number">0</span>);</span><br><span class="line">            put(<span class="string">&#x27;C&#x27;</span>, <span class="number">1</span>);   </span><br><span class="line">            put(<span class="string">&#x27;G&#x27;</span>, <span class="number">2</span>);     </span><br><span class="line">            put(<span class="string">&#x27;T&#x27;</span>, <span class="number">3</span>);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;  </span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findRepeatedDnaSequences</span><span class="params">(String s)</span> &#123;   </span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();    </span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();    </span><br><span class="line">        <span class="keyword">if</span> (n &lt;= L) &#123;     </span><br><span class="line">            <span class="keyword">return</span> ans;     </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; L - <span class="number">1</span>; ++i) &#123;   </span><br><span class="line">            x = (x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i));     </span><br><span class="line">        &#125;      </span><br><span class="line">        Map&lt;Integer, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();   </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - L; ++i) &#123;   </span><br><span class="line">            x = ((x &lt;&lt; <span class="number">2</span>) | bin.get(s.charAt(i + L - <span class="number">1</span>))) &amp; ((<span class="number">1</span> &lt;&lt; (L * <span class="number">2</span>)) - <span class="number">1</span>); </span><br><span class="line">            cnt.put(x, cnt.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);    </span><br><span class="line">            <span class="keyword">if</span> (cnt.get(x) == <span class="number">2</span>) &#123;         </span><br><span class="line">                ans.add(s.substring(i, i + L));    </span><br><span class="line">            &#125;      </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> ans;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="223-矩形面积-E"><a href="#223-矩形面积-E" class="headerlink" title="223.矩形面积(E)"></a>223.矩形面积(E)</h1><p>给你 <strong>二维</strong> 平面上两个 <strong>由直线构成的 矩形</strong>，请你计算并返回两个矩形覆盖的总面积。</p><p>每个矩形由其 <strong>左下</strong> 顶点和 <strong>右上</strong> 顶点坐标表示：</p><p>第一个矩形由其<strong>左下顶点 (ax1, ay1)</strong> 和<strong>右上顶点 (ax2, ay2)</strong> 定义。<br>第二个矩形由其<strong>左下顶点 (bx1, by1)</strong> 和<strong>右上顶点 (bx2, by2)</strong> 定义。</p><p>方法 ：直接计算重叠面积</p><p>如果两个矩形重叠，则两个矩形的重叠部分也是矩形，重叠部分的面积可以根据重叠部分的边界计算。</p><p>两个矩形的水平边投影到 x<em>x</em> 轴上的线段分别为[<em>ax</em>1,<em>ax</em>2] 和 [<em>bx</em>1,<em>bx</em>2]，竖直边投影到 y<em>y</em> 轴上的线段分别为[<em>ay</em>1,<em>ay</em>2] 和 [<em>by</em>1,<em>by</em>2]。如果两个矩形重叠，则重叠部分的水平边投影到 x 轴上的线段为 [max(ax1, bx1) , min(ax2, bx2)] , 竖直边投影到 <em>y</em> 轴上的线段为 [max(ay1, by1) , min(ay2, by2)] , 根据重叠部分的水平边投影到 x 轴上的线段长度和竖直边投影到 y 轴上的线段长度即可计算重叠部分的面积。只有当两条线段的长度都大于 0 时，重叠部分的面积才大于 0，否则重叠部分的面积为 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">computeArea</span><span class="params">(<span class="type">int</span> ax1, <span class="type">int</span> ay1, <span class="type">int</span> ax2, <span class="type">int</span> ay2, <span class="type">int</span> bx1, <span class="type">int</span> by1, <span class="type">int</span> bx2, <span class="type">int</span> by2)</span> &#123;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">area1</span> <span class="operator">=</span> (ax2 - ax1) * (ay2 - ay1), area2 = (bx2 - bx1) * (by2 - by1); </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapWidth</span> <span class="operator">=</span> Math.min(ax2, bx2) - Math.max(ax1, bx1), overlapHeight = Math.min(ay2, by2) - Math.max(ay1, by1);  </span><br><span class="line">        <span class="type">int</span> <span class="variable">overlapArea</span> <span class="operator">=</span> Math.max(overlapWidth, <span class="number">0</span>) * Math.max(overlapHeight, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> area1 + area2 - overlapArea; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="229-求众数2-M"><a href="#229-求众数2-M" class="headerlink" title="229.求众数2(M)"></a>229.求众数2(M)</h1><p>给定一个大小为 <em>n</em> 的整数数组，找出其中所有出现超过 n&#x2F;3  次的元素。</p><blockquote><p> 进阶：尝试设计时间复杂度为 O(n)、空间复杂度为 O(1)的算法解决此问题。</p></blockquote><p>哈希表计数：</p><p>一个朴素的做法是使用「哈希表」进行计数，在计数完成后将所有出现次数超过 n &#x2F; 3<em>n</em>&#x2F;3 的元素加入答案。</p><p>时间和空间复杂度都为O(n)</p><hr><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>摩尔投票法的核心思想为<strong>对拼消耗</strong>。</p><p>最基本的摩尔投票问题，比如找出一组数字序列中出现次数大于总数 1&#x2F;2  的数字（并且假设这个数字一定存在）。我们可以直接利用反证法证明这样的数字只可能有一个。摩尔投票算法的核心思想是基于这个事实：</p><ul><li><strong>每次</strong>从序列里<strong>选择两个不相同的数字删除掉</strong>（或称为「抵消」），<strong>最后剩下</strong>一个数字或几个相同的数字，<strong>就是出现次数大于总数一半的那个元素</strong>。</li></ul><p>题目要求找出出现超过n&#x2F;3次的元素，可以用反证法推出满足条件的元素最多只有2个。所以可以利用摩尔投票法的核心思想，<strong>每次选择三个互不相同的元素进行删除</strong>（或称为「抵消」）。</p><p>摩尔投票法最后还需要计数阶段，来确定选出来的元素是否满足条件；</p><p>时间复杂度：O(n)，空间复杂度：O(1)，只使用了常数个元素来存储关键元素和统计次数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;  </span><br><span class="line">        <span class="comment">// 摩尔投票：抵消阶段  </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//第一个元素的值     </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element2</span> <span class="operator">=</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="comment">//第二个元素的值    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="comment">//第一个元素的可抵消个数    </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">vote2</span> <span class="operator">=</span> <span class="number">0</span>;   </span><br><span class="line">        <span class="comment">//第二个元素的可抵消个数    </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;     </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123; </span><br><span class="line">                <span class="comment">//如果该元素为第一个元素，则计数加1   </span></span><br><span class="line">                vote1++;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; <span class="comment">//如果该元素为第二个元素，则计数加1 </span></span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote1 == <span class="number">0</span>) &#123; <span class="comment">// 第一元素为空，则选择第一个元素      </span></span><br><span class="line">                element1 = num;     </span><br><span class="line">                vote1++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vote2 == <span class="number">0</span>) &#123; <span class="comment">// 选择第二个元素       </span></span><br><span class="line">                element2 = num;        </span><br><span class="line">                vote2++;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果三个元素均不相同，则相互抵消1次      </span></span><br><span class="line">                vote1--;        </span><br><span class="line">                vote2--;         </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="comment">// 摩尔投票：计数阶段   </span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt1</span> <span class="operator">=</span> <span class="number">0</span>;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt2</span> <span class="operator">=</span> <span class="number">0</span>;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; num == element1) &#123;   </span><br><span class="line">                cnt1++;        </span><br><span class="line">            &#125;       </span><br><span class="line">            <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; num == element2) &#123; </span><br><span class="line">                cnt2++;       </span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="comment">// 检测元素出现的次数是否满足要求   </span></span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();      </span><br><span class="line">        <span class="keyword">if</span> (vote1 &gt; <span class="number">0</span> &amp;&amp; cnt1 &gt; nums.length / <span class="number">3</span>) &#123;      </span><br><span class="line">            ans.add(element1);     </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">if</span> (vote2 &gt; <span class="number">0</span> &amp;&amp; cnt2 &gt; nums.length / <span class="number">3</span>) &#123;     </span><br><span class="line">            ans.add(element2);</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="230-二叉搜索树中第k小的元素-M"><a href="#230-二叉搜索树中第k小的元素-M" class="headerlink" title="230.二叉搜索树中第k小的元素(M)"></a>230.二叉搜索树中第k小的元素(M)</h1><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3输出：3</span><br></pre></td></tr></table></figure><blockquote><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 10的4次方</code></li><li><code>0 &lt;= Node.val &lt;= 10的4次方</code></li></ul><p><strong>进阶：</strong>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <code>k</code> 小的值，你将如何优化算法？</p></blockquote><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>由于题目中的树为搜索树，即树中左子节点小于当前节点，右子节点大于当前节点，各子树本身也是二叉搜索树；因此中序遍历二叉搜索树得到的结果是排序的；</p><p>时间复杂度：O(H + k)：H为树的高度</p><p>空间复杂度：O(H)：栈中最多存储H个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();    </span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span> || !stack.isEmpty()) &#123;   </span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;     </span><br><span class="line">                stack.push(root);       </span><br><span class="line">                root = root.left;   </span><br><span class="line">            &#125;     </span><br><span class="line">            root = stack.poll(); </span><br><span class="line">            k--;       </span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;    </span><br><span class="line">                <span class="keyword">break</span>;     </span><br><span class="line">            &#125;          </span><br><span class="line">            root = root.right;   </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> root.val; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="记录子树的节点数"><a href="#记录子树的节点数" class="headerlink" title="记录子树的节点数"></a>记录子树的节点数</h3><blockquote><p>如果要频繁地查找第k小的值，该如何优化？</p></blockquote><p>中序遍历中，以为我们不知道子树的节点数量，不得不通过遍历子树来获得前k个元素；</p><p>因此，我们可以记录下<strong>每个节点为根结点的子树的结点数</strong>，并在查找第 k 小的值时，使用如下方法搜索：</p><ul><li><p>令 node 等于根结点，开始搜索。</p></li><li><p>对当前结点 node 进行如下操作：</p><ul><li>如果 node 的左子树的结点数 left 小于 k-1，则第 k 小的元素一定在node 的右子树中，令 node 等于其的右子结点，k 等于 k - left−1，并继续搜索；</li><li>如果 node 的左子树的结点数 left 等于 k-1，则第 k 小的元素即为 node ，结束搜索并返回 node 即可；</li><li>如果 node 的左子树的结点数 left 大于 k-1，则第 k 小的元素一定在 node 的左子树中，令 node 等于其左子结点，并继续搜索。</li></ul></li></ul><p>可以再每个节点中存在子树节点数，也可以用哈希表记录；</p><p>时间复杂度：预处理的时间为O(N)：N为树中节点的总数（需要遍历所有节点来统计每个节点的为根的子树节点数）；搜索的时间为O（H)，H为树高；</p><p>空间复杂度 ：O(N)，哈希表存储每个节点的子树节点数信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">MyBst</span> <span class="variable">bst</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyBst</span>(root); </span><br><span class="line">        <span class="keyword">return</span> bst.kthSmallest(k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyBst</span> &#123; </span><br><span class="line">    TreeNode root;  </span><br><span class="line">    Map&lt;TreeNode, Integer&gt; nodeNum; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyBst</span><span class="params">(TreeNode root)</span> &#123;  </span><br><span class="line">        <span class="built_in">this</span>.root = root;   </span><br><span class="line">        <span class="built_in">this</span>.nodeNum = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;TreeNode, Integer&gt;();    </span><br><span class="line">        countNodeNum(root);    </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 返回二叉搜索树中第k小的元素   </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span> k)</span> &#123;    </span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> root;   </span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;  </span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> getNodeNum(node.left);     </span><br><span class="line">            <span class="keyword">if</span> (left &lt; k - <span class="number">1</span>) &#123;    </span><br><span class="line">                node = node.right;   </span><br><span class="line">                k -= left + <span class="number">1</span>;     </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (left == k - <span class="number">1</span>) &#123;  </span><br><span class="line">                <span class="keyword">break</span>;         </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">                node = node.left;     </span><br><span class="line">            &#125;     </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> node.val; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 统计以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countNodeNum</span><span class="params">(TreeNode node)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;     </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;      </span><br><span class="line">        &#125;      </span><br><span class="line">        nodeNum.put(node, <span class="number">1</span> + countNodeNum(node.left) + countNodeNum(node.right)); </span><br><span class="line">        <span class="keyword">return</span> nodeNum.get(node);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">// 获取以node为根结点的子树的结点数  </span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getNodeNum</span><span class="params">(TreeNode node)</span> &#123;   </span><br><span class="line">        <span class="keyword">return</span> nodeNum.getOrDefault(node, <span class="number">0</span>);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="平衡二叉搜索树"><a href="#平衡二叉搜索树" class="headerlink" title="平衡二叉搜索树"></a>平衡二叉搜索树</h3><blockquote><p>如果二叉搜索树经常被修改（插入&#x2F;删除操作）并且你需要频繁地查找第 <em>k</em> 小的值，你将如何优化算法？</p></blockquote><ul><li>平衡二叉搜索树中每个节点的左子树和右子树高度最多相差1；</li><li>其子树也是平衡二叉搜索树；</li><li>一棵存有n个节点的平衡二叉搜索树的高度为O(logn);</li></ul><p>在方法二中，其搜索的时间复杂度为O(H)，当树是平衡树时，时间复杂度可取到O(logN)；</p><p>时间复杂度：预处理的时间复杂度为 O(N)，其中 N 是树中结点的总数。插入、删除和搜索的时间复杂度均为 O(log N)。</p><p>空间复杂度：O(N)，用于存储平衡二叉搜索树。</p><h1 id="260-只出现一次的数字III-M"><a href="#260-只出现一次的数字III-M" class="headerlink" title="260.只出现一次的数字III (M)"></a>260.只出现一次的数字III (M)</h1><p>给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。</p><blockquote><p>进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">输入：nums = [1,2,1,3,2,5]</span><br><span class="line">输出：[3,5]</span><br><span class="line">解释：[5, 3] 也是有效的答案。</span><br></pre></td></tr></table></figure><p>方法一：用哈希映射统计数组中每一个元素出现的次数。在统计完成后，对哈希映射进行遍历，将所有只出现了一次的数放入答案中。</p><p>时间复杂度：O(n)；空间复杂度：O(n)</p><hr><p>方法二：位运算</p><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>假设数组 nums 中只出现一次的元素分别是x1和x2，如果<strong>把nums 中的所有元素全部异或起来，得到结果 x，则x &#x3D; x1异或x2</strong>，因为数组中出现两次的元素都会因为异或运算而被抵消掉（如：a异或b异或b&#x3D;a）。</p><p>因为x1和x2不等，所以x不会等于0。此时，<strong>利用 x &amp; -x 得到 x 的最低有效位lowbit</strong>，即x二进制表示中最低位的1，设这个1在第i位；</p><p>这样，数组中的元素就可以分为两类：一类是二进制表示中第i位为1的，另一类是第i位为0的，而x1和x2不会在同一类里（因为只有x1和x2的第i位不同，异或得到的第i位才为1）；然后<strong>将同一类的元素全部异或起来，那么其中一类最终会得到x1，另一类得到x2</strong>（出现两次的元素都会被异或运算抵消，最后只留下x1或x2）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumber(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">xorNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            xorNum ^= num;      <span class="comment">//最终xor=x1异或x2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//防止溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lowBit</span> <span class="operator">=</span> (xorNum == Integer.MIN_VALUE ? xorNum : xorNum &amp; (-xorNum));</span><br><span class="line">        <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> <span class="number">0</span>, x2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((lowBit &amp; num) != <span class="number">0</span>) &#123;      <span class="comment">//将同属一类的元素异或起来，最后得到x1</span></span><br><span class="line">                x1 ^= num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                x2 ^= num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1, x2&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="335-交叉路径-D"><a href="#335-交叉路径-D" class="headerlink" title="335.交叉路径(D)"></a>335.交叉路径(D)</h1><p>给定一个整数数组distance；</p><p>从X-Y平面上的原点（0，0）开始，每四个数字一组，分别向北，西，南，东移动。</p><p>判断你所经过的路径是否相交，如果相交，返回true，否则，返回false；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：distance = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">输出：<span class="literal">true</span></span><br><span class="line"><span class="comment">//画图</span></span><br></pre></td></tr></table></figure><h3 id="归纳法-找规律"><a href="#归纳法-找规律" class="headerlink" title="归纳法(找规律)"></a>归纳法(找规律)</h3><p>首先，至少需要4条边才可能存在相交路径，如果distance长度小于4，可直接返回fasle；</p><p>对可能相交情况进行分情况讨论，设当前枚举到的边为 d[ i ] ，(画图理解！)</p><ol><li>d[i] 与 d[i - 3] 发生相交：此时满足 d[i] &gt;&#x3D; d[i - 2]，同时 d[i - 1] &lt;&#x3D; d[i - 3]；</li><li>d[i] 与 d[i - 4] 发生相交：此时满足 d[i - 1] &gt;&#x3D; d[i - 3]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]；</li><li>d[i] 与 d[i - 5] 发生相交：此时满足 d[i - 1] &lt;&#x3D; d[i - 3]，同时 d[i - 2] &gt; d[i - 4]，同时 d[i] + d[i - 4] &gt;&#x3D; d[i - 2]，同时 d[i - 1] + d[i - 5] &gt;&#x3D; d[i - 3]</li></ol><p>综上，d[i] 不会与d[i - 1] 和 d[i - 2] 发生相交，而 d[i] 在与d[i - x] (x&gt;5)发生相交前，必然先与d[i - y] (3&lt;&#x3D;y&lt;5) 发生相交。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSelfCrossing</span><span class="params">(<span class="type">int</span>[] d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> d.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">4</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d[i] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">4</span> &amp;&amp; d[i - <span class="number">1</span>] == d[i - <span class="number">3</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= <span class="number">5</span> &amp;&amp; d[i - <span class="number">1</span>] &lt;= d[i - <span class="number">3</span>] &amp;&amp; d[i - <span class="number">2</span>] &gt; d[i - <span class="number">4</span>] &amp;&amp; d[i] + d[i - <span class="number">4</span>] &gt;= d[i - <span class="number">2</span>] &amp;&amp; d[i - <span class="number">1</span>] + d[i - <span class="number">5</span>] &gt;= d[i - <span class="number">3</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="352-将数据流变为多个不相交区间-D"><a href="#352-将数据流变为多个不相交区间-D" class="headerlink" title="352.将数据流变为多个不相交区间(D)"></a>352.将数据流变为多个不相交区间(D)</h1><p> 给你一个由非负整数 a1, a2, …, an 组成的数据流输入，请你将到目前为止看到的数字总结为不相交的区间列表。</p><p>（如：arr[1,2,3,7] ，则将其分为：[1,3]，[7,7]  ）</p><blockquote><p>实现 SummaryRanges 类：</p><p>SummaryRanges()：使用一个空数据流初始化对象。<br>void addNum(int val) ：向数据流中加入整数 val 。<br>int[][] getIntervals()： 以不相交区间 [starti, endi] 的列表形式返回对数据流中整数的总结。</p></blockquote><h3 id="有序映射（TreeMap"><a href="#有序映射（TreeMap" class="headerlink" title="有序映射（TreeMap)"></a>有序映射（TreeMap)</h3><p>使用某一数据结构维护这些不相交的区间，在设计具体的数据结构之前，我们需要先明确 void addNum(int val) 这一操作会使得当前的区间集合发生的变化：</p><ul><li><p>情况一：如果存在一个区间 [ l , r ]，它完全包含 val，即 l ≤ val ≤ r，那么在加入 val 之后，区间集合不会有任何变化；</p></li><li><p>情况二：如果存在一个区间 [ l , r ]，它的右边界 r「紧贴着」val，即 r + 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l , r+1 ]；</p></li><li><p>情况三：如果存在一个区间 [ l , r ]，它的左边界 l「紧贴着」val，即 l - 1 &#x3D; val，那么在加入 val 之后，该区间会从 [ l , r ] 变为 [ l−1 , r ]；</p></li><li><p>情况四：如果情况二和情况三同时满足，即存在一个区间 [ l0 , r0] 满足 r0 + 1 &#x3D; val， 并且存在一个区间 [ l1, r1] 满足 l1 - 1 &#x3D; val，那么在加入val后，这两个区间会合并成一个大区间；</p></li><li><p>情况五：在上述四种情况均不满足的情况下，val 会单独形成一个新的区间 [ val , val ]。</p></li></ul><p>一种可以<strong>找到「最近」区间</strong>的数据结构是<strong>有序映射</strong>。有序映射中的键和值分别表示区间的左边界 l 和右边界 r。由于有序映射支持查询「最大的比某个元素小的键」以及「最小的比某个元素大的键」这两个操作，因此我们可以快速地定位区间 [ l0 , r0 ] 和[ l1 , r1]；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SummaryRanges</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; intervals;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SummaryRanges</span><span class="params">()</span> &#123;</span><br><span class="line">        intervals = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="comment">// 找到 l1 最小的且满足 l1 &gt; val 的区间 interval1 = [l1, r1]</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval1 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval1 = intervals.ceilingEntry(val + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 找到 l0 最大的且满足 l0 &lt;= val 的区间 interval0 = [l0, r0]</span></span><br><span class="line">        <span class="comment">// 在有序集合中，interval0 就是 interval1 的前一个区间</span></span><br><span class="line">        <span class="comment">// 如果不存在这样的区间，interval0 为尾迭代器</span></span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; interval0 = intervals.floorEntry(val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (interval0 != <span class="literal">null</span> &amp;&amp; interval0.getKey() &lt;= val &amp;&amp; val &lt;= interval0.getValue()) &#123;</span><br><span class="line">            <span class="comment">// 情况一</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">leftAside</span> <span class="operator">=</span> interval0 != <span class="literal">null</span> &amp;&amp; interval0.getValue() + <span class="number">1</span> == val;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">rightAside</span> <span class="operator">=</span> interval1 != <span class="literal">null</span> &amp;&amp; interval1.getKey() - <span class="number">1</span> == val;</span><br><span class="line">            <span class="keyword">if</span> (leftAside &amp;&amp; rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况四</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> interval0.getKey(), right = interval1.getValue();</span><br><span class="line">                intervals.remove(interval0.getKey());</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(left, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftAside) &#123;</span><br><span class="line">                <span class="comment">// 情况二</span></span><br><span class="line">                intervals.put(interval0.getKey(), interval0.getValue() + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rightAside) &#123;</span><br><span class="line">                <span class="comment">// 情况三</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> interval1.getValue();</span><br><span class="line">                intervals.remove(interval1.getKey());</span><br><span class="line">                intervals.put(val, right);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 情况五</span></span><br><span class="line">                intervals.put(val, val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] getIntervals() &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> intervals.size();</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size][<span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : intervals.entrySet()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> entry.getKey(), right = entry.getValue();</span><br><span class="line">            ans[index][<span class="number">0</span>] = left;</span><br><span class="line">            ans[index][<span class="number">1</span>] = right;</span><br><span class="line">            ++index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="405-数字转换为十六进制数-E"><a href="#405-数字转换为十六进制数-E" class="headerlink" title="405.数字转换为十六进制数(E)"></a>405.数字转换为十六进制数(E)</h1><p>给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。</p><p>注意:</p><blockquote><ol><li>十六进制中所有字母(a-f)都必须是小写。</li><li>十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符’0’来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 </li><li>给定的数确保在32位有符号整数范围内。</li><li>不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</li></ol></blockquote><p><strong>模拟+进制转换</strong></p><p>利用通用的进制转换思路来做，不断循环 num % k 和 num &#x2F; k 的操作来构造出 k 进制每一位。</p><p>但需要处理「补码」问题：对于负数的 num，我们需要先在 num 基础上加上 2^32 的偏移量，再进行进制转换。</p><p>（将有符号整数 转化为 无符号整数，其二进制表示方式不变，十进制则相当于原数字加上2的n次方，n为二进制的位数，同样的，其十六进制表示方式也不变）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">if</span> (num &lt; <span class="number">0</span>) temp = (<span class="type">long</span>) (Math.pow(<span class="number">2</span>, <span class="number">32</span>) + num);        <span class="keyword">while</span> (temp != <span class="number">0</span>) &#123;            <span class="type">long</span> <span class="variable">u</span> <span class="operator">=</span> temp % <span class="number">16</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            temp /= <span class="number">16</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>位运算 + 分组换算</strong></p><p>将长度为 32 的二进制转换为 16 进制数，本质是对长度为 32 的二进制数进行分组，</p><p>由于我们是直接对长度为 32 的二进制进行分组转算（4 个为一组，共 8 组），而长度为 32 的二进制本身就是使用补码规则来表示的，因此我们无须额外处理「补码」问题。</p><p>具体的，我们将 num 与 15的二进制 进行 &amp; 运算，然后对 num 进行无符号右移 4 位来实现每 4 位处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;    <span class="keyword">public</span> String <span class="title function_">toHex</span><span class="params">(<span class="type">int</span> num)</span> &#123;        <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();        <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> num &amp; <span class="number">15</span>;            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">char</span>) (u + <span class="string">&#x27;0&#x27;</span>);            <span class="keyword">if</span> (u &gt;= <span class="number">10</span>) c = (<span class="type">char</span>) (u - <span class="number">10</span> + <span class="string">&#x27;a&#x27;</span>);            sb.append(c);            num &gt;&gt;&gt;= <span class="number">4</span>;        &#125;        <span class="keyword">return</span> sb.reverse().toString();    &#125;&#125;</span><br></pre></td></tr></table></figure><h1 id="437-路径总和III-M"><a href="#437-路径总和III-M" class="headerlink" title="437.路径总和III(M)"></a>437.路径总和III(M)</h1><p>给定一个二叉树的根节点 <strong>root</strong> ，和一个整数 <strong>targetSum</strong> ，求该二叉树里<strong>节点值之和等于 targetSum 的 路径</strong> 的<strong>数目</strong>。</p><p>路径 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：root =[10,5,-3,3,2,null,11,3,-2,null,1]，targetSum = 8输出：3解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure><h3 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h3><p>前缀和，就是到达当前元素的路径上，之前所有元素的和。</p><p>如果前缀总和currSum，在节点A和节点B处相差target，则位于节点A和节点B之间的元素之和是target，也就是说A和B之间的路径符合题目要求</p><p><strong>算法思路：</strong></p><p>抵达当前节点(即B节点)后，将前缀和累加，然后查找在前缀和上，有没有前缀和currSum-target的节点(即A节点)，存在即表示从A到B有一条路径之和满足条件的情况。结果加上满足前缀和currSum-target的节点的数量。然后递归进入左右子树。</p><p>左右子树遍历完成之后，回到当前层，需要把当前节点添加的前缀和去除。避免回溯之后影响上一层。因为思想是前缀和，不属于前缀的，我们就要去掉它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;  </span><br><span class="line">        <span class="comment">// key是前缀和, value是大小为key的前缀和出现的次数    </span></span><br><span class="line">        Map&lt;Integer, Integer&gt; prefixSumCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();    </span><br><span class="line">        prefixSumCount.put(<span class="number">0</span>, <span class="number">1</span>);<span class="comment">// 前缀和为0的一条路径    </span></span><br><span class="line">        <span class="keyword">return</span> recursionPathSum(root, prefixSumCount, sum, <span class="number">0</span>);  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recursionPathSum</span><span class="params">(TreeNode node, Map&lt;Integer, Integer&gt; prefixSumCount, <span class="type">int</span> target, <span class="type">int</span> currSum)</span> &#123;    </span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;    </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;       </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        currSum += node.val;   </span><br><span class="line">        <span class="comment">//如果此前有和为currSum-target,而当前的和又为currSum,两者的差就肯定为target了        res += prefixSumCount.getOrDefault(currSum - target, 0);    </span></span><br><span class="line">        <span class="comment">// 更新路径上当前节点前缀和的个数     </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.getOrDefault(currSum, <span class="number">0</span>) + <span class="number">1</span>);   </span><br><span class="line">        res += recursionPathSum(node.left, prefixSumCount, target, currSum);   </span><br><span class="line">        res += recursionPathSum(node.right, prefixSumCount, target, currSum);</span><br><span class="line">        <span class="comment">//回到本层，恢复状态，去除当前节点的前缀和数量  </span></span><br><span class="line">        prefixSumCount.put(currSum, prefixSumCount.get(currSum) - <span class="number">1</span>);   </span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O（N），每个节点只遍历一次</p><p>；空间复杂度：O（N），用了一个hashMap</p><p>476.数字的补数(E)</p><p>对整数的二进制表示取反（0 变 1 ，1 变 0）后，再转换为十进制表示，可以得到这个整数的补数。</p><ul><li>例如，整数 5 的二进制表示是 “101” ，取反后得到 “010” ，再转回十进制表示得到补数 2 。（无视了前导零）</li></ul><p>给你一个整数 num ，输出它的补数。</p><blockquote><p>1 &lt;&#x3D; num &lt; 2的31次方</p></blockquote><p>模拟(lowbit)</p><p>如果 num 的二进制表示中最高位 1 的位置为 s 的话，那么实际上我们只需要对 num 的前 s - 1 位进行取反即是答案（第 s 位的取反结果始终为 0）。</p><p>因此我们可以先使用 lowbit 操作来得到 num 二进制表示中最高位 1 的位置为 1，其余位为 0 时所代表的数字 x。</p><p>然后 x - 1 即是二进制表示中前 s - 1 位均为 1，其余位为 0 的数字，将其与 num 的取反数执行「按位与」操作，即可达到「仅对 num 的前 s - 1 位进行取反」的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123;    </span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> num; i != <span class="number">0</span>; i -= i &amp; -i) x = i;      </span><br><span class="line">        <span class="keyword">return</span> ~num &amp; (x - <span class="number">1</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以用这种：</p><p>找到二进制表示最高位的 1 ：第 i (0≤i≤30) 位，后，</p><p>我们可以遍历 num 的第 0 ∼ i 个二进制位，将它们依次进行取反。也可以用更高效的方式，构造掩码 mask &#x3D; 2<br>的i+1次方 - 1，它是一个 i+1 位的二进制数，并且每一位都是 1。我们将 num 与mask 进行异或运算，即可得到答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findComplement</span><span class="params">(<span class="type">int</span> num)</span> &#123; </span><br><span class="line">        <span class="type">int</span> <span class="variable">highbit</span> <span class="operator">=</span> <span class="number">0</span>;     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">30</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num &gt;= <span class="number">1</span> &lt;&lt; i) &#123;      </span><br><span class="line">                highbit = i;      </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;          </span><br><span class="line">                <span class="keyword">break</span>;    </span><br><span class="line">            &#125;          </span><br><span class="line">        &#125;     </span><br><span class="line">        <span class="type">int</span> <span class="variable">mask</span> <span class="operator">=</span> highbit == <span class="number">30</span> ? <span class="number">0x7fffffff</span> : (<span class="number">1</span> &lt;&lt; (highbit + <span class="number">1</span>)) - <span class="number">1</span>;      </span><br><span class="line">        <span class="keyword">return</span> num ^ mask;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="483-密钥格式化-E"><a href="#483-密钥格式化-E" class="headerlink" title="483.密钥格式化(E)"></a>483.密钥格式化(E)</h1><p>有一个密钥字符串 S ，只包含字母，数字以及 ‘-‘（破折号）。其中， N 个 ‘-‘ 将字符串分成了 N+1 组。</p><p>给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分组之间需要用 ‘-‘（破折号）隔开，并且将所有的小写字母转换为大写字母。</p><p>给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：输入：S = <span class="string">&quot;5F3Z-2e-9-w&quot;</span>, K = <span class="number">4</span>输出：<span class="string">&quot;5F3Z-2E9W&quot;</span>解释：字符串 S 被分成了两个部分，每部分 <span class="number">4</span> 个字符；注意，两个额外的破折号需要删掉。</span><br></pre></td></tr></table></figure><p><strong>模拟</strong></p><p>简单字符串模拟，从后往前处理，避免对首个分区的分情况讨论和取余操作。（注意答案字符串首部不要加上‘-’）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">licenseKeyFormatting</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, cnt = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;-&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (cnt == k)&#123;</span><br><span class="line">                sb.append(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            sb.append(s.charAt(i));</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString().toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="583-两个字符串的删除操作-M"><a href="#583-两个字符串的删除操作-M" class="headerlink" title="583.两个字符串的删除操作(M)"></a>583.两个字符串的删除操作(M)</h1><p>给定两个单词 <em>word1</em> 和 <em>word2</em>，找到使得 <em>word1</em> 和 <em>word2</em> 相同所需的最小步数，每步可以删除任意一个字符串中的一个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入: &quot;sea&quot;, &quot;eat&quot;</span><br><span class="line">输出: 2</span><br><span class="line">解释: 第一步将&quot;sea&quot;变为&quot;ea&quot;，第二步将&quot;eat&quot;变为&quot;ea&quot;</span><br></pre></td></tr></table></figure><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>该问题等价于求解量字符的「最长公共子序列」，若两者长度分别为 n 和 m，而最长公共子序列长度为 max，则 n - max + m - maxn 即为答案。</p><p>f[i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符</p><p>当有了「状态定义」之后，基本上「转移方程」就是呼之欲出：</p><ul><li><strong>s1[i]&#x3D;&#x3D;s2[j] : f [i] [j] &#x3D; f [i-1] [j-1] +1</strong> </li><li><strong>s1[i] !&#x3D; s2[j] : f [i] [j]&#x3D;max( f [i-1] [j], f [i] [j-1] )</strong></li></ul><p>不加哨兵空格：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>])</span><br><span class="line">                    f[i][j] = f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - f[n][m] + m - f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加哨兵空格：</p><p>可以往字符串头部追加一个空格，以减少边界判断（使下标从 1 开始，并很容易构造出可滚动的「有效值」）。但实现上，不用真的往字符串中最佳空格，只需在初始化动规值时假定存在首部空格，以及对最后的 LCS 长度进行减一操作即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs1 = s1.toCharArray(), cs2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">int</span>[][] f = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 假定存在哨兵空格，初始化 f[0][x] 和 f[x][0]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) f[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                f[i][j] = Math.max(f[i - <span class="number">1</span>][j], f[i][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (cs1[i - <span class="number">1</span>] == cs2[j - <span class="number">1</span>]) f[i][j] = Math.max(f[i][j], f[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> f[n][m] - <span class="number">1</span>; <span class="comment">// 减去哨兵空格</span></span><br><span class="line">        <span class="keyword">return</span> n - max + m - max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="动态规划-2"><a href="#动态规划-2" class="headerlink" title="动态规划"></a>动态规划</h3><p>更加契合题意的状态定义是根据「最长公共子序列（LCS）」的原始状态定义进行微调：定义 f [i] [j] 代表考虑 s1 的前 i 个字符、考虑 s2 的前 j 个字符（最终字符串不一定包含 s1[i] 或 s2[j]）时形成相同字符串的最小删除次数。</p><p>则转移方程 f [i] [j] 计算：</p><ul><li><strong>s1[i] &#x3D;&#x3D; s2[j]：f [i] [j] &#x3D; f [i - 1] [j - 1]，代表可以不用必然删掉 s1[i] 和 s2[j] 形成相同字符串；</strong></li><li><strong>s1[i] !&#x3D; s2[j]：f[i] [j] &#x3D; min(f[i - 1] [j] + 1, f[i] [j - 1] + 1)，代表至少一个删除 s1[i] 和 s2[j] 中的其中一个。</strong></li></ul><p>f [i] [j] 为上述方案中的最小值，最终答案为 f [n] [m]。</p><p><strong>动态规划的边界：</strong></p><p>当i 或 j &#x3D; 0 时，其中一个字符串为空，空字符串和任何字符串要变成相同，只有将另一个字符串的字符全部删除，所以 <strong>dp[i] [0] &#x3D; i</strong> 以及 <strong>dp[0] [j] &#x3D; j</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length(), m = s2.length();</span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray(), c2 = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++)</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++)&#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i][j - <span class="number">1</span>] + <span class="number">1</span>, dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1[i - <span class="number">1</span>] == c2[j - <span class="number">1</span>]) dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="638-大礼包"><a href="#638-大礼包" class="headerlink" title="638.大礼包"></a>638.大礼包</h1><p>在 商店中， 有 n 件在售的物品。每件物品都有对应的价格。然而，也有一些大礼包，每个大礼包以优惠的价格捆绑销售一组物品。</p><p>给你一个整数数组 <code>price</code> 表示物品价格，其中 <strong><code>price[i]</code> 是第 i 件物品的价格</strong>。另有一个整数数组 <code>needs</code> 表示购物清单，其中 <strong><code>needs[i]</code> 是需要购买第 i 件物品的数量</strong>。</p><p>还有一个数组 <code>special</code> 表示大礼包，<code>special[i]</code> 的长度为 n + 1 ，其中 <strong><code>special[i][j]</code> 表示第 i 个大礼包中内含第 j 件物品的数量</strong>，且 <strong><code>special[i][n]</code> （也就是数组中的最后一个整数）为第 i 个大礼包的价格</strong>。</p><p>返回 确切 满足购物清单所需花费的最低价格，你可以充分利用大礼包的优惠活动。你不能购买超出购物清单指定数量的物品，即使那样会降低整体价格。任意大礼包可无限次购买。</p><blockquote><p>输入：price &#x3D; [2,3,4], special &#x3D; [[1,1,0,4],[2,2,1,9]], needs &#x3D; [1,2,1]<br>输出：11<br>解释：A ，B ，C 的价格分别为 ¥2 ，¥3 ，¥4 。<br>可以用 ¥4 购买 1A 和 1B ，也可以用 ¥9 购买 2A ，2B 和 1C 。<br>需要买 1A ，2B 和 1C ，所以付 ¥4 买 1A 和 1B（大礼包 1），以及 ¥3 购买 1B ， ¥4 购买 1C 。<br>不可以购买超出待购清单的物品，尽管购买大礼包 2 更加便宜。</p></blockquote><h3 id="记忆化搜索"><a href="#记忆化搜索" class="headerlink" title="记忆化搜索"></a>记忆化搜索</h3><p>因为大礼包中可能包含多个物品，所以并不是所有状态都可以得到。因此，我们使用记忆化搜索而不是完全遍历的方法，来计算出满足每个购物清单 needs 所需花费的最低价格。</p><ul><li><p>首先，我们过滤掉不需要计算的大礼包。</p><p>如果大礼包完全没有优惠（大礼包的价格大于等于原价购买大礼包内所有物品的价格），或者大礼包内不包含任何的物品，那么购买这些大礼包不可能使整体价格降低。因此，我们可以不考虑这些大礼包，并将它们过滤掉，以提高效率和方便编码。</p></li><li><p>然后，计算满足购物清单所需花费的最低价格：</p><p>用 dp[needs] 表示满足购物清单 needs 所需花费的最低价格。在进行状态转移时，我们考虑在满足购物清单 needs 时的最后一次购买；其中，将原价购买购物清单中的所有物品也视作一次购买。则有两种情况：</p><ul><li><p>一，购买大礼包，状态转移方程为：</p><p>dp[needs] &#x3D; min{price<del>i</del> +dp[ needs - needs<del>i</del> ]} ( i ∈ K )，</p><ul><li><p>K 表示所有可以购买的大礼包的下标集合，i 表示其中一个大礼包的下标，</p></li><li><p>price<del>i</del> 表示第 i 个大礼包的价格，</p></li><li><p>needs<del>i</del> 表示大礼包中包含的物品清单，</p></li><li><p>needs−needs<del>i</del> 表示购物清单 needs 减去第 i 个大礼包中包含的物品清单后剩余的物品清单。</p></li></ul></li><li><p>二，不购买任何大礼包，原价购买购物清单中的所有物品，此时 dp [needs] 可以直接求出。</p></li></ul><p>对此，要求出当前购物清单 <code>cur_needs</code> 所需花费的最低价格 <code>min_price</code> ，具体做法为：</p><ul><li><p>将 min_price 初始化为原价购买购物清单cur_needs 中的所有物品的花费；</p></li><li><p>逐个遍历所有可以购买的大礼包，不妨设当前遍历的大礼包为 cur_special，其价格为special_price：</p><ul><li><p>计算购买大礼包 cur_special 后新的购物清单 next_needs，并递归地计算满足购物清单 next_needs 所需花费的最低价格 next_price；</p></li><li><p>计算满足当前购物清单 cur_needs 所需花费的最低价格 cur_price &#x3D; special_price + next_price；</p></li><li><p>如果 cur_price &lt; min_price，则将 min_price 更新为 cur_price。</p></li></ul></li><li><p>返回计算满足购物清单 cur_needs 所需花费的最低价格 min_price。</p></li></ul></li></ul><p>时间复杂度：O ( n × k × m^n^ )：k为大礼包数量，m为每种物品的需求量(等于最大需求量加1)，n表示物品数量</p><p>空间复杂度：O ( n × m^n^ )：用于存储记忆化搜索中 m^n^个状态的计算结果，每个状态需要存储 n  个商品的需求量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//存储 某个状态的清单~~它所需花费的最低值 的键值对</span></span><br><span class="line">    Map&lt;List&lt;Integer&gt;, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;List&lt;Integer&gt;, Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shoppingOffers</span><span class="params">(List&lt;Integer&gt; price, List&lt;List&lt;Integer&gt;&gt; special, List&lt;Integer&gt; needs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> price.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过滤不需要计算的大礼包，只保留需要计算的大礼包</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; filterSpecial = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; sp : special) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">totalCount</span> <span class="operator">=</span> <span class="number">0</span>, totalPrice = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                totalCount += sp.get(i);</span><br><span class="line">                totalPrice += sp.get(i) * price.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (totalCount &gt; <span class="number">0</span> &amp;&amp; totalPrice &gt; sp.get(n)) &#123;</span><br><span class="line">                filterSpecial.add(sp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dfs(price, needs, filterSpecial, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索计算满足购物清单所需花费的最低价格</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(List&lt;Integer&gt; price, List&lt;Integer&gt; curNeeds, List&lt;List&lt;Integer&gt;&gt; filterSpecial, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!memo.containsKey(curNeeds)) &#123;      <span class="comment">//传进来的清单 还没有计算出最低花费</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                minPrice += curNeeds.get(i) * price.get(i); <span class="comment">// 不购买任何大礼包，原价购买购物清单中的所有物品</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (List&lt;Integer&gt; curSpecial : filterSpecial) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">specialPrice</span> <span class="operator">=</span> curSpecial.get(n);   <span class="comment">//sepcialPrice = 当前礼包的费用</span></span><br><span class="line">                List&lt;Integer&gt; nextNeeds = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;(); <span class="comment">//nextNeeds = 当前清单各物品数 - 礼包各物品数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (curSpecial.get(i) &gt; curNeeds.get(i)) &#123; <span class="comment">// 不能购买超出购物清单指定数量的物品</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nextNeeds.add(curNeeds.get(i) - curSpecial.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (nextNeeds.size() == n) &#123; <span class="comment">// 大礼包可以购买</span></span><br><span class="line">                    minPrice = Math.min(minPrice, dfs(price, nextNeeds, filterSpecial, n) + specialPrice);  </span><br><span class="line">                    <span class="comment">//当递归到一个礼包都不能购买时，dfs返回的就是当时清单的各物品原价</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            memo.put(curNeeds, minPrice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo.get(curNeeds);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="869-重新排序得到2的幂-M-待理解！"><a href="#869-重新排序得到2的幂-M-待理解！" class="headerlink" title="869.重新排序得到2的幂(M)  ~~ ~~ 待理解！"></a>869.重新排序得到2的幂(M)  ~~ ~~ 待理解！</h1>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/Notes/2022/04/14/Java/"/>
      <url>/Notes/2022/04/14/Java/</url>
      
        <content type="html"><![CDATA[<h2 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h2><h3 id="2-HashMap和Hashtable"><a href="#2-HashMap和Hashtable" class="headerlink" title="2. HashMap和Hashtable"></a>2. HashMap和Hashtable</h3><p><strong>相同点:</strong></p><p>hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口</p><p><strong>不同点:</strong></p><ol><li><p>底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树</p></li><li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p></li><li><p>添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p></li><li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p></li><li><p>扩容机制不同：当已用容量&gt;总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。</p></li><li><p>支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历</p></li><li><p>迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。</p></li><li><p>部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法</p></li><li><p>同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,</p><p>而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。sdfla</p></li></ol><h3 id="3-Arrays-asList"><a href="#3-Arrays-asList" class="headerlink" title="3.Arrays.asList"></a>3.Arrays.asList</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);</span><br></pre></td></tr></table></figure><p>( new 一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 是动态扩容的了。)</p><p>注意：</p><ul><li>不要将  原生数据类型的数组  作为参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//输出结果为1，而不是3</span></span><br></pre></td></tr></table></figure><p>上述代码，遍历mylist的话，会得到一个带有hashCode 的对象。</p><p>（当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是<strong>数组对象</strong>本身）</p><p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 <strong>Integer</strong> 而不是 int。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());</span><br></pre></td></tr></table></figure><ul><li><p>asList返回一个由指定数组生成的固定大小的List；</p><p>如果不new一个ArrayList，那么得到的list不能修改其大小，且Arrays的内部类ArrayList没有重写add等方法，用add会抛出异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);<span class="comment">//异常</span></span><br></pre></td></tr></table></figure><h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h3><p>java允许将同一个类中的<strong>多个同名，同功能但参数个数不同的方法</strong>，封装成一个方法，即通过<strong>可变参数</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int... 表示接受的是可变参数，类型是int， 即可接受多个int；可变参数的实参可以为0到任意多个；</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以作为数组；</span></span><br><span class="line"><span class="comment">//可变参数可以和普通类型的参数一起放在形参列表，但可变参数必须放在最后；列表里可变参数只能一个</span></span><br><span class="line"><span class="comment">//可变参数的本质就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;接受的参数个数：&quot;</span> + nums.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-字符"><a href="#5-字符" class="headerlink" title="5.字符"></a>5.字符</h3><h4 id="1-字符分割"><a href="#1-字符分割" class="headerlink" title="1.字符分割"></a>1.字符分割</h4><p>使用了 <strong>split(string)</strong> 方法通过指定分隔符将字符串分割为数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        String[] temp = str.split(d);</span><br><span class="line">        <span class="keyword">for</span>(String x : temp)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>使用 <strong>StringTokennizer</strong> 设置不同分隔符来分隔字符串，默认的分隔符是：<strong>空格、制表符（\t）、换行符(\n）、回车符（\r）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;this is string , split by stringtokenizer&quot;</span>;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用空格作为分隔符</span></span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//用逗号做分隔</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(st2.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st2.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this</span><br><span class="line">is</span><br><span class="line">string</span><br><span class="line">,</span><br><span class="line">split</span><br><span class="line">by</span><br><span class="line">stringtokenizer</span><br><span class="line"></span><br><span class="line">this is string </span><br><span class="line"> split by stringtokenizer</span><br></pre></td></tr></table></figure><h4 id="2-字符大小写"><a href="#2-字符大小写" class="headerlink" title="2.字符大小写"></a><strong>2.字符大小写</strong></h4><p>toUpperCase() 方法将字符串从小写转为大写</p><p>tolowerCase() 方法将字符串从大写转为小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;string runoob&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strUpper</span> <span class="operator">=</span> str.toUpperCase();</span><br></pre></td></tr></table></figure><h4 id="3-测试两个字符串区域是否相等"><a href="#3-测试两个字符串区域是否相等" class="headerlink" title="3.测试两个字符串区域是否相等"></a><strong>3.测试两个字符串区域是否相等</strong></h4><p> regionMatches() 方法测试两个字符串区域是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Welcome to Microsoft&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;I work with microsoft&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">//第一个参数 true 表示忽略大小写区别</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str1.regionMatches(<span class="literal">true</span>, <span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>); </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>) 表示将 str1 字符串从第<span class="number">11</span>个字符<span class="string">&quot;M&quot;</span>开始和 str2 字符串的第<span class="number">12</span>个字符<span class="string">&quot;M&quot;</span>开始逐个比较，共比较 <span class="number">9</span> 对字符，由于字符串区分大小写，所以结果为<span class="literal">false</span>。</span><br><span class="line">如果设置第一个参数为 <span class="literal">true</span> ，则表示忽略大小写区别，所以返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><h4 id="获取最大"><a href="#获取最大" class="headerlink" title="获取最大"></a>获取最大</h4><p>通过 Collections 类的 Collections.max() 和 Collections.min() 方法来查找数组中的最大和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.max(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure><h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><p>使用List类的Arrays.toString方法和list.Addall（list.Addall（array1.aslist(array2））方法将两个数组合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">String b[] = &#123; <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(a));</span><br><span class="line">list.addAll(Arrays.asList(b));</span><br><span class="line">Object[] c = list.toArray();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure><h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p>通过 Java Util 类的 <strong>Arrays.fill(arrayname,value)</strong> 方法和<strong>Arrays.fill(arrayname ,starting index ,ending index ,value)</strong> 方法向数组中填充元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(array, <span class="number">100</span>);<span class="comment">//全部填充 </span></span><br><span class="line">Arrays.fill(array, <span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>);<span class="comment">//填充第3 - 第6 d</span></span><br></pre></td></tr></table></figure><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">String[] extended = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">extended[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">extended[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"><span class="comment">//从names索引为0处 复制names.length长度的元素，到extend索引为0处</span></span><br><span class="line">System.arraycopy(names, <span class="number">0</span>, extended, <span class="number">0</span>, names.length);</span><br><span class="line"><span class="keyword">for</span> (String str : extended)&#123;</span><br><span class="line">    System.out.println(str);</span><br></pre></td></tr></table></figure><h4 id="数组差集，交集"><a href="#数组差集，交集" class="headerlink" title="数组差集，交集"></a>数组差集，交集</h4><p> 用<strong>removeAll</strong> () 方法来计算两个数组的差集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.removeAll(objArray2);<span class="comment">//objArray中删去元素一样的，留下不一样的</span></span><br></pre></td></tr></table></figure><p>用 <strong>retainAll</strong> () 方法来计算两个数组的交集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.retainAll(objArray2);<span class="comment">//objArray中删去元素不一样的，留下一样的</span></span><br></pre></td></tr></table></figure><h3 id="7-时间处理"><a href="#7-时间处理" class="headerlink" title="7.时间处理"></a>7.时间处理</h3><h4 id="当前时间及格式化"><a href="#当前时间及格式化" class="headerlink" title="当前时间及格式化"></a>当前时间及格式化</h4><p>用simpleDateFormat类的format(date)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Date对象，获取当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是&quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd日 E HH 点 mm分 ss 秒&quot;</span>)</span><br><span class="line">System.out.pritntln(f.format(now));<span class="comment">//将当前时间格式化为指定的格式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 <span class="number">2019</span> 年 <span class="number">10</span> 月 <span class="number">15</span> 日 星期一 09 点 <span class="number">26</span> 分 <span class="number">23</span> 秒</span><br></pre></td></tr></table></figure><p>SimpDateFormat自定义格式中常用字母及含义</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc0Mzc5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="获取年份月份等"><a href="#获取年份月份等" class="headerlink" title="获取年份月份等"></a>获取年份月份等</h4><p>用Calendar类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//cal.getTime 可获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> cal.get(Calendar.DATE);<span class="comment">//日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);<span class="comment">//年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_WEEK);<span class="comment">//一周中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dom</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);<span class="comment">//一个月中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR);<span class="comment">//一年中的第几天</span></span><br></pre></td></tr></table></figure><h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h3><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Vector)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.Vector 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArrayList)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 &quot;</span> + o.getClass() + <span class="string">&quot; 类的实例&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象是 java.util.ArrayList 类的实例</span><br></pre></td></tr></table></figure><h4 id="标签（Label）"><a href="#标签（Label）" class="headerlink" title="标签（Label）"></a>标签（Label）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OUTER:  <span class="comment">//定标签义，可以是任意标识符（一般放在迭代语句之前）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Even number: &quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span> OUTER;<span class="comment">//在continue或break后使用标签，直接跳到标签处</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Varargs可变参数"><a href="#Varargs可变参数" class="headerlink" title="Varargs可变参数"></a>Varargs可变参数</h4><p>在一个形参的”类型”与”参数名”之间加上三个连续的”.”，就可以让它和不确定个实参相匹配。</p><p>本质上和字符串一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumvarargs</span><span class="params">(<span class="type">int</span>... intArrays)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, i;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; intArrays.length; i++) &#123;</span><br><span class="line">        sum += intArrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumstring</span><span class="params">(<span class="type">int</span>[] intArrays)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java练习"><a href="#Java练习" class="headerlink" title="Java练习"></a>Java练习</h2><h3 id="网上练习"><a href="#网上练习" class="headerlink" title="网上练习"></a>网上练习</h3><ol><li><p>JDK：java开发核心组件；JRE：java运行环境；JVM：java虚拟机</p></li><li><p>JDK，JRE，JVM的关系：</p><p>JDK &#x3D; JRE + Java的开发工具（javac.exe，java.exe，javadoc.exe)</p><p>JRE &#x3D; JVM + Java核心类库 </p></li><li><p>javac（java语言编译器）用于编译java源文件。</p></li><li><p>JDK工具中javadoc用于生成java文档，格式为HTML。</p></li><li><p>JVM运行于操作系统之上，依赖于操作系统；能够直接运行<strong>java字节码</strong>文件。</p></li><li><p>Java HotSpot是一种热编译技术，在运行Java代码时会被使用，只对程序的部分字节码进行优化。</p></li><li><p>环境变量PATH中包含多个路径时，路径之间用；（分号）分开。</p></li><li><p>CLASSPATH中的“ .  ” 表示当前目录。</p></li><li><p>JVM执行一个Java类时，大致流程为：</p><p>装载类—&gt;校验类—&gt;执行类中的代码</p></li><li><p>如果类的成员的访问权限设置为默认，则该成员被同一包中的类访问；</p></li><li><p>类具有封装性，但可以通过类的公共接口访问类中的数据；</p></li><li><p>super指的是当前对象的父类对象的内存地址；</p></li><li><p>尝试对null对象进行操作时，会产生NullPointerException类型的异常；</p></li><li><p>覆盖（重写）只能发生在父类与子类之间；</p><p>重载可以发生在同一个类中；</p></li><li><p>this和super不能用在main()方法中；</p></li><li><p>每一个Unicode码占用16个比特位；</p></li><li><p>封装：对外隐藏内部实现细节，增强程序的安全性；</p></li><li><p>自定义异常必须继承Exception，可以继承自Error；</p></li><li><p>使用JDBC（Java Data Base Connectivity）连接数据库的顺序：</p><p>导入驱动包 ——加载驱动——建立数据库的连接——发送并处理SQL语句——关闭连接</p></li></ol><p>19.java分了5片内存：寄存器，本地方法区，方法区，栈，堆。</p><p>​栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；栈的存取速度要比堆快，次于CPU寄存器</p><p>   只要数据运算完成所在的区域结束，该数据就会被释放。</p><p>​堆：用于存储数组和对象，也就是实体。</p><p> 1：每一个实体都有内存首地址值。</p><p> 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p><p> 3：垃圾回收机制。</p><h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><p>一、java入门</p><ol><li><p>java诞生：1995年5月；java特点：简单性，面向对象，安全性，跨平台性，支持多线程，分部性；</p></li><li><p>path环境变量的作用：使用jdk命令 &#x2F; 在任何目录下都可以使用javac和java命令；</p></li><li><p>java程序运行需要经过编译和运行两个步骤：<strong>编译器</strong>执行 <strong>.java文件</strong>，编译生成 .class的字节码文件，而<strong>Java虚拟机</strong>运行 <strong>.class文件</strong>；</p><p>java命令用于运行编译后的 .class文件，不需要文件后缀名；</p></li><li><p>JDK中可执行程序都放在bin目录下：Java编译器javac.exe 和 Java运行工具 java.exe；</p></li><li><p>一个java程序不一定要有main方法，需要独立运行的程序才要有main方法。</p></li></ol><p>二、java编程基础</p><ol><li>在Java中，浮点型数会被默认为double类型，所以给float赋值浮点型数据时，应该加F&#x2F;f，如 float &#x3D; 1F；</li><li>文档注释 格式： &#x2F;**      *&#x2F;</li></ol><p>三、面向对象</p><ol><li>public，static不能修饰局部变量；</li><li>构造方法不能被继承；</li><li>面向对象的三大特征：封装，继承，多态；</li><li>this关键字的作用：（简答题）<ul><li>this调用本类中的属性，即成员变量；</li><li>this调用本类的其他方法；</li><li>this调用本类的其他构造方法，调用时要放在构造方法的首行；</li></ul></li><li>成员变量和局部变量的区别：<ul><li>定义位置的区别：成员变量定义与方法之外，类之内；局部变量定义在方法之内；</li><li>生命周期：成员变量随着对象的创建而产生，随着对象的消失而消失；局部变量随着方法内的创建语句而产生，在代码运行至自己的作用域外即消失；</li><li>存储位置的区别：成员变量存储在堆中，局部变量存储在栈中；</li><li>初始值不同：成员变量有默认的初始值；局部变量没有，需要初始化才能使用；</li></ul></li><li>构造方法和普通成员方法的不同：<ul><li>构造方法与类名相同；</li><li>构造方法前没有返回类型的声明；</li><li>构造方法因为没有返回类型，所以不能返回任何值，但可以使用return来返回；</li></ul></li><li>面向对象的三特征：<ul><li>封装：将对象的属性和行为封装起来，不需要让外界知道具体的实现细节；</li><li>继承：描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类进行功能拓展；</li><li>多态：允许程序中出现重名现象，使同种类的多个对象，在接收到同一个消息时能产生不同反应和效果；（前提是有一个父类，多个子类）</li></ul></li><li>局部内部类只可以被final修饰，且只能访问被final修饰的局部变量；</li><li>super和this不能同时存在与同一个构造方法中；</li></ol><p>五、集合</p><ol><li>如果使用通配符“？”接收对象，则此对象只能接收，不能修改。</li></ol><p>六、IO</p><h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>src（source源文件）—package（包）—-class（类）</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>IDEA 中代码模板位置：setting - Editor - Live Templates &#x2F; postfix Completion</p><p>常用模板：</p><ol><li><p>psvm ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sout</p></li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>删除当前行：ctrl + y</p><p>复制当前行：ctrl + d</p><p>补全代码：at + &#x2F;</p><p>添加取消注释：ctrl + &#x2F;</p><p>生成方法：alt + insert</p><p>生成环绕方式：ctrl + alt + t （即 if … else ，do…while，try…catch 之类的）</p><p>查看类的的层级关系：ctrl + H</p><p>定位方法：ctrl + B</p><p>自动分配变量名：alt + 回车   &#x2F;   ctrl + alt + v  &#x2F; 在后面加 .var</p><p>显示所有快捷键：ctrl + j</p><p>使用单元测试工具 JUnit 来运行调试 单个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法上加上@Test，按Alt+Enter，点”将JUnit5加入到类路径中&quot;，之后方法右边会右绿色小箭头可以使用，之后在这个类中要使用JUnit5，只要加上@Test即可</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>分类</strong></th><th align="left"><strong>功能点</strong></th><th align="left"><strong>Eclipse快捷键</strong></th><th align="left"><strong>IDEA快捷键</strong></th></tr></thead><tbody><tr><td><strong>搜索</strong></td><td align="left">搜索文本</td><td align="left">Ctrl + F</td><td align="left">Ctrl + FCtrl + R 查找替换                                        Alt + P&#x2F;A 逐个&#x2F;全部替换                                       Alt + F3 查找当前选中词</td></tr><tr><td></td><td align="left">继续搜索</td><td align="left">Ctrl + K 向前        Ctrl + Shift + K 向后</td><td align="left">F3                                                                 Shift + F3</td></tr><tr><td></td><td align="left">搜索方法</td><td align="left">Ctrl + O</td><td align="left">Ctrl + F12</td></tr><tr><td></td><td align="left">搜索类</td><td align="left">Ctrl + Shift + T</td><td align="left">Ctrl + N</td></tr><tr><td></td><td align="left">搜索文件</td><td align="left">Ctrl + Shift + T</td><td align="left">Ctrl + Shift + N                                                         这两个都支持简单的正则表达式，还支持直接按大写字母的缩略，                                   例如：查找JsonTranscoder，只需要输入JT</td></tr><tr><td></td><td align="left">搜索所有引用处</td><td align="left">Ctrl + Alt + H</td><td align="left">Alt + F7</td></tr><tr><td></td><td align="left">搜索所有文本出现的位置</td><td align="left">Ctrl + H</td><td align="left">Ctrl + Shift + F</td></tr><tr><td><strong>编辑</strong></td><td align="left">自动代码补全</td><td align="left">Alt + &#x2F;</td><td align="left">Ctrl + J</td></tr><tr><td></td><td align="left">自动代码生成</td><td align="left"></td><td align="left">Alt + Insert</td></tr><tr><td></td><td align="left">快速修复错误</td><td align="left">Ctrl + 1</td><td align="left">Alt + Enter</td></tr><tr><td></td><td align="left">删除当前行</td><td align="left">Ctrl + D</td><td align="left">Ctrl + X</td></tr><tr><td></td><td align="left">复制到下一行</td><td align="left"></td><td align="left">Ctrl + D</td></tr><tr><td></td><td align="left">注释&#x2F;取消注释</td><td align="left">Ctrl + &#x2F;</td><td align="left">Ctrl + &#x2F;</td></tr><tr><td></td><td align="left">选中当前字</td><td align="left"></td><td align="left">Ctrl + W</td></tr><tr><td></td><td align="left">补全当前行</td><td align="left"></td><td align="left">Ctrl + Shift + Enter神器，补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</td></tr><tr><td></td><td align="left">调出最近复制的N份内容</td><td align="left"></td><td align="left">Ctrl + Shift + V</td></tr><tr><td></td><td align="left">查看最近编辑的文件</td><td align="left"></td><td align="left">Ctrl + E</td></tr><tr><td></td><td align="left">对比最近修改</td><td align="left"></td><td align="left">Alt + Shift + C</td></tr><tr><td></td><td align="left">格式化代码</td><td align="left">Ctrl + Shift + F</td><td align="left">Ctrl + Alt + L</td></tr><tr><td></td><td align="left">整理import</td><td align="left">Ctrl + Shift + O</td><td align="left">Ctrl + Alt + O</td></tr><tr><td><strong>跳转</strong></td><td align="left">显示方法层次</td><td align="left"></td><td align="left">Ctrl + Shift + H</td></tr><tr><td></td><td align="left">显示类、方法说明</td><td align="left">F2</td><td align="left">Ctrl + Q</td></tr><tr><td></td><td align="left">跳到方法定义处</td><td align="left"></td><td align="left">Ctrl + B</td></tr><tr><td></td><td align="left">跳到方法实现处</td><td align="left"></td><td align="left">Ctrl + Alt + B</td></tr><tr><td></td><td align="left">跳到上&#x2F;下一方法</td><td align="left"></td><td align="left">Alt + Up&#x2F;Down</td></tr><tr><td></td><td align="left">上&#x2F;下一查看处</td><td align="left">Alt + &lt;-Alt + -&gt;</td><td align="left">Ctrl + Alt + Up&#x2F;Down</td></tr><tr><td></td><td align="left">跳到指定行</td><td align="left">Ctrl + L</td><td align="left">Ctrl + G</td></tr><tr><td><strong>重构</strong></td><td align="left">改名</td><td align="left">Alt + Shift + R</td><td align="left">Shift + F6</td></tr><tr><td></td><td align="left">其他常用</td><td align="left"></td><td align="left">Ctrl + F6 修改方法签名                                          Ctrl + Shift + F6 修改参数的类型                       Ctrl + Shift + V引入局部变量                              Ctrl + Shift + P 引入参数                              Ctrl + Shift + F 引入类变量                                     Ctrl + Shift + M 引入方法                         Ctrl + Shift + C 引入常量</td></tr><tr><td><strong>运行</strong></td><td align="left">启动调试</td><td align="left"></td><td align="left">Alt + Shift + F9</td></tr><tr><td></td><td align="left">启动运行</td><td align="left"></td><td align="left">Alt + Shift + F10</td></tr><tr><td></td><td align="left">单步进入</td><td align="left">F5</td><td align="left">F7</td></tr><tr><td></td><td align="left">单步跳过</td><td align="left">F6</td><td align="left">F8</td></tr><tr><td></td><td align="left">跳过</td><td align="left">F8</td><td align="left">F9</td></tr><tr><td></td><td align="left">执行选中语句</td><td align="left"></td><td align="left">Alt + F8</td></tr><tr><td><strong>窗口</strong></td><td align="left">调出界面</td><td align="left"></td><td align="left">Ctrl + Alt + S调出Settings界面                                 Ctrl + Alt + Shift + S调出项目Setting界面</td></tr><tr><td></td><td align="left">关闭界面</td><td align="left"></td><td align="left">Ctrl + F4 或 ESC</td></tr><tr><td></td><td align="left">打开窗口</td><td align="left"></td><td align="left">Alt + 窗口编号(例如项目窗口编号是1)</td></tr><tr><td></td><td align="left">最大化窗口</td><td align="left">Ctrl + M</td><td align="left">Ctrl + Shift + F12</td></tr><tr><td></td><td align="left">隐藏窗口</td><td align="left"></td><td align="left">Shift + ESC</td></tr><tr><td></td><td align="left">关闭当前文件</td><td align="left"></td><td align="left">Ctrl + F4</td></tr><tr><td></td><td align="left">垂直分屏</td><td align="left"></td><td align="left">Ctrl + | (自定义的)</td></tr><tr><td></td><td align="left">调整窗口位置</td><td align="left"></td><td align="left">Ctrl + M 将当前光标处显示到屏幕中央</td></tr><tr><td></td><td align="left">切换窗口</td><td align="left"></td><td align="left">Ctrl + Tab</td></tr></tbody></table><h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>Java可以使用修饰符来修饰类中 方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul><li><p><strong>public</strong> : <strong>对所有类可见（对外公开）</strong>。使用对象：类、接口、变量、方法</p></li><li><p><strong>protected</strong> : 对<strong>所有子类 和 同一包内的类 可见</strong>。使用对象：变量、方法。 注意：不能修饰类（外部类）</p></li><li><p><strong>default</strong> (即默认，什么也不写）: 在<strong>同一包内可见</strong>。使用对象：类、接口、变量、方法。</p></li><li><p><strong>private</strong> : 仅在<strong>类本身内可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p></li></ul><p>可以通过以下表来说明访问权限：</p><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left"><strong>Y</strong></td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left"><strong>Y</strong></td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left"><strong>Y</strong></td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left"><strong>Y</strong></td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h5><p><strong>类变量，也叫静态变量，是该类的所有对象共享的变量，</strong>任何一个该类的对象去访问&#x2F;修改它，取到&#x2F;修改的都是相同的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><p>jdk8以前，静态变量放在静态域（方法区），jdk8以后放在<strong>堆中</strong>，当这个类加载的时候会在堆生成这个类的class对象，静态变量就放在class实例的尾部。</p><p><strong>访问方式</strong>：类名.类变量名 或者 对象名.类变量名</p><p>（类变量在类加载时就初始化了，而不管new几次对象，类只会加载一次，类变量的生命周期与类相同）</p><hr><p><strong>类方法</strong>，也叫静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>访问方式</strong>：类名.类方法名 或者 对象名.类方法名</p><p>当方法中不涉及任何和对象相关的成员（包括this，super），则可以设计成静态方法，提高开发效率；如：工具类中的方法utils：Math类、Collections集合</p><hr><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol><li><p>这个关键字是一个修饰符，可以修饰类，方法，变量。</p></li><li><p>被final修饰的类是一个<strong>最终类，不可以被继承</strong>。</p></li><li><p>被final修饰的方法是一个<strong>最终方法，不可以被重写</strong>。</p></li><li><p>被final修饰的变量是一个<strong>常量，只能赋值一次</strong>。</p></li></ol><p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 <strong>_</strong> 连接。</p><p>注意点：</p><ul><li>final修饰的属性在定义时，必须赋初值，且不能再修改，可以在如下位置<strong>赋值</strong>：<ul><li><strong>定义时；</strong></li><li><strong>在构造器中</strong></li><li><strong>在代码块中</strong></li></ul></li><li>如果final修饰的<strong>属性是静态</strong>的，则只能在定义时和在静态代码块中赋值，<strong>不能在构造器中赋值</strong>；</li><li>final类不能继承，但可以实例化对象；</li><li>如果类不是final类，但含有final方法，则该方法虽不能重写，但能被继承</li><li>final类中，没有必要再将用final修饰方法；</li><li><strong>final不能修饰构造器；</strong></li><li><strong>final和static搭配使用，不会导致类加载；</strong></li><li>包装类（Integer，Double，Float，Boolean等都是final），String也是final类；</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>这些保留字不能用于常量、变量、和任何标识符的名称。</p><table><thead><tr><th align="left">类别</th><th align="left">关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">访问控制</td><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left"></td><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left"></td><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left"></td><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">类、方法和变量修饰符</td><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left"></td><td align="left">class</td><td align="left">类</td></tr><tr><td align="left"></td><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left"></td><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left"></td><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left"></td><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left"></td><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left"></td><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left"></td><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left"></td><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left"></td><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left"></td><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left"></td><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">程序控制语句</td><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left"></td><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left"></td><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left"></td><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left"></td><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left"></td><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left"></td><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left"></td><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left"></td><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left"></td><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left"></td><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left"></td><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">错误处理</td><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left"></td><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left"></td><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left"></td><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left"></td><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left"></td><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">包相关</td><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left"></td><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">基本类型</td><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left"></td><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left"></td><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left"></td><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left"></td><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left"></td><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left"></td><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left"></td><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">变量引用</td><td align="left">super</td><td align="left">父类,超类</td></tr><tr><td align="left"></td><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left"></td><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">保留关键字</td><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">null</td><td align="left">空</td></tr></tbody></table><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><strong>作用：</strong></p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（Java API文档）</li><li>控制访问范围</li></ol><p><strong>包的基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>包本质上，就是创建不同的文件夹&#x2F;目录来保存类文件</p><p><strong>包的命名规则：</strong></p><p>只能包含数字、字母、下划线、小圆点，不能数字开头，不能用关键字或保留字</p><p><strong>命名规范：</strong> 小写字母 + 小圆点 </p><p>一般是    <strong>com.公司名.项目名.业务模块名</strong></p><p><strong>常用的包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*<span class="comment">//lang包是基本包，默认导入</span></span><br><span class="line">java.util.*<span class="comment">//util包是系统提供的工具包，工具类</span></span><br><span class="line">java.net.*<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure><p><strong>引入包：</strong> <strong>使用 import 关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javautil.Scanner;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只能声明一句package；</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解@"></a>注解@</h3><p>注解（Annotation），也叫元数据（Metadata），用于修饰包，类，方法，属性，构造器，局部变量等数据信息；</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息；</p><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等；而在JavaEE中，注解有更大的作用，如：配置应用程序的任何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等；</p><p><strong>使用：</strong></p><p>三个基本的Annotaton：</p><ol><li><p><strong>@Override：限定某个方法，是重写父方法的，该注解只能用于方法；</strong></p><ul><li><p>@Override 表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错；</p></li><li><p>@Override 只能用来修饰方法</p></li><li><p>查看@Override注解源码@Target(ElementType. METHOD)，说明只能修饰方法；</p></li><li><p>@Target是修饰注解的注解，称为元注解</p></li></ul></li><li><p><strong>@Deprecated：用于表示某个程序元素（类&#x2F;方法等）已过时；</strong></p><ul><li>@Target(vlaue &#x3D; {CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</li><li>@Deprecated的作用：新旧版本的兼容和过度</li></ul></li><li><p><strong>@SuppressWarnings：抑制编译器警告；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以指定的警告类型有 (可以查看黄色警告光标，看是什么类型的警告)</p><p>all，抑制所有警告 </p><p>boxing，抑制与封装&#x2F;拆装作业相关的警告 </p><p>cast，抑制与强制转型作业相关的警告 </p><p> dep-ann，抑制与淘汰注释相关的警告</p><p>deprecation，抑制与淘汰的相关警告  </p><p>fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告  </p><p>finally，抑制与未传回 finally 区块相关的警告 </p><p> hiding，抑制与隐藏变数的区域变数相关的警告 </p><p> incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告 </p><p> javadoc，抑制与 javadoc 相关的警告 </p><p> nls，抑制与非 nls 字串文字相关的警告 </p><p> null，抑制与空值分析相关的警告 </p><p> rawtypes，抑制与使用 raw 类型相关的警告 </p><p>resource，抑制与使用 Closeable 类型的资源相关的警告 </p><p>restriction，抑制与使用不建议或禁止参照相关的警告</p><p> serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p><p>static-access，抑制与静态存取不正确相关的警告 </p><p>static-method，抑制与可能宣告为 static 的方法相关的警告 </p><p> super，抑制与置换方法相关但不含 super 呼叫的警告 </p><p> synthetic-access，抑制与内部类别的存取未最佳化相关的警告 </p><p> sync-override，抑制因为置换同步方法而遗漏同步化的警告 </p><p>unchecked，抑制与未检查的作业相关的警告 </p><p>unqualified-field-access，抑制与栏位存取不合格相关的警告 </p><p>unused，抑制与未用的程式码及停用的程式码相关的警告</p></blockquote></li></ol><p> 补充说明：查看源码时，有个：@interface，表明是一个注解类，跟interface是不一样的          </p><hr><p><strong>四种元注解：</strong></p><ol><li>Retention  ：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li></ol><ol start="2"><li>Target ： 指定注解可以在哪些地方使用 </li><li>Documented ：指定该注解是否会在 javadoc 体现</li><li>Inherited ：子类会继承父类注</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><table><thead><tr><th align="left">基本类型</th><th align="left">引用类型(包装类)</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr></tbody></table><p>此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p><h4 id="包装类与其他的转换"><a href="#包装类与其他的转换" class="headerlink" title="包装类与其他的转换"></a>包装类与其他的转换</h4><p><strong>包装类与基本类型的相互转换</strong></p><p>jdk5后可以自动装箱和拆箱，自动装箱底层调用的是valueOf 方法，比如：Integer.valueOf()；</p><p>手动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(n);</span><br></pre></td></tr></table></figure><p>手动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure><hr><p><strong>包装类与String类型的相互转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 —&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;<span class="comment">//方法一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();<span class="comment">//方法二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);<span class="comment">//方法三</span></span><br><span class="line"><span class="comment">//String —&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4); <span class="comment">//构造器</span></span><br></pre></td></tr></table></figure><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>Integer和Character常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer.MIN_VALUE <span class="comment">//返回最小值</span></span><br><span class="line">Integer.MAX_VALUE<span class="comment">//返回最大值</span></span><br><span class="line">    </span><br><span class="line">Character.isDigit(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//判断是否是数字</span></span><br><span class="line">Character.isLetter(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//判断是不是字母</span></span><br><span class="line">Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是大写</span></span><br><span class="line">Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是小写</span></span><br><span class="line">Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是空格</span></span><br><span class="line">    </span><br><span class="line">Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//转成大写</span></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure><p><strong>关于Integer的数据存放位置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">127</span>;<span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//Integer.valueOf(n),如果传入的值在-128 ~ 127，直接返回等于这个数值的对象。如果超过了范围，则new一个Integer对象</span></span><br><span class="line"><span class="comment">//即-128 ~ 127范围内的数字，都已经有一个自己的对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;<span class="comment">//valueOf源码</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i9 == i10);<span class="comment">//F，对象不同</span></span><br><span class="line"></span><br><span class="line">Integer i11=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> i12=<span class="number">127</span>;</span><br><span class="line">System.out.println(i11==i12); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//只要有基本数据类型，判断的是值是否相同</span></span><br></pre></td></tr></table></figure><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table><p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p><p><strong>Java没有无符号形式的int,long,short,byte类型。</strong></p><p>（可以将有符号整数解释为无符号数，但需要非常仔细）</p><hr><p><strong>浮点型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td></tr><tr><td>double</td><td>8字节</td><td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td></tr></tbody></table><p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p><ul><li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p><p>1.正无穷大：Double.POSITIVE_INFINITY</p><p>2.负无穷大：Double.NEGATIVE_INFINITY</p><p>3.NaN(不是一个数字)：Double.NaN</p><ul><li>检测一个特定值是否等于Double.NaN：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isNaN(x))<span class="comment">//检查x是否是一个数</span></span><br></pre></td></tr></table></figure><ul><li>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</li></ul></li><li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，命令System.out.plantln(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p></li></ul><hr><p><strong>char</strong>类型</p><p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p><ul><li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p><p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p><p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p></li><li><p>java中，char类型描述了UTF-16编码中的一个代码单元，但辅助字符编码为一对连续的代码单元（即不止一个代码单元），所以<strong>建议不要在程序中使用char类型，除非确实要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</strong></p></li></ul><hr><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a><strong>变量与常量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明与初始化</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12.0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//对于局部变量，如果可以从初始值推断出它的类型，可以不声明类型，只用关键字var即可：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>；  <span class="comment">//i is an int</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>  <span class="comment">//a is a string</span></span><br></pre></td></tr></table></figure><hr><p><strong>常量</strong></p><p>利用关键字<strong>final</strong>指示常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//final表示这个变量只能被赋值一次，习惯上常量名用全大写</span></span><br></pre></td></tr></table></figure><p><strong>类常量</strong>：使某个常量在一个类的多个方法中使用，用关键字<strong>static final</strong>设置类常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Constant&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//类常量的定义位于main的外部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h4><p>枚举类型的变量只能存储这个类型声明中给定的某个枚举值，或特殊值null（表示这个变量没有设置任何值）</p><hr><h4 id="关系运算boolean"><a href="#关系运算boolean" class="headerlink" title="关系运算boolean"></a><strong>关系运算boolean</strong></h4><ul><li><p>&amp;&amp;和||运算符按照短路方式求值，如果第一个操作数已能确定表达式的值，第二个操作数就不会进行计算。</p></li><li><p>&amp;和|不采用短路方式求值，即两个操作数都会进行计算。</p></li></ul><p>&amp;：对应位都为1则结果为1，否则为0；</p><p>|：对应位都为0则结果为0，否则为1；</p><p>^：对应位值相同则为0，否则为1；</p><p>~：按位取反每一位；</p><p>位模式左移：&gt;&gt;</p><p>右移：&lt;&lt;</p><p>运算符&gt;&gt;&gt;会用0填充高位，不存在&lt;&lt;&lt;</p><hr><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a><strong>子串</strong></h4><p>String类的substring方法：从字符串中<strong>提取</strong>出一个子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.substring(<span class="number">0</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="comment">//substring方法中第二个参数是不想复制的第一个位置，即复制0，1，2位</span></span><br><span class="line"><span class="comment">//substring有个优点，就是子串b的长度容易计算，为3-0 = 3，即第2个参数减第1个参数</span></span><br></pre></td></tr></table></figure><p>java可以用+号<strong>连接</strong>两个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br></pre></td></tr></table></figure><p>静态join方法：将多个字符串放在一起，用<strong>界定符分开</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String all = String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);</span><br><span class="line">//结果：all = &quot;S/M/L/XL&quot;</span><br></pre></td></tr></table></figure><p>repeat方法：将字符串<strong>复制n次</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//结果：a = &quot;javajavajava&quot;</span></span><br></pre></td></tr></table></figure><p>java没有提供<strong>修改字符串</strong>的方法，因此要通过其他操作来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a = a.substring(<span class="number">0</span>,<span class="number">3</span>) +<span class="string">&quot;p!&quot;</span>;</span><br><span class="line"><span class="comment">//结果为a = help!</span></span><br></pre></td></tr></table></figure><p>（尽管通过这种方式修改字符串效率不高，但不可变字符串有其他的优点：编译器可以让字符串共享，即原始字符串与复制字符串共享相同的字符（地址））。</p><p><strong>检测字符串是否相等</strong>：equals方法——s.equals(t）——其中s和t可以是字符串变量，也可以是字符串字面量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(a);</span><br><span class="line"><span class="comment">//如果相等，返回true，否则返回false</span></span><br><span class="line"><span class="comment">//不要使用==运算符来检测两字符串！==只能确定两个字符串是否存放在同一位置，但只有字符串字面量是共享的，而+获substring等操作得到的字符串并不共享。</span></span><br></pre></td></tr></table></figure><hr><p>localDate类的程序：（显示当前月的日历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">data</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">//下面获得当前的月份和日期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> data.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> data.getDayOfMonth();</span><br><span class="line">        <span class="comment">//将data设置为这个月的第一天，并得到这一天为星期几</span></span><br><span class="line">        data = data.minusDays(today - <span class="number">1</span>);</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> data.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();</span><br><span class="line">        <span class="comment">//打印日历的表头和第一行缩进</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入循环，使data遍历月的每一天，并打印日期；</span></span><br><span class="line">        <span class="keyword">while</span>(data.getMonthValue() == month)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,data.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfMonth() == today)&#123;      <span class="comment">// 如果data是当前日期，则用*标记；</span></span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            data = data.plusDays(<span class="number">1</span>);    <span class="comment">// 接下来将data推进到下一天，如果到达新一周，则换行打印</span></span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfWeek().getValue() == <span class="number">1</span>) System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mon Tue Wed Thu Fri Sat Sun</span><br><span class="line">              <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span> </span><br><span class="line"> <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>*</span><br><span class="line"> <span class="number">26</span>  <span class="number">27</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">30</span> </span><br></pre></td></tr></table></figure><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>main方法时虚拟机调用</li><li>jvm需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>jvm在执行main()方法时不必创建对象，所以main()为static</li><li>main()接受String类型的参数数组，该数组中保存执行java命令时传递给所运行的类的参数</li></ol><p>在main()方法中，可以直接调用main方法所在类的静态方法和静态变量，但不能访问非静态的方法和变量，必须创建该类的一个实例对象后，才能这个对象去访问；</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类（Class）和对象（object"><a href="#类（Class）和对象（object" class="headerlink" title="类（Class）和对象（object)"></a>类（Class）和对象（object)</h3><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态</p><p>(类包含：<strong>属性，方法，构造器，代码块，内部类</strong>)</p><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>（非静态变量）：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>（静态变量）：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><blockquote><p>类什么时候会被加载？</p><ol><li>创建对象实例时；</li><li>创建子类对象实例，父类也会被加载；</li><li>使用类的静态成员</li></ol></blockquote><hr><p><strong>代码块：</strong>又称初始化块，类似于方法，将语句封装在方法体中，用{}包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//修饰符可选，但只能写static</span></span><br><span class="line"><span class="comment">// ; 号可写可不写</span></span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong>，作用就是对类初始化，随着类的加载而执行，且<strong>只会执行一次</strong>，如果<strong>是普通代码块，每创建一个对象都会执行一次</strong>（如果只是使用类的静态成员，普通代码不会执行）；</p><hr><p><strong>对象</strong>：对象是类的一个示例，有状态和行为。软件对象的状态就是属性，行为通过方法体现</p><p><strong>创建对象</strong></p><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用顺序：</strong></p><ol><li><strong>调用静态代码块和静态属性初始化（有多个则顺序调用）；</strong></li><li><strong>调用普通代码块和普通属性的初始化；</strong></li><li><strong>调用构造方法；</strong></li></ol><hr><p><strong>源文件声明规则</strong></p><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>好处：</p><p>1：提高了代码的复用性。</p><p>2：提高了代码的拓展性和维护性，让类与类之间产生了关系，提供了另一个特征多态的前提。</p><ul><li><p><strong>一般类只能单继承；内部类实现多继承；接口可以多继承；</strong></p></li><li><p>子类继承了所有的属性和方法，<strong>非私有的</strong>属性和方法可以在子类<strong>直接访问</strong>，但是<strong>私有的</strong>属性和方法要通过父类提供的<strong>公共方法去访问</strong>；</p></li><li><p><strong>子类必须调用父类的构造器，完成父类的初始化；</strong></p></li></ul><ol><li><strong>对与成员变量：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关键字：</span><br><span class="line"><span class="built_in">this</span>：是本类类型的对象引用</span><br><span class="line"><span class="comment">//this从本类中开始查找，没有才从父类中找</span></span><br><span class="line"><span class="built_in">super</span>：是子类所属的父类中的内存空间引用</span><br><span class="line"><span class="comment">//super直接从父类中查找</span></span><br><span class="line"><span class="comment">//super不能访问父类的private属性或方法</span></span><br></pre></td></tr></table></figure><p>注意：<strong>子父类中通常是不会出现同名成员变量的</strong>，因为父类中只要定义了，子类就不用在定义，直接继承过来用。（当有属性&#x2F;方法<strong>重名时</strong>，<strong>只能用super访问父类的重名属性&#x2F;方法</strong>；super的访问不限于直接父类，如果爷爷类也有与本类重名的属性&#x2F;方法，也能用super去访问；即<strong>多个基类中都有重名的成员，super的访问遵循就近原则</strong>）</p><ol start="2"><li><strong>成员函数：</strong></li></ol><p>当子父类可以出现一样的方法，即可以覆盖（重写）函数（当一个类的功能需要修改时，可以通过覆盖来实现）</p><ol start="3"><li><strong>构造函数</strong></li></ol><p>子类的构造函数运行时，一定会先运行父类的构造函数；</p><p>原因：子类的构造函数中的第一行，都有一条隐身的语句super()，而这个super（）是在调用父类中空参数的构造函数；</p><blockquote><p>因为子类继承父类，会继承父类中的数据，所以必须要看到父类对自己数据进行初始化的过程</p></blockquote><p>子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p><blockquote><p>注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</p><p>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</p><p>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p></blockquote><p><strong>在方法覆盖（重写）时，注意：</strong></p><ol><li><p>子类覆盖父类时，必须要保证，<strong>子类方法的权限必须大于等于父类方法权限</strong>可以实现继承。否则，编译失败。</p></li><li><p>覆盖时，要么<strong>都静态</strong>，要么<strong>都不静态</strong>。 (静态只能覆盖静态，或者被静态覆盖)</p></li><li><p>子类中重写父类的方法，必须与父类的那个方法：<strong>名称，返回类型，参数一样</strong>；</p></li></ol><p><strong>而对于重载：只要同一类中，且方法名一致，参数列表不一样即可，对返回类型，修饰符无要求；</strong></p><p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p><p>此时可以用到final;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：这个关键字是一个修饰符，可以修饰类，方法，变量。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：被<span class="keyword">final</span>修饰的类是一个最终类，不可以被继承。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：被<span class="keyword">final</span>修饰的方法是一个最终方法，不可以被覆盖。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：被<span class="keyword">final</span>修饰的变量是一个常量，只能赋值一次。</span><br></pre></td></tr></table></figure><p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p><p><strong>创建子类对象时的调用顺序：</strong></p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性初始化；</li><li>父类的构造方法；</li><li>子类的普通代码块和普通属性初始化；</li><li>子类的构造方法；</li></ol><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现 细节部分 包装、隐藏起来的方法。</p><p>也就是说：<strong>将数据和对数据的操作封装起来，程序的其他部分只有通过被允许的操作才能对数据进行修改。</strong></p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p><strong>封装的优点：</strong></p><ol><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。</p></li></ol><hr><p><strong>实现Java封装的步骤：</strong></p><ol><li><p>修改属性的可见性来<strong>限制对属性的访问</strong>（一般限制为<strong>private</strong>）,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">person</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p><p><strong>访问权限控制：public &gt; protected &gt; 包 &gt; private</strong> </p></li><li><p>对每个值属性<strong>提供对外的公共方法访问</strong>，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>static关键字</strong>：可对数据进行静态修饰</p><blockquote><ol><li><p><strong>被静态修饰的成员，可以直接被类名所调用。</strong>也就是说，静态的成员多了一种调用方式。<strong>类名.静态方式。</strong></p></li><li><p><strong>静态随着类的加载而加载，而且优先于对象存在。</strong></p></li><li><p><strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p></li><li><p><strong>静态方法中不能使用this，super关键字。</strong></p></li></ol><p>   因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p></blockquote><p>成员变量和静态变量的区别：</p><p>1，成员变量所属于对象，所以也称为<strong>实例变量</strong>。</p><p>   静态变量所属于类，所以也称为<strong>类变量</strong>。</p><p>2，成员变量存在于<strong>堆内存</strong>中。</p><p>   静态变量存在于<strong>方法区</strong>中。</p><p>3，成员变量随着对象创建而存在，随着对象被回收而消失。</p><p>   静态变量随着类的加载而存在，随着类的消失而消失。</p><p>4，成员变量只能被对象所调用。</p><p>   静态变量可以被对象调用，也可以被类名调用。</p><p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>实现多态的三个必要条件：<strong>继承，重写（重载也是），向上转型</strong>；</p><p><strong>向上转型：子类对象被父类引用；</strong></p><p><strong>向下转型：向下转型是子类对象被父类引用之后，再把父类引用强转成子类；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//向上转型</span></span><br><span class="line">        b.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird)b;<span class="comment">//向下转型</span></span><br><span class="line">        bird.run();</span><br><span class="line">        bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>向下转型的意义：当多个子类继承同一个父类或接口时，可以写一个公用的方法，方法传入的形参为父类或接口，这样每个子类实参就可以传入这个父类形参中，进而实现公用性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="comment">//传入子类的实参引用</span></span><br><span class="line">        sleep(b);</span><br><span class="line">        sleep(tom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法的参数是父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(Animal A)</span>&#123;</span><br><span class="line">        A.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用例子： </p><ol><li><p><strong>多态参数：</strong>可以<strong>在方法实参中使用父类，然后调用方法时传入子类，即向上转型</strong></p></li><li><p><strong>多态数组：</strong>数组的定义类型为父类，里面保存的实际元素类型为子类类型</p><p>如果要调用数组中子类特有的方法，可以使用<strong>类型判断+向下转型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu[] f = <span class="keyword">new</span> <span class="title class_">Fu</span>[n];</span><br><span class="line"><span class="keyword">if</span>(f[i] instancef Zi)&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> (Zi)f[i];</span><br><span class="line">    z.方法();</span><br><span class="line">    <span class="comment">//两句直接写成：((Zi)f[i]).方法();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>多态 体现在：<strong>父类引用变量可以指向子类对象</strong></p><p>多态的定义格式：</p><blockquote><p>父类类型 变量名 &#x3D; new 子类类型（）；</p></blockquote><p>多态成员特点：</p><ol><li>多态成员<strong>变量</strong>：编译类型 运行类型 <strong>都看左边</strong></li><li>多态成员<strong>方法</strong>：<strong>编类型看左边，运行类型看右边</strong></li></ol><p><strong>java的动态绑定机制</strong></p><ul><li><strong>当调用对象方法时，该方法会和对象的内存地址&#x2F;运行类型绑定；</strong></li><li><strong>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"><span class="comment">//f是父类Fu中的值，只能取到父中的值</span></span><br><span class="line"><span class="comment">//f表面是Fu，实际类型是Zi，所以调用到的方法是重写后的方法，</span></span><br><span class="line"><span class="comment">//方法里所用到的值，是当前类的值，即调用的方法在哪个类，就用哪那个类的值；</span></span><br></pre></td></tr></table></figure><hr><p><strong>instanceof关键字：</strong>用于判断对象是否属于某种数据类型（返回值为布尔类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   Fu f1=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        Fu f2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">if</span>(f1 <span class="keyword">instanceof</span> Zi)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Zi的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Son的类型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>多态的转型：</strong></p><p>向上转型：多态本身就是向上转型过的过程</p><ul><li>使用格式：父类类型 变量名&#x3D;new 子类类型();</li></ul><blockquote><p>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。</p></blockquote><p>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型</p><ul><li>使用格式：子类类型 变量名&#x3D;（子类类型） 父类类型的变量；</li></ul><blockquote><p>适用场景：当要使用子类特有功能时。</p></blockquote><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整嵌套了另一个结构，被嵌套的类被称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。</p><p>内部类最大的特点是<strong>可以直接访问外部类的所有成员，包括私有属性</strong>。</p><p>按定义的位置：</p><ol><li>定义<strong>在局部位置</strong>（方法&#x2F;代码块）：<ul><li><strong>局部内部类</strong></li><li><strong>匿名内部类</strong></li></ul></li><li>定义<strong>在成员位置</strong>：<ul><li><strong>成员内部类</strong>（不加static）&#x2F; 普通内部类</li><li><strong>静态内部类</strong>（加static）</li></ul></li></ol><hr><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>在类里面作为一个字段直接定义即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里 B 类为 A 类的普通内部类，在这种定义方式下，普通内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="comment">//不在外部类内部，要用：外部类对象.new 内部构造器()；的方式创建对象</span></span><br><span class="line">        a.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一个类的静态成员独立于这个类的任何一个对象存在，只要在具有访问权限的地方，我们就可以通过 <strong>类名.静态成员名</strong> 的形式来访问这个静态成员，同样的，静态内部类也是作为一个外部类的静态成员而存在，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。</p><p>与静态成员一样，静态内部类 无法访问外部类的非静态成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在同一个外部类中，且同样是静态的，可以直接new</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不在外部类内部，用：外部类名.静态成员名 进行访问</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类没有名字，定义在外部类的局部位置（方法&#x2F;代码块）</p><p>某个类实现接口&#x2F;抽象类，但只使用一次，可以使用匿名内部类（简化开发）  </p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>基于接口的匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;<span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//anonymity的编译类型是IA，运行类型是匿名内部类</span></span><br><span class="line">        <span class="comment">//匿名内部类其实在底层会分配一个名字，不会显示出来</span></span><br><span class="line">        <span class="comment">//jdk底层在创建匿名内部类anomymity$1,立刻就创建了其实例，并把地址返回给anomymity;</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">anonymity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="comment">//查看一下运行类型，即在原名字后加$1: anomymity$1</span></span><br><span class="line">        system.out.println(anomymity.getclass());</span><br><span class="line">        <span class="comment">//匿名内部类anomymity$1使用一次就回收掉，但anonymity是一个对象，仍可以反复调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于类的匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;<span class="comment">//A可以为普通类或抽象类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类可以直接当作实参直接传递，简洁高效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//当做实参直接传递，简洁高效</span></span><br><span class="line">f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//传统方法</span></span><br><span class="line">f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在外部类的局部位置，有名字。</p><p>不能添加访问修饰符，但可以使用final修饰（跟局部变量一样）</p><p>作用域：仅在定义它的方法或代码块中</p><ul><li><p>访问方式：</p><ul><li>局部内部类访问外部类的成员：直接访问</li><li>外部类访问局部内部类的成员：<strong>在它的作用域中创建对象</strong>，再访问；</li></ul></li><li><p>外部其他类不能访问局部内部类（地位相当于是一个局部变量）</p></li><li><p>如果外部类和局部内部类的成员<strong>同名</strong>，默认遵循就近原则，如果想访问外部类成员，可以用：<strong>外部类名. this. 成员名</strong> ，去访问</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，</p><p>如果一个类中<strong>没有包含足够的信息来描绘一个具体的对象</strong>，这样的类就是<strong>抽象类</strong>。</p><p>抽象类除了<strong>不能实例化对象</strong>之外，类的<strong>其它功能依然存在</strong>，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承，才能被使用</strong>。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p><strong>使用abstract class来定义抽象类。</strong></p><p>抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，<strong>抽象方法只包含一个方法名，而没有方法体。</strong></p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类<strong>包含抽象方法</strong>，那么该类<strong>必须是抽象类</strong>。</li><li>任何<strong>子类必须重写父类的抽象方法</strong>，<strong>或者声明自身为抽象类</strong>。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p> <strong>抽象类总结规定</strong></p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li><li>抽象关键字abstract 和 final, private, static不共存</li></ol><p>设计模式：</p><p>解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span>&#123; <span class="comment">//此功能如果不需要复写，可加final限定</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">//不确定的功能部分，提取出来，通过抽象方法实现</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;毫秒是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>; <span class="comment">//抽象不确定的功能，让子类复写实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123; &lt;font color=red &gt;<span class="comment">//子类复写功能方法&lt;/font&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;<span class="number">1000</span>; y++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface），在JAVA中是一个抽象类型，是抽象方法的集合，</p><p>接口通常以interface来声明。一个类通过继承接口，从而继承接口中的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p><strong>接口声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口 允许继承 多个其他接口</span></span><br></pre></td></tr></table></figure><p><strong>接口实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口与类相似点：</strong></p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p><strong>接口特性：</strong></p><ul><li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</p><ul><li><p>使用static可以 在继承多接口时，如果存在多个同名变量，可以使用接口名.变量名来区分；</p></li><li><p>使用final，让接口中的变量不可更改，否则，每个实现接口的类都可以改变这个变量的值，就违背了OCP原则；</p></li></ul></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li><li><p>接口的修饰符只能是public和默认。</p></li></ul><p><strong>抽象类和接口的区别：</strong></p><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>注：</p><ol><li><p>JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></li><li><p>JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。</p></li><li><p>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p></li></ol><hr><p><strong>实现接口和继承类的区别</strong></p><p>当子类继承了父类，就自动拥有父类的功能，是 is-a的关系</p><p>如果子类<strong>需要扩展功能</strong>，可以通过实现接口的方式扩展，是like - a 的关系，可以理解 ” 实现接口“ 是对java单继承机制的补充；</p><p>继承的价值只要是：解决代码的复用性和可维护性。</p><p>接口的价值主要是：<strong>设计好各种规范</strong>（方法），让其它子类去实现，更加灵活。且接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）。</p><hr><p><strong>接口与多态</strong></p><p>接口也能利用动态参数 和 多态数组</p><p>接口存在多态传递现象</p><hr><p>在重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><p><strong>标记接口：</strong></p><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口。它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p></li><li><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的两种实现：</p><ol><li>自定义枚举类；</li><li>使用enum关键字实现枚举；</li></ol><hr><p> 枚举是一个特殊的类，一般表示一组常量，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ...&#123;</span><br><span class="line">... , ... , ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用enum，要求将定义常量<strong>对象写在最前面</strong>;</li><li>直接使用： <strong>常量名（实参列表）</strong>; 如果使用无参构造器，则实参列表和小括号都可以省略；</li><li>如果有多个常量&#x2F;对象,使用<strong>逗号间隔</strong>即可；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//使用enum，要求将定义常量对象写在最前面</span></span><br><span class="line">    <span class="comment">//直接使用： 常量名（实参列表）</span></span><br><span class="line">    <span class="comment">//如果有多个常量/对象,使用逗号间隔即可；</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>values(), ordinal() 和 valueOf() 方法:</strong></p><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p><p>（所以使用enum关键字后，就<strong>不能再继承其他类</strong>了，因为enum隐式继承了Enum类）</p><p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li><strong>values() 返回枚举类中所有的值。</strong></li><li><strong>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</strong></li><li><strong>valueOf()方法返回指定字符串值的枚举常量。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类成员:</strong></p><p>枚举跟普通类一样可以用<strong>自己的变量、方法和构造函数</strong>，构造函数只能使用 <strong>private</strong> 访问修饰符，让外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><hr><p><strong>自定义枚举类</strong></p><ol><li>将构造器私有化，防止外部直接new；</li><li>去掉set方法，防止属性被修改；</li><li>在枚举类内部，直接创建固定的对象；</li><li>对外暴露对象：对枚举对象&#x2F;属性使用public + final + static共同修饰，实现底层优化； </li><li>枚举对象名通常全部大写（这是常量的命名规范）；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = neme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h3><p>包是Java语言提供的一种区别类名字命名空间的机制，它是类的一种文件组织和管理方式、是一组功能相似或相关的类或接口的集合。</p><p>Java package提供了访问权限和命名的管理机制。</p><p>一、<strong>包的作用</strong> </p><ol><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 </li><li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ol><p>二、<strong>包的定义</strong><br>在一个.java文件中可以一个public类和多个非public类，如果要将这些类组织在一个包当中，则在.java文件中除注释以外的第一行使用关键字package即可实现。</p><p>当需要调用此包中的类时，就可以使用关键字import进行导入。在定义包的时候，应该注意几点: </p><ol><li>为了尽量使包名保持唯一性，包名通常采用小写、按倒写互联网址的形式进行定义。</li><li>在进行命名包时，应该避免使用与系统发生冲突的名字。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常：程序执行中发生的不正常情况</p><p>异常分为两大类：</p><ol><li><strong>Error</strong>（错误）：JVM无法解决的严重问题，如：JVM系统内部错误，资源耗尽等严重情况</li><li><strong>Exception</strong>：其他因编程错误或外在因素导致的一般性问题，可以使用针对性代码进行处理；Exception分为两大类：<strong>运行时异常</strong>（程序运行时发生的异常），<strong>编程时异常</strong>（编程时，编译器检查出的异常，编译器要求必须处理）</li></ol><p><strong>常见的运行时异常：</strong></p><ol><li><p>**NullPointerException  空指针异常 **</p><p>如：当应用程序试图在需要对象的地方使用 null 时，会抛出该异常；</p></li><li><p>**ArithmeticException  数学运算异常 **</p><p>如：当出现异常的运算条件时，抛出此异常，比如整数除以零时；</p></li><li><p><strong>ArrayIndexOutOfBoundsException</strong> <strong>数组下标越界异常</strong></p><p>用非法索引访问数组时抛出的异常，比如索引为负或大于等于数组大小，则该索引为非法索引；</p></li><li><p><strong>ClassCastException</strong> <strong>类型转换异常</strong></p><p>当试图将对象强制转换为不是实例的子类时，抛出该异常；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastException_</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b;<span class="comment">//向下转型，这里是 OK</span></span><br><span class="line"><span class="type">C</span> <span class="variable">c2</span> <span class="operator">=</span> (C)b;<span class="comment">//这里抛出 ClassCastException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>NumberFormatException</strong> <strong>数字格式不正确异常</strong></p><p>当程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常（使用此异常可以确保输入满足条件的数字）</p></li></ol><p><strong>常见的编译异常：</strong></p><ol><li>SQLException ：操作数据库时，查询表可能发生异常</li><li>IOException ：操作文件时，发生的异常</li><li>FileNotFoundException ：当操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException：加载类，而该类不存在时，异常</li><li>EOFException：操作文件时，到文件末尾，发生异常</li><li>IllegalArguementException：参数异常</li></ol><hr><p><strong>异常处理机制</strong></p><ol><li><p><strong>try - catch - finally</strong></p><p>程序员在代码中捕获发生的异常，自行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能有异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//当异常发生时，系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//得到异常对象后，程序员自己处理</span></span><br><span class="line">    <span class="comment">//如果没有发生异常，catch代码块不执行</span></span><br><span class="line">    <span class="comment">//可以有多个catch语句，捕获不同的异常，要求子类异常写在前，父类异常在后（只会匹配一个catch）</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块有没有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将释放资源的代码放在finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就算在catch中ruturn了，但因为finally必须执行，所以catch的return中的语句会执行，但不会立即返回（return）；</li><li>如果catch中 ruturn  i  ；但finally中又用到了 变量 i  ，底层会保存临时变量temp &#x3D; i ，执行完finally后，catch返回temp（finally有return的话则在finally中return）；</li></ul></li><li><p><strong>throws</strong></p><p>将发生的异常抛出，交给调用者（方法）处理，最高级的处理者是JVM（JVM会直接打印异常信息，退出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> XXException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要和父类的一致或其异常类型的子类型；</li></ul></li><li><p><strong>自定义异常</strong></p><p>自定义异常 需要继承 Excption或RuntimeException；如果继承Exception属于编译异常， 继承RuntimeException属于运行异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line"><span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line"><span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line"><span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;  <span class="comment">//构造器</span></span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>throw和throws的区别</p><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的是</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合主要有 单列集合 和 双列集合：</p><ul><li><p>Collection接口有两个重要的子接口List，Set，它们实行的都是单列集合；</p></li><li><p>Map接口的实现子类，是双列集合，从存放K - V；</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707036.png" alt="image-20211003183537824"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707037.png" alt="image-20211003183548688"></p><hr><p><strong>如何选择</strong>集合实现类：判断存储的类型：单列&#x2F;双列</p><ul><li><p>一组对象（单列）：Collection接口</p><ul><li><p>允许重复：List</p><ul><li>增删多：LinkedList（底层是双向链表）</li><li>查改多：ArrayList（底层是可变数组）</li></ul></li><li><p>不允许重复：Set</p><ul><li><p>无序：HashSet（底层HashMap）</p></li><li><p>排序：TreeSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure></li><li><p>插入和取出顺序一致：LinkedHashSet（维护数组和双向链表）</p></li></ul></li></ul></li><li><p>一组键值对（双列）：Map</p><ul><li><p>键无序：HashMap（底层：维护了一个哈希表：数组+链表+红黑树）</p></li><li><p>键排序：TreeMap</p></li><li><p>键插入和取出顺序一致：LinkedHashMap</p></li><li><p>读取文件：Properties</p></li></ul></li></ul><hr><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h3><p>Collection接口的常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll（All都是指多个元素）</p><p>遍历方式：</p><ol><li>使用 <strong>Iterator</strong> 迭代器（快捷模板：while-&gt;itit）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//先得到col对应的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在调用iterator.next()之前必须先用iterator.hasNext()进行检测，不然，如果下一条记录无效，且直接调用next方法会抛出NoSuchElementException异常</p></li><li><p>当退出while循环后，iterator迭代器指向最后的元素，如果要再次遍历，需重置迭代器：ite &#x3D; col.iterator();</p></li><li><p>iterator迭代器的remove方法是迭代过程中唯一能 线性安全地 删除集合元素的方法，因为iterator在遍历过程中，会锁定集合中的元素。</p></li><li><p>不能直接使用集合的remove方法：因为集合中会有变量modCount记录修改次数，当调用remove方法时，modCount ++，而迭代开始时，会先把modCount 记录下来，在调用iterator.next时会检查修改次数是否一致，如果不一致，则会报错ConcurrentModificationException；</p><blockquote><p>注：由于hasnext是检查当前已经迭代的数量是否等于集合大小，如果删除倒数第二个数据，集合size–，就会使size &#x3D;&#x3D; 已经迭代的个数，所以会漏掉最后一项数据，即最后一遍循环不执行，iterator.next不执行，也就不会报错。</p></blockquote></li></ul><ol start="2"><li><p>使用for循环增强</p><p>增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名 ： 集合名/数组名)&#123;</span><br><span class="line">访问元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul><li>元素有序（添加和取出的顺序一致），有索引</li><li>元素可重复</li></ul><p>List接口常用方法：add，add（index，Object），get，indexOf，lastIndexOf，remove，set，subList（fromIndex，toIndex）(注意fromIndex &lt;&#x3D; subList &lt; toIndex)</p><p>ArrayList和Vector基本等同，区别在线程是否安全</p><p>ArrayList类：效率较高，但线程不安全</p><p>创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为0，第一次添加，则扩容elementData 为10，后面再次扩容，则扩容为原来的1.5倍 + 1；如果使用指定大小的构造器，则初始elementData 为指定大小，再次扩容，则为原来的1.5倍 + 1。</p><hr><p>Vector类：线程安全，效率比ArrayList低</p><p>Vector类的操作方法带有synchronized。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= elementCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector扩容：无参构造，默认10；扩容为原来的2倍</p><hr><p>LinkList类：底层实现了双向链表和双端队列的特点，线程不安全，没有实现同步；</p><ul><li>LinkList维护了两个属性：first指向首节点，last指向尾节点，</li><li>每个节点（Node对象）又维护了三个属性：prev指向前一个，next指向下一个，item存放数值；</li></ul><hr><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul><li>无序（添加和取出的顺序不一致，但存放位置是固定的），没有索引</li><li>不允许重复元素，所以最多包含一个null</li></ul><p>Set常用方法，因为也是Collection的子接口，所以常用方法和Collection接口一样</p><p>遍历方式：迭代器，增强for（但不能使用索引方式来获取）</p><p><strong>HashSet类</strong></p><p>HashSet实现了Set接口，实际上是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的构造器</span></span><br><span class="line">pUblic <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashSet类</strong></p><p>LinkedHashSet是HashSet的子类，底层是LinkedHashMap，底层中维护了一个hash表和双向链表；</p><p><strong>LinkedHashMap类</strong></p><p>LinkedHashMap中有<strong>头节点head和尾节点tail</strong>（指向第一个添加的节点和最后添加的节点），还创建了<strong>Entry类</strong>来存放节点，它继承自HashMap.Node类，<strong>每个节点有before和after属性</strong>。</p><ul><li>LinkedHashMap根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElenment</span><br><span class="line">newElement.pre = tail;</span><br><span class="line">tail = newElement;</span><br><span class="line"><span class="comment">//新加入节点和末尾节点相连；</span></span><br><span class="line"><span class="comment">//这样，遍历LinkedHashMap时也能确保插入顺序和遍历顺序一致</span></span><br></pre></td></tr></table></figure><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map中用于保存具有映射关系的数据：Key - Value</p><p>key不允许重复，只能有一个key为null；value允许重复，可以有多个null；</p><p><strong>遍历方式：</strong></p><p><strong>containsKey：查找键是否存在</strong></p><p><strong>keySet：获取所有的键</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">ks</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object key : ks)&#123;</span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> ks.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet：获取所有的关系k - v</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> ite.next();</span><br><span class="line"><span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValues());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>values：获取所有的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">val</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object value : val)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> val.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap类</strong></p><p>如果添加相同的key，则会<strong>覆盖原来的key - value，相当于修改了value</strong>；</p><p>底层没有实现同步，<strong>线程不安全</strong>；</p><p>HashMap底层：<strong>数组+链表+红黑树</strong>（不保证映射顺序）</p><ol><li>先获取元素的哈希值（hashcode方法）；</li><li>对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置；（用（length-1）&amp;hash得到数组下标）</li><li>如果该位置上没有其他元素，则直接存放，如果有，则需要进行equals判断，如果相等，则不添加，如果不等，则以链表的方式添加；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算hash值的算法，“扰动函数”</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容机制：</p><ol><li>第一次添加时，table数组扩容到<strong>16</strong>，临界值（threshold）是16 * <strong>加载因子（loadFactor &#x3D; 0.75）</strong>&#x3D; 12；</li><li>如果table数组使用到临界值12，就会扩容到16*2 &#x3D; 32，新的临界值为32 * 0.75 &#x3D; 24；</li><li>在Java8中，如果一条链表的<strong>元素个数到达TREEIFY_THRESHOLD（默认是8），且table大小&gt;&#x3D;MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树）</strong>；（table是HashMap的一个数组，类型是Node[]）</li><li>如果链表的元素个数达到8以上，但table不足64，会将元素加入链表后，对table进行一次扩容。</li></ol><hr><p><strong>Hashtable类</strong></p><p>存放的元素的键值对：K - V ，键和值都<strong>不能为null</strong>，否则会抛出NullPointerException；</p><p>是<strong>线程安全</strong>的（效率比HashMap低）</p><p>（使用方法和HashMap基本一样）</p><hr><p><strong>Properties类</strong></p><p>Properties类<strong>继承自Hashtable类并实行了Map接口</strong>；键和值同样<strong>不能为null</strong>，否则会抛出NullPointerException；</p><p>特点：可以用于<strong>从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</strong>（工作中，xxx.properties文件<strong>通常为配置文件</strong>）</p><hr><p>一道<strong>练习</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(p1);<span class="comment">//OK</span></span><br><span class="line">set.add(p2);<span class="comment">//OK</span></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//name被修改过，找不到，删除失败</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型又称参数化类型。</p><p>java中的泛型<strong>只在编译阶段有效</strong>，在编译之后程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型声明</span></span><br><span class="line">interface 接口&lt;T&gt; &#123;&#125;<span class="comment">//泛型接口</span></span><br><span class="line">class 类&lt;K,V&gt;&#123;&#125;<span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>&#123;&#125;<span class="comment">//泛型方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化,在类名后面指定类型参数的值</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li><p>T，E …只能是引用类型，不能是基本数据类型</p></li><li><p>在给泛型指定具体类型后，可以传入该类型的子类类型</p></li><li><p>要注意，在静态方法中使用泛型，必须将静态方法定义成泛型方法。因为静态方法访问在类上定义的泛型，不能引用不确定的数据类型。</p></li><li><p>如果在创建对象时，没有指定类型，默认为Object</p></li><li><p>泛型接口的类型，在<strong>继承接口</strong>或<strong>实现接口</strong>时确定</p></li><li><p>java中不能创建一个确切的泛型类型的数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//这样是不允许的</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>];<span class="comment">//这样可以</span></span><br><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];<span class="comment">//这样也可以</span></span><br></pre></td></tr></table></figure><p>解释：由于JVM泛型的擦除机制，在运行时JVM不知道泛型信息，可以将一个确切数据类型的数据加入，但在取出数据时却还要做一次类型转换，所以有可能出现ClassCastException。如果可以进行泛型数组的声明，则这种情况不会在编译期进行警告和错误，只有到运行时才出错，所有对泛型数据的声明进行限制可以防止运行时的错误发生；</p><p>而使用通配符，最后取出数据要做显式的类型转换，所以没问题；</p></li></ul><hr><p><strong>泛型上下边界</strong></p><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行<strong>上下边界的限制</strong>，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p><strong>泛型通配符 &lt;?&gt;</strong> ：支持任意泛型类型</p><p><strong>&lt; ? extends A &gt;</strong> ：支持<strong>A类以及A类的子类</strong>，规定了泛型的上限</p><p><strong>&lt; ? super A&gt;</strong> ：支持<strong>A类以及A类的父类</strong>，不限于直接父类，规定了泛型的下限</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>创建文件</strong>的三种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：new File(String pathname) </span></span><br><span class="line">   <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">   <span class="comment">//上面的file1对象，在java程序中，只是一个对象，只有执行了CreatNewFile方法，才会在磁盘创建该文件</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;creat successful&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法二：new File(File parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录文件+之路径构建</span></span><br><span class="line">   <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file1.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法三：new File(String parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录+子目录构建</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName1);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>获取文件的相关信息：</strong></p><p>getName()，length()，</p><p>getAbsolutePath()：获取绝对路径</p><p>getParent()：获取父目录</p><p>exist()：文件是否存在</p><p>isFile()：是不是文件</p><p>isDirectory()：是不是目录</p><hr><p><strong>目录的操作和文件删除：</strong></p><p>mkdir：创建一级目录</p><p>mkdirs：创建多级目录</p><p>delete：删除空目录或空文件</p><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><p>I&#x2F;O 是Input &#x2F; Output 的缩写，用于处理数据传输，如：读写文件、网络通讯等；</p><p><strong>输入input</strong>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</p><p><strong>输出output</strong>：将程序（内存)中的数据输出到磁盘等存储设备中；</p><p><strong>分类：</strong></p><ul><li>按操作的数据单位不同：字节流文件（二进制文件），字符流文件（文本文件）；</li><li>按数据流的流向不同：输入流，输出流；</li><li>按流的角色的不同：节点流，处理流（包装流）；</li></ul><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>由上面四个类派生出来的子类名称 都是以其父类名作为子类名后缀</p><p>体系图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/20200307125658523.png" alt="img"></p><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次接受一个字节的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//接受单个直接的数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read()无参时会返回单个字节的数据</span></span><br><span class="line">        <span class="comment">//读取完毕，会返回-1</span></span><br><span class="line">        <span class="keyword">while</span>((readData = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);<span class="comment">//转为char显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();<span class="comment">//记得要关闭文件流，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字节数据一次接受多个数据，效率更高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次读取8个字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//一次最多读取8字节，返回读取读取字节的数量</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);<span class="comment">//再加一个true，表示写入内容追加到文件末尾，不加true，则表示覆盖原来的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        fos.write(str.getBytes(),<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="FileReader-和-FileWriter"><a href="#FileReader-和-FileWriter" class="headerlink" title="FileReader 和 FileWriter"></a>FileReader 和 FileWriter</h4><p>FileReader —&gt; InputStreamReader —&gt;Reader</p><p>FileReader  —&gt;  InputStreamReader —&gt;Reader</p><p>使用方法跟上面的差不多</p><p>注意：<strong>对于字符流，记得操作完后要关闭文件流，或使用flush()，否则更新内容不会保存</strong></p><hr><h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流 ：从一个特定的数据源读写数据，如FileReader，FileWriter；</p><p>处理流（包装流）：是连接在已存在的流（节点流&#x2F;处理流）之上，提供了更方便，更强大的读写功能，如BufferedReader，BufferedWriter。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707038.png" alt="image-20211007204910829"></p><p>节点流是底层流，直接跟数据源相接。</p><p>处理流包装节点流，既可以<strong>消除不同节点流的实现差异，也可以提供更方便的方法</strong>；处理流使用了修饰器设计模式，<strong>不会直接与数据源相连</strong>。</p><p>处理流对性能的提高：主要<strong>以增加缓冲的方式来提高输入输出的效率</strong>；</p><hr><p>（BufferedReader，BufferedWriter是字符流，不要去操作二进制文件（声音、视频、pdf等），可能造成文件损坏）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedReader</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));<span class="comment">//将</span></span><br><span class="line">    String line;<span class="comment">//按行读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;<span class="comment">//读取完毕，返回null</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();<span class="comment">//关闭外层流即可，以为底层会去关闭内层的流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedWriter</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">    bw.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">    bw.write(<span class="string">&quot;hello,hello,world&quot;</span>);</span><br><span class="line">    bw.close();</span><br></pre></td></tr></table></figure><hr><p><strong>BufferedInputStream 和 BufferedOutputStream</strong></p><p>（是字节流，创建时，内部会创建一个缓冲区数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用BufferedInputStream 和 BufferedOutputStream将一个二进制文件的内容拷贝到另一个文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;  <span class="comment">//因为对象为空会被自动回收，但此时对象还在，需要手动关闭</span></span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p><strong>ObjectOutputStream ：提供 序列化功能 ObjectInputStream ：提供 反序列化</strong></p><hr><p>序列化：在保存数据时，保存数据的值和数据类型</p><p>反序列化：恢复数据时，恢复数据的值和数据类型</p><p>想要让对象支持序列化机制，其类应该是可序列化的，必须实现两个接口之一：<strong>Serializable</strong>（是一个标记接口，没有方法）或  Externalizable（有方法需要实现，所以一般实现Serializable接口）</p><hr><p>注意：</p><ul><li>读写顺序要一致；</li><li>要求对象实现Serializable</li><li>为了提高版本的兼容性，序列化的类中建议添加SerialVersionUID</li><li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li><li>序列化对象时，要求其属性的类型也实现序列化接口</li><li>序列化具备可继承性，即实现了序列化的类，它的子类默认也实现了序列化</li></ul><hr><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><table><thead><tr><th></th><th>类型</th><th>默认设备</th></tr></thead><tbody><tr><td>System.in标准输入</td><td>InputStream</td><td>键盘</td></tr><tr><td>System.out标准输出</td><td>PrintStream</td><td>显示器</td></tr></tbody></table><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong>和<strong>OutputStreamWriter</strong></p><p>可以将字节流转换成字符流，同时可以指定编码格式（如：utf-8，gbk等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="comment">//把 FileInputStream 转成 InputStreamReader，并指定编码</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><hr><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流只有输出流，没有输入流</p><p><strong>PrintStream</strong> 和  <strong>PrintWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line"><span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印输出(当s为空时，print方法会打印&quot;null&quot;);</span></span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改打印流输出的位置/设备</span></span><br><span class="line"><span class="comment">//这里修改，打印到 e:\\f1.txt</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;e:\\f1.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="properties类"><a href="#properties类" class="headerlink" title="properties类"></a>properties类</h4><p>专门用于<strong>读写配置文件</strong>的集合类</p><p>配置文件的格式：<strong>键&#x3D;值</strong></p><p>（不用空格，值不需要引号，默认类型时String）</p><hr><p>常用方法：</p><p><strong>load</strong>：加载配置文件的键值对到Properties对象；</p><p><strong>list</strong>：将数据显示到指定设备；</p><p><strong>getProperty（key）</strong>：根据键 取 值</p><p><strong>setProperty（key，value）</strong>：设置键值对</p><p><strong>store</strong>：键Properties对象中的键值对存储到配置文件（在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">   p.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">   p.list(System.out); <span class="comment">//将K-V显示到控制台</span></span><br><span class="line">   p.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line">   p.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程：一个独立的正在执行的程序；</p><p>多进程：在操作系统中，同时运行多个程序；</p><ul><li>多进程好处：可以充分利用CPU，提高CPU使用率；</li></ul></li><li><p>线程：一个进程的最基本的执行单位，执行路径；</p><p>多线程：在同一个进程（应用程序）中同时执行多个线程</p><ul><li>多线程好处：提高进程的执行使用率，提高CPU的使用率</li></ul></li><li><p>并发：同一时刻，多个任务交替执行；</p><p>并行：同一时刻，多个任务同时执行，多核cpu可以实现并行；</p></li></ul><p>注意：</p><ol><li>在同一个时间点，一个CPU中只能有一个线程在执行；</li><li>多线程会降低效率，但可以提高CPU使用率；</li><li>一个进程如果有多条执行路径，则称为多线程程序；</li><li>Java虚拟机的启动至少开启两条进程：主线程和垃圾回收线程；</li><li>一个线程可以理解为进程的子任务；</li></ol><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ol><li>继承Thread类，重写run方法；</li><li>实现Runnable接口，重写run方法；</li></ol><p>（Thread类实现了Runnable接口，Runnable接口里面只有一个方法run() ）</p><ul><li>调用start方法，才是真正开启了一个子线程，调用run方法不会开启新的线程（所处的线程还是执行调用的那个线程）</li><li>start() 方法调用了start0()方法， start0()方法是本地方法，由JVM调用，底层是C&#x2F;C++实现， start0()真正实现多线程的效果。</li><li>start() 方法调用start() 方法后，该线程不一定会立即执行，只是将线程变成了可运行的状态。具体什么时候执行，取决于CPU，由CPU统一调度。</li></ul><p><strong>方法一：继承Thread类</strong></p><p>当一个类继承了Thread类，该类就可以当作线程使用，并在run方法里写上自己的业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread01.start();<span class="comment">//开启线程</span></span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//让主线程休眠1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>方法二：实现Runnable接口</strong></p><p>可能一个类已经继承了某个父类，再继承Thread类来创建线程显然不可能。此时可以通过实现Runnable接口来创建进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">//不能用aa.start()来调用start，</span></span><br><span class="line">        <span class="comment">//应该创建Thread对象，把对象aa（需要实现了Runnable）放进Thread；</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(aa);</span><br><span class="line">        thead.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>继承Thread 和 实现Runnable 的区别</strong></p><p>从本质上来讲是没有区别的；</p><p>不过实现Runnable接口的方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制（建议使用Runnable）</p><hr><p><strong>线程终止</strong></p><ol><li>当线程完成任务后，会自动退出；</li><li>可以通过<strong>使用变量</strong>来控制run方法退出的方式来停止线程，即<strong>通知方式</strong></li></ol><hr><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><strong>setName</strong>  ： 设置线程名称，赋值给name；</p><p><strong>getName</strong> ： 返回该线程的名称；</p><p><strong>start</strong>：使该线程开始执行（JVM底层调用该线程的start0方法）；</p><p><strong>run</strong>：调用该线程对象的run方法；</p><p><strong>setPriority</strong>：更改线程的优先级；</p><p><strong>getPriority</strong>：获取线程的优先级；</p><p><strong>sleep</strong>：让当前正在执行的线程在指定的毫秒数内休眠（线程的静态方法，使当前线程暂停休眠）</p><p><strong>interrupt</strong>：中断线程（不是终止线程，一般用于中断线程的休眠状态）；</p><p><strong>yield</strong>：线程的礼让。让出CPU，让其他线程先执行，但礼让的时间不确定，也不一定能礼让成功；</p><p><strong>join</strong>：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务；（t1.join() ）</p><hr><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>用户线程和守护线程：</strong></p><ul><li>用户线程：也叫工作线程</li><li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。（常见的守护线程：垃圾回收机制）</li></ul><p>使用<strong>setDaemon</strong>方法将普通线程设为守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>守护线程的优先级非常低；</p><p><strong>TimerTask</strong></p><p>守护线程经常要做一些周期性的操作，如：每5分钟执行某操作，每天12点执行某操作等；此时可以用到Java的计时器的工具类：Timer和TimerTask</p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>JDK中用<strong>Thread.State</strong>枚举了线程的六种状态：</p><ol><li><strong>NEW</strong>：（new）尚未启动的线程 处于此状态</li><li><strong>RUNNABLE</strong>：（runnable）在java虚拟机中执行的线程 处于此状态</li><li><strong>BLOCKED</strong>：（blocked）被阻塞等待监视器锁定的线程 处于此状态</li><li><strong>WAITING</strong>：正在等待另一个线程执行特定动作的线程 处于此状态</li><li><strong>TIMED_WAITING</strong>：正在等待另一个线程执行动作达到指定等待时间的线程 处于此状态</li><li><strong>TERMINATED</strong>：已退出的线程 处于此状态</li></ol><p>线程状态转换图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707039.png" alt="image-20211006205038275"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707040.png" alt="image-20211007085636266"></p><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>在多线程编程中，为了防止部分数据被多个线程同时访问，所有就使用同步访问计数，保证数据在任何 同一时刻，最多被一个线程访问，以保证数据的完整性</p><p>实现同步的方法：<strong>Synchronized &#x2F; Lock</strong></p><p><strong>Synchronized</strong></p><ul><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;<span class="comment">//需要对象的锁，才能操作同步代码</span></span><br><span class="line">    被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">     被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态同步方法的锁是加在当前类本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> vodi <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同步方法如果没有使用static修饰，默认锁对象是this，如果方法由static修饰，默认锁对象：当前类.class</p><p><strong>Lock</strong></p><p>Lock 是一种比 Synchroized更加灵活的一种加锁方式，使用的时候必须显示的加锁 ：lock.lock ，然后 在释放锁的时候我们也需要显示的 lock.unlock 调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>互斥锁：</strong></p><p>保证共享数据操作的完整性；每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，都只能有一个线程访问该对象；</p><p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问；</p><p><strong>死锁：</strong></p><p>多个线程都占用了对方的锁资源，但不肯让出资源，导致了死锁（必须要避免死锁发生）</p><p><strong>释放锁：</strong></p><ol><li>当前线程的同步方法，同步代码块执行结束；</li><li>当前线程在同步方法，同步代码块中遇到break，return；</li><li>当前线程在同步方法，同步代码块中出现了未处理的Error或Exception，导致异常结束；</li><li>当前线程在同步方法，同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁；</li></ol><p>注意：下面操作不会释放锁</p><ol><li>线程执行同步方法，同步代码块时，程序调用了Thread.sleep()，Thread.yied()方法暂停当前线程的执行，不会释放锁；</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend() 方法将该线程挂起，该线程不会释放锁；（尽量避免使用suspend() 和resume() 来控制程序，方法不再推荐使用）</li></ol><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>java.net包中包含的类和接口，提供了低层次的通信细节，因此我们专注于网络程序开发，而不用考虑通信的细节。</p><p><strong>java.net</strong>包中提供了两种常见的网络协议的支持：<strong>TCP和UDP</strong>；</p><p>而对于IP地址，java中的<strong>InetAddress类</strong>表示<strong>互联网协议（IP）地址</strong>；</p><hr><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>无构造方法</p><p>常用方法：</p><p>**type[] getAddress( )**：返回此InetAddress对象的原始IP地址</p><p>**static Inetaddress getByName(String host)**：在给定主机名的情况下确定主机的IP地址</p><p>**String getHostAddress( )**：返回IP地址字符串（以文本表现形式）</p><p>**String getHostName( )**：获取此IP地址的主机名</p><p>**static InetAddress getLocalHost( )**：返回本地主机</p><blockquote><p>127.0.0.1：本地主机，主要用于测试。</p><p>别名：Localhost</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">// 获取此 IP 地址的主机名。</span></span><br><span class="line">System.out.println(inetAddress.getHostName());</span><br><span class="line"><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line">System.out.println(inetAddress.getHostAddress());</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="comment">//14.215.177.39</span></span><br></pre></td></tr></table></figure><hr><h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a>InetSocketAddress类</h3><p>InetSocketAddress类实现了<strong>IP套接字地址（IP地址+端口号）</strong></p><p>注意：</p><ul><li>编写的程序要占用端口号的话 只占用1024以上的端口号，<strong>1024以下的端口号不要去占用，因为系统有可能会随时征用。端口号本身又分为TCP端口和UDP端口，TCP的8888端口和UDP的8888端口是完全不同的两个端口。TCP端口和UDP端口都有65536个</strong>。（端口的表示是一个16位的二进制整数，2个字节，对应十进制的<strong>0~65535</strong>）(ssh 22, ftp 21, smtp, 25, http 80, tomcat 2020, mysql 3306, oracle 1521, sqlserver 1433)</li></ul><blockquote><p><strong>DOS命令查看端口：</strong></p><ul><li>查看所有端口：netstat  -ano</li><li>查看指定端口：netstat  -ano|findstr “端口号”</li><li>查看指定端口的进程：tasklist|findstr “端口号”</li></ul></blockquote><p>InetSocketAddress类：</p><p><strong>构造方法</strong>：</p><p><strong>InetSocketAddress ( InetAddress addr, int port)</strong> ：根据IP地址和端口号创建套接字地址。</p><p>**InetSocketAddress ( int port)**：创建套接字地址，其中IP地址为通配符地址，端口号为指定值。</p><p>**InetSocketAddress ( String hostname, int port)**：根据主机名和端口号创建套接字地址。</p><p>常用方法：</p><p>**InetAddress getAddress( )**：获取InetAddress（IP对象)</p><p><strong>String</strong> getHostName( )：获取主机名</p><p>**int getPort( )**：获取端口号</p><hr><h3 id="TCP网络编程："><a href="#TCP网络编程：" class="headerlink" title="TCP网络编程："></a>TCP网络编程：</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要<strong>严格区分为客户端（Client）与服务端（Server）。</strong></p><p><strong>两端通信时步骤</strong>：</p><ol><li>服务端程序，需要<strong>事先启动</strong>，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能实现通信。服务端不可以主动连接客户端。</li></ol><p>java提供了两个类用于实现TCP通信程序：</p><ol><li>客户端：用 java.net.Socket类实现。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：用 java.netServerSocket类实现。创建ServerSocket对象，相当于开启一个服务，等待客户端的连接。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707041.png" alt="image-20211011200948784"></p><h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket类实现客户端套接字，套接字指的是两台设备间通讯的端点。</p><p><strong>构造方法：</strong></p><p>**public Socket ( String host, int port)**：创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。</p><blockquote><p>回送地址（127.0.0.1）是本机回送地址（Loopback   Address），主要用于网络让江测试以及本地机进程间通讯，无论什么程序，一旦使用回送地址发送数据，会立即返回，不进行任何网络传输。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>**public InputStream getInputStream( )**：返回此套接字的输入流</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul><p>**public OutputStream getOutputStream( )**：返回此套接字的输出流</p><ul><li>如果此Socket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul><p>**public void closs( )**：关闭此套接字</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li></ul><p><strong>public void shutdownOutput( )</strong> ： 禁用此套接字的输出流。</p><ul><li>任何先前写出的数据将被发送，随后终止输出流。</li></ul><hr><h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p><code>ServerSocket</code>类实现了服务器套接字，该对象等待通过网络的请求。</p><p><strong>构造方法：</strong></p><p>**public ServerSocket( int port)**：创建ServerSocket对象，并将其绑定到一个指定的端口号上，参数port就是端口号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>**public Socket accept( )**：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直柱塞直到建立连接。</p><p>注意：</p><ul><li>服务器是没有IO流的，服务器可以获取到请求的客户端对象socket；</li><li>使用每个客户端socket中提供的IO流和客户端进行交互；</li><li>服务器使用客户端的字节输入流读取客户端发送的数据；</li><li>服务器使用客户端的字节输出流给客户端回写数据；</li></ul><hr><p>示例：客户端向客户端发送消息，服务端向客户端回写消息</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建Socket对象，它的第一个参数需要的是服务端的IP，第二个参数是服务端的端口</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、获取一个输出流，用于写出要发送的数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">//==========================解析回复==================================</span></span><br><span class="line">            <span class="comment">//4、首先必须通知服务器，我已经输出完毕了，不然服务端不知道什么时候输出完毕</span></span><br><span class="line">            <span class="comment">//服务端的while循环会一直执行，会阻塞</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            <span class="comment">///5、获取输入流，用于读取服务端回复的数据</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自服务端的消息：&quot;</span> + baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//6、释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建服务端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、调用accept接收到来自于客户端的socket</span></span><br><span class="line">            socket = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待客户端接入</span></span><br><span class="line">            <span class="comment">//3、获取socket的输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        不建议这样写：因为如果我们发送的数据有汉字，用String的方式输出可能会截取汉字，产生乱码</span></span><br><span class="line"><span class="comment">//        int len=0;</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        while ((len=is.read(buffer))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//            System.out.println(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、读取输入流中的数据</span></span><br><span class="line">            <span class="comment">//ByteArrayOutputStream的好处是它可以根据数据的大小自动扩充</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于客户端&quot;</span> + socket.getInetAddress().getHostName()</span><br><span class="line">                    + <span class="string">&quot;的消息：&quot;</span> + baos.toString());</span><br><span class="line">            <span class="comment">//===========================回复==========================================</span></span><br><span class="line">            <span class="comment">//5、获取一个输出流，写出回复给客户端</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//6、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//7、关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p><code>java.net</code>包提供了两个类DatagramSocket类和DatagramPacket类</p><ul><li><code>DatagramSocket</code>类：表示用于发送和接收数据报的套接字</li><li><code>DatagramPacket</code>类：表示数据报的数据包。</li></ul><hr><h4 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h4><p><strong>构造方法：</strong></p><p>**protected DatagramSocket()**：构造数据报套接字并将其绑定到本地主机上的任何可用端口。</p><p>**protected DatagramSocket(int port)**：构造数据报套接字并将其绑定到本地主机上的指定端口。</p><p>**protected DatagramSocket(int port, InetAddress laddr)**：创建一个数据报套接字，绑定到指定的本地地址。</p><hr><h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p><strong>构造方法：</strong></p><p><strong>DatagramPacket( byte[] buf, int offset, int length)</strong> ：构造一个DatagramPacket对象用于接受指定长度的数据报 包到缓冲区。</p><p>**DatagramPacket（ byte[] buf, int offset, int length, InetAddress address, int port)**：构造用于发送指定长度的数据报包 到指定主机的指定端口号上。</p><p><strong>常用方法：</strong></p><p><strong>byte[] getData()</strong> ：返回数据报包中的数据。</p><p>**InetAddress getAddress()**：返回该数据报发送或接收数据报的计算机的IP地址。</p><p>**int getLength()**：返回要发送的数据的长度或接收到的数据的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        String msg=<span class="string">&quot;你好，很高兴认识你！&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">        <span class="comment">//2、创建一个包（要发送给谁）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inet,<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//3、发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket，开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//2、创建一个包接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        <span class="comment">//3、接收数据</span></span><br><span class="line">        socket.receive(packet);<span class="comment">//阻塞式接收</span></span><br><span class="line">        <span class="comment">//将数据包转换为字符串输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>如果是TCP中先启动客户端会报错；而UDP中先启动发送方不会报错，但会正常退出；</strong></p><p>案例：在线咨询功能，学生和老师一对一交流（多线程）</p><p>发送方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//创建一个流 用于录入键盘的数据</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//发送数据目的地的IP</span></span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="comment">//发送数据目的地的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPSender</span><span class="params">(String toIP, <span class="type">int</span> toPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toIP = toIP;</span><br><span class="line">        <span class="built_in">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        bfr = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));<span class="comment">//从键盘录入数据到流中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环发送数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bfr.readLine();<span class="comment">//从流中读取数据</span></span><br><span class="line">                <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(toIP);</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length, inet, toPort);</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                <span class="comment">//如果发送了拜拜，则退出发送</span></span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bfr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bfr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//接收方自己所在的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromPort;</span><br><span class="line">    <span class="comment">//数据发送者的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPReceiver</span><span class="params">(<span class="type">int</span> fromPort, String msgFrom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromPort = fromPort;</span><br><span class="line">        <span class="built_in">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(fromPort);<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                socket.receive(packet);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(msgFrom + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;<span class="comment">//如果接收到的数据为拜拜，则退出接收</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">7777</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老师线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">8888</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>位于java.net包下</p><p><strong>构造方法：</strong><br>**URL(String spec)**：根据 String 表示形式创建 URL 对象。<br><strong>URL(String protocol, String host, int port, String file)</strong> ：根据指定协议名、主机名、端口号和文件名创建 URL 对象。<br>**URL(String protocol, String host, String file)**： 根据指定的协议名、主机名和文件名创建 URL。</p><p><strong>常用方法：</strong></p><p>**String getProtocol()**：获取此 URL的协议名称。</p><p><strong>String getHost()</strong> ：获取此 URL 的主机名。</p><p><strong>int getPort()</strong> ：获取此 URL 的端口号。</p><p><strong>String getPath()</strong> ：获取此 URL 的文件路径。</p><p>**String getFile()**：获取此 URL 的文件名。</p><p>**String getQuery()**：获取此 URL的查询部分。</p><p><strong>URLConnection openConnection()</strong> ：返回一个URLConnection实例，表示与URL引用的远程对象的URL </p><ul><li>URLConnection类中又有一个方法：<br><strong>InputStream getInputStream()</strong> ：返回从此打开的连接读取的输入流。</li></ul><p>演示案例：URL下载网络资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//下载地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://img.t.sinajs.cn/t6/style/images/global_nav/WB_logo.png?id=1404211047727&quot;</span>);</span><br><span class="line">        <span class="comment">//连接到这个资源 HTTP</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;weibo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        urlConnection.disconnect();<span class="comment">//断开连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到一张图片：微博t</span></span><br></pre></td></tr></table></figure><p>a</p><table><thead><tr><th>x</th><th>f1(x)</th><th>f2(x)</th><th>f3(x)</th><th>f4(x)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>11</td><td>0</td><td>2</td><td>20</td></tr><tr><td>2</td><td>12</td><td>5</td><td>10</td><td>21</td></tr><tr><td>3</td><td>13</td><td>10</td><td>30</td><td>22</td></tr><tr><td>4</td><td>14</td><td>30</td><td>32</td><td>23</td></tr><tr><td>5</td><td>15</td><td>20</td><td>40</td><td>24</td></tr></tbody></table><table><thead><tr><th>x</th><th>F1(x)</th><th>F2(x)</th><th>F3(x)</th><th>F4(x)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>11</td><td>11</td><td>11</td><td>20</td></tr><tr><td>2</td><td>12</td><td>12</td><td>13</td><td>31</td></tr><tr><td>3</td><td>13</td><td>16</td><td>30</td><td>33</td></tr><tr><td>4</td><td>14</td><td>21</td><td>41</td><td>50</td></tr><tr><td>5</td><td>15</td><td>26</td><td>43</td><td>61</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//n为项目</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; maxMomey; j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> maxMomey - j;</span><br><span class="line">        temp = F[j][i - <span class="number">1</span>] + f[k][i] </span><br><span class="line">        F[j][i] = max&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p><strong>java程序有三个阶段：</strong></p><ul><li>代码阶段&#x2F;编译阶段</li><li><strong>Class类阶段（加载阶段）：当new一个对象时（类实例化），会在堆里加载一个Class类，里面存放类的成员变量，构造器，成员方法</strong>(通过类加载器ClassLoader从.class字节码文件中加载数据，体现了反射)；会<strong>在方法区生成该类的字节码二进制数据&#x2F;元数据</strong>；</li><li>运行阶段</li></ul></blockquote><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul><li>反射机制允许程序在<strong>运行期</strong>借助Reflection API 取得<strong>任何类的内部信息</strong>（比如成员变量，构造器，成员方法等），并能<strong>操作对象的属性及方法</strong>，反射在设计模式和框架底层都会用到；</li><li>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，反射可以通过这个对象得到类的结构。</li><li>功能：<ul><li>在运行时<strong>判断</strong>任意一个<strong>对象所属的类</strong>；</li><li>在运行时<strong>构造</strong>任意一个<strong>类的对象</strong>；</li><li>在运行时<strong>得到</strong>任意一个<strong>类所具有的成员变量和方法</strong>；</li><li>在运行时<strong>调用</strong>任意一个<strong>对象的成员变量和方法</strong>；</li><li>生成<strong>动态代理</strong>；</li></ul></li></ul><hr><h4 id="反射的主要类"><a href="#反射的主要类" class="headerlink" title="反射的主要类"></a>反射的主要类</h4><p>java.lang.<strong>Class</strong>：代表一个<strong>类</strong>，Class对象表示某个类加载在堆中的对象；</p><p>java.lang.<strong>reflect.Method</strong>：代表类的<strong>方法</strong>，Method对象表示某个类的方法；</p><p>java.lang.<strong>reflect.field</strong>：代表类的成员<strong>变量</strong>，Field对象表示某个类的成员变量；</p><p>java.lang.<strong>reflect.Constructor</strong>：代表类的<strong>构造方法</strong>，Constructor对象表示构造器；</p><hr><p>反射优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活。</p><p>反射缺点：使用反射基本是解释执行，对执行速度有影响；</p><p>反射调用优化：Method和Field，Constructor对象都有setAccessible方法； 使用setAccessible（true）可以访问安全检查的开关；</p><hr><p>使用反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//2. 使用反射机制解决</span></span><br><span class="line">        <span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line">        <span class="comment">//(3) 通过 cls 得到你加载的类的&quot;methodName&quot;的方法对象</span></span><br><span class="line">        <span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">        method1.invoke(o); <span class="comment">//传统方法: 对象.方法() ; 反射机制: 方法.invoke(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量</span></span><br><span class="line">        <span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(nameField.get(o)); <span class="comment">// 传统写法: 对象.成员变量 , 反射: 成员变量对象.get(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象 表示构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getConstructor(); <span class="comment">//()中可以指定构造器参数类型, 返回无参构造器</span></span><br><span class="line">        System.out.println(constructor);   <span class="comment">//打印方法名，无参</span></span><br><span class="line">        Constructor&lt;?&gt; constructor2 = cls.getConstructor(String.class); <span class="comment">//这里传入的String.class就是String类的Class对象</span></span><br><span class="line">        System.out.println(constructor2);<span class="comment">// 打印方法名，有参 (String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也继承Object类；</li><li>Class类对象不是new出来的，而是<strong>系统创建</strong>的；</li><li>对于每个类的Class类对象，在<strong>内存中只有一份</strong>，因为<strong>类只加载一次</strong>；</li><li>每个类的实例 都知道自己是由哪个Class实例生成的；</li><li>通过Class对象可以<strong>完整地得到一个类的完整结构;</strong></li><li>Class对象<strong>存放在堆中</strong>；</li><li>类的 字节码二进制数据&#x2F;元数据 是放在<strong>方法区</strong>的（包括类的方法代码，变量名，方法名，访问权限，返回值等）；</li></ol><h4 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h4><p>**static Class forName (String name)**：返回指定类名name的Class对象；</p><p><strong>Object newInstance( )</strong> ：调用缺省构造函数，返回该Class对象的一个实例；</p><p><strong>getName( )</strong> ：返回此Class对象所表示的实体（类，接口，数组类，基本类型等）名称；</p><p>**Class[] getInterfaces( )**：获取当前Class对象的接口；</p><p>**ClassLoader getClassLoader( )**：返回该类的类加载器；</p><p><strong>Class getSuperclass( )</strong> ：返回此Class所表示的试题的超类的Class；</p><p><strong>Constructor[] getConstructors( )</strong> ：返回一个包含某些Constructor对象的数组；</p><p>**Field[] getDeclaredFields( )**：返回Field对象的一个数组；</p><p><strong>Method getMethod( )</strong> ：返回一个Method对象，此对象的形参类型为paramType；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.leaning.Car&quot;</span>;</span><br><span class="line">       <span class="comment">//1 . 获取到 Car 类 对应的 Class 对象</span></span><br><span class="line">       Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">       <span class="comment">//2. 输出 cls</span></span><br><span class="line">       System.out.println(cls); <span class="comment">//显示 cls 对象, 是哪个类的 Class 对象 com.leaning.Car</span></span><br><span class="line">       System.out.println(cls.getClass());<span class="comment">//输出 cls 运行类型 java.lang.Class</span></span><br><span class="line">       <span class="comment">//3. 得到包名</span></span><br><span class="line">       System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">       <span class="comment">//4. 得到全类名</span></span><br><span class="line">       System.out.println(cls.getName());</span><br><span class="line">       <span class="comment">//5. 通过 cls 创建对象实例</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">       System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">       <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//得到属性的赋值：宝马</span></span><br><span class="line">       <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">       brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//奔驰</span></span><br><span class="line">       Field[] fields = cls.getFields();   <span class="comment">//得到所有的属性(字段)</span></span><br><span class="line">       <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">           System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName( ) 获取，如：**Class cls &#x3D; Class.forName(“java.lang.Cat”)**；</p><p>应用场景：<strong>多用于配置文件，读取类全路径，加载类</strong>；</p></li><li><p>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高；如：<strong>Class cls &#x3D; Cat.class</strong>；</p><p>应用场景：多用于<strong>参数传递</strong>，比如通过反射得到对应构造器对象；</p></li><li><p>前提：已知某个类的实例，调用该实例的getClass() 方法获取Class对象，如：<strong>Class cls &#x3D; 对象.getClass()</strong>; &#x2F;&#x2F;运行类型</p><p>应用场景：通过创建好的对象，获取Class对象；</p></li><li><p>先得到类加载器，再<strong>通过类加载器得到Class对象</strong>：</p><p>ClassLoader cl&#x3D;对象.getClass().getClassLoader()；</p><p>Class cls &#x3D; cl.loadClass(“类的全类名”)；</p></li><li><p>基本数据（int, char, boolean, float, double, byte, long, short）得到Class类对象：</p><p>Class cls &#x3D; <strong>基本数据类型.class</strong></p></li><li><p>基本数据类型对应的包装类，可以通过 .TYPE得到Class对象：Class cls &#x3D; <strong>包装类.type</strong></p></li></ol><hr><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><strong>静态加载</strong>：<strong>编译时加载相关的类</strong>，如果没有则报错，依赖性强；</p><p><strong>动态加载</strong>：<strong>运行时加载需要的类</strong>，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性；</p><hr><p><strong>类加载时机</strong>：</p><ul><li>当创建对象时（new）&#x2F;&#x2F;静态加载</li><li>当子类被加载时，父类也加载 &#x2F;&#x2F;静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li><li>通过反射 &#x2F;&#x2F;动态加载</li></ul><hr><p><strong>类加载的三个阶段：</strong></p><p>Java源码 —(javac编译)—&gt; 字节码文件 —(java运行)—&gt; <strong>加载 –&gt; 连接（验证，准备，解析）–&gt; 初始化</strong></p><ul><li><p><strong>加载阶段</strong>：将类的字节码从不同的数据源（可能是Class文件，jar包，网络）转化为二进制字节流加载到内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成；</p></li><li><p><strong>连接阶段</strong>：将类的二进制数据合并到JRE中；</p><ul><li><p><strong>验证</strong>：</p><p>目的：是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。</p><p>包括：文件格式验证（是否以魔数oxcafebabe开头），元数据验证，字节码验证，符号引用验证；</p><p>可以考虑使用 -Xverify : none参数来关闭大部分的类验证措施，缩短虚拟机 类加载的时间；</p></li><li><p><strong>准备</strong>：</p><p>JVM会在该阶段对静态变量分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解析</strong>：</p><p>到这里，才真正开始执行类中定义的Java程序代码，此阶段是执行 &lt; clinit &gt; ( ) 方法的过程；</p><p>&lt; clinit &gt; ( ) 方法 是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<strong>静态变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句，并进行合并；</p><p>虚拟机会保证一个类的&lt; clinit &gt; ( ) 方法在多线程环境中被正确地<strong>加锁、同步</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line"><span class="comment">//因为有同步机制，能保证某个类在内存中, 只有一份 Class 对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化阶段</strong>：JVM负责对类进行初始化，这里主要是指静态成员；</p></li></ul><h3 id="反射获取类结构信息"><a href="#反射获取类结构信息" class="headerlink" title="反射获取类结构信息"></a>反射获取类结构信息</h3><ul><li><p>java.lang.<strong>Class</strong>类</p><ol><li>getName：获取全类名</li><li>getSimpleName：获取简单类名</li><li>getFields：获取所有public修饰的属性，包括本类以及父类的</li><li>getDeclaredFields：获取本类中所有属性</li><li>getMethods：获取所有public修饰的方法，包括本类以及父类的</li><li>getDeclaredMethods：获取本类中所有方法</li><li>getConstructors：获取本类中所有public修饰的构造器</li><li>getDeclaredConstructors：获取本类中所有构造器</li><li>getPackage：以Package形式返回 包信息</li><li>getSuperClass：以Class形式返回父类信息</li><li>getInterfaces：以Class[] 形式返回接口信息</li><li>getAnnotations：以Annotation[] 形式返回注解信息</li></ol></li><li><p>java.lang.reflect.<strong>Field</strong>类</p><ol><li><p>getModifiers：以int形式返回修饰符</p><p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p></li><li><p>getType：以Class形式返回 类型</p></li><li><p>getName：返回属性名</p></li></ol></li><li><p>java.lang.reflect.<strong>Method</strong>类</p><ol><li><p>getModifiers：以int形式返回修饰符</p><p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p></li><li><p>getReturnType：以Class形式获取 返回类型</p></li><li><p>getParameterTypes：以Class[] 返回参数类型数组</p></li></ol></li><li><p>java.lang.reflect.<strong>Constructor</strong>类</p><ol><li>getModifiers：以int形式返回修饰符</li><li>getName：返回构造器名（全名）</li><li>getParameterTypes：以Class[] 形式返回参数类型数组</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="comment">//第一组方法 API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//homework.OrangeJuice</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//OrangeJuice</span></span><br><span class="line">        <span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以 Package 形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//package homework</span></span><br><span class="line">        <span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);<span class="comment">//class homework.Drink</span></span><br><span class="line">        <span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第2，3，4组api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是 0 ， public 是 1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里只输出名</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">reflect</span> <span class="variable">reflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">reflect</span>();</span><br><span class="line">        reflect.api_01();</span><br><span class="line">        reflect.api_02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><p>方式一：调用类中的public修饰的无参构造器</p><p>方式二：调用类中的指定构造器</p><p>方式三：Class类相关方法：newInstance，getConstructor，getDecalaredConstructor</p><p>方式四：Constructor类相关方式：setAccessible，newInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 先获取到 User 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;leaning.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通过 public 的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3. 通过 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//3.2 创建实例，并传入实参</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hsp</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;屏平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;屏平 = &quot;</span> + hsp);</span><br><span class="line">        <span class="comment">//4. 通过非 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//4.1 得到 private 的构造器对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">        <span class="comment">//4.2 创建实例</span></span><br><span class="line">        <span class="comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2 = &quot;</span> + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">//User 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;灿灿灿&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;<span class="comment">//无参 public</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;<span class="comment">//public 的有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;<span class="comment">//private 有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射访问类中成员"><a href="#反射访问类中成员" class="headerlink" title="反射访问类中成员"></a>反射访问类中成员</h3><p><strong>访问属性：</strong></p><ol><li><p>根据属性名获取Field对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> class对象.getDeclaredField(属性名);</span><br></pre></td></tr></table></figure></li><li><p>爆破：f.setAccessible (true);   &#x2F;&#x2F;f是Field</p></li><li><p>访问：</p><p>f.set(o值)； &#x2F;&#x2F;o表示对象</p><p>syso(f.get(o))；&#x2F;&#x2F;o表示对象</p><p>（如果是静态属性，则set和get中的参数o可以写成null）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;leaning.Student2&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student</span></span><br><span class="line">        System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line">        <span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">        System.out.println(o);<span class="comment">//</span></span><br><span class="line">        System.out.println(age.get(o));<span class="comment">//返回 age 属性的值</span></span><br><span class="line">        <span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//name.set(o, &quot;小郑&quot;);</span></span><br><span class="line">        name.set(<span class="literal">null</span>, <span class="string">&quot;小郑~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">        System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//获取属性值, 要求 name 是 static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问方法：</strong></p><ol><li><p>根据方法名和参数列表获取Method方法对象：Method m &#x3D; class.getDeclaredMethod(方法名，XX.class)；&#x2F;&#x2F;得到本类的所有方法</p></li><li><p>获取对象：Object o &#x3D; class.newInstance()；</p></li><li><p>爆破：m.setAccessible(true)；</p></li><li><p>访问：Object.returnValue &#x3D; m.invoke(o，实参列表)； &#x2F;&#x2F;o就是对象</p><p>（如果是静态方法，则invoke的参数o，可以写成null）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Boss 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;leaning.Boss&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用 public 的 hi 方法</span></span><br><span class="line">        <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">        <span class="comment">//3.1 得到 hi 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//3.2 调用</span></span><br><span class="line">        hi.invoke(o, <span class="string">&quot;调用了hi方法&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 调用 private static 方法</span></span><br><span class="line">        <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class);</span><br><span class="line">        <span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">        <span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null</span></span><br><span class="line">        System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line">        <span class="comment">//5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示一个返回的案例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal2</span> <span class="operator">=</span> m1.invoke(o);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal2 的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;<span class="comment">//静态方法</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;<span class="comment">//普通 public 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>（String能使用正则表达式，如</p><p>string.replaceAll(“aaa”, “AAA”);  </p><p>string.matches(“1(38|39)\d{8}”)；（返回true或false） </p><p>String[] split &#x3D; string.split(“#|-|~|\\d+”); </p><p>（stirng都是指一个字符串）</p><p>)</p><h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String content;<span class="comment">//目标串</span></span><br><span class="line">String regStr;<span class="comment">//模式串</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);<span class="comment">//创建模式对象，参数如果加上Pattern.CASE_INSENSITIVE,表示不区分大小写</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);<span class="comment">//创建匹配器matcher，按照 正则表达式的规则 去匹配content字符串;</span></span><br></pre></td></tr></table></figure><p>正则表达式中的（）表示分组，第一个（）表示第一组..</p><p>底层：</p><ul><li><p>根据指定的表达式规则，定位到满足规则的子字符串；</p></li><li><p>找到后，将子字符串的开始索引值和结束索引值+1记录到 int[] groups;</p></li><li><p>同时记录oldLast的值为子字符串的结束索引值+1，即下一次执行find时，就从oldLast开始；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (group &lt; <span class="number">0</span> || group &gt; groupCount())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;No group &quot;</span> + group);</span><br><span class="line">        <span class="keyword">if</span> ((groups[group * <span class="number">2</span>] == -<span class="number">1</span>) || (groups[group * <span class="number">2</span> + <span class="number">1</span>] == -<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> getSubSequence(groups[group * <span class="number">2</span>], groups[group * <span class="number">2</span> + <span class="number">1</span>]).toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//group(0)表示匹配到的子字符串</span></span><br><span class="line"><span class="comment">//group(1)表示匹配到的子字符串的第一组子串</span></span><br><span class="line"><span class="comment">//group(2)表示匹配的子字符串的第二组子串</span></span><br><span class="line"><span class="comment">//...但是分组的数不能越界，否则报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;第 1 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>*</td><td>指定字符字符重复0到多次</td><td>(abc)*</td><td>仅包含任意个abc字符串</td></tr><tr><td>+</td><td>指定字符重复1到多次</td><td>(abc)+</td><td>仅包含至少一个abc字符串</td></tr><tr><td>？</td><td>指定字符重复0或1次</td><td>abc？</td><td>ab或abc</td></tr><tr><td>{n}</td><td>只能输入n个字符</td><td>[abcd]{3}</td><td>由abcd中字母组成的任意长度为3的字符串</td></tr><tr><td>{n,}</td><td>指定至少n个匹配</td><td>[abcd]{3,}</td><td>由abcd中字母组成的任意长度不小于3的字符串</td></tr><tr><td>{n,m}</td><td>指定至少n个到m个之间的匹配</td><td>[abcd]{3,5}</td><td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td></tr></tbody></table><hr><h4 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h4><p>有选择性的匹配字符：|</p><p>|：匹配之前或之后的表达式</p><p>如：ab|cd ：匹配ab或cd</p><hr><h4 id="分组组合和方向应用符"><a href="#分组组合和方向应用符" class="headerlink" title="分组组合和方向应用符"></a>分组组合和方向应用符</h4><p>在表达式分组中:</p><p><strong>（表达式）</strong>：非命名捕获，编号为0的第一个捕获是整个表达式模式匹配的文本，其他捕获则根据括号顺序从1开始编号；</p><p>**(?&lt; name&gt;表达式)**：命名捕获，将匹配到的子字符串捕获到一个组名或编号name中。name不能包含任何标点符号，不能以数字开头，可以使用单引号代替&lt;&gt;</p><hr><p><strong>（?:表达式）</strong>：</p><p>非捕获匹配（即匹配但不存储）,例：“industr(?:y|ies)”效果与”industry|intdustries“相同，但更经济；</p><p><strong>（?&#x3D;表达式）</strong>：</p><p>是非捕获匹配 ，例：“Windows(?&#x3D;95|98|NT)”匹配“Windows 95”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”；</p><p><strong>（?!表达式）</strong>：</p><p>非捕获匹配，例：“Windows(?!95|98|NT)”匹配“Windows 3.1”中的“Windows”，但不匹配“Windows 98”中的“Windows”；</p><hr><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>对于已经有特殊的含义的字符，想要匹配这些字符，就需要加上转义符号：**\\**（java中使用两个\，其他语言使用一个\）；</p><p>需要用到转义符号的字符有： <strong>.  *  +  ( )  $  &#x2F; \  ?  [ ]  ^  { }</strong></p><hr><p><strong>字符匹配符</strong></p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>[ ]</td><td>可接收的字符列表</td><td>[efgh]</td><td>efgh中任意一个字符</td></tr><tr><td>[^ ]</td><td>不可接收的字符列表</td><td>[^abc]</td><td>除了a，b，c之外的任意一个字符，包括特殊符号</td></tr><tr><td>-</td><td>连字符</td><td>A-Z</td><td>任意单个大写字符</td></tr><tr><td>.</td><td>匹配除\n外的任何字符</td><td>a..b</td><td>以a开头，b结尾，中间任意2个字符</td></tr><tr><td>\\d</td><td>匹配单个数字字符，相当于[0-9]</td><td>\\d{3}(\\d)?</td><td>包含3个或4个数字的字符串</td></tr><tr><td>\\D</td><td>匹配单个非数字字符，相当于[ ^ 0-9 ]</td><td>\\D(\\d)*</td><td>以单个非数字字符开头，后接任意个数字</td></tr><tr><td>\\w</td><td>匹配单个数字，大小写字母，相当于[0-9a-zA-Z]</td><td>\\w{4}</td><td>长度为4的数字字母字符串</td></tr><tr><td>\\W</td><td>匹配单个非数字，大小写字母，相当于[ ^ 0-9a-zA-Z]</td><td>\\W+\\d{2}</td><td>以至少一个非数字字母字符开头，2个数字结尾</td></tr><tr><td>\\s</td><td>匹配任何空白字符（空格，制表符）</td><td></td><td></td></tr></tbody></table><hr><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>至少一个数字开头，后接任意小写字母</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9] [a-z]+$</td><td>以一个数字开头，后接至少一个小写字母结尾</td></tr><tr><td>\\b</td><td>匹配目标字符串的边界</td><td>can\\b</td><td>边界指空格或结束位置，如：can<strong>can</strong>  c<strong>can</strong></td></tr><tr><td>\\B</td><td>匹配目标字符串的非边界</td><td>can\\B</td><td>如：<strong>can</strong>can can</td></tr></tbody></table><hr><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>Pattern类，Matcher类，PatternSyntaxException</p><p>Pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建对象，应调用其公共静态方法，它接收一个正则表达式作为参数，返回一个Pattern对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure><p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法或获得一个Matcher对象；</p><p>PatternSyntaxException是一个非强制性异常类，它表示一个正则表达式模式中的语法错误；</p><hr><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>分组：</p><p>正则表达式中的 一个括号的部分可以看成是一个分组&#x2F;子表达式；</p><p>捕获：</p><p>分组匹配到的内容，会保存到以数字编号或显示命名的组里，方便后面引用；</p><p><strong>反向引用：</strong></p><p>圆括号（分组）的内容被捕获后，可以在这个括号后被使用；这种引用可以在内部使用，也可以在外部使用；</p><p>内部：<strong>\\分组号</strong></p><p>外部：**$分组号**</p><p>如：要匹配两个连续的相同数字： (\\d)\\1</p><p>​要匹配五个连续的相同数字：(\\d)\\1{4}</p><p>​要匹配个位与千位相同，十位与百位相同的数(5225,1551)：(\\d)(\\d)\\2\\1</p><p>程序案例：<strong>结巴去重</strong></p><p>把 类似 : “我….我要….学学学学….编程 java!”</p><p>通过正则表达式 修改成 “我要学编程 java” ；（即没有连续重复的字符）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;我....我要....学学学学....编程 java!&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 去掉所有的. </span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">      content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">//2. 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">      <span class="comment">// 思路</span></span><br><span class="line">      <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">      <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">      <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line">       pattern = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>);<span class="comment">//分组的捕获内容记录到$1</span></span><br><span class="line">       matcher = pattern.matcher(content);</span><br><span class="line">       <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">      <span class="comment">//使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">       content = matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 使用一条语句 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure><h3 id="元字符-详细说明"><a href="#元字符-详细说明" class="headerlink" title="元字符-详细说明"></a>元字符-详细说明</h3><table><thead><tr><th><strong>字符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>\</td><td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</strong></td></tr><tr><td><strong>^</strong></td><td><strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></td></tr><tr><td><strong>$</strong></td><td><strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></td></tr><tr><td>*****</td><td><strong>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</strong></td></tr><tr><td><strong>+</strong></td><td><strong>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</strong></td></tr><tr><td><strong>?</strong></td><td><strong>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</strong></td></tr><tr><td><strong>{*n*}</strong></td><td>*<strong>n*</strong> <strong>是非负整数。正好匹配 *n* 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</strong></td></tr><tr><td><strong>{*n*,}</strong></td><td>*<strong>n*</strong> <strong>是非负整数。至少匹配 *n* 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*“。</strong></td></tr><tr><td><strong>{*n*,*m*}</strong></td><td>*<strong>m*</strong> <strong>和 *n* 是非负整数，其中 *n* &lt;&#x3D; *m*。匹配至少 *n* 次，至多 *m* 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于  ‘o?’。注意：您不能将空格插入逗号和数字之间。</strong></td></tr><tr><td><strong>?</strong></td><td><strong>当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</strong></td></tr><tr><td><strong>.</strong></td><td><strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></td></tr><tr><td><strong>(*pattern*)</strong></td><td><strong>匹配 *pattern* 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</strong></td></tr><tr><td><strong>(?:*pattern*)</strong></td><td><strong>匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’  更经济的表达式。</strong></td></tr><tr><td><strong>(?&#x3D;*pattern*)</strong></td><td><strong>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows  2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td></tr><tr><td><strong>(?!*pattern*)</strong></td><td><strong>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows  3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td></tr><tr><td><em><strong>x*</strong></em><em>|*y*</em>*</td><td><strong>匹配 *x* 或 *y*。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></td></tr><tr><td><strong>[*xyz*]</strong></td><td><strong>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</strong></td></tr><tr><td><strong>[^*xyz*]</strong></td><td><strong>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</strong></td></tr><tr><td><strong>[*a-z*]</strong></td><td><strong>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</strong></td></tr><tr><td><strong>[^*a-z*]</strong></td><td><strong>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</strong></td></tr><tr><td><strong>\b</strong></td><td><strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</strong></td></tr><tr><td><strong>\B</strong></td><td><strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></td></tr><tr><td><strong>\c*x*</strong></td><td><strong>匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或  a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</strong></td></tr><tr><td><strong>\d</strong></td><td><strong>数字字符匹配。等效于  [0-9]。</strong></td></tr><tr><td><strong>\D</strong></td><td><strong>非数字字符匹配。等效于  [^0-9]。</strong></td></tr><tr><td><strong>\f</strong></td><td><strong>换页符匹配。等效于  \x0c 和 \cL。</strong></td></tr><tr><td><strong>\n</strong></td><td><strong>换行符匹配。等效于  \x0a 和 \cJ。</strong></td></tr><tr><td><strong>\r</strong></td><td><strong>匹配一个回车符。等效于  \x0d 和 \cM。</strong></td></tr><tr><td><strong>\s</strong></td><td><strong>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</strong></td></tr><tr><td><strong>\S</strong></td><td><strong>匹配任何非空白字符。与  [^ \f\n\r\t\v] 等效。</strong></td></tr><tr><td><strong>\t</strong></td><td><strong>制表符匹配。与  \x09 和 \cI 等效。</strong></td></tr><tr><td><strong>\v</strong></td><td><strong>垂直制表符匹配。与  \x0b 和 \cK 等效。</strong></td></tr><tr><td><strong>\w</strong></td><td><strong>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</strong></td></tr><tr><td><strong>\W</strong></td><td><strong>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</strong></td></tr><tr><td><strong>\x*n*</strong></td><td><strong>匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</strong></td></tr><tr><td><strong>*num*</strong></td><td><strong>匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</strong></td></tr><tr><td><strong>*n*</strong></td><td><strong>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。</strong></td></tr><tr><td><strong>*nm*</strong></td><td><strong>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 *nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。</strong></td></tr><tr><td><strong>\nml</strong></td><td><strong>当 *n* 是八进制数  (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。</strong></td></tr><tr><td><strong>\u*n*</strong></td><td><strong>匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</strong></td></tr></tbody></table><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>采用一定的方法保证在整个软件系统中，<strong>对某个类，只能存在一个对象实例，且该类只提供一个取得其对象实例的方法</strong>。</p><p><strong>步骤：</strong></p><ul><li><strong>构造器私有化，防止直接new；</strong></li><li><strong>在类的内部创建对象；</strong></li><li><strong>向外暴露一个静态的公共方法</strong></li></ul><p>饿汉式和懒汉式<strong>区别</strong>：</p><ol><li>创建时机不同，<strong>饿汉式是在类加载就创建了对象实例</strong>，而<strong>懒汉式是使用时才创建</strong>；</li><li><strong>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</strong>；</li><li><strong>饿汉式存在资源浪费问题</strong>，如果使用时一个对象实例都没使用，饿汉式创建的对象就浪费了；</li></ol><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了能在静态方法中返回这个对象，使用static</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;饿汉&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是一个引用，还没有创建对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Instance ins;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="comment">//若对象还未创建，才去创建，即第一次调用了这个方法，对象才会被创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">null</span>)&#123;</span><br><span class="line">            ins = <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>**equals（object o)**：指示其他对象是否与此对象相等</p><p><strong>finalize()</strong></p><p>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。</p><p>**getclass()**：返回此 <code>Object</code>的运行时类。 </p><p>**hashcode()**：返回对象的哈希码值</p><p>**toString()**：返回对象的字符串表示形式</p><p>**clone()**：创建并返回此对象的一个副本</p><p><strong>notify()</strong></p><p><strong>notifyAll()</strong></p><p><strong>wait()</strong></p><hr><p><strong>&#x3D;&#x3D;与equals的对比</strong>：</p><p>&#x3D;&#x3D;是一个比较运算符</p><ul><li><strong>&#x3D;&#x3D; 判断基本类型时，判断值是否相等</strong></li><li><strong>&#x3D;&#x3D; 判断引用类型时，判断地址是否相等</strong>，即是不是同一个对象</li></ul><p><strong>equals</strong>是Objects类中的方法，<strong>只能判断引用类型，默认判断地址是否相等</strong>，不过其<strong>子类往往重写该方法，用于判断内容是否相等</strong>，如Integer, String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((integer)obj).intValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>hashcode方法</strong></p><ol><li>提高具有哈希结构的容器的效率；</li><li>两个引用，如果指向同一个对象，则哈希值肯定是一样的；</li><li>两个引用，如果指向不同的对象，则哈希值不一样；</li><li>哈希值主要根据地址号 计算得来的，不能完全将哈希值等价与地址</li></ol><p>重写hahscode：</p><hr><p><strong>toString方法</strong></p><p>Object的toString方法默认返回：全类名 + @ + 哈希值的十六进制；子类往往重写toString方法，用于返回对象的属性信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>finalize方法</strong></p><ul><li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法；</p></li><li><p>垃圾回收机制的调用，是由系统来决定 ( 即有自己的 GC 算法 ) ，也可以通过 System.gc() 主动触发垃圾回收机制</p><p>（实际开发中，几乎不会用到finalize）</p></li></ul><hr><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p><strong>reverse（List）</strong>：反转List中元素的顺序；</p><p><strong>shuffle（List</strong>）：对List中元素进行随机排序；</p><p><strong>swap（List， int ，int）</strong>：交换List中两个元素的位置</p><p>Object max（Collection）：返回给定集合中最大元素</p><p><strong>Object max（Collection，Comparator）</strong>：根据Comparator指定的顺序，返回最大元素；</p><p>min跟max一样</p><p><strong>int frequency（Collection， Object）</strong>：返回指定集合中指定元素的出现次数</p><p><strong>void copy（List dest，List src）</strong>：将src复制到dest中</p><p><strong>boolean replaceAll（List list，Object oldVal，Object newVal）</strong>：使用新值，替换掉List中所有旧值</p><hr><p><strong>sort（）：</strong></p><p>Map, Set, List等集合中，都提供了一个排序方法：**sort()**，不过要保证集合中的对象是可比较的；</p><p>让对象是 可比较的， 可以让对象实现 <strong>Comparable&lt; T&gt;接口</strong>，然后重写里面的**compareTo()**方法，</p><p><strong>compareTo（Object o）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="comment">//return o.age - this.age;</span></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>负整数</td><td>当前对象的值 <strong>&lt;</strong> 比较对象的值 ， 位置排在前</td></tr><tr><td>零</td><td>当前对象的值 <strong>&#x3D;</strong> 比较对象的值 ， 位置不变</td></tr><tr><td>正整数</td><td>当前对象的值 <strong>&gt;</strong> 比较对象的值 ， 位置排在后</td></tr></tbody></table><p><strong>比较器的使用：</strong></p><p>(例题可看 笔记（数据结构 ) —堆 692.前k个高频词)</p><p>想要排序集合中的其他元素，可以使用Comparator :</p><ul><li>Collertions.sort ( list , Comparator&lt; T&gt; ) ;</li><li>list.sort ( Comparator&lt; T&gt;) ;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序1</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序2</span></span><br><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> hh.nextInt();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.next  -&gt;  输入字符串</span></span><br><span class="line"><span class="comment">//.nextDouble  -&gt;  输入双精度浮点数</span></span><br><span class="line"><span class="comment">//其他类型 输入样式 相似</span></span><br></pre></td></tr></table></figure><p>当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。</p><p>如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">string</span> <span class="variable">line</span> <span class="operator">=</span>  s.nextLine;</span><br></pre></td></tr></table></figure><p>Scanner类主要提供了两个方法来扫描输入：</p><p>1）**hasNextXx()**：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。</p><p>2）**nextXxx()**：获取下一个输入项。Xxx的含义同上。</p><p>默认情况下，Scanner使用空白（包括空格、Tab空白和回车）作为多个输入项的分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="comment">//System.in代表键盘输入</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//使用回车作为分隔符</span></span><br><span class="line">    sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>String 类是<strong>被 final 修饰的，即 String 类不能被继承</strong>。</p><p>其中有一个很重要的数组，char 数组，用来保存字符串的，既然是用 final 关键字来修饰的，那就代表 <strong>String 是不可变的</strong>（不能指向新地址，但char[]里面的单个字符可改）</p><p>在源代码中，substring，replace 最后都是通过 new String(xxx) 来产生了一个新的 String 对象，最原始的字符串并没有改变。</p><p>（String实现了serializable接口，说明可以串行化（可以在网络上传输），实现了comparable接口，说明String对象可以比较；）</p><p>而<strong>StringBuilder</strong>中的字符可变</p><p>比如使用append方法，返回的依然是 StringBuffer 对象本身，说明他确实是值改变了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实际调用的是 StringBuilder 的父方法。该父方法，会先检测容量够不够，不够的话会进行扩容，然后调用 String 的 getChars 方法。注意，最后返回的依旧是 StringBuffer 对象</p><p><strong>关于字符串相加：</strong><br>使用“+”对两个字符串相加的过程：</p><p>String 对象的操作符“+”其实被赋予了特殊的含义，该操作符是 Java 中仅有的两个重载过的操作符。</p><p>String 对象在进行“+”操作的时候，其实是调用了StringBuilder 对象的 append() 方法来加以构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;<span class="comment">//a1指向常量区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//也指向常量区</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> b + c;<span class="comment">//指向堆中的String对象</span></span><br><span class="line"><span class="comment">//a1 == a</span></span><br><span class="line"><span class="comment">//a != d</span></span><br><span class="line"><span class="comment">//a1 != d</span></span><br></pre></td></tr></table></figure><p>看 String a，“hello” + “world” 在 String 编译期间进行优化，优化结果为 “helloworld”，而该值在常量池中已经存有一份，因此 a 也指向了该常量池中的字符串，因此 a1 和 a 相等;</p><p>在对 b 和 c 进行相加的过程中：1. xia你创建StringBuilder sb &#x3D; StringBuilder()；2. 执行sb.append(“hello”);  再执行一次sb.append(“world”)； 3. String d &#x3D; sb.toString();</p><p>很明显 d 对象指向的是堆中的 String 对象，而 a1 则指向的是常量池中的字符串，两者引用明显不同，</p><p><strong>小结：String s &#x3D; “ab” + “cd”：常量相加，看的是池；String s &#x3D; a + b :  变量相加，是在堆中</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707042.png" alt="image-20211002201859440"></p><hr><p><strong>创建</strong>的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="comment">//一，先从常量池查看是否有“ssss”数据空间，如果有，直接指向；没有则重新创建，然后指向。s最终指向的是常量池的空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line"><span class="comment">//二，先在堆中创建空间，里面维护了value属性，指向常量池的“ssss”空间。如果常量池没有，重新创建，有的话则直接通过value指向。s最终指向的是堆中的空间地址。</span></span><br></pre></td></tr></table></figure><p>构造器 参数列表有多种：(String s)， (char[] a ), (char[] a, int startIndex, int count), (byte[] b) ….</p><p>int **indexOf(int ch) : ** <strong>lastIndexOf(int ch) :</strong></p><p>返回指定字符第一次(最后一次)出现处的索引</p><p>int **indexOf(String str) ** <strong>&#x2F; lastIndexOf(String str)</strong></p><p>返回指定 子字符串 第一次出现处的索引</p><p>char <strong>cahrAt(int index) :</strong></p><p>返回index’位置上的字符</p><p><strong>concat( String s) :</strong>  拼接字符串</p><p>boolean <strong>endsWith(String suffix) :</strong></p><p>判断此字符串是否以指定的字符串结尾</p><p>boolean <strong>startsWith(String prefix) :</strong></p><p>判断此字符串是否以指定的字符串开始</p><p>int <strong>length() :</strong>  返回此字符串的长度</p><p>boolean <strong>equals (Object anObject) :</strong></p><p>将此字符串与指定的字符串比较</p><p><strong>equaIsIgnoreCase</strong> :忽略大小写的判断内容相等</p><p>boolean <strong>isEmpty() :</strong></p><p>此字符串长度为0时返回true</p><p>boolean <strong>contains(CharSequence cs) :</strong></p><p>判断是否包含指定的字符序列</p><p>String <strong>toLowerCase() :</strong></p><p>将String中的所有字符都转换为小写（使用默认语言环境的规则）</p><p>String <strong>toUpperCase() :</strong></p><p>将String中的所有字符都转换为大写</p><p>static <strong>String valueOf(int i) :</strong></p><p>返回int参数的字符串表示形式</p><p>char[] <strong>toCharArray() :</strong></p><p>将此字符串转换为一个字符数组</p><p>String <strong>replace(CharSequence oldstr, CharSequence newstr) :</strong></p><p>返回新的字符串，用newstr替换所有的oldstr</p><p>String[] <strong>split(String regex) :</strong></p><p>根据参数regex（regex是一个正则表达式，用于限定分隔规则）将此字符串分割为若干个字符串</p><p>String <strong>substring(itn beginIndex) :</strong> </p><p>返回一个新字符串，从指定的beginIndex开始，直至末尾</p><p>String <strong>substring(itn beginIndex， int endIndex) :</strong> </p><p>返回一个新字符串，从指定的beginIndex到endIndex - 1</p><p>String <strong>trim() :</strong></p><p>返回一个新字符串，它去除了原字符串 首尾的空格</p><p><strong>format（String s, …）</strong>：格式化字符串，%s 字符串，%c 字符 … </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(s, ....);</span><br><span class="line"><span class="comment">//format的第一个参数是要格式化的字符串，后面是要替换s中占位符%的变量；</span></span><br><span class="line">system.out.println(<span class="string">&quot;s = &quot;</span> + info);</span><br></pre></td></tr></table></figure><p>Strng方法练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span> &#123;<span class="comment">//定义一个静态方法，获取变量的类型，通过类Main来调用它</span></span><br><span class="line"><span class="keyword">return</span> o.getClass().getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice!&quot;</span>);<span class="comment">//这里全部使用String类的构造方法来初始化字符串对象</span></span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice&quot;</span>);</span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">String s5=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">String s6=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot; abcd &quot;</span>);</span><br><span class="line">String s7=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a123a123b456&quot;</span>);</span><br><span class="line"><span class="type">char</span>[] str=s1.toCharArray();</span><br><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;↓↓↓String类的一些常用方法如下↓↓↓&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1的长度为：&quot;</span> + s1.length());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符&#x27;J&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&#x27;J&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;从指定的索引2开始搜索，返回字符串&#x27;a1&#x27;在字符串s7中第一次出现的索引：&quot;</span> + s7.indexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符&#x27;a&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;从指定的索引8开始反向搜索，返回字符串&#x27;a1&#x27;在字符串s7中最后一次出现的索引：&quot;</span>+s7.lastIndexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;获取字符串s1中第3个位置上的字符：&quot;</span> + s1.charAt(<span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串开始：&quot;</span> + s1.startsWith(<span class="string">&quot;我喜欢&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串结尾：&quot;</span> + s1.endsWith(<span class="string">&quot;nice&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.equals(s2));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.equalsIgnoreCase(s4));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.compareTo(s2));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.compareToIgnoreCase(s4));</span><br><span class="line"><span class="comment">/*compareTo(String anotherString)方法将当前字符串与参数字符串进行比较，</span></span><br><span class="line"><span class="comment">如果相同，则返回0。</span></span><br><span class="line"><span class="comment">不相同时，从两个字符串第1个字符开始比较，返回第一个不相等的字符差，按照字典顺序</span></span><br><span class="line"><span class="comment">另一种情况，某个字符串和其子串进行比较，返回它们的长度差。</span></span><br><span class="line"><span class="comment">compareToIgnoreCase(str)与compareTo的区别是忽略了大小写*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s5的长度是否为0：&quot;</span> + s5.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1中是否包含指定的序列：&quot;</span> + s1.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s4连接到s3的结尾：&quot;</span> + s3.concat(s4));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s4的所有字符转为小写：&quot;</span> + s4.toLowerCase());</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s3的所有字符转为大写：&quot;</span> + s3.toUpperCase());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将int类型转为字符串，并获取a的变量类型：&quot;</span> + Main.getType(String.valueOf(a)));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;将字符串s1转为字符数组str：&quot;</span>);<span class="comment">//见代码第13行</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s2中的&#x27;Java&#x27;全部替换为&#x27;Python&#x27;：&quot;</span> + s2.replace(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;截取字符串s1从第3个位置开始到结尾：&quot;</span> + s1.substring(<span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;截取字符串s1从0个位置开始到第7个位置结尾：&quot;</span> + s1.substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;去掉字符串s6首尾的空格：&quot;</span> + s6.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删；是一个final类，不能被继承；</p><p>很多方法与String相同，StringBuffer是一个容器；</p><p>StringBuffer中的char[] value<strong>没有加final</strong>，所以可以增删字符，且<strong>放在堆中</strong></p><hr><p><strong>String与StringBuffer的转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//一，使用构造器，返回的是StringBuffer对象，对s没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//二，使用append方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb2 =sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//使用StringBuffer的toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb3.toString();</span><br><span class="line"><span class="comment">//使用构造器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb3);</span><br></pre></td></tr></table></figure><hr><p><strong>StringBuffer方法</strong></p><p><strong>append( String s)</strong> ：末尾增添字符串</p><p><strong>delete( int start, int end)</strong> ：删，将start到end的内容删掉，不包括end</p><p><strong>replace( int start, int end, String s)</strong> ：改，将start到end的内容换掉，不包括end</p><p><strong>insert（int index， String s)</strong> ：插，在索引n处插入字符串，索引n后的内容自动后移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(s);<span class="comment">//传入一个空的字符串，但这里没问题</span></span><br><span class="line"><span class="comment">//底层调用了父类的AbstractStingBuffer的appendNull方法，加入一个字符串“null”。</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//构造器传入空的字符串，会出现异常；因为底层调用的父类构造器传入的参数是字符串的长度+16，而字符串为空，显然会出现异常</span></span><br></pre></td></tr></table></figure><hr><p><strong>StringBulider类</strong></p><p>StringBulider提供一个与 StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计作为StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。</p><p>StringBuilder类的方法和StringBuffer类的一样</p><hr><p><strong>String，StringBuffer，StringBuilder的比较</strong></p><ul><li>String：不可变字符序列，效率低，但复用率高</li><li>StringBuffer：可变序列，效率较高，线程安全</li><li>StringBuilder：可变序列，效率最高，线程不安全</li></ul><p>所以，如果字符串存在大量修改操作：在<strong>单线程时用StringBuilder</strong>，在<strong>多线程时用StringBuffer</strong>；如果字符串<strong>很少修改，且被多个对象引用，使用String</strong>。</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p><strong>数组转List</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(arr).contains(<span class="number">3</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(array).contains(<span class="number">3</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的转换，拆开：</span></span><br><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; integers = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(array);</span><br><span class="line"><span class="comment">//区别:原始数据类型int的数组调用asList之后得到的List只有一个元素，这个元素就是元素类型的数组。而封装类Integer数组调用asList是把数组中每个元素加到了List中。</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.fill() ;填充数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">4</span>);<span class="comment">//给所有值赋值4</span></span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//给第2位（0开始）到第4位（不包括）赋值6</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.sort(); &#x2F;&#x2F;数组排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intArray);</span><br><span class="line"><span class="comment">//数字排序：从小到大；</span></span><br><span class="line"><span class="comment">//字符串排序：先大写后小写（ASCII码）</span></span><br><span class="line"></span><br><span class="line"> Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"><span class="comment">//严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"><span class="comment">//反向排序， Reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER); Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"><span class="comment">//忽略大小写反向排序 Case-insensitive reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//选择数组指定位置进行排序：给第0位（0开始）到第3位（不包括）排序</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)  &#x2F;&#x2F;自定义数组排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1 - o2; <span class="comment">//返回&gt;0或&lt;0会影响排序结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Arrays.toString(); &#x2F;&#x2F;将数组中的内容全部打印出来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(arr);<span class="comment">//直接将数组打印输出</span></span><br><span class="line"><span class="comment">//输出：[I@7852e922 (数组的地址)</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部转为字符串输出</span></span><br><span class="line"><span class="comment">//System.out.print(str);</span></span><br><span class="line"><span class="comment">//输出：[3, 2, 1, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.toString(deepArray)); <span class="comment">//[[I@1540e19d, [I@677327b6]</span></span><br><span class="line">out.println(Arrays.deepToString(deepArray)); <span class="comment">//[[1, 3], [2, 4]]</span></span><br><span class="line"><span class="comment">//对于多维数组，需要使用deepToString</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.equals(); &#x2F;&#x2F;比较数组元素是否相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] deepArray2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.equals(deepArray1, deepArray2)); <span class="comment">//false</span></span><br><span class="line">out.println(Arrays.deepEquals(deepArray1, deepArray2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对多维数组，同样要用deepEquals</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.binarySearch(); &#x2F;&#x2F;二分查找法找指定元素的索引值（下标）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.binarySearch(arr, <span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （下标索引值从0开始）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">36</span>)</span><br><span class="line"><span class="comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">40</span>)</span><br><span class="line"><span class="comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.copeOf() 和Arrays.copeOfRange(); &#x2F;&#x2F;截取数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[10, 20, 30] （截取arr数组的3个元素赋值给新数组arr1）</span></span><br><span class="line"><span class="type">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span></span><br></pre></td></tr></table></figure><p> <strong>对数组元素采用指定的方法计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelPrefix(array, (x,y)-&gt;(x+y)); <span class="comment">//[3, 13, 17, 17, 19]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelSetAll(array, (x)-&gt;(x*x)); <span class="comment">//[0, 1, 4, 9, 16]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">Arrays.setAll(array, (x)-&gt;(x%<span class="number">3</span>));</span><br><span class="line">out.println(Arrays.toString(array)); <span class="comment">//[0, 1, 2, 0, 1], 与parallelSetAll相比只是不并行</span></span><br></pre></td></tr></table></figure><p><strong>自定义排序规则</strong></p><p><code>Arrays.sort</code>方法和<code>Collections.sort</code>方法都提供了一个可以接收<code>Comparator</code>实例作为第二个参数的版本。</p><p>像Comparator、Runable等这&#x3D;一些接口有一个特点就是只有一个抽象方法（其他的都是static或者default的方法），比如继承Comparator接口只需要重写compare方法，继承Runnable接口只需要重写run方法，这种类型的接口被称为函数式接口，可以被lambda表达式所代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line">Arrays.sort(names, comp);</span><br></pre></td></tr></table></figure><p>或者更简单些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p><strong>add()</strong></p><p>将元素插入指定位置的动态数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.add（<span class="type">int</span> index，E element）</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure><p><strong>insert(itn index, object value)</strong></p><p>将元素插入到索引处(不过其有一定的限制性,必须在数组长度以内插入数组)</p><p><strong>addAll()</strong></p><p>将给定集合中的所有元素添加到 arraylist 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.addAll(<span class="type">int</span> index, Collection c)</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure><p><strong>clear()</strong></p><p>用于删除动态数组中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clear()</span><br></pre></td></tr></table></figure><p><strong>clone()</strong></p><p>用于拷贝一份动态数组，属于浅拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clone()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：sites为已设置好的数组，使用clone将其拷贝给clonesites;</span></span><br><span class="line">ArrayList&lt;String&gt; cloneSites = (ArrayList&lt;String&gt;)sites.clone();</span><br></pre></td></tr></table></figure><p><strong>拓展：</strong></p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存， 所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p><p>浅拷贝对应的就是深拷贝，深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p><p><strong>contains()</strong></p><p>判断元素是否在动态数组中。</p><p>存在于动态数组中，则返回 true。</p><p>不存在于动态数组中，则返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.contains(Object obj)</span><br></pre></td></tr></table></figure><p><strong>set()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.set(<span class="type">int</span> index,E element) ;</span><br><span class="line">修改指定索引处的元素，返回被修改的元素。</span><br></pre></td></tr></table></figure><p><strong>get()</strong></p><p>通过索引值获取动态数组中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.get(<span class="type">int</span> index)</span><br></pre></td></tr></table></figure><p><strong>indexOf()</strong></p><p><strong>remove()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arraylist.remove(<span class="type">int</span> index) ;</span><br><span class="line">移除此集合中指定位置上的元素。返回被删除的元素。</span><br><span class="line">arraylist.remove(Object o) ;</span><br><span class="line">删除指定的元素，返回删除是否成功    </span><br></pre></td></tr></table></figure><p><strong>size()</strong></p><p>返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p><p><strong>isEmpty()</strong></p><p><strong>subList()</strong></p><p><strong>sort()</strong></p><p><strong>toArray()</strong></p><p><strong>toString()</strong></p><p><strong>ensureCapacity()</strong></p><p><strong>lastIndexOf()</strong></p><p><strong>retainAll()</strong></p><p><strong>containAll()</strong></p><p><strong>trimToSize()</strong></p><p><strong>removeRange()</strong></p><p> <strong>replaceAll()</strong></p><p><strong>removeIf()</strong></p><p><strong>forEach()</strong></p><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p><strong>add(E e)</strong> 将指定元素添加到此列表的结尾。</p><p><strong>add(int index, E element)</strong> 在此列表中指定的位置插入指定的元素。</p><p><strong>get(int index)</strong> 返回此列表中指定位置处的元素。</p><p><strong>getFirst()</strong> 返回此列表的第一个元素。</p><p><strong>getLast</strong>() 返回此列表的最后一个元素。</p><p><strong>remove(int index)</strong> 移除此列表中指定位置处的元素。</p><p><strong>remove()</strong> 获取并移除此列表的头（第一个元素）。</p><p><strong>remove(Object o)</strong> 从此列表中移除首次出现的指定元素（如果存在）。</p><p><strong>size()</strong>   返回此列表的元素数。</p><p><strong>push(E e)：</strong>与addFirst一样，实际上它就是addFirst；</p><p><strong>pop()  :</strong> removeFirst一样，实际上它就是removeFirst；</p><p><strong>E poll()：</strong>查询并移除第一个元素；</p><p><strong>peek()  :</strong> 获取第一个元素，但是不移除；</p><p> <strong>offer(E e)：</strong>在链表尾部插入一个元素；</p><p><strong>isEmpty :</strong> 判空</p><p><strong>contains(Object o) ：</strong>是否包含</p><h3 id="Hashset类"><a href="#Hashset类" class="headerlink" title="Hashset类"></a>Hashset类</h3><h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p><strong>put(key, value) ：</strong>将键&#x2F;值 映射 存放到Map集合中（如果key重复，则会覆盖原先的value值）</p><p><strong>get(key) ：</strong>返回指定键 所映射的值，没有该key对应的值则返回null</p><p><strong>getOrDefault ( key, defaultvalue) :</strong> 当集合中有这个key时，就返回key对应的value，没有这个key的话，返回默认值；</p><p><strong>size( ) ：</strong>返回Map集合中的 key-value的组数</p><p><strong>clear( )：</strong>清空Map集合</p><p><strong>isEmpty( )：</strong>判空，集合中为空则返回true</p><p><strong>remove（key）：</strong>删除集合中键为key的数据，并返回对应的value值</p><p>getOrDefault( key, defaultValue) :  返回key对应的value值，如果没有该key值，就返回默认值defaultValue</p><p><strong>values（）：</strong>返回Map集合中所有value组成的以Collection数据类型格式数据（一般用于遍历HashMap集合中value值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">Collection&lt;Integer&gt; con = map.values();</span><br><span class="line"><span class="keyword">for</span> (Integer score : con) &#123;</span><br><span class="line">System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>keyset（）：</strong>返回Map集合中所有key组成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key作为元素转存入一个set集合。</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历HashMap集合中的key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet（）：</strong> 将Map集合每个key-value转换为一个Entry对象，并返回由所有的Entry对象组成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每一组key-value变为一个entry对象存入set集合</span></span><br><span class="line">Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : set)&#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable定义了四个构造方法。第一个是默认构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable()</span><br></pre></td></tr></table></figure><p>第二个构造函数创建指定大小的哈希表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size)</span><br></pre></td></tr></table></figure><p>第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。</p><p>填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size,float fillRatio)</span><br></pre></td></tr></table></figure><p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表。</p><p>哈希表的容量被设置为M的两倍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(Map m)</span><br></pre></td></tr></table></figure><p>Hashtable中除了从Map接口中定义的方法外，还定义了以下方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>void clear( )</strong>  将此哈希表清空，使其不包含任何键。</td></tr><tr><td align="left">2</td><td align="left"><strong>Object clone( )</strong> 创建此哈希表的浅表副本。</td></tr><tr><td align="left">3</td><td align="left"><strong>boolean contains(Object value)</strong>  测试此映射表中是否存在与指定值关联的键。</td></tr><tr><td align="left">4</td><td align="left"><strong>boolean containsKey(Object key)</strong> 测试指定对象是否为此哈希表中的键。</td></tr><tr><td align="left">5</td><td align="left"><strong>boolean containsValue(Object value)</strong> 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。</td></tr><tr><td align="left">6</td><td align="left"><strong>Enumeration elements( )</strong> 返回此哈希表中的值的枚举。</td></tr><tr><td align="left">7</td><td align="left"><strong>Object get(Object key)</strong>  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。</td></tr><tr><td align="left">8</td><td align="left"><strong>boolean isEmpty( )</strong> 测试此哈希表是否没有键映射到值。</td></tr><tr><td align="left">9</td><td align="left"><strong>Enumeration keys( )</strong>  返回此哈希表中的键的枚举。</td></tr><tr><td align="left">10</td><td align="left"><strong>Object put(Object key, Object value)</strong> 将指定 key 映射到此哈希表中的指定 value。</td></tr><tr><td align="left">11</td><td align="left"><strong>void rehash( )</strong> 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。</td></tr><tr><td align="left">12</td><td align="left"><strong>Object remove(Object key)</strong> 从哈希表中移除该键及其相应的值。</td></tr><tr><td align="left">13</td><td align="left"><strong>int size( )</strong>  返回此哈希表中的键的数量。</td></tr><tr><td align="left">14</td><td align="left"><strong>String toString( )</strong> 返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 “, “ （逗号加空格）分隔开的、括在括号中的一组条目。</td></tr></tbody></table><p>TreeMap类</p><h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><p>Properties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个<strong>字符串</strong>。</p><p>这个类的优势是可以从流中加载属性集，或者把属性集报错到流中。</p><p>除了从 Hashtable 中所定义的方法，Properties 还定义了以下方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>String getProperty(String key)</strong>  用指定的键在此属性列表中搜索属性。</td></tr><tr><td align="left">2</td><td align="left"><strong>String getProperty(String key, String defaultProperty)</strong> 用指定的键在属性列表中搜索属性。</td></tr><tr><td align="left">3</td><td align="left"><strong>void list(PrintStream streamOut)</strong>  将属性列表输出到指定的输出流。</td></tr><tr><td align="left">4</td><td align="left"><strong>void list(PrintWriter streamOut)</strong> 将属性列表输出到指定的输出流。</td></tr><tr><td align="left">5</td><td align="left"><strong>void load(InputStream streamIn) throws IOException</strong>  从输入流中读取属性列表（键和元素对）。</td></tr><tr><td align="left">6</td><td align="left"><strong>Enumeration propertyNames( )</strong> 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。</td></tr><tr><td align="left">7</td><td align="left"><strong>Object setProperty(String key, String value)</strong>  调用 Hashtable 的方法 put。</td></tr><tr><td align="left">8</td><td align="left"><strong>void store(OutputStream streamOut, String description)</strong>  以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</td></tr></tbody></table><h3 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h3><p>Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h3><h5 id="xxxValue"><a href="#xxxValue" class="headerlink" title="xxxValue()"></a>xxxValue()</h5><p>以xxx类型返回指定的数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxValue()</span><br><span class="line">byteValue()  <span class="comment">//以byte类型返回指定的数值</span></span><br><span class="line"><span class="comment">//有byte,double,float,int,long,short</span></span><br><span class="line"><span class="comment">//此函数不接受参数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 返回 byte 原生数据类型</span></span><br><span class="line">      System.out.println( x.doubleValue() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：5.0</span><br></pre></td></tr></table></figure><h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h5><p>用于两个相同数据类型的比较；</p><p>两个不同类型的数据不能用此方法来比较。</p><ul><li>如果指定的数与参数<strong>相等返回0</strong>。</li><li>如果指定的数<strong>小于</strong>参数<strong>返回 -1</strong>。</li><li>如果指定的数<strong>大于</strong>参数<strong>返回 1</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(referenceName)</span></span><br><span class="line"><span class="comment">//referenceName -- 可以是一个 Byte, Double, Integer, Float, Long 或 Short 类型的参数。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Interger</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(x.compareTo(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：1</span><br></pre></td></tr></table></figure><h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>判断 Number 对象与方法的参数是否相等（类型和数值）</p><ul><li>如果Number 对象不为 Null，且与方法的参数类型与数值都相等返回 True，否则返回 False。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object x)</span> <span class="comment">//x为任何对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(x.equals(y));</span><br><span class="line">        System.out.println(x.equals(z));</span><br><span class="line">        System.out.println(x.equals(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回给定参数的原生 Number 对象值，</p><p>参数可以是原生数据类型，如String等。</p><p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> Double.valueOf(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Float</span> <span class="variable">a</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;444&quot;</span>, <span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">80.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>返回以一个字符串表示的 Number 对象值。</p><p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串参数作为有符号的十进制整数进行解析。</p><p>如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span>Integer.parseInt(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure><h3 id="Math数学类"><a href="#Math数学类" class="headerlink" title="Math数学类"></a>Math数学类</h3><p>在源文件顶部加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>Math类</p><h4 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h4><p>返回参数的<strong>绝对值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line">                        </span><br><span class="line">        System.out.println(Math.abs(a));</span><br><span class="line">        System.out.println(Math.abs(d));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure><h4 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h4><p>返回参数的算术平方根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;sqrt(%.3f) 为 %.3f%n&quot;</span>, x, Math.sqrt(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt(<span class="number">11.635</span>) 为 <span class="number">3.411</span></span><br></pre></td></tr></table></figure><h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>返回一个最接近的int ,long型值，”<strong>四舍五入</strong>“，算法为**Math.floor(x+0.5)**；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        System.out.println(Math.round(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h4 id="min-和max"><a href="#min-和max" class="headerlink" title="min()和max()"></a>min()和max()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Math.min(<span class="number">12</span>,<span class="number">30</span>)); </span><br><span class="line">        System.out.println(Math.max(<span class="number">12</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h4><p>返回一个随机数，随机数范围为 0.0 &lt;&#x3D; x &lt; 1.0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println( Math.random() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5444085967267008</span><br></pre></td></tr></table></figure><h4 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h4><p>返回第一个参数的第二个参数次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2.76</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;pow(%.3f, %.3f) 为 %.3f%n&quot;</span>, x, y, Math.pow(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(11.635, 2.760) 为 874.008</span><br></pre></td></tr></table></figure><h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><p>返回自然数底数e的参数次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;exp(%.3f) 为 %.3f%n&quot;</span>, x, Math.exp(x));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">exp(<span class="number">11.635</span>) 为 <span class="number">112983.831</span></span><br></pre></td></tr></table></figure><h4 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h4><p>返回参数的自然数底数的对数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;log(%.3f) 为 %.3f%n&quot;</span>, x, Math.log(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">log(<span class="number">11.635</span>) 为 <span class="number">2.454</span></span><br></pre></td></tr></table></figure><h4 id="rint"><a href="#rint" class="headerlink" title="rint()"></a>rint()</h4><p>返回最接近参数的整数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">100.500</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">100.200</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.rint(d));</span><br><span class="line">        System.out.println(Math.rint(e)); </span><br><span class="line">        System.out.println(Math.rint(f)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101.0</span><br><span class="line">100.0</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure><h4 id="floor-x2F-ceil"><a href="#floor-x2F-ceil" class="headerlink" title="floor()&#x2F;ceil()"></a>floor()&#x2F;ceil()</h4><p>floor()：对一个数进行下舍入，返回给定参数最大的整数，该整数小于或等给定的参数。</p><p>ceil()：对一个数进行上舍入，返回值大于或等于给定的参数，类型为双精度浮点型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> -<span class="number">90</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.floor(d));</span><br><span class="line">        System.out.println(Math.floor(f));</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.ceil(d));</span><br><span class="line">        System.out.println(Math.ceil(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><p><strong>枚举</strong></p><table><thead><tr><th>1</th><th><strong>boolean hasMoreElements( )</strong></th><th>测试此枚举是否包含更多的元素。</th></tr></thead><tbody><tr><td>2</td><td><strong>Object nextElement( )</strong></td><td>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td></tr></tbody></table><h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：</p><ul><li>Vector 是同步访问的。</li><li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li></ul><p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p><p>Vector 类支持 <strong>4 种构造方法</strong>。</p><p>第一种构造方法创建一个默认的向量，默认大小为 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector()</span><br></pre></td></tr></table></figure><p>第二种构造方法创建指定大小的向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size)</span><br></pre></td></tr></table></figure><p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size,int incr)</span><br></pre></td></tr></table></figure><p>第四种构造方法创建一个包含集合 c 元素的向量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(Collection c)</span><br></pre></td></tr></table></figure><p>Vector还拥有以下方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void add(int index, Object element)   在此向量的指定位置插入指定的元素。</td></tr><tr><td align="left">2</td><td align="left">boolean add(Object o)   将指定元素添加到此向量的末尾。</td></tr><tr><td align="left">3</td><td align="left">boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。</td></tr><tr><td align="left">4</td><td align="left">boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。</td></tr><tr><td align="left">5</td><td align="left">void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。</td></tr><tr><td align="left">6</td><td align="left">int capacity()  返回此向量的当前容量。</td></tr><tr><td align="left">7</td><td align="left">void clear()  从此向量中移除所有元素。</td></tr><tr><td align="left">8</td><td align="left">Object clone()  返回向量的一个副本。</td></tr><tr><td align="left">9</td><td align="left">boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。</td></tr><tr><td align="left">10</td><td align="left">boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。</td></tr><tr><td align="left">11</td><td align="left">void copyInto(Object[] anArray)   将此向量的组件复制到指定的数组中。</td></tr><tr><td align="left">12</td><td align="left">Object elementAt(int index)  返回指定索引处的组件。</td></tr><tr><td align="left">13</td><td align="left">Enumeration elements()  返回此向量的组件的枚举。</td></tr><tr><td align="left">14</td><td align="left">void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。</td></tr><tr><td align="left">15</td><td align="left">boolean equals(Object o)  比较指定对象与此向量的相等性。</td></tr><tr><td align="left">16</td><td align="left">Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。</td></tr><tr><td align="left">17</td><td align="left">Object get(int index)  返回向量中指定位置的元素。</td></tr><tr><td align="left">18</td><td align="left">int hashCode()  返回此向量的哈希码值。</td></tr><tr><td align="left">19</td><td align="left">int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。</td></tr><tr><td align="left">20</td><td align="left">int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。</td></tr><tr><td align="left">21</td><td align="left">void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。</td></tr><tr><td align="left">22</td><td align="left">boolean isEmpty()  测试此向量是否不包含组件。</td></tr><tr><td align="left">23</td><td align="left">Object lastElement()  返回此向量的最后一个组件。</td></tr><tr><td align="left">24</td><td align="left">int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。</td></tr><tr><td align="left">25</td><td align="left">int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。</td></tr><tr><td align="left">26</td><td align="left">Object remove(int index)   移除此向量中指定位置的元素。</td></tr><tr><td align="left">27</td><td align="left">boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。</td></tr><tr><td align="left">28</td><td align="left">boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。</td></tr><tr><td align="left">29</td><td align="left">void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。</td></tr><tr><td align="left">30</td><td align="left">boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。</td></tr><tr><td align="left">31</td><td align="left">void removeElementAt(int index)  删除指定索引处的组件。</td></tr><tr><td align="left">32</td><td align="left">protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。</td></tr><tr><td align="left">33</td><td align="left">boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。</td></tr><tr><td align="left">34</td><td align="left">Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。</td></tr><tr><td align="left">35</td><td align="left">void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。</td></tr><tr><td align="left">36</td><td align="left">void setSize(int newSize)   设置此向量的大小。</td></tr><tr><td align="left">37</td><td align="left">int size()   返回此向量中的组件数。</td></tr><tr><td align="left">38</td><td align="left">List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。</td></tr><tr><td align="left">39</td><td align="left">Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。</td></tr><tr><td align="left">40</td><td align="left">Object[] toArray(Object[] a)  返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。</td></tr><tr><td align="left">41</td><td align="left">String toString()  返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。</td></tr><tr><td align="left">42</td><td align="left">void trimToSize()   对此向量的容量进行微调，使其等于向量的当前大小。</td></tr></tbody></table><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// initial size is 3, increment is 2</span></span><br><span class="line">      <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial size: &quot;</span> + v.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Capacity after four additions: &quot;</span> +</span><br><span class="line">          v.capacity());</span><br><span class="line"></span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">5.45</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">6.08</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">7</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">9.4</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First element: &quot;</span> +</span><br><span class="line">         (Integer)v.firstElement());</span><br><span class="line">      System.out.println(<span class="string">&quot;Last element: &quot;</span> +</span><br><span class="line">         (Integer)v.lastElement());</span><br><span class="line">      <span class="keyword">if</span>(v.contains(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)))</span><br><span class="line">         System.out.println(<span class="string">&quot;Vector contains 3.&quot;</span>);</span><br><span class="line">      <span class="comment">// enumerate the elements in the vector.</span></span><br><span class="line">      <span class="type">Enumeration</span> <span class="variable">vEnum</span> <span class="operator">=</span> v.elements();</span><br><span class="line">      System.out.println(<span class="string">&quot;\nElements in vector:&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(vEnum.hasMoreElements())</span><br><span class="line">         System.out.print(vEnum.nextElement() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial size: <span class="number">0</span></span><br><span class="line">Initial capacity: <span class="number">3</span></span><br><span class="line">Capacity after four additions: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">7</span></span><br><span class="line">Current capacity: <span class="number">9</span></span><br><span class="line">First element: <span class="number">1</span></span><br><span class="line">Last element: <span class="number">12</span></span><br><span class="line">Vector contains <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Elements in vector:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5.45</span> <span class="number">6.08</span> <span class="number">7</span> <span class="number">9.4</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="Bitset类"><a href="#Bitset类" class="headerlink" title="Bitset类"></a>Bitset类</h3><p>Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。</p><p>BitSet定义了两个构造方法。</p><p>第一个构造方法创建一个默认的对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet()</span><br></pre></td></tr></table></figure><p>第二个方法允许用户指定初始大小。所有位初始化为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet(int size)</span><br></pre></td></tr></table></figure><p>BitSet中实现了Cloneable接口中定义的方法如下表所列：</p><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void and(BitSet set) 对此目标位 set 和参数位 set 执行逻辑与操作。</td></tr><tr><td align="left">2</td><td align="left">void andNot(BitSet set) 清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。</td></tr><tr><td align="left">3</td><td align="left">int cardinality( ) 返回此 BitSet 中设置为 true 的位数。</td></tr><tr><td align="left">4</td><td align="left">void clear( ) 将此 BitSet 中的所有位设置为 false。</td></tr><tr><td align="left">5</td><td align="left">void clear(int index) 将索引指定处的位设置为 false。</td></tr><tr><td align="left">6</td><td align="left">void clear(int startIndex, int endIndex) 将指定的 startIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。</td></tr><tr><td align="left">7</td><td align="left">Object clone( ) 复制此 BitSet，生成一个与之相等的新 BitSet。</td></tr><tr><td align="left">8</td><td align="left">boolean equals(Object bitSet) 将此对象与指定的对象进行比较。</td></tr><tr><td align="left">9</td><td align="left">void flip(int index) 将指定索引处的位设置为其当前值的补码。</td></tr><tr><td align="left">10</td><td align="left">void flip(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。</td></tr><tr><td align="left">11</td><td align="left">boolean get(int index) 返回指定索引处的位值。</td></tr><tr><td align="left">12</td><td align="left">BitSet get(int startIndex, int endIndex) 返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。</td></tr><tr><td align="left">13</td><td align="left">int hashCode( ) 返回此位 set 的哈希码值。</td></tr><tr><td align="left">14</td><td align="left">boolean intersects(BitSet bitSet) 如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true。</td></tr><tr><td align="left">15</td><td align="left">boolean isEmpty( ) 如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。</td></tr><tr><td align="left">16</td><td align="left">int length( ) 返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1。</td></tr><tr><td align="left">17</td><td align="left">int nextClearBit(int startIndex) 返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。</td></tr><tr><td align="left">18</td><td align="left">int nextSetBit(int startIndex) 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。</td></tr><tr><td align="left">19</td><td align="left">void or(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑或操作。</td></tr><tr><td align="left">20</td><td align="left">void set(int index) 将指定索引处的位设置为 true。</td></tr><tr><td align="left">21</td><td align="left">void set(int index, boolean v)  将指定索引处的位设置为指定的值。</td></tr><tr><td align="left">22</td><td align="left">void set(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。</td></tr><tr><td align="left">23</td><td align="left">void set(int startIndex, int endIndex, boolean v) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。</td></tr><tr><td align="left">24</td><td align="left">int size( ) 返回此 BitSet 表示位值时实际使用空间的位数。</td></tr><tr><td align="left">25</td><td align="left">String toString( ) 返回此位 set 的字符串表示形式。</td></tr><tr><td align="left">26</td><td align="left">void xor(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑异或操作。</td></tr></tbody></table><h3 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map 接口中键和值一一映射. 可以通过键来获取值。</p><ul><li>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</li><li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void clear( )  从此映射中移除所有映射关系（可选操作）。</td></tr><tr><td align="left">2</td><td align="left">boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td></tr><tr><td align="left">3</td><td align="left">boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td></tr><tr><td align="left">4</td><td align="left">Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td align="left">5</td><td align="left">boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td></tr><tr><td align="left">6</td><td align="left">Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td align="left">7</td><td align="left">int hashCode( ) 返回此映射的哈希码值。</td></tr><tr><td align="left">8</td><td align="left">boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td align="left">9</td><td align="left">Set keySet( ) 返回此映射中包含的键的 Set 视图。</td></tr><tr><td align="left">10</td><td align="left">Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td align="left">11</td><td align="left">void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td></tr><tr><td align="left">12</td><td align="left">Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td></tr><tr><td align="left">13</td><td align="left">int size( ) 返回此映射中的键-值映射关系数。</td></tr><tr><td align="left">14</td><td align="left">Collection values( ) 返回此映射中包含的值的 Collection 视图。</td></tr></tbody></table><h3 id="system类"><a href="#system类" class="headerlink" title="system类"></a>system类</h3><p><strong>exit  退出当前程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">//表示程序退出，0表示一个正常的状态</span></span><br></pre></td></tr></table></figure><p><strong>arraycopy ：复制数组元素</strong>，比较适合底层调用，一般使用Arrays.copyOf 完成复制数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line"><span class="comment">//src: 源数组</span></span><br><span class="line"><span class="comment">//srcPos: 从源数组的哪个索引开始拷贝</span></span><br><span class="line"><span class="comment">//dest: 目标数组</span></span><br><span class="line"><span class="comment">//destPos：源数组的数据拷贝到目标数组的哪个索引处</span></span><br><span class="line"><span class="comment">//length： 从源数组拷贝多少数据</span></span><br></pre></td></tr></table></figure><p><strong>currentTimeMillens ： 返回当前时间距离1970-1-1的毫秒数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillens();</span><br></pre></td></tr></table></figure><p><strong>gc：运行垃圾回收机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure><h3 id="大数类型"><a href="#大数类型" class="headerlink" title="大数类型"></a>大数类型</h3><p><strong>BigInteger类：适合保存比较大的整型</strong></p><p><strong>BigDecimal类：适合保存进度更高的浮点型（小数）</strong></p><p>方法（算术）：</p><p>add  加</p><p>subtract   减</p><p>multiply    乘</p><p>divide    除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigInter.add(bigInteger2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigInter.subtract(bigInteger2); <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigInter.multiply(bigInteger2); <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigInter.divide(bigInteger2); <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100.11&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigDecimal.add(bigDecimal2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigDecimal.subtract(bigDecimal2); <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigDecimal.multiply(bigDecimal2); <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING); <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"><span class="comment">//因为除法可能会出现除不尽的情况，所以调用divide方法时，可以指定精度（在参数列表加上BigDecimal.ROUND_CEILING，如果出现无限循环小数，就会保留分子的进度）</span></span><br></pre></td></tr></table></figure><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>第三代日期类（jdk8加入）</p><p>LocalDate（日期&#x2F;年月日）</p><p>LocalTime（时间&#x2F;时分秒）</p><p>LocalDateTime（时间&#x2F;年月日时分秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"><span class="comment">//输出：2021-10-03T16:20:05.137</span></span><br></pre></td></tr></table></figure><p>使用DateTimeFormatter对象来进行格式化（ofPattern方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期 = &quot;</span> + format);</span><br><span class="line"><span class="comment">//输出：格式化的日期 = 2021-10-03 16:22:05</span></span><br></pre></td></tr></table></figure><p>日期类还有plus增加时间的某个部分，minus查看一年前和一年后的日期 …等等（具体看API文档）</p>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java—SSM&amp;Maven</title>
      <link href="/Notes/2022/04/14/Java%E2%80%94SSM&amp;Maven/"/>
      <url>/Notes/2022/04/14/Java%E2%80%94SSM&amp;Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven 是专门用于<strong>管理和构建java项目的工具</strong>，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构；</p></li><li><p>提供了一套标准化的构建流程 (编译，测试，打包，发布…)；</p></li><li><p>提供了一套依赖管理机制（指jar包，插件）；</p></li></ul><h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><p>多个场景的模块代码如果放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动；而且，各个模块可以单独维护，更方便团队协作。</p><p>例子：将SSM的各层分成各个模块</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205141022803.png" alt="image-20220514102205532" style="zoom:50%;" /><p>步骤：</p><ol><li><p>创建新模块，将对应代码拷贝进去，删除原代码；</p></li><li><p>删除domain包后项目会报红，需要在<code>maven_ssm</code>的pom.xml 中添加<code>maven_03_pojo</code>的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于项目<code>maven_pojo</code>存在于IDEA，而Maven在本地仓库是找不到对应的jar包的，所以还要将<code>maven_pojo</code>安装到本地仓库中：</p><p>（使用maven的install命令，安装完后可以在Maven的本地仓库repository中对应的项目中查看jar包）</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205141022468.png" alt="image-20220514102250294" style="zoom:50%;" /><p>同理，其他模块也是同样的操作：代码转移、添加依赖（安装项目jar包）</p></li></ol><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="lt-dependency-gt"><a href="#lt-dependency-gt" class="headerlink" title="&lt;dependency&gt;"></a>&lt;dependency&gt;</h3><blockquote><p>jar包查找顺序：本地仓库——远程仓库——中央仓库</p><p>远程仓库（私服）：一般由公司团队搭建的私有仓库。</p></blockquote><p>使用坐标导入jar包：</p><ol><li>在 pom.xml 中编写 &lt; dependencies &gt; 标签；</li><li>在&lt; dependencies &gt;标签中使用&lt; dependency &gt;引入坐标；</li><li>定义坐标的 groupld, artifactld, version；</li></ol><p><u>资源直接网上搜索：资源名 maven，如 mysql maven，然后会出现maven repository的网页，点进去复制坐标即可。</u></p><blockquote><p>Maven坐标：是资源的唯一标识，使用坐标来定义项目或引入项目中需要的依赖。</p><p>坐标组成：</p><ul><li>groupld：定义当前Maven项目隶属组织的名称（通常是域名反写，如：com.zzc）</li><li>artifactld：定义当前Maven项目名称（通常是模块名称，如：order-service，goods-service）</li><li>version：定义当前项目的版本号</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>通过设置坐标的依赖范围(scope),可以设置对应ja包的作用范围：编译环境、测试环境、运行环境</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707938.png" alt="image-20220224164841772"></p><table><thead><tr><th>依赖范围</th><th>编译</th><th>测试</th><th>运行</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td></td><td>servlet-api</td></tr><tr><td>runtime</td><td></td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td></td><td>存储在本地的jar包</td></tr><tr><td>import</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li><p><strong>依赖传递</strong></p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205141033631.png" alt="image-20220514103345400" style="zoom: 33%;" /><p>上图所示：A依赖了B和C，B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递。</p><p><strong>依赖冲突</strong>：项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><ul><li>Maven的默认管理：<ul><li>特殊优先：一个配置页中 配置了相同资源的不同版本，后配置的覆盖先配置的。</li><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高（先出现的就选择）</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。如图中的D1和D2，层级相同，就看谁先声明。</li></ul></li></ul></li><li><p><strong>可选依赖</strong></p><p>可选依赖 指对外隐藏当前所依赖的资源——不透明，别人不需要；隐藏后将不会有依赖传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除依赖</strong></p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本——自己不需要；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="聚合、继承"><a href="#聚合、继承" class="headerlink" title="聚合、继承"></a>聚合、继承</h2><p>问题：分模块开发后，各模块相互依赖，可能要多次安装、编译。</p><p>对此，我们可以抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，其他所有的项目都走一样的流程，这就很省事省力。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul><li>概念：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>步骤：</p><ol><li><p>新建一个空的Maven工程<code>maven_01_parent</code>，将项目的打包方式改为pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>项目的打包方式，一般有三种，分别是</p><ul><li>jar：默认情况，说明该项目为java项目</li><li>war：说明该项目为web项目</li><li>pom：说明该项目为聚合或继承项目</li></ul></blockquote></li><li><p>添加要管理的项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击 compile 命令就可以让被管理的项目都会被执行编译操作。这就是聚合工程的作用。</p><blockquote><p>注：聚合工程管理的项目在进行运行的时候，执行的顺序是 按照项目与项目之间的依赖关系来自动决定的。</p></blockquote></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>问题：多个模块中会出现重复配置的问题，同一个jar包或其不同版本 在不同模块中引入，最后汇集到一起。</p><ul><li><p>概念：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p><blockquote><p><strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong></p></blockquote></li><li><p>作用：</p><ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>步骤：</p><ol><li><p>新建一个空的Maven工程<code>maven_01_parent</code>，将项目的打包方式改为pom（一般和聚合放在同一个工程，不冲突）</p></li><li><p>在子项目中设置它的父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置父项目pom.xml位置路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优化子项目共有依赖的导入问题：</p><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中；</p><p>然后删除子项目中已经抽取到父项目的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优化</p><p>可能有的子项目并不需要 父项目的jar包，如果引入过多的jar包，也会有“负担”；</p><p>使用<code>&lt;dependencyManagement&gt;</code>，它不真正引入jar包，而是配置可供子项目选择的jar包依赖。<br>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定版本<code>&lt;version&gt;</code></p><p>如：父项目中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子项目中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不需要添加版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205141121299.png" alt="image-20220514112158055" style="zoom:50%;" /><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>Maven中的自定义属性和变量类似，可以方便修改；</p><p>如：定义spring版本号 spring.version &#x3D; “5.2.10.RELEASE“， junit.version &#x3D; “4.12”等等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改依赖的version</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h3><p>。。。。。。。。</p><p>。。。。。。。。</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>在jar包的版本定义中，有两个工程版本用的比较多:</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本:</p><ul><li>alpha版:内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能</li><li>纯数字版</li></ul><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><h3 id="多环境配置-1"><a href="#多环境配置-1" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>一般项目分为若干环境，有：</p><ul><li>生产环境produce，</li><li>开发环境develop，</li><li>测试环境test，</li></ul><p>平时开发工作是在 开发环境develop进行的；开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用；等测试人员测试通过后，会将项目部署到生成环境上线使用。</p><p>这个时候就有一个问题是，不同环境的配置是不相同的，所以会有三个数据库的url配置，需要能在不同环境进行切换：</p><p><strong>父工程配置多个环境，并指定默认激活环境</strong>，配置完记得 install</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>切换不同环境： 执行Maven命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID[环境定义中获取]</span><br><span class="line"></span><br><span class="line">//如: mvn install -P env_test    切换到测试环境</span><br></pre></td></tr></table></figure><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，但有些时候我们需要跳过test：</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>方法一：点击Maven工具里的小闪电按钮，关闭测试。</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205141133545.png" alt="image-20220514113356322" style="zoom:33%;" /><p>方法二：配置插件</p><ul><li><p>skipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试</p></li><li><p>excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的</p></li><li><p>includes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除掉不参与测试的内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/BookServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><p>Spring是一个分层的 Java SE&#x2F;EE应用的 full-stack 轻量级的控制反转（IOC，Inverse Of Control）和面向切面编程（AOP，Aspect Oriented Programming）的框架.</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>IoC：<strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。</strong></p><ul><li><p>也就是说，使用对象时，在程序中不要主动使用new产生对象，将<code>对象创建控制权</code>由程序<code>转移到外部</code>，这就是<u>控制反转</u>；</p></li><li><p>Spring对IoC思想的思想：</p><ul><li><p>提供了IoC容器，充当“外部”：</p><p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在Ioc容器中统称为 <code>Bean</code>。</p></li><li><p>提供DI（Dependency Injection）依赖注入：</p><p>在容器中建立bean与bean之间的依赖关系，就是依赖注入；</p></li></ul></li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li><p>Core Container：核心容器</p></li><li><p>AOP：面向切面编程； </p><p>Aspects：AOP思想实现</p></li><li><p>Data Access：数据访问</p><p>Data Integration：数据集成</p><ul><li>Transactions：事务</li></ul></li><li><p>Web：Web开发（SpringMVC内容）</p></li><li><p>Test：单元测试、集成测试</p></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204251201927.png" alt="image-20220425120157613"></p><blockquote><p>拓展：</p><ul><li>SpringBoot<ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速的开发单个微服务</li><li>约定大于配置</li></ul></li><li>SpringCloud<ul><li>基于SpringBoot实现的</li></ul></li></ul><p>多数公司在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC，承上启下！</p><p><strong>spring弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，容易出错，人称“配置地狱”，所以有了springboot，其更简单，更稳定健壮，功能更丰富。</strong></p></blockquote><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><blockquote><p>IoC思路：</p><ul><li>管理什么？ —— Service 与 Dao</li><li>被管理的对象如何告知IoC容器？ —— 配置</li><li>如何获得IoC容器？ ——  接口</li><li>如何从容器中获取bean？ —— 接口方法</li></ul></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204251213944.png" alt="image-20220425121331702"></p><ol><li><p>导入Spring开发的基本包坐标；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Dao接口和实现类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzc.dao.impl;</span><br><span class="line"><span class="keyword">import</span> com.zzc.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring核心配置文件；</p><p>在resources中新建spring config配置文件，一般命名为applicationContext.xml</p></li><li><p>在Spring配置文件中配置UserDaolmpl；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;useDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用Spring的API获得Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">useDao</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;useDao&quot;</span>);</span><br><span class="line">        useDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><h3 id="引入其他配置文件"><a href="#引入其他配置文件" class="headerlink" title="引入其他配置文件"></a>引入其他配置文件</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他 配置文件中，而在Spring主配置文件通过import标签进行加载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean标签"><a href="#Bean标签" class="headerlink" title="Bean标签"></a>Bean标签</h3><ul><li>用于配置对象交由Spring来创建；</li><li>默认情况下它调用的是类中的无参构造函数，如果没有则会创建失败。（反射）</li></ul><p>属性：</p><ul><li><p>id：Bean实例在Spring容器中的唯一标识</p></li><li><p>name：可以定义bean的别名，通过id和name都可以获取bean对象</p></li><li><p>class：Bean的全限定名称（全包名）</p></li><li><p>scope：指定对象的作用范围</p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td><u>singleton</u></td><td><u>默认值，单例的</u></td></tr><tr><td><u>prototype</u></td><td><u>多例的</u></td></tr><tr><td>request</td><td>web项目中，spring创建一个Bean对象，将对象存入request域中</td></tr><tr><td>session</td><td>web项目中，spring创建一个Bean对象，将对象存入session域中</td></tr><tr><td>global session</td><td>web项目中，应用在Portlet环境，如果没有Portlet环境，那么global session相当于session</td></tr></tbody></table><blockquote><p>Bean生命周期：</p><p>scope&#x3D;”singleton”时，Bean对象在Spring核心配置文件读取时 实例化，即获取applicationContext对象时；</p><ul><li>生命周期：应用加载，容器创建时，对象就被创建了，只要容器在，对象就一直存在；<br>当应用卸载，容器销毁时，对象也跟着销毁；</li></ul><p>scope&#x3D;”prototype”时，Bean对象在配置文件读取时不会实例化，而是在获取Bean对象时才实例化，即使用 getBean() 方法时；</p><ul><li>生命周期：当使用对象时，创建新的对象实例， 当对象长时间不使用时，被java垃圾回收器回收。</li></ul><p>关闭容器（实际应用中不用自己写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">app.registerShutdownHook(); <span class="comment">//方法一: 注册钩子关闭容器(放在哪都可以)</span></span><br><span class="line">app.close();   <span class="comment">//方法二: 直接关闭容器</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>init-method：指定类中的初始化方法名称</p></li><li><p>destory-menthod：指定类中销毁方法名称</p><blockquote><p>如果不想写上面的初始化或销毁的属性，可以直接让 类实现InitializingBean和DisposableBean ，这样Spring就会识别。</p></blockquote></li><li><p>autowire：自动装配（按指定的规则，如按类型，名称等自动装配）</p><blockquote><p>注：</p><p>只能用于引用类型注入，不能对简单类型进行操作；</p><p>使用按类型装配（byType）必须保障容器中相同类型的bean唯一，推荐使用；</p><p>使用按类型装配（byName）必须保障容器中有指定名称的bean，因变量名与配置耦合，不推荐使用；</p><p>自动装配优先级低于setter和构造器注入；</p></blockquote></li></ul><h3 id="Bean实例化的三种方式"><a href="#Bean实例化的三种方式" class="headerlink" title="Bean实例化的三种方式"></a>Bean实例化的三种方式</h3><ul><li><p>无参构造方法（就是上面用的，最常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;useDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactoryBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.StaticFactoryBean&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactoryBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.DynamicFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring提供了 FactoryBean 来简化工厂开发：</p><ol><li><p>创建一个实现FactoryBean接口，重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//得到bean实例，代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到bean类型，返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否是单例的，返回true为单例，false为多例的</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入 Dependency Injection：它是 Spring 框架核心 IOC 的具体实现。 </p><p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。<br>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p><blockquote><p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>例：将 UserDao 注入道 UserService 内部，有两种方式：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204261813763.png" alt="image-20220426181345650"></p><p>都是要有一个UserDao成员变量，用构造方法或set方法将UserDao实例引入， 其配置文件的书写格式不一样；</p><ul><li><p><strong>构造器方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里的name是形参的名字，不是成员变量的名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>setter方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name是userService中的成员属性的名字，ref表示参照具体哪一个Bean  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注： property 中的 <strong>name 的值为 set方法（setUserDao）的 ”set“后的字符串，且首字母小写</strong>。 ref 的值为要注入的Bean的 id，value为简单类型注入的值，如字符数字等；</p><blockquote><p>还可以使用p命名空间注入，其本质也是set方法注入，当要写很多注入时会比set方法注入的配置文件方面要方便；</p><ol><li><p>先引入P命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改注入方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>有三种，下面用set方式展示注入：</p><ul><li><p>普通数据类型 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量username(String)和age(Integer) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李华&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userService中有成员变量 useDao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>集合数据类型</p><p>数组 int[] array</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>111<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>222<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>333<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>List&lt; String &gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 strList&lt;String&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>List&lt; User &gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 userList&lt;User&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Map&lt;Stirng, User&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 userMap&lt;Stirng, User&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 Properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;标签</span><br><span class="line">    id属性:在容器中Bean实例的唯一标识，不允许重复</span><br><span class="line">    class属性:要实例化的Bean的全限定名</span><br><span class="line">    scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</span><br><span class="line">    &lt;property&gt;标签：属性注入</span><br><span class="line">        name属性：属性名称</span><br><span class="line">        value属性：注入的普通属性值</span><br><span class="line">        ref属性：注入的对象引用值</span><br><span class="line">        &lt;list&gt;标签</span><br><span class="line">        &lt;map&gt;标签</span><br><span class="line">        &lt;properties&gt;标签</span><br><span class="line">    &lt;constructor-arg&gt;标签</span><br><span class="line">    </span><br><span class="line">&lt;import&gt;标签:导入其他的Spring的分文件</span><br></pre></td></tr></table></figure><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>ApplicationContext的实现类 </p><ul><li><p>ClassPathXmlApplicationContext </p><p>它是从类的根路径下加载配置文件 推荐使用这种 </p></li><li><p>FileSystemXmlApplicationContext </p><p>它是从磁盘的绝对路径上加载配置文件，配置文件可以在磁盘的任意位置。 </p></li><li><p>AnnotationConfigApplicationContext </p><p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p></li></ul><p>getBean的使用</p><ul><li>getBean(“id”)   根据id获取Bean实例</li><li>getBean(class)    根据类的Class类型获取Bean实例，如 getBean(UsrService.class) </li><li>getBean(“id”，class)     根据id并指定类型获取bean实例，不用强转</li></ul><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据源（链接池）的作用：</p><ul><li><p>数据源(连接池)是提高程序性能如出现的 ；</p></li><li><p>事先实例化数据源，初始化部分连接资源 ；</p></li><li><p>使用连接资源时从数据源中获取 ；</p></li><li><p>使用完毕后将连接资源归还给数据源 ；</p><blockquote><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p></blockquote></li></ul><p>数据源的开发步骤：</p><ol><li>导入数据源的坐标和数据库驱动坐标 ；</li><li>创建数据源对象 ；</li><li>设置数据源的基本连接数据 ；</li><li>使用数据源获取连接资源和归还连接资源；</li></ol><h3 id="手动配置数据源"><a href="#手动配置数据源" class="headerlink" title="手动配置数据源"></a>手动配置数据源</h3><p>jdbc.properties文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/stu7</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">zzc</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dataSourceTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>));</span><br><span class="line">        dataSource.setUrl(rb.getString(<span class="string">&quot;jdbc.url&quot;</span>));</span><br><span class="line">        dataSource.setUsername(rb.getString(<span class="string">&quot;jdbc.username&quot;</span>));</span><br><span class="line">        dataSource.setPassword(rb.getString(<span class="string">&quot;jdbc.password&quot;</span>));</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring配置数据源-XML"><a href="#Spring配置数据源-XML" class="headerlink" title="Spring配置数据源(XML)"></a>Spring配置数据源(XML)</h3><p>可以将DataSource的创建权交由Spring容器去完成 </p><ul><li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 ；</li><li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里bean的class属性，填的是数据源对象的全限定名，即 DruidDataSource 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DriverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/stu7&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽取jdbc配置文件"><a href="#抽取jdbc配置文件" class="headerlink" title="抽取jdbc配置文件"></a>抽取jdbc配置文件</h3><p>让applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p><ol><li><p>需要先引入context命名空间和约束路径</p><ul><li>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a> </li><li>约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>  <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></li></ul><blockquote><p>约束路径写在 xsi:schemaLocation&#x3D;“ ” 的双引号里面，即多个路径都写在这个双引号里面；</p></blockquote></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>具体配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DriverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据源的代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li><p>如果使用自己的properties文件有变量的名字和当前系统的环境变量冲突，会以系统的环境变量为准，如果不想要，可以加上属性 system-properties-mode&#x3D;”NEVER”，即不加载系统环境变量；</p></li><li><p>如果想加载多个properties文件，推荐写： location&#x3D;”calsspath:*properties”</p></li><li><p>前面的只能导入当前工程的properties文件，而jar包里的文件读取不了，想全部加载，可以这样写：location&#x3D;”calsspath*:*properties”</p></li></ul></blockquote><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置 文件可以简化配置，提高开发效率。</p><h4 id="原始注解"><a href="#原始注解" class="headerlink" title="原始注解"></a>原始注解</h4><p>Spring原始注解主要代替 &lt; Bean&gt; 的配置</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired 一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resourse</td><td>相当于@Autowired+@Qualifier,按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestory</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table><p><strong>注：</strong></p><p>使用注解，需要在在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean 需要进行扫描以便识别使用注解配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>@Component     @Repository      @Scope      @PostConstruct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;bean id=&quot;useDao&quot; class=&quot;com.zzc.dao.impl.UserDaoImpl&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>   <span class="comment">//多例的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化方法....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service    @Autowired    @Qualifier     @Resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;com.zzc.service.impl.UserServiceImpl&quot;&gt;</span></span><br><span class="line"><span class="comment">//    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;useDao&quot;&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">//&lt;/bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    @Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;注入普通数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>   <span class="comment">//注入变量，来自上面jdbc抽取中的数据</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(driver);</span><br><span class="line">        System.out.println(<span class="string">&quot;save running... ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h4><p>使用 <strong>Spring配置类</strong> 来替代 Spring核心配置文件xxx.xml，这样，配置就都从配置类中加载就行（配置类在写好后改动不大，大都是改properties文件）。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定Spring在初始化容器时要扫描的包。<br />替代了 Spring的xml配置文件中的&lt;context:component-scan base-package&#x3D;”com.zzc”&#x2F;&gt;</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td>@PropertySource</td><td>用于加载 .properties文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table><blockquote><p>扫描后，只需要将对应的bean作为方法的形参，容器会根据类型自动装配对象；</p></blockquote><p>使用：</p><p>@Confuguration     @ComponentScan      @Import</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//核心配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span> <span class="comment">//扫描某包下的注解</span></span><br><span class="line"><span class="meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span> <span class="comment">//导入其他配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PropertySource        @value           @Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><span class="comment">//抽取jdbc配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span><span class="comment">//将方法的返回值保存到Spring容器中，其id为&quot;dataSource&quot;</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：使用 AnnotationConfigApplicationContext (配置类.class)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line"></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        </span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h3><p>在测试类中，每个测试方法都需要获得ApplicationContext对象，然后再用getBean() 获得Bean对象；</p><p>为了省去这两行，解决思路：</p><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 ；</li><li>将需要进行测试Bean直接在测试类中进行注入</li></ul><p><strong>步骤：</strong></p><ol><li><p>导入spring集成 Junit的坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用@Runwith注解替换原来的运行期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@ContextConfiguration指定配置文件或配置类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Autowired注入需要测试的对象 </p><p>创建测试方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        userService.save();</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring集成web环境"><a href="#Spring集成web环境" class="headerlink" title="Spring集成web环境"></a>Spring集成web环境</h2><p>应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 或 AnnotationConfigApplicationContext(spring配置类) 方式获取的，但是每次从 容器中获得Bean时都要 new 一个 ，这样的弊端是配置 文件加载多次，应用上下文对象创建多次。</p><p>所以，在Web项目中，可以使用ServletContextListener 监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域 中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p><ul><li>对此，Spring提供了一个监听器<code>ContextLoaderListener</code> 就是对上述功能的封装，该监 听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具 <code>WebApplicationContextUtils</code> 供使用者获得应用上下文对象。</li></ul><p>使用：</p><ol><li><p>在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在pom.xml中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">      org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用WebApplicationContextUtils获得应用上下文对象ApplicationContex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect Oriented Programming<br>意思为面向切面编程，指通过<code>预编译方式</code>和<code>运行期动态代理</code>实现程序功能的 统一维护。 </p><p>AOP 是 OOP 的延续，是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</p><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><ul><li><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强；</p></li><li><p>优势：减少重复代码，提高开发效率，并且便于维护；</p></li></ul><blockquote><p>底层实现：</p><p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的 生成代理对象，代理 对象方法执行时进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强。</p></blockquote><h3 id="底层-动态代理"><a href="#底层-动态代理" class="headerlink" title="底层: 动态代理"></a>底层: 动态代理</h3><p>常用的动态代理技术：</p><ul><li>JDK代理：基于<code>接口</code>的动态代理技术</li><li>cglib代理：基于父类的动态代理技术</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204282053325.png" alt="image-20220428205334230"></p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><ol><li><p>目标类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line"><span class="type">TargetInterface</span> <span class="variable">xxx</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),<span class="comment">//目标对象 类加载器</span></span><br><span class="line">    target.getClass().getInterfaces(),<span class="comment">//目标对象 相同的接口字节码对象数据</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="comment">//调用代理对象的任何方法，实质执行的都是invoke方法</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强代码...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强代码...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> invoke;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>测试，调用代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxxMethod();</span><br></pre></td></tr></table></figure></li></ol><h4 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h4><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（后面的spring包包含了cglib，可以不用导入了）</p><ol><li><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>(); <span class="comment">//创建增强器</span></span><br><span class="line">enhancer.setSuperclass(Target.class); <span class="comment">//设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123; <span class="comment">//设置回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置代码增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Target</span> <span class="variable">xxx</span> <span class="operator">=</span> (Target) enhancer.create(); <span class="comment">//创建代理对象</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxxMethod();</span><br></pre></td></tr></table></figure></li></ol><h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 </p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>AOP 的相关常用的术语如下：</p><ul><li>Target（目标对象）：代理的目标对象 ；</li><li>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 ；</li><li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点  —— 指 <code>可以增强的方法</code>；</li><li>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义  ——  指 <code>将要增强的方法</code>；</li><li>Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是<code>通知/增强</code>  ；</li><li>Aspect（切面）：是切入点和通知（引介）的结合  —— <code>将要增强的方法 和 增强 的结合</code>；</li><li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而 AspectJ采用编译期织入和类装载期织入 —— 指 <code>方法增强的过程</code>；</li></ul><p><strong>切点表达式：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">访问修饰符可以省略</span></span><br><span class="line"><span class="comment">返回值类型、包名、类名、方法名可以使用星号* 代表任意，以及任意前后缀</span></span><br><span class="line"><span class="comment">包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</span></span><br><span class="line"><span class="comment">参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution(public void com.zzc.aop.Target.method())</span><br><span class="line">execution(void com.zzc.aop.Target.*(..))</span><br><span class="line">execution(* com.zzc.aop.*.*(..))</span><br><span class="line">execution(* com.zzc.aop..*.*(..))</span><br><span class="line">execution(* *..*(..))</span><br></pre></td></tr></table></figure><p>书写规范：</p><ul><li>切入点 通常描述接口，而不描述实现类；</li><li>访问控制修饰符 针对接口开发均采用public描述（可省略修饰符）；</li><li>对于增删改类使用 精确的返回类型 可加速匹配，对查询类使用 *通配符 快速描述；</li><li>包名书写尽量不使用 .. 匹配，效率低；</li><li>接口名&#x2F;类名 的模块相关的采用 *  匹配，例如： UserService写成 *Service，绑定业务层接口名；</li><li>方法名中的 动词精准匹配，名词 * 匹配，例如：getById 写成 getBy*，selectAll 写成 selectAll；</li><li>通常不适用异常作为匹配规则；</li></ul><h4 id="开发事项"><a href="#开发事项" class="headerlink" title="开发事项"></a>开发事项</h4><ol><li><p>需要编写的内容 </p><ul><li>编写核心业务代码（<u>目标类的目标方法</u>） </li><li>编写切面类，切面类中有通知（<u>增强功能方法</u>）</li><li>在配置文件中，<u>配置织入关系</u>，即将哪些通知与哪些连接点进行结合</li></ul></li><li><p>AOP 技术实现的内容 ：</p><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的 代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 </p></li><li><p>AOP底层使用哪种代理方式？</p><p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p></li></ol><h3 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h3><h4 id="XML配置AOP写法"><a href="#XML配置AOP写法" class="headerlink" title="XML配置AOP写法"></a>XML配置AOP写法</h4><p><strong>aop织入配置：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">“切面类”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">“通知方法名称”</span> <span class="attr">pointcut</span>=<span class="string">&quot;切点表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通知的配置语法：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:通知类型 method=“切面类中方法名” pointcut=&quot;切点表达式&quot;&gt;&lt;/aop:通知类型&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt; aop:before&gt;</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>&lt; aop:after-returning&gt;</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>&lt; aop:around&gt;</td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>&lt; aop:throwing&gt;</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>&lt; aop:after&gt;</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知的方法</span></span><br><span class="line"><span class="comment">//Proceeding JoinPoint : 正在执行的连接点，即切点</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    <span class="comment">//环绕前增强</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="comment">//环绕后方法</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切点表达式的抽取：</strong></p><p>如果有多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用 抽取后的切点表达式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zzc.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h4><ol><li><p>导入 AOP 相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类（内部有增强方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将目标类和切面类的对象创建权交给 spring </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 applicationContext.xml 中配置织入关系 </p><p>先导入aop的命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/aop</span><br><span class="line">http://www.springframework.org/schema/aop/spring-aop.xsd</span><br></pre></td></tr></table></figure><p>在applicationContext.xml中配置织入关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明切面: 引用myAspect的Bean为切面对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面:切点+通知; 配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.zzc.aop.Target.method())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h3><h4 id="注解写法"><a href="#注解写法" class="headerlink" title="注解写法"></a>注解写法</h4><ul><li><p><strong>@EnableAspectJAutoProxy</strong></p><p>配置类注解，开启注解格式AOP功能；</p></li><li><p><strong>@Aspect</strong></p><p>类注解，设置当前类为AOP切面类；</p></li><li><p><strong>@Pointcut</strong></p><p>方法注解，设置切入点方法，写的是 切入点表达式；</p></li></ul><p><strong>注解通知的类型：</strong></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>@Before</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>@AfterReturning</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>@Around</td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>@AfterThrowing</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>@After</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.zzc.dao.*.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**获取切入点方法的 —— **</p><p><strong>参数：</strong></p><ul><li><p>JoinPoint：前置，后置，返回后，抛出异常后通知，要设为方法的第一个形参；</p></li><li><p>ProceedingJoinPoint：环绕通知</p><blockquote><p>方法是 getArgs()</p></blockquote></li></ul><p><strong>返回值：</strong>返回后通知，环绕通知；</p><blockquote><p>如： Object  ret &#x3D; pjp.proceed();</p></blockquote><p><strong>运行异常信息：</strong> 抛出异常后通知，环绕通知；</p><hr><p><strong>切点表达式的抽取：</strong></p><p>同 xml 配置 aop 一样，可以将切点表达式抽取。抽取方式是在切面内<u>定义方法</u>，在<u>该方法上使用@Pointcut注解定义切点表达式</u>，然后在在增强注解中进行引用。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;MyAspect.myPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.zzc.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPoint</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h4><ol><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类（内部有增强方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将目标类和切面类的对象创建权交给 spring </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在切面类中使用注解配置织入关系 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点，这里是个空方法，起什么名字都行</span></span><br><span class="line">    <span class="comment">//@pointcut(&quot;execution(* com.zzc.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@pointcut(&quot;execution(void com.zzc.aop.Target.method())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，将 “execution(…)” 直接写在 @Before 中，不写@pointcut也行 </p></li><li><p>主配置类开启注解格式AOP功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> ctx.getBean(Target.class);</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>编程式事务控制 三大相关对象：</p><ul><li><p><strong>PlatformTransactionManager接口</strong> 是spring的事务管理器，它里面提供了我们常用的操作事务的方法。</p><p>方法：</p><ul><li>TransactionStatus  getTransaction(TransactionDefination defination)  ：获取事务的状态信息</li><li>void commit(TransactionStatus status) ：提交事务</li><li>void rollback(TransactionStatus status)：回滚事务</li></ul><blockquote><p>这个接口，不同的 Dao 层技术则有不同的实现类，例如：Dao层技术是</p><ul><li>是jdbc或mybatis时 ：org.springframework.jdbc.datasource.DataSourceTransactionManager ；</li><li>是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManage</li></ul></blockquote></li><li><p><strong>TransactionDefinition</strong> 是事务的定义信息对象。</p><p>方法：</p><ul><li><p>int getIsolationLevel() ：获得事务的隔离级别</p><p>事务隔离级别：</p><ul><li>ISOLATION_DEFAULT </li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ </li><li>ISOLATION_SERIALIZABLE</li></ul></li><li><p>int getPropogationBehavior() ：获得事务的传播行为</p><p>事务传播行为：</p><ul><li>REQUIRED：<code>required</code> | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</li><li>SUPPORTS：<code>supports</code> | 支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li><li>MANDATORY：<code>mandatory</code> | 使用当前的事务，如果当前没有事务，就抛出异常 </li><li>REQUERS_NEW：<code>requers_new</code> | 新建事务，如果当前在事务中，把当前事务挂起。</li><li>NOT_SUPPORTED：<code>not_supported</code> | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 </li><li>NEVER：<code>never</code> | 以非事务方式运行，如果当前存在事务，抛出异常</li><li>NESTED： <code>nested</code> | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</li><li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 </li><li>是否只读：建议查询时设置为只读</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205061748284.png" alt="image-20220506174825069"></p></li><li><p>int getTimeout()：获得超时时间</p></li><li><p>boolean isReadOnly() ：是否只读</p></li></ul></li><li><p><strong>TransactionStatus</strong> 接口提供的是事务具体的运行状态。</p></li></ul><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>Spring 声明式事务控制底层就是AOP。</strong></li></ul><p>Spring 的声明式事务，顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指 使用配置文件或注解 的方式进行声明 ，以声明式的处理事务 来代替 代码式的处理事务。</p><p>作用：</p><ul><li><code>事务管理不侵入开发的组件</code>。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如 此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话， 也只需要在定义文件中重新配置即可 </li><li>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译 ，这样<code>维护起来极其方便</code>。</li></ul><p>实现：</p><ul><li><p>切点 就是 业务方法</p></li><li><p>通知 就是 事务控制方法</p></li><li><p>切面织入</p></li></ul><h3 id="角色与属性"><a href="#角色与属性" class="headerlink" title="角色与属性"></a>角色与属性</h3><p>事务角色：</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><blockquote><p>注意:</p><p>目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p></blockquote><p>事务属性：</p><p>事务属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><table><thead><tr><th>属性</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>readOnly</td><td>设置是否为只读事务</td><td>readOnly&#x3D;true  只读事务</td></tr><tr><td>timeout</td><td>设置事务超时时间</td><td>timeout&#x3D;-1  永不超时</td></tr><tr><td>rollbackFor</td><td>设置事务回滚异常(class)</td><td>rollbackFor&#x3D;{NullPointException.class}</td></tr><tr><td>rollbackForClassName</td><td>设置事务回滚异常(String)</td><td></td></tr><tr><td>noRollbackFor</td><td>设置事务不回滚异常(class)</td><td></td></tr><tr><td>noRollbackForClassName</td><td>设置事务不回滚异常(String)</td><td></td></tr><tr><td>isolation</td><td>设置事务隔离级别</td><td>isolation&#x3D;Isolation.DEFAULT</td></tr><tr><td>propagation</td><td>设置事务传播行为</td><td>propagation &#x3D; Propagation.REQUIRES_NEW</td></tr></tbody></table><blockquote><p>rollbackFor： 并不是所有异常都会回滚事务，所以需要对一些异常额外设置事务回滚异常。</p></blockquote><p>事务传播行为：</p><h3 id="XML实现"><a href="#XML实现" class="headerlink" title="XML实现"></a>XML实现</h3><ol><li><p>引入tx命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">http://www.springframework.org/schema/tx </span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd</span><br></pre></td></tr></table></figure></li><li><p>配置事务增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器, 指明DAO层用了哪种技术--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 &lt; tx:method &gt; 代表切点方法的 事务参数 的配置，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：切点方法名称 </li><li>isolation：事务的隔离级别 </li><li>propogation：事务的传播行为 </li><li>timeout：超时时间 </li><li>read-only：是否只读</li></ul></blockquote></li><li><p>配置事务AOP织入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(*com.zzc.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.zzc.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><ol><li><p>在需要被事务管理的方法上添加注解，标明事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring注解式事务 通常添加在业务层接口中，而不会添加到业务层实现类中，降低耦合；</p><p>添加到接口或类上，它的所有方法都会开启事务；</p></blockquote></li><li><p>在JdbcConfig类中配置事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p></li><li><p>开启事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement //开启注解式事务驱动</span></span><br><span class="line"><span class="meta">public class SpringConfig &#123;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC就是一个Spring内置的 实现了MVC模型的 Web框架。</p><p>它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。</p><p><strong>SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封装。</strong></p><blockquote><p>MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化等等)，而且使用简单，与Spring无缝集成。</p></blockquote><h2 id="开发步骤-3"><a href="#开发步骤-3" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤： </p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ol><li><p>导入SpringMVC相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建主配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用配置类替换web.xml</p><p>web.xml可以删除，换成ServletContainersInitConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载springmvc配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//加载指定配置类</span></span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置由springmvc控制器处理的请求映射路径</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现二</span></span><br><span class="line"><span class="comment">//也可以继承AbstractAnnotationConfigDispatcherServletInitializer，实现更方便，作用和上面 的代码一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行tomcat，测试</p></li></ol><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><ol><li><p>导入SpringMVC相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jsp坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在web.xml 中配置SpringMVC核心控制器DispathcerServlet </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Controller类和视图页面 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用注解配置Controller类中业务方法的映射地址 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建配置SpringMVC核心文件 spring-mvc.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>客户端发起请求</p></li></ol><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li>用户发送请求至 前端控制器DispatcherServlet。 </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果 有则生成) 一并返回给DispatcherServlet。 </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li><li>Controller执行完成返回ModelAndView。 </li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li><li>ViewReslover解析后返回具体View。 </li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204271852603.png" alt="image-20220427185241362"></p><p><strong>启动服务器初始化过程：</strong></p><ol><li><p>服务器启动，执行ServletContainersInitConfig类，初始化web容器</p><ul><li>功能类似于以前的web.xml</li></ul></li><li><p>执行createServletApplicationContext方法，创建了WebApplicationContext对象</p><ul><li>该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器</li></ul></li><li><p>加载SpringMvcConfig配置类</p></li><li><p>执行@ComponentScan加载对应的bean</p><ul><li>扫描指定包及其子包下所有类上的注解，如Controller类上的@Controller注解</li></ul></li><li><p>加载UserController，每个@RequestMapping的名称对应一个具体的方法</p><ul><li>此时就建立了 <code>/save</code> 和 save方法的对应关系</li></ul></li><li><p>执行getServletMappings方法，设定SpringMVC拦截请求的路径规则</p><ul><li><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</li></ul></li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205070952207.png" alt="image-20220507095206842"></p><p><strong>单次请求过程：</strong></p><ol><li>发送请求<code>http://localhost/save</code></li><li>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</li><li>解析请求路径&#x2F;save</li><li>由&#x2F;save匹配执行对应的方法save(）<ul><li>上面的第五步已经将请求路径和方法建立了对应关系，通过&#x2F;save就能找到对应的save方法</li></ul></li><li>执行save()</li><li>检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</li></ol><h2 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h2><ul><li><p>前端控制器：DispatcherServlet </p><p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 </p></li><li><p>处理器映射器：HandlerMapping HandlerMapping </p><p>负责根据用户请求 找到Handler，即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </p></li><li><p>处理器适配器：HandlerAdapter </p><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。</p></li><li><p>处理器：Handler </p><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 </p></li><li><p>视图解析器：View Resolver </p><p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即 具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>视图：View </p><p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最 常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程 序员根据业务需求开发具体的页面</p></li></ul><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系 </p><p>位置： </p><ul><li>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 </li><li>方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</li></ul><p>属性： </p><ul><li><p><strong>value</strong>：用于指定请求的URL。它和path属性的作用是一样的 </p></li><li><p><strong>method</strong>：用于指定请求的方式 </p></li><li><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 ；</p><p>例如：<br>params &#x3D; {“accountName”}，表示请求参数必须有<br>accountName  params &#x3D; {“moeny!100”}，表示请求参数中money不能是10</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/func&quot;)</span><span class="comment">//访问时需要加上这一级目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick&quot;, method = RequestMethod.GET, params = &#123;&quot;username&quot;&#125;)</span><span class="comment">//请求方式必须为GET，参数需带有 username</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;<span class="comment">//加上&quot;/&quot;表示从默认根开始访问,否则会从/func开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问路径为：http://localhost/func/quick?username=xxx</span></span><br></pre></td></tr></table></figure><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>类注解，位于类定义上方；</p><p>作用：设置spring配置类扫描路径，加载使用注解格式定义的bean</p><p>属性：</p><ul><li>excludeFilters —— 排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)</li><li>includeFilters —— 加载指定的bean，需要指定类别(type)和具体项(classes)</li></ul><h4 id="XML的"><a href="#XML的" class="headerlink" title="XML的"></a>XML的</h4><h5 id="MVC命名空间引入"><a href="#MVC命名空间引入" class="headerlink" title="MVC命名空间引入"></a>MVC命名空间引入</h5><p>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a> </p><p>​xmlns:mvc&#x3D;”<a href="http://www.springframework.org/schema/mvc&quot;">http://www.springframework.org/schema/mvc&quot;</a> </p><p>约束地址：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> </p><p>​<a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a> </p><p>​<a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a> </p><p>​<a href="http://www.springframework.org/schema/mvc/spring-mvc.xsd">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a></p><h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用 &lt;context:component-scan base-package&#x3D;”com.zzc.controller”&#x2F;&gt;  进行组件扫描。</p><p>还可以指定扫描 某目录下指定的注解，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc.controller&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是不扫描 某目录下指定的注解，将 include-filter 改为 exclude-filter </p><h5 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h5><p>SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址 org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br></pre></td></tr></table></figure><ul><li>redirect:        重定向前缀</li><li>forward:        转发前缀（默认）</li></ul><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/success.jsp&quot;</span>; <span class="comment">//重定向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以修改视图解析器的前后缀：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 修改默认前缀为 /jsp/ ，默认后缀为 .jsp  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="bean加载控制"><a href="#bean加载控制" class="headerlink" title="bean加载控制"></a>bean加载控制</h2><p>设一个项目目录结构：com.zzc.</p><ul><li>config目录<ul><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul></li><li>controller目录：放SpringMVC的controller类</li><li>service目录：service接口和实现类</li><li>dao目录：dao&#x2F;Mapper接口和实现类</li></ul><p>以上类需要被容器管理成对象：</p><ul><li>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</li><li>Spring控制的bean<ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li></ul><p>所以需要区分各自的加载范围：</p><ul><li><p>方式一：Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.service&quot;,&quot;com.zzc.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>做开发的时候，Dao最终是交给<code>MapperScannerConfigurer</code>对象来进行扫描处理的，所以SpringConfig只需要将其扫描到service包即可。</p></blockquote></li><li><p>方式二：Spring加载的bean设定扫描范围为com.zzc,排除掉controller包中的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.zzc&quot;,</span></span><br><span class="line"><span class="meta">    excludeFilters=@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Controller.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</p></li><li><p>type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除</p><ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE:按照指定的类型过滤</li><li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li><li>REGEX:按照正则表达式排除</li><li>CUSTOM:按照自定义规则排除</li></ul><p>一般只用到第一种ANNOTATION</p></li><li><p>classes属性：设置排除的具体注解类，当前设置排除@Controller定义的bean</p></li></ul></li><li><p>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中[了解即可]</p></li></ul><h2 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h2><p>SpringMVC的数据响应方式有两种：</p><ul><li>页面跳转<ul><li>直接返回字符串</li><li>通过ModelAndView对象返回</li></ul></li><li>回写数据<ul><li>直接返回字符串</li><li>返回对象或集合</li></ul></li></ul><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><ul><li><p>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转；</p></li><li><p>通过ModelAndView对象返回；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/func&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//直接返回字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过ModelAndView对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        mav.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//设置视图名称</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ModelAndView对象作为参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView mav)</span>&#123;</span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        mav.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置视图名称</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模型和视图分离</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save4</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//也可以用request存储数据,不常用（request是框架直接注入的）</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save5</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="回写数据"><a href="#回写数据" class="headerlink" title="回写数据"></a>回写数据</h3><ul><li><p>直接回写字符串，需要添加注解 <strong>@ResponseBody</strong>，以告知SpringMVC框架，这个方法返回的字符串不是跳转 而是直接在http响应体中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello SpringMVC&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发中往往要将复杂的java对象转换成json格式的字符串， 可以使用json转换工具jackson进行转换，导入jackson坐标。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jackson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以只导下面这个依赖，会自动导入前两个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相应的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乱码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><p>实现返回对应对象的json数据，需要依赖&#x3D;&#x3D;@ResponseBody&#x3D;&#x3D;注解和&#x3D;&#x3D;@EnableWebMvc&#x3D;&#x3D;注解，然后数据直接返回，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save9</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="获得请求数据"><a href="#获得请求数据" class="headerlink" title="获得请求数据"></a>获得请求数据</h2><h3 id="资源放行"><a href="#资源放行" class="headerlink" title="资源放行"></a>资源放行</h3><p>SpringMVC的前端控制器 DispatcherServlet的url-pattern配置的是”&#x2F;“，代表对所有的资源都进行过滤操作，如果要放行某类资源，可以通过以下两种 方式指定放行静态资源： </p><ul><li><p>注解方式：</p><p>让SpringMVC放行对应的静态资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置在config目录下，记得让SpringMVC扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.controller&quot;,&quot;com.zzc.config&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml方式，在spring-mvc.xml配置文件中指定放行的资源</p></li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当指定路径为&quot;/js/**&quot;时，就会到&quot;/js/&quot;下寻找 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用标签（交给tomcat自动寻找）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四种类型参数"><a href="#四种类型参数" class="headerlink" title="四种类型参数"></a>四种类型参数</h3><p>客户端请求参数的格式是：name&#x3D;value&amp;name&#x3D;value… … </p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p><ul><li>基本类型参数</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick10?username=zhangsan&amp;age=12</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick10&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save10</span><span class="params">(String username, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot; -- &quot;</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POJO类型参数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick11?username=zhangsan&amp;age=12</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save11</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick12?strs=aaa&amp;strs=xxx</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    System.out.println(Arrays.toString(strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick12?likes=aaa&amp;likes=xxx</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需在形参前面加上@RequsetParam，而url与传递数组参数的一样。</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(<span class="meta">@RequsetParam</span> List&lt;String&gt; likes)</span> &#123;</span><br><span class="line">    System.out.println(likes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者(以前的)另一种方式，需要先将参数包装到一个POJO中才可以</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick13&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数Vo是View Object的意思，里面有一个list</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save13</span><span class="params">(Vo vo)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">System.out.println(vo.getUserList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当使用ajax提交时，可以<strong>指定contentType为 json形式</strong>，那么在方法参数位置使用 **@RequestBody **可以 直接接收集合数据而无需使用POJO进行包装。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//模拟数据</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">userList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    userList.push(&#123;username: <span class="string">&quot;zhangsan&quot;</span>,age: <span class="string">&quot;20&quot;</span>&#125;);</span><br><span class="line">    userList.push(&#123;username: <span class="string">&quot;lisi&quot;</span>,age: <span class="string">&quot;20&quot;</span>&#125;);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;/quick14&quot;</span>,</span><br><span class="line">        data: JSON.stringify(userList),</span><br><span class="line">        contentType : <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod13</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="请求数据乱码问题"><a href="#请求数据乱码问题" class="headerlink" title="请求数据乱码问题"></a>请求数据乱码问题</h3><p>当post请求时，数据会出现乱码，</p><p>注解方式：</p><p>在配置类中重写getServletFilters()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置过滤器，处理中文乱码</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml方式：</p><p>在<strong>web.xml</strong> 中设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参数绑定注解-requestParam"><a href="#参数绑定注解-requestParam" class="headerlink" title="参数绑定注解@requestParam"></a>参数绑定注解@requestParam</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过**@RequestParam**注解显示的绑定。</p><p>（这样前端发送的参数的名字 只需和@RequestParam中的value值相同，<br>    不用和后端定义的参数名字一样了）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick14&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick14&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod14</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestParam的属性：</p><ul><li>value：请求参数名称 </li><li>required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错 </li><li>defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</li></ul><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON；</p><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,”value2”,”value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>使用：</p><ol><li><p>首先要添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启SpringMVC注解支持： @EnableWebMvc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数前添加 @RequestBody</p><p>普通数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端数据发送</span></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span><span class="string">&quot;value3&quot;</span><span class="punctuation">,</span>...<span class="punctuation">]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后端数据接收</span></span><br><span class="line"><span class="comment">//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;list common(json)参数传递 list ==&gt; &quot;</span>+likes);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User类中有name，age，address(province,city)三个成员参数</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;itcast&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;pojo(json)参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;itcast&quot;,&quot;age&quot;:15&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;zzc&quot;,&quot;age&quot;:12&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listPojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; list)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;list pojo(json)参数传递 list ==&gt; &quot;</span>+list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>@RequestBody与@RequestParam：</p><ul><li><p>区别</p><ul><li>@RequestParam用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li>@RequestBody用于接收json数据【application&#x2F;json】</li></ul></li><li><p>应用</p><ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul></li></ul><h3 id="Restful风格的参数"><a href="#Restful风格的参数" class="headerlink" title="Restful风格的参数"></a>Restful风格的参数</h3><p>REST —— Representational State Transfer，表现形式状态转换，即约定了 访问网络资源的格式。</p><p>（根据REST风格对资源进行访问称为RESTful）</p><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><ul><li>GET：用于获取资源 </li><li>POST：用于新增&#x2F;保存资源 </li><li>PUT：用于修改&#x2F;更新资源 </li><li>DELETE：用于删除资源</li></ul><p>例如：</p><p>&#x2F;users&#x2F;1  GET ： 得到 id &#x3D; 1 的 user<br>&#x2F;users&#x2F;1  DELETE： 删除 id &#x3D; 1 的 user<br>&#x2F;users&#x2F;1  PUT： 更新 id &#x3D; 1 的 user<br>&#x2F;users  POST： 新增 user</p><blockquote><p> 可以看到，url可以是相同的，而执行的行为根据请求方式的不同进行区分，不仅简洁，更是隐藏了 资源的访问行为，无法通过地址得知对资源是何种操作。</p><p>注：</p><p>描述模块的名称通常使用复数，表示此类资源，而非单个资源，如：users</p></blockquote><p>在业务方法中我们可以使用**@PathVariable**注解进行占位符的匹配获取工作，在@RequestMapping中设置method以限定请求方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick20/zhangsan&amp;12</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@PathVariable占位，method = RequestMethod.GET限定只能为get请求;</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/users/&#123;name&#125;&amp;&#123;age&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod19</span><span class="params">(<span class="meta">@PathVariable(value = &quot;name&quot;)</span> String name, <span class="meta">@PathVariable</span> Integer age)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接收参数，有三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code></p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>SpringMVC 默认已经提供了一些常用的类型转换器，但有一些类型没有提供转换器的就需要自定义，例如：日期类型的数据就需要自定义转换器。</p><p>注解方式：日期类型有一个专门的用于转换日期格式的注解 @DateTimeFormat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dataParam?date=2088/08/08&amp;date1=2088-08-08&amp;date2=2088/08/08 8:08:08</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date2)</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递 date ==&gt; &quot;</span>+date);</span><br><span class="line">System.out.println(<span class="string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);</span><br><span class="line">System.out.println(<span class="string">&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;</span>+date2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML方式：</p><p>自定义类型转换器的开发步骤： </p><ol><li>定义转换器类实现Converter接口 </li><li>在配置文件中声明转换器 </li><li>在&lt; annotation-driven&gt;中引用转换器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Date&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring-mvc.xml中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converterService&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.converter.DateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;converterService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>客户端要求：</p><ul><li>表单项 type&#x3D;”file“</li><li>提交方式  method&#x3D;”post”</li><li>表单的 enctype属性是多部分表单形式，即 enctype&#x3D;”multipart&#x2F;form-data”</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick20&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>服务端：</p><ul><li><p>导入fileupload和io坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件上传解析器 </p><p>在spring-mvc.xml中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件总大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传单个文件的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件的编码类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写文件上传代码</p><p>单文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick20&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod20</span><span class="params">(String name,MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获得文件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">    <span class="comment">//保存文件</span></span><br><span class="line">    uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多文件（客户端表单 添加多个文件上传按钮）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick21&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod21</span><span class="params">(String name,MultipartFile[] uploadFiles)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile uploadFile : uploadFiles)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="拦截器interceptor"><a href="#拦截器interceptor" class="headerlink" title="拦截器interceptor"></a>拦截器interceptor</h2><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。<br>拦截器也是AOP思想的具体实现。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205121628515.png" alt="image-20220512162807264"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205121629047.png" alt="image-20220512162817000"></p><table><thead><tr><th>区别</th><th>过滤器（Filter）</th><th>拦截器（interceptor）</th></tr></thead><tbody><tr><td>使用范围</td><td>是 servlet 规范中的一部分，任何 Java Web 工程都可以使用</td><td>只有使用了 SpringMVC 框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 <code>url-pattern</code> 中配置了 &#x2F;* 之后， 可以对所有要访问的资源拦截</td><td>在<code>&lt;mvc:mapping path=“”/&gt;</code>中配置了 &#x2F;** 之 后，可以对所有资源进行拦截，但是可以通过<code>&lt;mvc:exclude-mapping path=“”/&gt;</code>标签排除不需要拦截的资源</td></tr></tbody></table><p>方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的， 当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会 再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方 法</td></tr><tr><td>postHandle()</td><td>该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为 true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调 用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象 进行操作</td></tr><tr><td>afterComplrtion()</td><td>该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图 之后执行，前提是preHandle 方法的返回值为true 时才能被调用</td></tr></tbody></table><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205131027171.png" alt="image-20220513102758813"></p><p>将拦截器按一定的顺序联结成一条链，这条链称为<code>拦截器链（Interceptor Chain）</code>。在访问被拦截的方 法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205131049477.png" alt="image-20220513104959292"></p><p>使用：</p><ul><li><p>创建拦截器类，实现HandlerInterceptor接口 </p><p>（**注意:**拦截器类要被SpringMVC容器扫描到。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//拦截前运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle running...&quot;</span>);<span class="comment">//拦截逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// true放行，false不放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在整个请求结束之后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>XML配置拦截器 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.interceptor.MyHandlerInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>配置拦截器类</p><p>（<strong>注意:</strong> SpringMvcSupport类要被SpringMVC容器扫描到。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//需要拦截器类，spring容器注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放行/配置 前端页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放行/配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//配置拦截器</span></span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(<span class="string">&quot;/books,&quot;</span>/books<span class="comment">/*&quot;&quot; );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>SpringMvcSupport的内容也可以写在 SpringMVC配置类SpringMvcConfig中，只要实现 WebMvcConfigurer 接口并重写相同的方法即可。 但这样侵入性较强，SpringMvcConfig与容器有绑定。</p></blockquote></li><li><p>测试拦截器的拦截效果</p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>处理思路：</p><p>系统中异常包括两类：<code>预期异常</code>和<code>运行时异常RuntimeException</code>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的Dao、Service、Controller出现异常都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205120929169.png" alt="image-20220428201456607"></p><p>注解方式：</p><p>详情见 SSM整合-统一异常处理</p><p>XML方式：</p><p>两种处理方式：</p><ul><li><p>使用 Spring MVC 提供的简单异常处理器SimpleMappingExceptionResolver </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“defaultErrorView”</span> <span class="attr">value</span>=<span class="string">“error”/</span>&gt;</span>  <span class="comment">&lt;!-- 未知异常，则跳默认错误视图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“exceptionMappings”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- key值为异常类型, value值为错误视图  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.zzc.exception.MyException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器。</p><ol><li><p>创建异常处理器类实现HandlerExceptionResolver </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">//创建ModelAndView对象</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//处理异常的代码实现</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyException)&#123;</span><br><span class="line">            ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ClassCastException)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//添加异常时显示的视图</span></span><br><span class="line">  modelAndView.setViewName(<span class="string">&quot;exceptionPage&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置异常处理器 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exceptionResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.zzc.exception.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写异常页面 </p></li><li><p>测试异常跳转</p></li></ol></li></ul><hr><hr><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p> MyBatis是一款优秀的持久层框架，用于简化 JDBC开发。</p><blockquote><p>JavaEE三层框架（MVC）：</p><ul><li>表现层：页面展示</li><li>业务层：逻辑处理</li><li>持久层：数据持久化（将数据保存到数据库）</li></ul><p>框架：相当于一个半成品软件，是一套可重用的，通用的、软件基础代码模型。</p><p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。</p></blockquote><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205120929393.png" alt="image-20220224170810620"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191707940.png" alt="image-20220224171023073"></p><h2 id="开发步骤-4"><a href="#开发步骤-4" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li>添加MyBatis的坐标</li></ol>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   其他坐标：</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建user数据表 </p><p>user(id, username, password)</p></li><li><p>编写User实体类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写映射文件UserMapper.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多条sql语句  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写核心文件SqlMapConfig.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com.zzc.mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试类 (可以使用spring进行优化)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得sqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql查询语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//sql插入语句</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;zzc&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">sqlSession.insert(<span class="string">&quot;userMapper.add&quot;</span>, user);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//sql修改语句</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;zzl&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>, user);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//sql删除语句</span></span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">6</span>);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204301521813.png" alt="image-20220430152118466"></p><p><strong>sql动态语句：</strong></p><ul><li><p>&lt;if&gt;  </p><p>select * from user where id&#x3D;?  or  username&#x3D;? or password&#x3D;? 相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">        and id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">        and username=#&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        and password=#&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>&lt;foreach&gt;</p><p>select * from user where id in(?,?,?……) 相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from User</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签用于遍历集合，它的属性： </p><ul><li>collection：代表要遍历的集合元素，注意编写时不要写#{} </li><li>open：代表语句的开始部分 </li><li>close：代表结束部分 </li><li>item：代表遍历集合的每个元素，生成的变量名 </li><li>sperator：代表分隔符</li></ul><p>（其中collection属性，根据传进来的数据，数组——array，集合——list  。。。）</p></li></ul><p><strong>sql片段抽取：</strong></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204302033476.png" alt="image-20220430203329385"></p><h3 id="核心配置文件-1"><a href="#核心配置文件-1" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><p>层级关系：</p><ul><li><code>configuration</code>配置<ul><li><code>properties</code>      属性</li><li><code>settings</code>      设置</li><li><code>typeHandleres </code>     类型处理器</li><li><code>objectFactory</code>       对象工厂</li><li><code>plugins </code>     插件</li><li><code>environments</code>      环境<ul><li><code>environment</code>       环境变量</li><li><code>transactionManager</code>      事务管理器</li><li><code>dataSource</code>       数据源</li></ul></li><li><code>databaseldProvider</code>        数据库厂商标识</li><li><code>mappers</code>        映射器</li></ul></li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202204301549635.png" alt="image-20220430154957315"></p><p><strong>mapper标签：</strong></p><ul><li>使用相对于类路径的资源引用，例如： &lt; mapper resource&#x3D;”org.mybatis.builder.AuthorMapper.xml”&#x2F;&gt;</li><li>使用完全限定资源定位符（URL），例如： &lt; mapper url&#x3D;”file:&#x2F;&#x2F;&#x2F;var&#x2F;mappers&#x2F;AuthorMapper.xml”&#x2F;&gt;</li><li>使用映射器接口实现类的完全限定类名，例如： &lt; mapper class&#x3D;”org.mybatis.builder.AuthorMapper”&#x2F;&gt;</li><li>将包内的映射器接口实现全部注册为映射器，例如：&lt; package name&#x3D;”org.mybatis.builder”&#x2F;&gt;</li></ul><p><strong>typeAliases标签</strong>：</p><p>mybatis设置了一些常用类型的别名：</p><p>String的别名为string，Long别名为long，Integer别名为int，Double别名为double，Boolean别名为boolean ……….</p><p><strong>typeHandlers标签</strong></p><p>MyBatis 不论在在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用 类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>但遇到不支持或非标准的类型，就需要重写类型处理器：</p><ul><li><p>定义转换类继承类BaseTypeHandler </p></li><li><p>覆盖4个未实现的方法，其中：<br>setNonNullParameter  是java程序设置数据到数据库的回调方法，<br>getNullableResult  是查询时 mysql的字符串类型转换成 java的Type类型的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Date date, JdbcType type)</span> &#123;</span><br><span class="line">        preparedStatement.setString(i,date.getTime()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> callableStatement.getDate(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在MyBatis核心配置文件中进行注册 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册类型自定义转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.zzc.typeHandlers.MyDateTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试转换是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">userMapper.add2(user);</span><br></pre></td></tr></table></figure></li></ul><p><strong>plugins标签</strong></p><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即 可获得分页的相关数据 开发步骤： </p><ol><li><p>导入通用PageHelper的坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在mybatis核心配置文件中配置PageHelper插件 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试分页数据获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; select = userMapper2.select(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(User user : select)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>获得分页相关的其他参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他分页的数据</span></span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(select);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">System.out.println(<span class="string">&quot;每页显示长度：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">System.out.println(<span class="string">&quot;是否最后一页：&quot;</span>+pageInfo.isIsLastPage());</span><br></pre></td></tr></table></figure><h3 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h3><p><strong>SqlSessionFactory build（InputStream inputStream）</strong>：通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p><p>（其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或 一个 web URL 中加载资源文件。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;xxx.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br></pre></td></tr></table></figure><p>SqlSessionFactory工厂对象<strong>创建 SqlSession 实例</strong>：</p><ul><li>openSession()  ——  开启一个事务，但事务不会自动提交；</li><li>openSession(boolean autoCommit) —— 开启一个事务，如果参数为true，则会自动提交；</li></ul><p><strong>SqlSession会话对象：</strong></p><ul><li><p>执行语句：</p><ul><li>&lt; T&gt; selectOne(String statement, Object parameter)  </li><li>&lt; E&gt; List&lt; E&gt;  selectList(String statement, Object parameter)  </li><li>int insert(String statement, Object parameter)  </li><li>int update(String statement, Object parameter)  </li><li>int delete(String statement, Object parameter)</li></ul></li><li><p>操作事务：</p><ul><li>void commit()</li><li>void rollback()</li></ul></li></ul><h2 id="Dao层实现"><a href="#Dao层实现" class="headerlink" title="Dao层实现"></a>Dao层实现</h2><h3 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h3><ol><li><p>编写UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写UserDaoImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTraditionDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">    System.out.println(all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="代理开发方式"><a href="#代理开发方式" class="headerlink" title="代理开发方式"></a>代理开发方式</h3><p>Mapper 接口开发方法只需要程序员编写 Mapper接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体和上边Dao接口实现类方法一样。 </p><p>Mapper 接口开发需要遵循以下规范： </p><ul><li>Mapper.xml文件中的namespace与mapper接口的全限定名相同；</li><li>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同；</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同；</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</li></ul><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205120929808.png" alt="image-20220430192216358"></p><ol><li><p>编写mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DaoMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com/zzc/dao/DaoMapper.java&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line">    <span class="type">DaoMapper</span> <span class="variable">daoMapper</span> <span class="operator">=</span> sqlSession.getMapper(DaoMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> doaMapper.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><p>使用 <strong>resultMap</strong>标签， 主要用于解决<code>实体类属性名与数据库表中字段名不一致</code>的情况，可以将查询结果映射成实体对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span><span class="comment">&lt;!-- 类再实例化时用来注入结果到构造方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span>/&gt;</span><span class="comment">&lt;!-- ID参数，结果为ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span>/&gt;</span><span class="comment">&lt;!-- 注入到构造方法的一个普通结果 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span><span class="comment">&lt;!-- 用于表示哪个列是主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>/&gt;</span><span class="comment">&lt;!-- 注入到字段或JavaBean属性的普通结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 用于一对一关联 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 用于一对多、多对多关联 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="comment">&lt;!-- 使用结果值来决定使用哪个结果映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 基于某些值的结果映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中id 和result 元素有以下属性：</p><ul><li>property： 映射到列结果的字段或属性。如果 POJO 的属性和 SQL 字段名（column元素）是相同的，那么 MyBatis 就会映射到 POJO 上；</li><li>column：对应sql字段；</li><li>javaType：配置 Java 类型。可以是特定的类完全限定名或 MyBatis 上下文的别名；</li><li>jdbcType：配置数据库类型。这是 JDBC 类型，MyBatis 已经为我们做了限定，基本支持所有常用数据库类型；</li><li>typeHandler：类型处理器。允许你用特定的处理器来覆盖 MyBatis 默认的处理器。需要指定 jdbcType 和 javaType 相互转化的规则；</li></ul><p><strong>一对一查询：</strong></p><ol><li><p>创建Order和User实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date ordertime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> total;</span><br><span class="line">    <span class="comment">//代表当前订单从属于哪一个客户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建OrderMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    List&lt;Order&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zzc.mapper.OrderMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">        select * from orders o,user u where o.uid=u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的resultMap还可以这样配：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p><strong>一对多查询：</strong></p><ol><li><p>修改User实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="comment">//添加一个列表</span></span><br><span class="line">    <span class="comment">//代表当前用户具备哪些订单</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zzc.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        select *,o.id oid from user u left join orders o on u.id=o.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p><strong>多对多查询：</strong></p><p>和一对多相似，主要区别在 sql 语句是查一张表还是多张表，而配置文件和一对多差不多。</p><h2 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h2><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><p>只用MyBatis的话，在service实现类中，需要多次新建session工厂</p><h3 id="未整合前环境"><a href="#未整合前环境" class="headerlink" title="未整合前环境"></a>未整合前环境</h3><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据数据表 创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"><span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加jdbc.properties文件</p></li><li><p>添加Mybatis核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.zzc.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.zzc.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205061127458.png" alt="image-20220506112714936"></p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205061139152.png" alt="image-20220506113908300"></p><h3 id="注解方式-1"><a href="#注解方式-1" class="headerlink" title="注解方式"></a>注解方式</h3><blockquote><p>主要用到的两个类分别是:</p><ul><li>SqlSessionFactoryBean</li><li>MapperScannerConfigurer</li></ul></blockquote><ol><li><p>导入需要的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring主配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建数据源的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主配置类中读properties文件，并引入数据源配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mybatis配置类并配置SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.zzc.domain&quot;</span>);</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.zzc.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SqlSessionFactoryBean中的方法需要DataSource类型参数，而当前Spring容器中已经创建了Druid数据源，类型为DataSource，即容器中已经有这个对象了，且使用@Bean时，所以可以在形参列表直接写上DataSource类型的参数。</p><p>MapperScannerConfigurer 中的 basePackage 就是用于设置说扫描的包路径。</p></blockquote></li><li><p>主配置类中引入Mybatis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="XML方法"><a href="#XML方法" class="headerlink" title="XML方法"></a>XML方法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置MyBatis的SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载mybatis的核心配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:sqlMapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Mapper扫描, 让Spring容器产生Mapper实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描mapper包下的多有 xxxMapper类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zzc.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置声明式事务控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transacionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transacionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* </span></span></span><br><span class="line"><span class="string"><span class="tag">    com.zzc.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改service实现类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountMapper.save(account);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="整合过程"><a href="#整合过程" class="headerlink" title="整合过程"></a>整合过程</h2><p>（1）创建工程</p><p>大体框架：</p><img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202205120929662.png" alt="image-20220510120627978" style="zoom:50%;" /><p>（2）SSM整合</p><ul><li><p>Spring</p><ul><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//表示该类为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.service&quot;&#125;)</span>     <span class="comment">//直接写“com.zzc”会误扫描到其他包</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MybatisConfig.class&#125;)</span><span class="comment">//引入Mybatis相关配置类</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>        <span class="comment">//开启注解式事务驱动，在Service层要管理事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>MyBatis</p><ul><li><p>MybatisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//构建SqlSessionFactoryBean并设置别名扫描与数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.zzc.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建MapperScannerConfigurer并设置DAO层的包扫描</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.zzc.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JdbcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">zzc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>SpringMVC</p><ul><li><p>ServletConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;springMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置过滤器，处理中文乱码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringMvcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//标识为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span><span class="comment">//扫描Controller包</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span><span class="comment">//开启SpringMVC注解支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>（3）功能模块</p><ul><li><p>创建数据库</p></li><li><p>表与实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dao（接口 + 实现类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert tbl_book (type, name, description) values (#&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service（接口 + 实现类）</p><ul><li><p>业务层接口测试（整合Junit）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getByID(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; all = bookService.getAll();</span><br><span class="line">        System.out.println(all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>controller</p><ul><li><p>表现层接口测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getByID(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><p>后端返回给前端的应该是同一的数据格式，因此，这里可以统一一个结果类<code>Result(code，data，msg)</code> ，将数据封装到<code>data</code>中，操作结果封装到<code>code</code>属性中，封装特殊信息到<code>message(msg)</code>属性中；</p><p>封装结果类Result：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义返回Code码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Controller类的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统一每个控制器方法的返回值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getByID</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getByID(id);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;查询失败，请重试&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; list = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> list != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> list != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;查询失败，请重试&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, list, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>项目的各个地方都有可能出现异常，这些可能出现的异常都需要进行处理。</p><p>异常的种类及出现异常的原因:</p><ul><li>框架内部抛出的异常：因使用不合规导致</li><li>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）</li><li>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</li><li>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）</li></ul><p>各个层级都会出现异常，所以，让所有异常都抛到最上面的表现层进行处理。</p><h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><p>通过 <code>异常分类</code> 区分不同的异常，使用AOP编写异常处理方法，SpringMVC提供了<strong>异常处理器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="comment">//返回结果给前端</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>,<span class="literal">null</span>,<span class="string">&quot;有异常，进行了处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保SpringMvcConfig能够扫描到异常处理器类</p><ul><li>@RestControllerAdvice<ul><li>类注解，位于Rest风格开发的控制器增强类上方；</li><li>此注解自带@ResponseBody注解与@Component注解，具备对应的功能；</li></ul></li><li>@ExceptionHandler<ul><li>方法注解，专用于异常处理的控制器方法上；</li><li>作用：设置指定异常的处理方案，出现异常后终止原始控制器执行,并转入当前方法执行。</li></ul></li></ul><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ul><li>业务异常（BusinessException）<ul><li>规范的用户行为产生的异常<ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul></li><li>不规范的用户行为操作产生的异常<ul><li>如用户故意传递错误数据</li></ul></li></ul></li></ul><ul><li><p>系统异常（SystemException）</p><ul><li>项目运行过程中可预计但无法避免的异常<ul><li>比如数据库或服务器宕机</li></ul></li></ul></li><li><p>其他异常（Exception）</p><ul><li>编程人员未预期到的异常，如:用到的文件不存在</li></ul></li></ul><p>对应的解决方案：</p><ul><li>业务异常（BusinessException）<ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul></li><li>系统异常（SystemException）<ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul></li><li>其他异常（Exception）<ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul></li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li>自定义异常类：</li></ol><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在try…catch…或throws了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常处理器，用于封装异常信息，对异常进行分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常处理器，用于封装异常信息，对异常进行分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将其他异常包成自定义异常：</li></ol><p>具体的包装方式有：</p><ul><li>方式一:<code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>方式二:直接throw自定义异常即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟业务异常，包装成自定义异常</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(Code.BUSINESS_ERR,<span class="string">&quot;错误信息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(Code.SYSTEM_TIMEOUT_ERR,<span class="string">&quot;服务器访问超时，请重试!&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>处理类中 处理自定义异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置当前处理器类对应的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doSystemException</span><span class="params">(SystemException ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(),<span class="literal">null</span>,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doBusinessException</span><span class="params">(BusinessException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(),<span class="literal">null</span>,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(Code.SYSTEM_UNKNOW_ERR,<span class="literal">null</span>,<span class="string">&quot;系统繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h2><p>首先，SpringMVC设置“&#x2F;”过滤所有文件，要对前端页面文件放行：</p><p>（需要让SpringMVC配置类扫描下面这个 SpringMvcSupport）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面meta --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../plugins/elementui/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../plugins/font-awesome/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;hold-transition&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>图书管理<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter-container&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.queryString&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px;&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getAll()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;butT&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">current-row-key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">stripe</span> <span class="attr">highlight-current-row</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;description&quot;</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleDelete(scope.row)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 新增标签弹层 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;add-form&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;新增图书&quot;</span> <span class="attr">:visible.sync</span>=<span class="string">&quot;dialogFormVisible&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;dataAddForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;formData&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">label-position</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">label-width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.type&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.name&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.description&quot;</span> <span class="attr">type</span>=<span class="string">&quot;textarea&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;dialogFormVisible = false&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleAdd()&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编辑标签弹层 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;add-form&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;编辑检查项&quot;</span> <span class="attr">:visible.sync</span>=<span class="string">&quot;dialogFormVisible4Edit&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;dataEditForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;formData&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">label-position</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">label-width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.type&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.name&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.description&quot;</span> <span class="attr">type</span>=<span class="string">&quot;textarea&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;dialogFormVisible4Edit = false&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleEdit()&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入组件库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../plugins/elementui/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">pagination</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataList</span>: [],<span class="comment">//当前页要展示的列表数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">formData</span>: &#123;&#125;,<span class="comment">//表单数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dialogFormVisible</span>: <span class="literal">false</span>,<span class="comment">//控制表单是否可见</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dialogFormVisible4Edit</span>: <span class="literal">false</span>,<span class="comment">//编辑表单是否可见</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">rules</span>: &#123;<span class="comment">//校验规则</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: [&#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;图书类别为必填项&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: [&#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;图书名称为必填项&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//钩子函数，VUE对象初始化完成后自动执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//列表</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">get</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//弹出添加窗口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="title function_">resetForm</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//重置表单</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">resetForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">formData</span> = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//添加</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleAdd</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">post</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>, <span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20011</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20010</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;添加失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//弹出编辑窗口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleUpdate</span>(<span class="params">row</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// console.log(row);   //row.id 查询条件</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//查询数据，根据id查询</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">get</span>(<span class="string">&quot;/SSM_war_exploded/books/&quot;</span> + row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// console.log(res.data.data);</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20041</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//展示弹层，加载数据</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">formData</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//编辑</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleEdit</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">put</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>, <span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20031</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;修改成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20030</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;修改失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 删除</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//1.弹出提示框</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.$confirm(<span class="string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>: <span class="string">&#x27;info&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//2.做删除业务</span></span></span><br><span class="line"><span class="language-javascript">                    axios.<span class="title function_">delete</span>(<span class="string">&quot;/SSM_war_exploded/books/&quot;</span> + row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20021</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                    &#125;);</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//3.取消删除</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;取消删除操作&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h1 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h1><p>非关系型数据库，即缓存数据库，读取速度快，但保存时间有限。</p><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>Zookeeper: 是一个分布式的、开源的程序协调服务，是 hadoop(分布式计算) 项目下的一个子项目。</p><p>用于<strong>分布式中一致性处理的框架</strong>。</p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架。</p><p>其内部使用了 Netty、Zookeeper，保证了高性能高可用性。</p><h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。</p><p>ActiveMQ</p><p>中小型公司，万级，非常成熟，功能强大，在早些年业内大量的公司以及项目中都有应用，主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用。</p><p>RabbitMQ</p><p>万级，延时很低，是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</p><p>RocketMQ</p><p>大型公司，十万级，阿里，接口简单易用，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。</p><h1 id="SpringBoot2"><a href="#SpringBoot2" class="headerlink" title="SpringBoot2"></a>SpringBoot2</h1><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Maven&amp;SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/Notes/2022/04/14/javaWeb/"/>
      <url>/Notes/2022/04/14/javaWeb/</url>
      
        <content type="html"><![CDATA[<p>CS ：客户端-服务器 架构模式</p><ul><li>优点：充分利用客户端机器的资源，减轻服务器的负荷<br>(一部分安全要求不高的计算任务存储任务放在客户端执行，不需要把所有的计算和存储都在服务器端执行，从而能櫛够减轻服务器的压力，也能够减轻网络负荷）</li><li>缺点：需要安装；升级维护成本较高；</li></ul><p>BS：浏览器-服务器 架构模式</p><ul><li>优点：客户端不需要安装；维护成本较低；</li><li>缺点：所有的计算和存储任务都是放在服务器端的，服务器的负荷较重；在服务端计算完成之后把结果再传输给客户端，因此客户端和服务器端会进行非常频繁的数据通信，从而网络负荷较重；</li></ul><hr><hr><blockquote><p>网页主要由三部分组成：</p><p>结构：HTML</p><p>表现：CSS</p><p>行为：JavaScript</p></blockquote><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><blockquote><p><strong>Chrome浏览器调试工具</strong>：右键点“检查”，或按F12</p></blockquote><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h3><p>标题标签 ： &lt; h1 &gt;  ~  &lt; h6 &gt;</p><p>段落标签：&lt; p &gt; &lt; &#x2F;p &gt;  (两段之间会插入一定的间距)</p><p>换行标签：&lt; br &gt;</p><p>水平分割线：&lt; hr &gt;</p><p>文本格式化标签： </p><ul><li>加粗：&lt; strong &gt;&lt; &#x2F;strong &gt;或者 &lt; b &gt;&lt; &#x2F;b &gt;</li><li>倾斜：&lt; em &gt;&lt; &#x2F;em &gt; 或者 &lt; i &gt;&lt; &#x2F;i &gt;</li><li>删除线：&lt; del &gt;&lt; &#x2F;del &gt; 或者 &lt; s &gt;&lt; &#x2F;s &gt;</li><li>下划线：&lt; ins &gt;&lt; &#x2F;ins &gt; 或者 &lt; u &gt;&lt; &#x2F;u &gt;</li></ul><p>分区标签：</p><ul><li>&lt; div &gt; &lt; &#x2F;div &gt; ：一行只能放一个 &lt; div &gt; ，是大分区；</li><li>&lt; span &gt; &lt; &#x2F;span &gt; ：一行可以放多个 &lt; span &gt;，是小分区；</li></ul><blockquote><p>其他布局标签：（用于手机网页制作）</p><table><thead><tr><th>标签名</th><th>语义</th></tr></thead><tbody><tr><td>header</td><td>网页头部</td></tr><tr><td>nav</td><td>网页导航</td></tr><tr><td>footer</td><td>网页底部</td></tr><tr><td>aside</td><td>网页侧边栏</td></tr><tr><td>section</td><td>网页区块</td></tr><tr><td>article</td><td>网页文章</td></tr></tbody></table><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705816.png" alt="image-20220228195231266"></p></blockquote><p>图像标签：</p><ul><li><p>&lt; img src&#x3D;”图像URL” &#x2F; &gt; </p></li><li><p>&lt; img src&#x3D;”图像URL”  alt&#x3D;”替换的文字” title&#x3D;”图像提示文字”&#x2F; &gt;</p><blockquote><p>图像标签的属性：</p><p>属性之间不分先后顺序，但必须用空格分开</p><p>属性采用键值对的格式：key&#x3D;”value”</p><table><thead><tr><th>属性</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>src</td><td>图片路径</td><td>必须属性</td></tr><tr><td>alt</td><td>文本</td><td>替换文本，图像不能显示时出现的文字</td></tr><tr><td>title</td><td>文本</td><td>提示文本，鼠标放到图像上会浮现的文字</td></tr><tr><td>width</td><td>像素</td><td>设置图像的宽度</td></tr><tr><td>height</td><td>像素</td><td>设置图像的高度</td></tr><tr><td>border</td><td>像素</td><td>设置图像的边框粗细</td></tr></tbody></table></blockquote></li></ul><p>相对路径： <strong>&#x2F;</strong> 指下一级路径， <strong>..&#x2F;</strong> 指上一级路径 </p><p>绝对路径：\</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注意最后应该有个斜杠/，以表示是目录 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://localhost:8080/07_servlet/a/b/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>base标签：可以设置当前页面中所有路径工作时，参照哪个路径来进行跳转。</p><p>超链接：&lt; a &gt;  具体为：&lt; a href&#x3D;”跳转目标” target&#x3D;”目标窗口的弹出方式” &gt; 文本、图像、音频等(点击样式)  &lt; &#x2F;a&gt;</p><blockquote><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>href</td><td>用于指定链接目标的url地址（必须属性）</td></tr><tr><td>target</td><td>用于指定链接页面的打开方式，_self为默认值， _blank为在新窗口打开</td></tr></tbody></table><p>如：&lt; a href&#x3D;”<a href="http://www.qq.com&quot;/">http://www.qq.com&quot;</a> target&#x3D;”_blank”&gt; 腾讯&lt; &#x2F;a &gt; </p><p>内部链接：则href 后可以直接写相对路径。即两者在同一文件夹。</p><p>空链接：href 后写个 # ，即 &lt; a href&#x3D;”#”&gt; ** &lt; &#x2F;a &gt;</p><p>下载链接：href后写压缩文件的路径</p><p>锚点链接：在href属性中，设为 #名字 的形式，如 &lt; a href&#x3D;”#ZZC”&gt; 哈哈 &lt; &#x2F;a &gt;，然后在目标处，添加一个id属性&#x3D;设定的名字，如 &lt; h4 id&#x3D;”ZZC” &gt;</p></blockquote><hr><p>注释： &lt; !–  注释语句 – &gt; ，快捷键 ：ctrl + &#x2F;</p><p>特殊字符：（只记空格符就行，所有字符后都要带个分号 ; )</p><table><thead><tr><th>特殊字符</th><th>描述</th><th>字符的代码</th></tr></thead><tbody><tr><td></td><td><strong>空格符</strong></td><td><strong>&amp;nbsp</strong></td></tr><tr><td>&lt;</td><td>小于号</td><td>&amp;lt</td></tr><tr><td>&gt;</td><td>大于号</td><td>&amp;gt</td></tr><tr><td>&amp;</td><td>和号</td><td>&amp;amp</td></tr><tr><td>￥</td><td>人民币</td><td>&amp;yen</td></tr><tr><td>©</td><td>版权</td><td>&amp;copy</td></tr><tr><td>®</td><td>注册商标</td><td>&amp;reg</td></tr><tr><td>°</td><td>摄氏度</td><td>&amp;deg</td></tr><tr><td>±</td><td>正负号</td><td>&amp;plusmn</td></tr><tr><td>×</td><td>乘号</td><td>&amp;times</td></tr><tr><td>÷</td><td>除号</td><td>&amp;divide</td></tr><tr><td>²</td><td>平方2</td><td>&amp;sup2</td></tr><tr><td>³</td><td>立方3</td><td>&amp;sup3</td></tr></tbody></table><hr><hr><h3 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h3><p>&lt; table&gt;&lt; &#x2F;table&gt;：是用于定于表格的标签</p><p>&lt; tr &gt;&lt; &#x2F;tr &gt;：用于定义表格中的行，必须在&lt; table &gt;中</p><p>&lt; td &gt;&lt; &#x2F;td &gt;：用于单元格，必须嵌套在&lt; tr &gt;中</p><p>&lt; th &gt;&lt; &#x2F;th &gt;：表示表头单元格（文本内容居中加粗）</p><p>表格结构标签：&lt; thead &gt;指表格的头部区域，&lt; tbody &gt;指表格 的主体区域。</p><p>合并单元格（属性）：跨行合并——rowspan&#x3D;”合并个数“，跨列合并——colspan&#x3D;”合并个数”（也可说是占了若干个单元格）</p><blockquote><p>合并步骤：找到目标单元格，写上合并方式，如：&lt; td colspan&#x3D;”2” &gt;&lt; &#x2F;td &gt;，然后再删除多余的单元格。</p></blockquote><p>表格属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>align</td><td>legt，center，right</td><td>规定表格相对周围元素的对齐方式</td></tr><tr><td>border</td><td>1或 ” “</td><td>是否有边框，默认为” “，即无边框</td></tr><tr><td>cellpadding</td><td>像素值</td><td>规定单元边沿与内容之间的空白，默认1像素</td></tr><tr><td>cellspacing</td><td>像素值</td><td>规定单元格之间的空白，默认1像素</td></tr><tr><td>width</td><td>像素值或百分比</td><td>规定表格的宽度</td></tr></tbody></table><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span> <span class="attr">cellpadding</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    &lt; th&gt;表头单元格的内容<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">&lt; td&gt;单元格中的内容<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><hr><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表：&lt; ul &gt; ，列表项：&lt; li &gt;</p><p>有序列表：&lt; ol &gt;</p><p>自定义列表：&lt; dl &gt; ，表项头&lt; dt &gt;，表项：&lt; dd &gt;</p><blockquote><p>&lt; ul &gt;和&lt; ol &gt;里只能放&lt; li &gt;， &lt; li &gt;里面可以放任意标签，&lt; dl &gt;里只能放&lt; dt &gt;和&lt; dd &gt;。</p></blockquote><hr><h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3><p>表单域（区域）：&lt; form &gt;</p><blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><p>表单域属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>作用</th></tr></thead><tbody><tr><td>action</td><td>url地址</td><td>指定接收该表的服务器程序的url地址</td></tr><tr><td>method</td><td>GET&#x2F;POST</td><td>设置表单数据的提交方式</td></tr><tr><td>name</td><td>名称</td><td>指定表单名称</td></tr></tbody></table><p>表单元素：</p><ul><li><p>输入元素：&lt; input type&#x3D;”属性值” &#x2F; &gt;</p><p>input属性：</p><table><thead><tr><th>属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>name</td><td>自定义</td><td>定义input元素的名称</td></tr><tr><td>value</td><td>自定义</td><td>规定input元素的值</td></tr><tr><td>checked</td><td>checked</td><td>规定此input首次加载时被选中</td></tr><tr><td>maxlength</td><td>正整数</td><td>规定输入字符的最大长度</td></tr></tbody></table><blockquote><p>注：name和value是每个表单元素都有的属性值，主要给后台人员使用；要求<u>单选按钮和复选框要有相同的name值</u>。</p></blockquote><p>type属性值：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 Javascript启动脚本）</td></tr><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>file</td><td>定义输入字段和“浏览”按钮，供文件上传。和 multiple 搭配可以上传多个文件</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。</td></tr><tr><td>image</td><td>定义图像形式的提交按钮</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。</td></tr><tr><td>radio</td><td>定义单选按钮</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为20个字符。</td></tr><tr><td>placeholder</td><td>占位符，作提示，常用于需要输入的文本框</td></tr></tbody></table><blockquote><p>&lt; label &gt; ：用于绑定一个表单元素，当单击此标签内的文本时，会自动选择对应的表单元素，以增加用户体验。</p><p>格式：&lt; label &gt;里的for属性 应该与相关元素的 id属性相同。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;zzc&quot;</span>&gt;</span> 文本<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot; &quot;</span> <span class="attr">id</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>下拉元素：&lt; select &gt; ：定义下拉列表</p><p>在&lt; option &gt;中添加selected&#x3D;”selected”时，为默认选中项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span> 选项 <span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>文本域元素：&lt; textarea &gt;：定义多行文本输入控件</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span>&gt;</span></span><br><span class="line">文本内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><p>CSS：层叠样式表</p><blockquote><p>CSS书写顺序：</p><ol><li>浮动 &#x2F; display</li><li>盒子模型：margin border padding 宽度高度背景色</li><li>文字样式</li></ol></blockquote><h3 id="导入方式"><a href="#导入方式" class="headerlink" title="导入方式"></a>导入方式</h3><ol><li><p>内联样式：在标签内使用style属性（耦合较高，较少使用）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span> HELLO CSS <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>内部样式：定义 &lt; style &gt; 标签，在标签内定义css样式；</p><p>（一般写在head标签里，title标签下面）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="comment">/*选择器 &#123; 样式 &#125; */</span></span></span><br><span class="line"><span class="language-css"><span class="comment">/*给谁改样式 &#123; 改什么样式 &#125; */</span></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">    <span class="attribute">color</span>: red;<span class="comment">/*键值对用:分开，每行用;结尾*/</span></span></span><br><span class="line"><span class="language-css">    fon-size: <span class="number">12px</span>;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>外部样式：定义link标签，引入外部的css文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;demo.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*demo.css*/</span></span><br><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>规范：</p><p>选择器、属性名、属性值统一小写；</p><p>选择器（标签）和大括号中间带空格；</p><p>冒号后带空格</p></blockquote><hr><hr><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ul><li><p>标签选择器：元素名称{color: red;}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>: red&#125;</span><br></pre></td></tr></table></figure></li><li><p>id选择器：#id属性值{color: red;}</p><blockquote><p>注意：id是唯一的，一般与js配合制作动态效果</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#name</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> id=&quot;name&quot;&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>类选择器：.class属性值{color: red;}</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.cls</span>&#123;<span class="attribute">color</span>: red;&#125;</span><br><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;cls&quot;&gt;helle css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure></li><li><p>通配符选择器：*{ color: red;}</p><p>作用：为页面的所有标签 设置样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line"><span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/*去除默认的外边距*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><hr><p><strong>更多用法:</strong></p><ul><li><p>后代选择器：选择器1 选择器2 { css }</p><blockquote><p>作用：根据嵌套关系，选择父元素的 后代中满足条件的元素。</p><p>注：后代包括 儿子、孙子….</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> <span class="selector-tag">p</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;   <span class="comment">/* 选择div下的p标签 */</span></span><br></pre></td></tr></table></figure></li><li><p>子代选择器： 选择器1 &gt; 选择器2{css}</p><blockquote><p>作用：选择父元素的子代元素。</p><p>注：子代只包含儿子</p></blockquote></li><li><p>并集选择器： 选择器1，选择器2{css}</p><blockquote><p>作用：用逗号隔开，同时选择多组标签，设置相同的样式。</p><p>注：一般写法是 每个选择器写一行，提高代码的可读性。</p></blockquote></li><li><p>交集选择器：选择器1选择器2 { css }</p><blockquote><p>作用：选中页面中同时满足多个选择器的标签</p><p>注：选择器连着写，且标签选择器优先写在前面。</p></blockquote></li><li><p>hover伪类选择器：选择器：hover {css}</p><blockquote><p>作用：在鼠标悬停在元素上时 会出现的状态样式</p></blockquote></li></ul><h3 id="字体和文本样式"><a href="#字体和文本样式" class="headerlink" title="字体和文本样式"></a>字体和文本样式</h3><h4 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h4><ul><li><p>字体大小：font-size</p><blockquote><p>取值：数字+px</p><p>谷歌浏览器默认文字大小是16px</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">30px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>粗细：font-weight</p><blockquote><p>取值：normal，bold；（指正常和加粗）</p><p>或取100到900的整百数，正常是400，加粗是700</p></blockquote></li><li><p>样式：font-style （是否倾斜）</p><blockquote><p>取值：normal，italic（正常和倾斜）</p></blockquote></li><li><p>类型系列：font-family</p><blockquote><p>取值：微软雅黑，黑体………等等，最后应该加sans-serif（无衬线字体）（从设置的第一种字体开始选，没有就选择下一个电脑有的字体）</p></blockquote></li><li><p>字体font连写：</p><blockquote><p>取值：font：style weight size family（可以省略前两个值，为默认值）</p><p>复合属性：一个属性后面写多个值的写法</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>: italic <span class="number">700</span> <span class="number">66px</span> 宋体</span><br></pre></td></tr></table></figure></li></ul><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><ul><li><p>文本缩进：text-indent</p><blockquote><p>取值：数字+px   或   数字+em（1em&#x3D;当前标签的大小，推荐）</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>&#123;</span><br><span class="line">    <span class="attribute">text-indent</span>: <span class="number">2em</span>  <span class="comment">/*缩进两字符*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>文本水平对齐方式：text-align</p><blockquote><p>属性值：left，center，right；分别是左对齐，居中，右对齐 </p><p>注：text-align 其实是内容对齐，不仅仅用于文本， 能用于 文本、span标签、a标签、input标签、img标签 。不过需要在以上元素的父元素设置，如<body>。</p></blockquote></li><li><p>文本修饰：text-decoration</p><blockquote><p>取值：underline，line-through，overline，none；分别是下划线（常用)，删除线，上划线，无装饰线（常用)。</p></blockquote></li></ul><hr><h4 id="line-height行高"><a href="#line-height行高" class="headerlink" title="line-height行高"></a>line-height行高</h4><p>作用：控制一行的上下行间距</p><blockquote><p>取值：数字+px 或 倍数（当前标签font-size的倍数）</p></blockquote><blockquote><p>注意：</p><p>如果同时设置了行高和font连写，注意覆盖问题<br>font：style weight size&#x2F;line-height family</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font</span>:ita1ic <span class="number">700</span> <span class="number">66px</span>/<span class="number">2</span> 宋体;</span><br></pre></td></tr></table></figure></blockquote><p><strong>标签水平居中： margin：0 auto</strong></p><blockquote><p> margin：0 auto 一般用于有固定宽度的盒子，如果没有宽度，会默认占满父元素的宽度。</p></blockquote><hr><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>背景色：background-color: </p><p>背景图：background-image: url(‘…..’)</p><p>背景平铺：background-repeat：</p><blockquote><table><thead><tr><th>取值</th><th>效果</th></tr></thead><tbody><tr><td>repeat</td><td>默认，水平和垂直方向平铺</td></tr><tr><td>no-repeat</td><td>不平铺</td></tr><tr><td>repeat-x</td><td>沿水平方向平铺</td></tr><tr><td>repeat-y</td><td>沿垂直方向平铺</td></tr></tbody></table></blockquote><p>背景位置：background-position：x值 y值；</p><blockquote><p>方向名词</p><ul><li>水平：left，center，right</li><li>垂直：top，center，bottom</li></ul><p>数字+px（坐标）</p></blockquote><p>背景相关属性连写</p><blockquote><p>顺序无要求，推荐顺序：background：color image repeat position</p></blockquote><hr><h3 id="元素显示模式"><a href="#元素显示模式" class="headerlink" title="元素显示模式"></a>元素显示模式</h3><p>&lt; &gt;可以叫标签，标记，元素。</p><ul><li><p>块级元素</p><p>独占一行，宽度默认是父元素的宽度，高度由内容撑开，可以设置宽高</p><blockquote><p>如：div，p，h系列，ul，li，dl，dt，dd，form，header</p></blockquote></li><li><p>行内元素</p><p>一行可以显示多个，宽度和高度默认由内容撑开，不可以设置宽高</p><blockquote><p>如：a，apar，b，u，i，s，strong，ins，em，del</p></blockquote></li><li><p>行内块元素</p><p>一行可以显示多个，可以设置宽高</p><blockquote><p>如：image，input，textarea，button，select</p></blockquote></li></ul><p><strong>元素显示模式转换：</strong></p><p>作用：改变元素默认的显示特点，让元素符合布局要求</p><p>语法：</p><table><thead><tr><th>属性</th><th>效果</th></tr></thead><tbody><tr><td>display: block</td><td>转成块级元素</td></tr><tr><td>display: inline-block</td><td>转成行内块元素</td></tr><tr><td>display: inline</td><td>转成行内元素</td></tr></tbody></table><p><strong>元素的嵌套规范</strong></p><ul><li><p>块级元素一般作为大容器，可以嵌套：文本、块级元素、行内元素、行内块元素等等…</p><blockquote><p>但是：p标签中不要嵌套div、p、h等块级元素</p></blockquote></li><li><p>a 标签内部可以嵌套任意元素</p><blockquote><p>但是：a标签不能嵌套a标签</p></blockquote></li></ul><h3 id="CSS特性"><a href="#CSS特性" class="headerlink" title="CSS特性"></a>CSS特性</h3><ul><li><p><strong>继承性</strong>：子元素默认继承父元素的样式特点</p><blockquote><p>控制文字属性的都可以继承，如：</p><p>color，font- ，text- ，line-height 。。。。</p><p>但有例外：a标签的color有自己的蓝色，h系列的font-size有自己的字体大小，都会继承失效。</p></blockquote></li><li><p><strong>层叠性</strong>：覆盖，后面的覆盖前面的</p></li><li><p><strong>优先级：</strong></p><p>继承 &lt; 通配符选择器 &lt; 标签选择器 &lt; 类选择器 &lt; id选择器 &lt; 行内样式 &lt; !important</p><blockquote><p>!important可以提升选择器的优先级到最高，写在属性值的后面，分号的前面。</p><p>注：继承的优先级不能用 !important提高，它的优先级最低。</p></blockquote></li></ul><h3 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h3><p>页面中的每一个标签，都可看做是一个“盒子”，通过盒子的视角更方便的进行布局。</p><h4 id="盒子构成"><a href="#盒子构成" class="headerlink" title="盒子构成"></a>盒子构成</h4><ul><li><p><strong>内容区域 content</strong></p></li><li><p><strong>内边距区域 padding</strong></p><blockquote><p>取值：可以四个，三个，两个，一个值</p><p>padding: 10px 20px 30px 40px （对应上 右 下 左，即逆时针开始数）   </p><p>padding: 10px 20px 30px  （对应上 左右 下，也是逆时针）</p><p>padding：  10px 20px（对应上下 左右，也是逆时针）</p></blockquote></li><li><p><strong>边框区域 border</strong></p><blockquote><p>如：<strong>border：10px solid red</strong> ——&gt;10像素，直线，红色（粗细，线段样式，颜色）</p><p>如果只需要一边的边框线，则<strong>border-方向</strong>即可，如：border-left&#x2F; right&#x2F; top&#x2F; bottom</p><p>线段：直线solid，dashed虚线，dotted点线（其他的线用不着，需要的用图片）</p></blockquote><blockquote><p>快捷键：bd</p></blockquote></li><li><p><strong>外边距区域 margin</strong></p></li></ul><h4 id="自动内减"><a href="#自动内减" class="headerlink" title="自动内减"></a>自动内减</h4><p><strong>box-sizing：border-box</strong></p><blockquote><p>给盒子设置border或paddingl时，盒子会被撑大，需要再次设置参数，手动计算麻烦，所以有了自动内减，浏览器会自动计算，在内容中减去相应大小。</p></blockquote><h4 id="清楚默认的内外边距"><a href="#清楚默认的内外边距" class="headerlink" title="清楚默认的内外边距"></a>清楚默认的内外边距</h4><p><strong>margin：0；</strong></p><p><strong>padding：0；</strong></p><blockquote><p>淘宝网的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">blockquote</span>,<span class="selector-tag">body</span>,<span class="selector-tag">button</span>,<span class="selector-tag">dd</span>,<span class="selector-tag">dl</span>,<span class="selector-tag">dt</span>,<span class="selector-tag">fieldset</span>,<span class="selector-tag">form</span>,<span class="selector-tag">h1</span>,<span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>,<span class="selector-tag">h4</span>,<span class="selector-tag">h5</span>,<span class="selector-tag">h6</span>,hr,<span class="selector-tag">input</span>,<span class="selector-tag">legend</span>,<span class="selector-tag">li</span>,<span class="selector-tag">ol</span>,<span class="selector-tag">p</span>,pre,<span class="selector-tag">td</span>,<span class="selector-tag">textarea</span>,<span class="selector-tag">th</span>,<span class="selector-tag">ul</span>&#123;</span><br><span class="line"><span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line"><span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>京东的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*&#123;</span><br><span class="line">   <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">   <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ul><li><p>塌陷现象：</p><p>场景：相互嵌套的块级元素，子元素设置了margin-top，会同样作用在父元素上。致使父元素一起往下移动。</p><p>解决：</p><ul><li>给父元素设置border-top或者padding-top(分隔父子元素的margin-top)</li><li>给父元素设置 overflow: hidden</li><li>转换成行内块元素</li><li>设置浮动</li></ul></li></ul><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="结构伪类选择器"><a href="#结构伪类选择器" class="headerlink" title="结构伪类选择器"></a>结构伪类选择器</h4><p>根据元素在HTML的结构关系查找元素。常用于查找某父级选择器的子元素。</p><p>优势：减少对HTML中类的依赖，有利于保持代码的整洁。</p><table><thead><tr><th>选择器</th><th>说明</th></tr></thead><tbody><tr><td>E:first-child{}</td><td>匹配父元素中第一个子元素，且是E元素</td></tr><tr><td>E:last-child{}</td><td>匹配父元素中最后一个子元素，且是E元素</td></tr><tr><td>E:nth-child(n){}</td><td>匹配父元素中第n个子元素，且是E元素</td></tr><tr><td>E:nth-last-child(n){}</td><td>匹配父元素中倒数第n个子元素，且是E元素</td></tr></tbody></table><blockquote><p>n可以写成公式，如4n+1，则会选中第5个，第9个….</p></blockquote><h4 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h4><p>一般在页面的非主体内容可以使用伪元素。</p><table><thead><tr><th>伪元素</th><th>作用</th></tr></thead><tbody><tr><td>::before</td><td>在父元素内容的最前添加一个伪元素</td></tr><tr><td>::after</td><td>在父元素内容的最后添加一个伪元素</td></tr></tbody></table><p>注：必须设置content属性才能生效，伪元素默认是行内元素</p><p> 例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;   </span><br><span class="line">&lt;style&gt;</span><br><span class="line">        <span class="selector-class">.father</span><span class="selector-pseudo">::before</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">&#x27;老鼠&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="selector-class">.father</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">            <span class="attribute">content</span>: <span class="string">&quot;大米&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">    &lt;!-- 老鼠爱大米 --&gt;</span><br><span class="line">    &lt;<span class="selector-tag">div</span> class=&quot;father&quot;&gt;爱&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">body</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="浮动特点"><a href="#浮动特点" class="headerlink" title="浮动特点"></a>浮动特点</h4><ul><li><p>浮动元素会脱离标准流(简称：脱标)，在标准流中不占位置</p><blockquote><p>标准流：又称文档流 ，指浏览器在渲染网页时默认采用的一套排版规则。</p></blockquote></li><li><p>浮动元素比标准流高半个级别，可以覆盖标准流中的元素</p></li><li><p>浮动找浮动，下一个浮动元素会在上一个浮动元素后面左右浮动</p></li><li><p>浮动元素有特殊的显示效果</p><ul><li>一行可以显示多个</li><li>可以设置宽高</li></ul></li></ul><blockquote><p>注：浮动的元素不能使用text-align: center或者margin: 0 auto 设置</p></blockquote><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p>浮动带来的问题：如果子元素浮动了，此时子元素不占位置，不能撑开标准流的块级父元素。</p><p>解决：</p><ol><li><p>直接设置父元素的高度</p><p>优点：简单</p><p>缺点：有些布局中不能固定父元素高度</p></li><li><p>额外标签法</p><p>在父元素内容的最后添加一个块级元素，并对其设置 clear: both。</p><p>缺点：添加了额外标签，会使HTML结构变复杂</p></li><li><p>单伪元素清除法</p><p>用伪元素替代了额外标签。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*基本写法*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;<span class="comment">/*clearfix常用作需要清除浮动的元素的类名*/</span></span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*补充写法*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: block;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="comment">/*补充的部分是为了在网页中看不见伪元素*/</span></span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>双伪元素清除法</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::before</span>,</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span>&#123;</span><br><span class="line"><span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：可以在项目中直接使用，直接给标签加类clearfix即可清除浮动。</p></li><li><p>设置overflow：hidden</p><p>直接给父元素设置overflow：hidden即可。</p><p>优点：方便</p></li></ol><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>可以让元素自由的摆放在网页的任意位置，一般用于盒子之间的层叠情况</p><p>应用：定位之后的元素层级最高，可以层叠在其他盒子上面，也可以让盒子始终固定在屏幕中的某个位置。</p><p>属性名：<strong>position:</strong></p><p>属性值：</p><table><thead><tr><th>定位方式</th><th>属性值</th></tr></thead><tbody><tr><td>静态定位</td><td>static（加不加效果一样）</td></tr><tr><td>相对定位</td><td><strong>relative</strong></td></tr><tr><td>绝对定位</td><td><strong>absolute</strong></td></tr><tr><td>固定定位</td><td><strong>fixed</strong></td></tr></tbody></table><p>偏移值：水平和垂直方向各选一个即可（都写的话以left和top为准）</p><table><thead><tr><th>方向</th><th>属性名</th><th>属性值</th><th>含义</th></tr></thead><tbody><tr><td>水平</td><td>left</td><td>数字px</td><td>距离左边的距离</td></tr><tr><td>水平</td><td>right</td><td>数字px</td><td>距离右边的距离</td></tr><tr><td>垂直</td><td>top</td><td>数字px</td><td>距离上边的距离</td></tr><tr><td>垂直</td><td>bottom</td><td>数字px</td><td>距离下边的距离</td></tr></tbody></table><blockquote><p>属性值 也可以用 % 来设置，这样就是以参照物来看，如 50%就是左边界在参照物的中间。</p></blockquote><ul><li><p><strong>相对定位——position: relative</strong></p><p>相对于非静态定位的父元素进行移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原位置仍在页面 中占位置(没有脱标)</p></blockquote></li><li><p><strong>绝对定位——position: absolute</strong></p><p>就近找已经定位的父级为参照进行定位，没有定位的父级，则默认相对于浏览器可视区域(即<body>)进行移动。（子绝父相）</p><blockquote><p>原位置在页面中不占位置(已经脱标)</p><p>绝对定位的盒子模式具备行内块特点</p></blockquote><blockquote><p>例题：让元素的位置处于浏览器或参照物正中间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line"><span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">150px</span>;<span class="comment">/*宽的一半*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">20%</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">200px</span>;<span class="comment">/*高的一半*/</span></span><br><span class="line">    <span class="comment">/*transform:translate(-50%,-50%); 上面的margin位移也可以写成这个，位移自己的一半*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">    heght: <span class="number">400px</span></span><br><span class="line">background-color: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>固定定位——position: fixed</strong></p><blockquote><p>特点：</p><p>脱标，不占位置；</p><p>参照浏览器窗口改变位置；</p><p>具备行内块特点</p></blockquote></li></ul><h4 id="层级关系"><a href="#层级关系" class="headerlink" title="层级关系"></a>层级关系</h4><p>不同布局：标准流 &lt; 浮动 &lt; 定位</p><p>而相对，绝对，固定三种定位方式层级相同，谁写在下就覆盖其他的。</p><h3 id="装饰"><a href="#装饰" class="headerlink" title="装饰"></a>装饰</h3><blockquote><p>浏览器解析 行内 和 行内块 时当作文字，会根据基线对齐，所以导致常常图片或按钮之类的与文本框或背景对不齐。</p></blockquote><h4 id="垂直对齐"><a href="#垂直对齐" class="headerlink" title="垂直对齐"></a>垂直对齐</h4><p>属性名：<strong>vertical-align</strong></p><p>属性值：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>baseline</td><td>默认，基线对齐</td></tr><tr><td>top</td><td>顶部对齐</td></tr><tr><td>middle</td><td>中间对齐</td></tr><tr><td>bottom</td><td>底部对齐</td></tr></tbody></table><h4 id="光标类型"><a href="#光标类型" class="headerlink" title="光标类型"></a>光标类型</h4><p>设置鼠标光标在元素上时显示的样式。</p><p>属性名：<strong>cursor</strong></p><p>属性值：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>default</td><td>默认值，通常是箭头</td></tr><tr><td>pointer</td><td>小手，提示可以点击</td></tr><tr><td>text</td><td>工字型，提示可以选择文字</td></tr><tr><td>move</td><td>十字光标，提示可以移动</td></tr></tbody></table><h4 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h4><p>场景：让盒子四个角变得圆润，增加页面细节。</p><p>属性名：<strong>border-radius</strong></p><p>常见取值：数字+px、百分比（指圆角半径）</p><p>赋值规则：从左上角开始，顺时针赋值，没有赋值的看对角</p><blockquote><p>画一个正圆：</p><p>盒子为正方形，设置圆角为盒子宽高的一半，即 border-radius: 50%</p><p>按钮胶囊：</p><p>盒子为长方形，设置圆角为盒子 高度 的一半，即 border-radius: 50%</p></blockquote><h4 id="溢出部分显示"><a href="#溢出部分显示" class="headerlink" title="溢出部分显示"></a>溢出部分显示</h4><p>溢出部分：指盒子内容部分所超出盒子范围的区域。</p><p>overflow用于控制内容溢出部分的显示效果，如：显示&#x2F;隐藏滚动条。</p><p>属性名：<strong>overflow</strong></p><p>属性值：</p><table><thead><tr><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>visible</td><td>默认值，溢出部分可见</td></tr><tr><td>hidden</td><td>溢出部分隐藏</td></tr><tr><td>scroll</td><td>无论是否溢出，都显示滚动条</td></tr><tr><td>auto</td><td>根据是否溢出，自动显示或隐藏滚动条</td></tr></tbody></table><h4 id="元素本身隐藏"><a href="#元素本身隐藏" class="headerlink" title="元素本身隐藏"></a>元素本身隐藏</h4><p>让某元素本身在屏幕中不可见，如：鼠标hover之后元素隐藏，用于隐藏&#x2F;显示子菜单之类的场景</p><p>属性：</p><ul><li><p><strong>visibility: hidden</strong></p><p>占位置的隐藏效果，用的不多</p></li><li><p><strong>display: none</strong></p><p>脱标的隐藏效果（不占位置）</p><blockquote><p>display：black  显示元素</p></blockquote></li></ul><h4 id="元素整体透明"><a href="#元素整体透明" class="headerlink" title="元素整体透明"></a>元素整体透明</h4><p>让某元素（包括内容）一起变透明。</p><p>属性名：<strong>opacity</strong></p><p>属性值：0~1之间的数字——0为完全透明</p><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><blockquote><p>跨平台、面向对象的脚本语言，用来控制网页行为，网页交互。</p></blockquote><h3 id="js引擎运行"><a href="#js引擎运行" class="headerlink" title="js引擎运行"></a>js引擎运行</h3><p>分两步：预解析，再代码执行</p><ul><li>预解析：js引擎会把js里面的所有var还有function提升到当前作用域的最前面；<ul><li>变量预解析(变量提升)：把所有的变量声明提升到当前作用域最前面，但不提升赋值操作。</li><li>函数预解析(函数提升)：把所有的函数声明提升到当前作用域最前面，不会调用函数。</li></ul></li><li>代码执行：按照代码书写顺序从上往下执行。</li></ul><h3 id="引入方式"><a href="#引入方式" class="headerlink" title="引入方式"></a>引入方式</h3><p>内部脚本：定义在HTML页面中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>JS代码必须在&lt; script &gt;&lt; &#x2F;script &gt;之间，可以放置在任何地方，任意数量。一般放在&lt; body &gt;的底部，可改善显示速度，因为脚本执行会拖慢显示。</p></blockquote><p>外部脚本：作为外部JS文件引入</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;文件路径&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><blockquote><p>外部脚本不能包含&lt; script &gt;标签，&lt; script &gt;不能自闭合</p></blockquote><hr><h3 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h3><p>与java相似，不过语句末的分号；可有可无。</p><h4 id="输出语句"><a href="#输出语句" class="headerlink" title="输出语句"></a>输出语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>(<span class="string">&quot; ... &quot;</span>)  <span class="comment">//写入警告框</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">write</span>(<span class="string">&quot; ... &quot;</span>)  <span class="comment">//写入HTML输出</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot; ... &quot;</span>)   <span class="comment">//写入浏览器控制台</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(object)  <span class="comment">//打印元素对象，查看属性,方法</span></span><br><span class="line"><span class="title function_">prompt</span>(info) <span class="comment">//弹出输入框，用户可以输入</span></span><br></pre></td></tr></table></figure><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>使用 <strong>var</strong> 关键字来声明变量。（variable）</p><blockquote><ul><li>作用域：全局变量；</li><li>变量可以重复声明；</li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="number">20</span>;</span><br><span class="line">test = <span class="string">&quot;张三&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>JS是弱类型语言，变量可以存放不同类型的值</p><p>ES6新增 let 关键字来定义变量，其变量只在let所在的代码块内有效，且不允许重复声明。</p><p>ES6新增 const 关键字来声明一个只读的常量。</p></blockquote><blockquote><ul><li><p>全局变量 在浏览器关闭时销毁；</p></li><li><p>局部变量 在程序运行完毕后就销毁；</p></li></ul></blockquote><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul><li><p>原始类型：</p><ul><li>number：数字(整数，小数，NaN(Not a Number))</li><li>string：字符，字符串，单双引号皆可</li><li>boolean：布尔类型</li><li>null：空</li><li>undefined：变量未初始化时的默认值</li></ul><blockquote><p>使用typeof运算符可以获取数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef 变量名</span><br></pre></td></tr></table></figure></blockquote></li><li><p>引用类型</p></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><ul><li>其他类型转为number：<ul><li>string：按字符的字面值转为数字，如果字面值不是数字，则转为NaN。一般使用正负号 或 parseInt 进行转化。</li><li>boolean：true 转为 1， false 转为 0.</li></ul></li><li>其他类型转为boolean：<ul><li>number：0和NaN转为 false，其他转为 true</li><li>string：空字符串转为 false，其他转为true</li><li>null：转为false</li><li>nudefined：转为fals e</li></ul></li></ul><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p>关系运算符</p><ul><li>&#x3D;&#x3D; ：先判断类型是否一致，不一致会进行类型转换再比较两个值；</li><li>&#x3D;&#x3D;&#x3D; ：（全等于）如果类型不一致，会直接返回false，类型一致时才会比较两个值。</li></ul><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数通过function关键字进行定义。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params">参数列表</span>)&#123;</span><br><span class="line">......</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//形式参数不需要类型，返回值也不需要定义类型，因为JavaScreipt是弱类型语言</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//定义方式二</span></span><br><span class="line"><span class="keyword">var</span> functionName = <span class="keyword">function</span>(<span class="params">参数列表</span>)&#123;...&#125;</span><br><span class="line"><span class="keyword">var</span> add = <span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用，JS函数调用函数，可以传递任意个参数个数</span></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(<span class="number">1</span>);</span><br><span class="line">                                  </span><br><span class="line"><span class="comment">//立即执行函数,作用:立即执行，同时也独立创建了一个作用域,里面所有变量都是局部变量,避免命名冲突;</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)();</span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;());                               <span class="comment">//如: </span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="title function_">console</span>(a + b);</span><br><span class="line">&#125;)(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b);</span><br><span class="line">&#125;(<span class="number">2</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><blockquote><p><strong>arguments</strong></p><p>是当前函数的内置对象，存储了传递的所有实参。其展示形式是一个伪数组，可以遍历，有lenght属性，有索引，没有push，pop等方法。</p></blockquote><blockquote><p>内部函数可以访问外部函数的变量：采用链式查找的方式来决定取哪个值，即找最近的——作用域链。</p></blockquote><h3 id="常用对象"><a href="#常用对象" class="headerlink" title="常用对象"></a>常用对象</h3><h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h4><p>Array用于定义数组</p><ul><li><p>创建方法：</p><ul><li>一、var 变量名 &#x3D; new Array(元素列表)；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>二、var 变量名 &#x3D; [元素列表]；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1,2,3]</span><br></pre></td></tr></table></figure></li><li><p>属性：</p><p>length：数组中元素的个数</p><p>push：添加方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrs = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arrs.<span class="title function_">push</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>splice：删除元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arrs.<span class="title function_">splice</span>(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">//参数:从0号位开始删，删2个</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><ul><li><p>创建方法：</p><ul><li><p>var 变量名 &#x3D; new String(s);</p></li><li><p>var 变量名 &#x3D; s；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性：</p><p>length：字符串的长度</p></li><li><p>方法：</p><p>chaAt()：返回在指定位置的字符</p><p>indexOf()：检索字符串</p><p>trim()：去除字符串前后的空格</p><p>concat(str1,str2….)：链接多个字符串，等效+，+更常用</p><p>substr(start,lenght)：从start开始，取lenght个字符</p></li></ul><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><p>和Math不同，Date对象需要实例化后才能使用。</p><p>Date() ——（没有参数）返回系统的当前时间</p><blockquote><p>使用 .valueOf() 或 getTime() 来获得总的毫秒数(时间戳)，从1970年1月1日到现在。</p><p>有更常用的写法：将 <strong>+new Date()</strong> 实例化，也可获得总的毫秒数。</p><p>H5新增的获取方法： <strong>Date.now()</strong></p></blockquote><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>getFullYear()</td><td>获取当年</td></tr><tr><td>getMonth()</td><td>获取当月（0~11）</td></tr><tr><td>getDate()</td><td>获取当天日期</td></tr><tr><td>getDay()</td><td>获取星期几（周期0 到 周六6）</td></tr><tr><td>getHours()</td><td>当前小时</td></tr><tr><td>getMinutes()</td><td>当前分钟</td></tr><tr><td>getSeconds()</td><td>当前秒</td></tr></tbody></table><h4 id="自定义对象"><a href="#自定义对象" class="headerlink" title="自定义对象"></a>自定义对象</h4><p>格式：</p><ul><li><p>var 对象名 &#x3D; {属性名 : 属性值，…   函数名 : function(参数){} …. };</p></li><li><p>或者使用：var 对象名 &#x3D; new Object(); 来创造一个空的对象，再利用追加属性的方法，往里面添加数据。</p></li><li><p>使用构造函数来创建对象：</p><p>function 构造函数名(参数值){ this.属性 &#x3D; 值； this.方法 &#x3D; function(){} }————调用时，用“new 构造方法名” 赋值给变量。 </p><blockquote><p>注：构造函数名字首字母要大写</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line"><span class="attr">name</span>:<span class="string">&quot;zhangsan&quot;</span>,</span><br><span class="line"><span class="attr">age</span>:<span class="number">23</span>,</span><br><span class="line"><span class="attr">eat</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;干饭&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&quot;zhangsan&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name,age,sex</span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">sing</span> = <span class="keyword">function</span>(<span class="params">sang</span>)&#123;</span><br><span class="line">        sonsole.<span class="title function_">log</span>(sang);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> zhangsan = <span class="keyword">new</span> <span class="title class_">People</span>(<span class="string">&#x27;刘德华&#x27;</span>，<span class="number">19</span>，<span class="string">&#x27;男&#x27;</span>);</span><br></pre></td></tr></table></figure><p>调用属性：<strong>对象名.属性名</strong>  或者  <strong>对象名[‘属性名’]</strong></p><p>调用方法：<strong>对象名.方法名</strong></p><p>遍历对象属性：for…in可以对数组或对象进行遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> k <span class="keyword">in</span> obj)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(k);<span class="comment">//k变量输出得到的是属性名</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj[k]); <span class="comment">//obj[k]得到的是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h3><p>JS是单线程的，即同一时间只能做一件事，这意味着所有任务需要排队，如果JS执行时间过长，会导致页面渲染不流畅。</p><p>于是，HTML5提出Web Worker标准，允许JS脚本创建多个线程。于是就有了同步和异步。</p><ul><li><p>同步</p><p>程序之间的执行顺序与排列顺序一致，即同步。</p></li><li><p>异步</p><p>执行某程序的同时可以执行另一个程序，即异步。</p></li><li><p>同步任务</p><p>同步任务都在主线程执行，形成一个执行栈</p></li><li><p>异步任务</p><p>JS的异步是通过回调函数实现的，一般而言，异步任务有三种：</p><ul><li>普通事件：如click，resize</li><li>资源加载：如load，error</li><li>定时器：如setInterval，setTimeout</li></ul><p>异步任务相关的回调函数会添加到任务队列(消息队列)中。</p></li></ul><p><strong>执行机制：</strong> </p><ol><li><p>先执行执行栈中的同步任务；</p></li><li><p>遇到异步任务，将其回调函数放入任务队列中；</p><blockquote><p>异步任务会先交给异步进程处理，只有异步任务的事件发生，或如click点击了，setInterval的时间到了，才会把相关的回调函数放入任务队列。</p></blockquote></li><li><p>等执行栈中的所有同步任务执行完毕后，系统会按次序读取任务队列中的异步任务，使其进入执行栈，开始执行。</p><blockquote><p>事件循环：主线程不断的重复获取任务，执行任务，再获取任务，反复循环。</p></blockquote></li></ol><h3 id="BOM对象"><a href="#BOM对象" class="headerlink" title="BOM对象"></a>BOM对象</h3><p>Browser Object Model 浏览器对象模型，JS将浏览器的各个组成部分封装成对象：Window，Navigator，Screen，History，Location。</p><ul><li><p><strong>Window对象：浏览器窗口对象</strong></p><ul><li><p>获取：直接使用window，其中window. 可以省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">alert</span>();</span><br></pre></td></tr></table></figure></li><li><p>属性：获取其他四个BOM对象</p></li><li><p>方法：</p><ul><li><strong>alert()</strong>  显示带有一段消息和一个确认的警告框</li><li><strong>confirm()</strong>   显示带有一段消息和确认和取消的对话框，点确定会返回ture，点取消会返回false</li><li><strong>setInterval()</strong>  按照指定的周期(毫秒计)来调用函数或计算表达式（定时器，循环执行）</li><li><strong>setTimeout()</strong>  在指定的毫秒后调用函数或计算表达式（定时器，只执行一次）</li></ul></li></ul></li><li><p><strong>Navigator：浏览器对象</strong></p><p>常用：userAgent  返回由客服端发送给服务器的user-agent头部的值。</p><p>使用下面代码尅判断用户在那个终端打开页面，以实现跳转：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((navigator.<span class="property">userAgent</span>.<span class="title function_">match</span>(<span class="regexp">/(phone|pad| pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MOOBrowser|JUC|Fennec|wosBrowser|BrowserNG|Webos|Symbian|Windows Phone)/i</span>)))&#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> =<span class="string">&quot;&quot;</span><span class="comment">//手机</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> =<span class="string">&quot;&quot;</span><span class="comment">//电脑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Screen：屏幕对象</strong></p></li><li><p><strong>History：历史记录对象</strong></p><ul><li><p>获取：使用window.history获取，其中window. 可以省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">history</span>.方法();</span><br><span class="line">history.方法();</span><br></pre></td></tr></table></figure></li><li><p>方法：</p><ul><li><strong>back()</strong>   后退，加载history列表的前一个url</li><li><strong>forward()</strong>  前进，加载history列表的下一个url</li><li>go(参数)   参数为n，前进n个页面，参数为-n，后退n个页面</li></ul></li></ul></li><li><p><strong>Location：地址栏对象</strong></p><ul><li><p>获取：使用window.location获取，其中window. 可以省略。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.location.方法();</span><br><span class="line">location.方法();</span><br></pre></td></tr></table></figure><blockquote><p><strong>URL</strong>:同一资源定位符 Uniform Resource Locator</p><p>是互联网上标准资源的地址，互联网的每个文件都有唯一的url，它包含的信息指出文件的位置，以及浏览器应该怎么处理它。</p><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protocol://host[:port]/path/[?query]#fragment</span><br><span class="line">如:http:/www.baidu.cn/index.html?name=andy&amp;age=18#link</span><br></pre></td></tr></table></figure><table><thead><tr><th>组成</th><th>说明</th></tr></thead><tbody><tr><td>protocol</td><td>通信协议常用的http, ftp, maito 等</td></tr><tr><td>host</td><td>主机（域名）</td></tr><tr><td>port</td><td>端口号，可选，省略时使用方案的默认端口如http的默认端口为80</td></tr><tr><td>path</td><td>路径，由零或多个 ‘&#x2F;‘ 符号隔开的字符串，一般用来表示主机上的一个目录或文件地址</td></tr><tr><td>query</td><td>参数，以键值对的形式，通过&amp;符号分隔开来</td></tr><tr><td>fragment</td><td>片段，#后面内容，常见于链接、锚点</td></tr></tbody></table></blockquote></li><li><p>属性：</p><p><strong>location.href</strong>   设置或返回完整的url</p><p>location.host返回主机&#x2F;域名</p><p>location.port返回端口号，如果未写则返回空字符串</p><p>location.pathname返回路径</p><p><strong>location.search</strong>返回参数</p><p>location.hash返回片段</p><blockquote><p>案例：第一页面，使用提交表单，url里的参数会携带表单的数据到另一个页面。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一个页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;index.html&quot;</span></span></span><br><span class="line"><span class="tag">      用户名<span class="attr">:</span> &lt;<span class="attr">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;uname&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;登录&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 第二个页面 url为index.html --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 假设表单提交的用户名输入为andy，则使用location.search得到 ?uname=andy --&gt;</span></span><br><span class="line">var arr = location.search.substr(1).split(&#x27;=&#x27;);  <span class="comment">&lt;!-- 去掉问号，再根据等于号做分割，则arr[1]就是名字andy了</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>方法：</p><table><thead><tr><th>方法</th><th>返回值</th></tr></thead><tbody><tr><td>location.assign(url)</td><td>跟href一样，可以跳转页面&#x2F;重定向页面；记录历史</td></tr><tr><td>location.replace(url)</td><td>替换当前页面，不记录历史，所以不能后退</td></tr><tr><td>location.reload()</td><td>重新加载页面，相当于刷新（部分有缓存的，从缓存获取数据）；如果参数为true，为强制刷新（从服务器重新获取数据）</td></tr></tbody></table></li></ul></li></ul><h4 id="页面加载事件"><a href="#页面加载事件" class="headerlink" title="页面加载事件"></a>页面加载事件</h4><ul><li><p>onload事件是等页面内容全部加载完毕 才会开始执行。</p><ul><li><p><strong>document.addEventListener(‘load’, function(){ })</strong></p></li><li><p>window.onload &#x3D; function(){ }  &#x2F;&#x2F;传统方式只有最后一个onload生效</p></li></ul></li><li><p>DOMContentLoaded 是只需DOM加载完毕，不包括flash， css等 就可以执行，速度比load快一些。</p><ul><li><strong>document.addEventListener(‘DOMContentLoaded’, function(){})</strong></li></ul></li></ul><h4 id="窗口大小调整"><a href="#窗口大小调整" class="headerlink" title="窗口大小调整"></a>窗口大小调整</h4><ul><li><p><strong>window.addEventListener(“resize”, function(){})</strong></p></li><li><p>window.onreasize &#x3D; function(){ }</p></li></ul><p>常用于响应式布局</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><ul><li><p><strong>setTimeout（函数，延迟时间）</strong> </p><p>延迟设定的时候后调用函数。</p><p>时间单位：毫秒，省略时默认为0毫秒；</p><p>浏览器中经常需要多个定时器，为了区分，一般把定时器赋值给一个变量，以起一个名字。</p><blockquote><p>setTimeout也称为回调函数callback。想click点击事件里的函数也叫回调函数。</p></blockquote><ul><li>清除定时器：clearTimeout (定时器)</li></ul></li><li><p><strong>setInterval（函数，间隔时间）</strong></p><p> 每隔设定的时间调用以此函数。</p><ul><li>clearInterval（定时器）</li></ul></li></ul><h3 id="DOM对象"><a href="#DOM对象" class="headerlink" title="DOM对象"></a>DOM对象</h3><p>Document Object Model，文档对象模型，JS将标记语言的各个组成部分封装为对象，分别有：Document，Element，Attribute，Text，Comment。</p><p>JS通过DOM，能对HTML进行操作：改变内容、样式，对事件做出反应，添加和删除元素。</p><ul><li><p><strong>Document：整个文档对象</strong></p></li><li><p><strong>Element：元素对象</strong></p><ul><li><p>获取：使用document对象的方法获取（document.方法 或者 document对象.方法）</p><ul><li><p>getElementByld</p><p>根据id属性值取，返回一个Element对象</p></li><li><p>getElementsByTagName</p><p>根据标签名称获取，返回Element对象数组</p></li><li><p>getElementsByName</p><p>根据name属性值获取，返回Element对象数组</p></li><li><p>getElementsByClassName</p><p>根据class属性值获取，返回Element对象数组</p></li><li><p><strong>querySelector(选择器)</strong></p><p>返回指定选择器的<strong>第一个元素对象</strong>，选择器需要<strong>加符号以区分： .类名    #id    标签名</strong></p></li><li><p><strong>querySelectorAll (选择器)</strong></p><p>返回指定选择器的<strong>所有元素对象集合</strong>，选择器需要加符号以区分 </p></li><li><p>获取特殊元素：bod y，html</p><p><strong>document.body</strong> ：返回body元素对象</p><p><strong>document.documentElement</strong>：返回html元素对象</p></li></ul></li></ul></li><li><p><strong>Attribute：属性对象</strong></p></li><li><p><strong>Text：文本对象</strong></p></li><li><p><strong>Comment：注释对象</strong></p></li></ul><hr><h4 id="改变元素内容"><a href="#改变元素内容" class="headerlink" title="改变元素内容"></a>改变元素内容</h4><ul><li><p>普通盒子修改，如div标签：</p><ul><li><p>对象.<strong>innerHTML</strong></p><p>可以识别html标签，保留空格和换行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line">div.<span class="property">innerHTML</span> = <span class="comment">//修改后的内容或对象</span></span><br></pre></td></tr></table></figure></li><li><p>对象.<strong>innerText</strong></p><p>不识别html标签，去除空格和换行</p></li></ul></li><li><p>表单内容修改：</p><p>对象**.value** &#x3D;  修改内容</p></li><li><p>修改样式：</p><ul><li><p>行内样式操作（适合样式较少的情况）：</p><p>对象.<strong>style.样式&#x2F;属性</strong> &#x3D;  修改内容</p></li><li><p>类名样式操作（适合样式复杂的情况）：</p><p>对象.<strong>className</strong> &#x3D; 新类名（修改内容放在新类名里）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">        <span class="selector-class">.change</span>&#123;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="language-css">            <span class="attribute">font-size</span>: <span class="number">25px</span>;</span></span><br><span class="line"><span class="language-css">        &#125;</span></span><br><span class="line"><span class="language-css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    对象.<span class="property">className</span> = <span class="string">&#x27;change&#x27;</span>;<span class="comment">//覆盖原先的类名</span></span></span><br><span class="line"><span class="language-javascript">    对象.<span class="property">className</span> = <span class="string">&#x27;原类名 新类名&#x27;</span>;<span class="comment">//不会覆盖原先的类名，存在多类名</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>禁用元素：   </p><p>对象.<strong>disabled</strong> &#x3D;  true；</p></li></ul><hr><h4 id="元素操作"><a href="#元素操作" class="headerlink" title="元素操作"></a>元素操作</h4><p><strong>获取属性值</strong>:</p><ul><li><strong>element.属性</strong> —— 获取内置属性值</li><li><strong>element.getAttribute(‘属性’)</strong> ——  主要获取自定义的属性</li></ul><p><strong>设置属性值</strong>： </p><ul><li><strong>element.属性 &#x3D; ‘值’</strong> —— 设置内置属性</li><li><strong>element.setAttribute(‘属性’，’值’)</strong> —— 主要设置自定义属性</li></ul><p><strong>移除属性</strong>：</p><ul><li><strong>element.removeAttribute(‘属性’)</strong></li></ul><blockquote><p>H5规定：</p><p>设置自定义属性要以 <strong>data-</strong> 开头，并且赋值。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">data-index</span> = <span class="string">&quot;1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">setAttribute</span>(<span class="string">&#x27;data-index&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>H5新增的获取自定义属性的方法（ie11后支持）：</p><p>使用dataset存放所有以data开头的自定义属性，通过dataset时属性名不用加 data- 前缀。</p><ul><li>element.dataset.属性名</li><li>element.dataset[‘属性名’]</li></ul><p>如果自定义属性中由多个 -链接的单词，获取时使用驼峰命名法，去掉 - </p></blockquote><p>阻止链接跳转：添加 <strong>javascript：；</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;javascript:;&#x27;</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h4 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h4><p>节点：网页中所有内容都是节点 (标签，属性，文本，注释)，在DOM中，节点用node表示。</p><p><strong>基本属性：</strong></p><ul><li><p><strong>nodeType</strong>（节点类型）</p><ul><li>元素节点 nodeType为1</li><li>属性节点 nodeType为2</li><li>文本节点 nodeType为3（文本节点包括文字，空格，换行等）</li></ul><blockquote><p>实际主要操作的是元素节点</p></blockquote></li><li><p><strong>nodeName</strong>（节点名称）</p></li><li><p><strong>nodeValue</strong>（节点值）</p></li></ul><p><strong>节点层级：</strong></p><ul><li><p>父节点： <strong>节点 .parenNode</strong></p><blockquote><p>返回指定节点的最近的父 节点，如果没有父节点则返回null</p></blockquote></li><li><p>子节点：节点 .childNodes</p><blockquote><p> 返回指定节点的子节点的集合，包括元素节点，文本节点等，需要再处理后才能得到元素节点，较麻烦，一般不使用。</p><p>可以使用 <strong>节点 .children</strong> 来获取子元素节点，虽然不是标准规定，但各浏览器2都支持。</p></blockquote><p>首个字节点和最后一个子节点： </p><ul><li>节点 .children[0] ——首个</li><li>节点.children[节点.children.lenght - 1] ——最后一个</li></ul></li><li><p>下一个兄弟元素节点： <strong>节点. nextElementSibling</strong></p><p>上一个兄弟元素节点： <strong>节点. previousElementSibling</strong></p></li></ul><p><strong>创建节点：</strong> <strong>document.createElement(‘新节点名’)</strong></p><p><strong>添加节点：</strong></p><ul><li><strong>父节点.appendChild(新建的节点)</strong> —— 添加到父节点的子节点列表的末尾</li><li><strong>父节点 .insertBefore(‘新建的节点’，指定节点)</strong> ——添加到指定子节点的前面</li></ul><p><strong>删除节点：</strong>  <strong>父节点.removeChild(要删除的子节点)</strong></p><p><strong>复制节点：</strong> <strong>节点.cloneNode()</strong> ——如果括号里参数为空 或者为 false，则为浅拷贝，即只复制节点本身，不复制里面的内容；括号里为true，则为深拷贝，复制标签和里面的子节点。 </p><hr><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>事件：HTML事件是发生在HTML元素上的”事情”。比如：按钮被点击，鼠标移动到元素之上，按下键盘按键。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象.事件 = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    事件处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li><strong>事件源：</strong>事件被触发的对象</li><li><strong>事件类型：</strong>如何触发&#x2F;发生了什么事件</li><li><strong>事件处理程序：</strong>通过函数赋值的方式进行</li></ul><p>事件监听：JavaScript可以在事件被侦测到时执行代码。</p><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>新方式——事件监听方式：</p><p><strong>对象. addEventListener(事件类型，处理函数，flag）</strong></p><blockquote><p>事件监听方式：</p><p>事件类型 为字符串形式，如：click，mouseover，注意不再带on</p><p>第三个参数flag，如果为false或省略，那么事件流处于冒泡阶段，如果为true，则为捕获阶段。实际开发中，很少使用事件捕获，不过有些事件没有冒泡，如：onblur，onfocus，onmouseenter，onmouseleave</p></blockquote><p>传统方式：</p><ul><li><p>方法一：通过HTML标签中的事件属性进行绑定（耦合）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">&quot;button&quot;</span> onclick=<span class="string">&#x27;on()&#x27;</span> &gt;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">on</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alet</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li><li><p>方法二：通过DOM元素属性绑定（推荐）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type = <span class="string">&quot;button&quot;</span> id = <span class="string">&quot;btn&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementByld</span>(<span class="string">&quot;btn&quot;</span>);</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&quot;我被点了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="删除事件"><a href="#删除事件" class="headerlink" title="删除事件"></a>删除事件</h4><p>事件监听方式：对象. removeEventListener(事件类型，处理函数) </p><p>传统方式：对象. 事件类型 &#x3D; null</p><h4 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h4><p>分为3个阶段：</p><ol><li>捕获阶段：由最顶层节点开始，然后逐级向下传播到最具体(最小)的元素。</li><li>当前目标阶段</li><li>冒泡阶段：事件开始由最具体(最小)的元素接收，然后逐级传播到最顶层阶段。</li></ol><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705818.png" alt="image-20220312204641336"></p><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><p>event 是一个事件对象，写在监听函数的小括号里当形参，事件对象只有事件发生了才会存在，是系统自动创建的，不需要传递实参进去。</p><p>事件对象：是事件的一系列相关数据的集合，跟事件相关的，如鼠标点击里就包含了鼠标坐标之类的信息。</p><blockquote><p>事件对象可以自己命名，如event，evt，e </p></blockquote><p><strong>属性方法</strong></p><table><thead><tr><th>属性&#x2F;方法</th><th>说明</th></tr></thead><tbody><tr><td>e.target</td><td>返回触发事件的对象</td></tr><tr><td>e.type</td><td>返回事件的类型</td></tr><tr><td>e.preventDefault()</td><td>阻止事件的默认行为，如阻止链接跳转</td></tr><tr><td>e.stopPropagation()</td><td>阻止冒泡</td></tr></tbody></table><blockquote><p>在监听函数中，e.target指触发事件的对象，this指绑定该事件的对象。</p></blockquote><h4 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h4><p>事件对象.stopPropagation()</p><blockquote><p>低版本浏览器：window.event.cancelBubble &#x3D; true;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(e &amp;&amp; e.<span class="property">stopPropagation</span>)&#123;<span class="comment">//浏览器是否认识新特性</span></span><br><span class="line">    e.<span class="title function_">stopPropagation</span>();</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="property">event</span>.<span class="property">cancelBubble</span> = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>阻止默认行为： event.preventDefault() </p></blockquote><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>对于子节点要设置相同的事件监听，可以不用在子节点上单独设置，而是设置在其父节点上，然后利用冒泡原理影响设置的每个子节点。</p><p>作用：只操作了以此DOM，提供了程序的性能。</p><blockquote><p>如果只想操作触发事件的那个子节点，可以利用e.target 得到触发事件的那个子节点</p></blockquote><h4 id="常见事件"><a href="#常见事件" class="headerlink" title="常见事件"></a>常见事件</h4><blockquote><p>使用传统方式window. 时，事件前要加on，如onclick，onfocus</p></blockquote><p>click：对象被点击</p><p> focus：鼠标获得焦点</p><p>blur：鼠标失去焦点</p><p>mouseover：鼠标经过 </p><p>mouseout：鼠标离开</p><p>mousemove：鼠标移动触发</p><p>mouseup：鼠标弹起触发</p><p>mousedown：鼠标按下触发</p><p>submit：确认按钮被点击（常用于v 表单提交）</p><p>change：域的内容被改变</p><p>keydown：某个按键被按下</p><p>keyup：某个按键被松开</p><p>keypress：某个按键被按下，但不识别ctrl shift等功能键</p><blockquote><p>mouseover 和 mouseenter 区别：</p><p>mouseover 经过自身盒子会触发，经过子盒子还会触发；</p><p>mouseenter 只会经过自身盒子触发</p></blockquote><hr><p><strong>鼠标事件对象</strong></p><p>属性：</p><p>e.clientX &#x2F; e.clientY —— 鼠标相对于浏览器窗口的X&#x2F;Y坐标</p><p>e.pageX &#x2F; e.pageY —— 鼠标相对于文档页面的X&#x2F;Y坐标</p><p>e.screenX &#x2F; e.screenY —— 鼠标相对于电脑屏幕的X&#x2F;Y坐标</p><blockquote><p>禁止鼠标右键菜单</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;contextmenu&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>禁止鼠标选中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;selectstart&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line">    e.<span class="title function_">preventDefault</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><p><strong>键盘事件对象</strong></p><p>属性：</p><p>keyCode：识别按下的是哪个键</p><blockquote><p>事件keyup和keydown不区分字母大小写，keypress区分大小写</p></blockquote><blockquote><p>例子：按s键，使搜索框获得焦点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> search = <span class="variable language_">document</span>.<span class="title function_">queryAelector</span>(<span class="string">&#x27;input&#x27;</span>);</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;keyup&#x27;</span>,<span class="keyword">function</span>(<span class="params">e</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(e.<span class="property">keyCode</span> === <span class="number">83</span>)&#123;</span><br><span class="line">        search.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></blockquote><h3 id="网页特效"><a href="#网页特效" class="headerlink" title="网页特效"></a>网页特效</h3><h4 id="元素偏移量-offset"><a href="#元素偏移量-offset" class="headerlink" title="元素偏移量 offset"></a>元素偏移量 offset</h4><ul><li><p>获得元素距离带有定位父元素的位置</p></li><li><p>获得元素自身的大小（宽度高度）</p><blockquote><p>注意：返回的数值都不带单位</p></blockquote></li></ul><p>常用属性：</p><table><thead><tr><th>offset系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.offsetParent</td><td>返回该元素带有定位的父元素，如果父级都无定位则返回body</td></tr><tr><td>element.offsetTop</td><td>返回元素相对带有定位父元素上方的偏移</td></tr><tr><td>element.offsetLeft</td><td>返回元素相对带有定位父元素左边框的偏移</td></tr><tr><td>element.offsetWidth</td><td>返回自身包括padding、边框、内容区的宽度，返回数值不带单位</td></tr><tr><td>element.offsetHeight</td><td>返回自身包括padding、边框、内容区的高度，返回数值不带 单位</td></tr></tbody></table><p>offset与style的区别：</p><table><thead><tr><th>offset</th><th>style</th></tr></thead><tbody><tr><td>offset可以得到任意样式表中的样式值</td><td>style只能得到行内样式表中的样式值</td></tr><tr><td>offset系列获得的数值是没有单位的</td><td>style.width获得的是带有单位的字符串</td></tr><tr><td>offsetWidth包含padding+border+width</td><td>style.width获得不包含padding和border的值</td></tr><tr><td>offsetWidth等属性是只读属性，只能获取不能赋值</td><td>style.width是可读写属性，可以获取也可以赋值</td></tr></tbody></table><p>所以，想要获取元素大小位置，用offset更合适；想要给元素更改值，则需要用stye改变</p><h4 id="元素可视区-client"><a href="#元素可视区-client" class="headerlink" title="元素可视区 client"></a>元素可视区 client</h4><p>client翻译：客户端。可以动态获取元素可视区的相关信息</p><table><thead><tr><th>client系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.clientTop</td><td>返回元素上边框的大小</td></tr><tr><td>element.clientLeft</td><td>返回元素左边框的大小</td></tr><tr><td>element.clientWidth</td><td>返回自身包括padding、内容区的宽度，不含边框，返回数值不带单位</td></tr><tr><td>element.clientHeight</td><td>返回自身包括padding、内容区的高度，不含边框，返回数值不带单位</td></tr></tbody></table><h4 id="元素滚动-scroll"><a href="#元素滚动-scroll" class="headerlink" title="元素滚动 scroll"></a>元素滚动 scroll</h4><p>scroll翻译：滚动。可以动态的得到该元素的大小，滚动距离等</p><table><thead><tr><th>scroll系列属性</th><th>作用</th></tr></thead><tbody><tr><td>element.scrollTop</td><td>返回被卷去的上侧距离，返回数值不带单位</td></tr><tr><td>element.scrollLeft</td><td>返回被卷去的左侧距离，返回数值不带单位</td></tr><tr><td>element.scrollWidth</td><td>返回自身<strong>实际</strong>的宽度，不含边框，返回数值不带单位</td></tr><tr><td>element.scrollHeight</td><td>返回自身实际的高度，不含边框，返回数值不带单位</td></tr></tbody></table><p>常用方法：window.scroll(x, y) 滚动窗口至文档的特定位置</p><blockquote><p>offset系列经常用于获得元素位置 offsetLeft  offsetTop</p><p>client 经常用于获取元素大小 clientWidth  clientHeight</p><p>scroll 经常用于获取滚动距离 scrallTop  scrollLeft</p><p>注意：页面滚动的距离通过 window.pagexoffset 获得</p></blockquote><h4 id="动画函数封装"><a href="#动画函数封装" class="headerlink" title="动画函数封装"></a>动画函数封装</h4><p>动画实现原理：通过定时器setInterval() 不断移动盒子位置。</p><blockquote><p>步骤：</p><ol><li>获取盒子当前位置</li><li>让盒子在当前位置加上一个移动距离</li><li>利用定时器不断重复操作，并加一个结束的条件</li></ol><p>注意 此元素需要<strong>添加定位</strong>，才能使用element.style.left</p><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将移动效果封装成函数，调用即可</span></span><br><span class="line"><span class="comment">//obj是传入的对象，target是要移动的距离，callback为传入的其他函数，用于实现额外的效果</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">animate</span>(<span class="params">obj, target，callback</span>)&#123;</span><br><span class="line">    <span class="comment">//防止同一对象同时开启多个定时器(只保留当前一个定时器执行)</span></span><br><span class="line">    <span class="built_in">clearInterval</span>(obj.<span class="property">timer</span>); </span><br><span class="line">    <span class="comment">//将timer作为传入对象obj的属性，可以避免开辟过多空间</span></span><br><span class="line">    obj.<span class="property">timer</span> = <span class="built_in">setInterval</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> step = (target - obj.<span class="property">offsetLeft</span>) / <span class="number">10</span>;<span class="comment">//实现缓动效果，速度从快到慢</span></span><br><span class="line">        step = step &gt; <span class="number">0</span> ? <span class="title class_">Math</span>.<span class="title function_">ceil</span>(step) : <span class="title class_">Math</span>.<span class="title function_">floor</span>(step); <span class="comment">//去掉小数点</span></span><br><span class="line">    <span class="keyword">if</span>(obj.<span class="property">offsetLeft</span> &gt;= target)&#123;</span><br><span class="line">        <span class="title function_">cleatInterval</span>(obj.<span class="property">timer</span>); <span class="comment">//停止定时器</span></span><br><span class="line">        callback &amp;&amp; callback;<span class="comment">//如果回调函数存在就执行回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//步长值变化</span></span><br><span class="line">    obj.<span class="property">style</span>.<span class="property">left</span> = obj.<span class="property">offsetLeft</span> + s + <span class="string">&#x27;px&#x27;</span>;&#125;,<span class="number">15</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;div&#x27;</span>);</span><br><span class="line"><span class="title function_">animate</span>(div, <span class="number">300</span>);</span><br></pre></td></tr></table></figure></blockquote><p>因为动画函数经常被使用，所以可以将其单独封装到一个JS文件里面，使用的时候应用这个JS文件即可。</p><h4 id="节流阀"><a href="#节流阀" class="headerlink" title="节流阀"></a>节流阀</h4><p>作用：当上一个函数动画内容执行完毕，再取执行下一个函数动画，让事件不会连续过快触发。</p><p>思想：利用回调函数，添加一个变量来控制，所著函数和解锁函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag)&#123;</span><br><span class="line">    flag = <span class="literal">false</span>;</span><br><span class="line">    ......   <span class="comment">//动画安徽念书</span></span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><p>本地存储特性：</p><ul><li>数据存储在用户浏览器中</li><li>设置、读取方便、甚至页面刷新不丢失数据</li><li>容量较大，sessionStorage约5M、localStorage约20M</li><li>只能存储字符串，可以将对象SON.stringify0编码后存储</li></ul><hr><p><strong>sessionStorage</strong></p><p>特点：</p><ul><li>生命周期为关闭浏览器窗口</li><li>在同一个窗口页面下数据可以共享</li><li>以键值对的形式存储使用</li></ul><p>方法：</p><ul><li><p>存储数据：</p><p>sessionStorage.setItem（key, value）</p></li><li><p>获取数据：</p><p>sessionStorage.getItem（key）</p></li><li><p>删除数据：</p><p>sessionStorage.removeItem（key）</p></li><li><p>删除所有数据</p><p>sessionStorage.clear()</p></li></ul><hr><p><strong>localStorage</strong></p><p>特点：</p><ul><li>生命周期永久生效，除非手动删除否则关闭页面也会存在</li><li>可以多窗口（页面）共享（同一浏览器可以共享）</li><li>以键值对的形式存储使用</li></ul><p>方法：</p><ul><li><p>存储数据：</p><p>localStorage.setItem（key, value）</p></li><li><p>获取数据：</p><p>localStorage.getItem（key）</p></li><li><p>删除数据：</p><p>localStorage.removeItem（key）</p></li><li><p>删除所有数据</p><p>localStorage.clear()</p></li></ul><h3 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h3><p>jQuery是JavaScript库，封装了JS中的DOM操作。</p><blockquote><p>j 指 JavaScript，query 查询</p></blockquote><p>优点：</p><ul><li>轻量级。核心文件才几十kb,不会影响页面加截速度</li><li>跨浏览器兼容。基本兼容了现在主流的浏览器</li><li>链式编程、隐式迭代</li><li>对事件、样式、动画支持，大大简化了DOM操作</li><li>支持插件扩展开发。有着丰富的第三方的插件，例如：树形菜单、日期控件、轮播图等</li><li>免费、开源</li></ul><p><strong>入口函数</strong></p><p>等DOM接口渲染完毕即可执行内部代码，相当于原生js中的DOMContentLoaded</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">....  <span class="comment">//此处是页面DOM加载完成的入口</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h4><p><strong>顶级对象 $</strong></p><p>$是jQuery的别称，在代码中也可以使用jQuery代替$。</p><p>$是jQuery的顶级对象，相当于原生JS中的window。把元素利用$包装成jQuery对象，就可以调用jQuery的方法。</p><p><strong>jQuery对象 和 DOM对象</strong></p><p>用原生JS获取过来的对象就是DOM对象。</p><p>用 jQuery 方式获取过来的对象是jQuery)对象。本质：通过$把DOM元素进行了包装</p><blockquote><p>DOM对象只能使用原生的 JS 属性和方法</p><p>jQuery对象只能使用 jQuery 方法</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM对象</span></span><br><span class="line"><span class="keyword">var</span> myDiv = <span class="variable language_">document</span>.<span class="title function_">querySelect</span>(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="comment">//jQuery对象</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>jQuery对象 和 DOM对象 相互转换：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DOM对象转换为jQuery对象</span></span><br><span class="line">$(<span class="variable constant_">DOM</span>对象)</span><br><span class="line"><span class="comment">//jQuery对象转换为DOM对象</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>)[index]</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">get</span>(index)</span><br></pre></td></tr></table></figure><h4 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h4><h5 id="选择器操作"><a href="#选择器操作" class="headerlink" title="选择器操作"></a>选择器操作</h5><p><strong>选择器： $(“选择器”)</strong></p><p>**筛选选择器： **</p><table><thead><tr><th>语法</th><th>用法</th><th>说明</th></tr></thead><tbody><tr><td>:first</td><td>$(“li:first”)</td><td>获取第一个li元素</td></tr><tr><td>:last</td><td>$(“li:last”)</td><td>获取最后一个li元素</td></tr><tr><td>:eq(index)</td><td>$(“li:eq(2)”)</td><td>获取的li元素中，选择下标为2的元素</td></tr><tr><td>:odd</td><td>$(“li:odd”)</td><td>获取的li元素中，选择下标为奇数的元素</td></tr><tr><td>:even</td><td>$(“li:even”)</td><td>获取的li元素中，选择下标为偶数的元素</td></tr></tbody></table><p><strong>筛选方法：</strong></p><table><thead><tr><th><strong>语法</strong></th><th><strong>用法</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><strong>parent()</strong></td><td>$(“li”).parent()</td><td>查找父级</td></tr><tr><td><strong>children(selector)</strong></td><td>$(“ul”).children(“li”)</td><td>相当于$(“u1&gt;li”),最近一级（亲儿子）</td></tr><tr><td><strong>find(selector)</strong></td><td>$(“ul”).find(“li”);</td><td>相当于$(“ul li”), 后代选择器</td></tr><tr><td><strong>siblings(selector)</strong></td><td>$(“.first”).siblings(“li”);</td><td>查找兄弟节点，不包括自己本身</td></tr><tr><td>nextAll ([expr])</td><td>$(“.first”).nextAll ()</td><td>查找当前元素之后所有的同辈元素</td></tr><tr><td>prevAll (class)</td><td>$(“.last”).prevAll ()</td><td>查找当前元素之前所有的同辈元素</td></tr><tr><td>hasClass (class)</td><td>$(‘div’).hasclass(“protected”)</td><td>检查当前的元素是否含有某个特定的类，如果有，则返回true</td></tr><tr><td><strong>eq (index)</strong></td><td>$(“li”).eq(2);</td><td>相当于$(“1i:eq(2)”), index从0开始</td></tr></tbody></table><p><strong>jQuery使用排他思想：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：思想点击 背景颜色跟随</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//隐式迭代，给所有按钮绑定点击事件</span></span><br><span class="line">    $(<span class="string">&quot;button&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="comment">//当前元素设置背景颜色</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">        <span class="comment">//其余兄弟去掉背景颜色</span></span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">siblings</span>(<span class="string">&quot;button&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>链式编程：</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原来写法</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">siblings</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//链式编程写法，节省代码量，比较简洁</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;red&quot;</span>).<span class="title function_">siblings</span>().<span class="title function_">css</span>(<span class="string">&quot;color&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure><hr><h5 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h5><p><strong>设置样式：</strong></p><ul><li><p><strong>$(“选择器”).css(“属性”)</strong> —— 只写属性，则返回属性值</p></li><li><p><strong>$(“选择器”).css(“属性”,”值”)</strong> ——设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号</p></li><li><p><strong>$(“选择器”).css( {color: “red”, font-size: 20});</strong> ——参数是对象形式，可以设置多组样式，属性和值用冒号隔开，属性可以不加引号</p></li></ul><blockquote><p>DOM元素设置样式需要显式迭代，而jQuery对象是以伪数组形式存储，它在设置样式时会自动遍历内部DOM元素，即隐式迭代。</p></blockquote><p><strong>类操作：</strong></p><ul><li>添加类：**$(“div”).addClass(“类名”)**</li><li>删除类：**$(“div”).removeClass(“类名”)**</li><li>切换类：**$(“div”).toggleClass(“类名”)**</li></ul><blockquote><p>可以先为某个类设置样式，需要时再通过类操作来修改样式。</p></blockquote><hr><h5 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h5><p>显示隐藏</p><ul><li><p>**show **( [speed], [easing], [fn] ) —— 显示</p><blockquote><p>参数都可以省略，则无动画直接显示</p><p>speed：预定字符串(“slow”,”normal”,”fast”)或动画时长的毫秒值；</p><p>easing：用来指定切换效果，默认”swing“，可选参数“linear”；</p><p>fn：回调函数，在动画完成时执行，每个元素执行一次。</p><p>（一般都是不加参数直接显示隐藏的）</p></blockquote></li><li><p>**hide **( [speed, [easing], [fn]] ) —— 隐藏</p></li><li><p><strong>toggle</strong> ( [speed, [easing], [fn]] ) —— 切换显示和隐藏</p></li></ul><p>滑动</p><ul><li><strong>slideDown</strong> ( [speed, [easing], [fn]] ) —— 下拉</li><li><strong>slideUp</strong> ( [speed, [easing], [fn]] ) —— 上拉</li><li><strong>slideToggle</strong> ( [speed, [easing], [fn]] ) ——切换上下拉动</li></ul><p>淡入淡出</p><ul><li><p><strong>fadeIn</strong> ( [speed, [easing], [fn]] ) —— 淡入</p></li><li><p><strong>fadeOut</strong> ( [speed, [easing], [fn]] ) —— 淡出</p></li><li><p><strong>fadeToggle</strong> ( [speed, [easing], [fn]] ) —— 切换淡入淡出</p></li><li><p><strong>fadeTo</strong> ( [speed, opacity, [easing], [fn]] ) —— 修改透明度</p><blockquote><p>speed速度为动画时长，必须写，</p><p>opacity透明度必须写，</p></blockquote></li><li><p><strong>animate</strong> ( params, [speed], [easing], [fn] ) —— 自定义动画</p><blockquote><p>params： 样式选择，以对象形式传递，必须写</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="keyword">function</span>(<span class="params"></span></span><br><span class="line"><span class="params">&#123;$(<span class="string">&quot;button&quot;</span>).click(<span class="keyword">function</span>(&#123;</span></span><br><span class="line"><span class="params">  $(<span class="string">&quot;div&quot;</span>).antimate(&#123;</span></span><br><span class="line"><span class="params">        legt:<span class="number">200</span></span></span><br><span class="line"><span class="params">   &#125;);</span></span><br><span class="line"><span class="params">&#125;)</span></span><br><span class="line"><span class="params">&#125;</span>)</span><br></pre></td></tr></table></figure></li></ul><h5 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h5><p>hover 是鼠标经过和离开的复合写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数分别是鼠标经过和鼠标离开时分别调用的函数</span></span><br><span class="line">$(<span class="string">&quot;.nav&gt;li&quot;</span>).<span class="title function_">hover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;,<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="comment">//只写一个函数，则鼠标经过和离开都会调用这个函数</span></span><br><span class="line">$(<span class="string">&quot;.nav&gt;li&quot;</span>).<span class="title function_">hover</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">children</span>(<span class="string">&quot;ul&quot;</span>).<span class="title function_">slideToggle</span>();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="停止排队"><a href="#停止排队" class="headerlink" title="停止排队"></a>停止排队</h5><p>动画效果一旦触发就会执行，如果多次触发，就会使多个动画同时执行。</p><p>停止排队：<strong>stop()</strong> —— 用于停止动画效果。可以写到动画的前面，相当于停止上一次的动画。</p><hr><h5 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h5><p>获取元素固有属性的值：prop(“属性名”)</p><p>设置固有属性值： prop(“属性”，”属性值”)</p><blockquote><p>元素固有属性就是元素本身自带的属性，如&lt; a &gt;里的href，&lt; input &gt; 里的type。</p></blockquote><p>获取元素自定义属性的值：attr(“属性”)</p><p>设置元素自定义属性的值：attr(“属性”，“属性值”)</p><blockquote><p>类似原生的getAttribute()和setAttribute()</p></blockquote><p>数据缓存data()：可以在指定的元素上存取数据，并不会修改DOM元素结构，一旦页面刷新，之前存放的数据都将被移除。</p><p>获取：data(“属性”) ；设置：data(“属性”,”值”)</p><hr><h5 id="内容文本值"><a href="#内容文本值" class="headerlink" title="内容文本值"></a>内容文本值</h5><p>**普通元素内容：html()**，相当于原生innerHTML。</p><blockquote><p>获取：html()</p><p>设置：html(“内容”)</p></blockquote><p>**普通元素文本内容：text()**，相当于原生innerText。</p><blockquote><p>获取：text()</p><p>设置：text(“内容”)</p></blockquote><p><strong>表单的值 val()</strong> ，相当于原生value</p><blockquote><p>获取：val()</p><p>设置：val(“内容”)</p></blockquote><hr><h5 id="元素操作-1"><a href="#元素操作-1" class="headerlink" title="元素操作"></a>元素操作</h5><p>jQuery隐式迭代是对同一类元素做同样的操作，如果想要给同一元素做不同操作，仍需要遍历。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>.<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params">index,domEle</span>)&#123;...&#125;))</span><br></pre></td></tr></table></figure><blockquote><p>index是每个元素的索引号，domEle是每个DOM元素对象，注意不是jquery对象，要用jquery方法，需要进行对象转化。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">each</span>(object, <span class="keyword">function</span>(<span class="params">index, element</span>)&#123;&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>object可以是任何对象，所以$each主要用于数据处理，如数组，对象；</p></blockquote><h5 id="尺寸、位置操作"><a href="#尺寸、位置操作" class="headerlink" title="尺寸、位置操作"></a>尺寸、位置操作</h5><p>尺寸：</p><table><thead><tr><th>语法</th><th>说明</th></tr></thead><tbody><tr><td>width() &#x2F; height()</td><td>只算width &#x2F; height</td></tr><tr><td>innerWidth() &#x2F; innerHeight()</td><td>包含padding</td></tr><tr><td>outerWidth() &#x2F; outerHeight()</td><td>包含padding、border</td></tr><tr><td>outerWidth(true) &#x2F; outerHeight(true)</td><td>包含padding、borde、margin</td></tr></tbody></table><p>位置：</p><p>offset()</p><p>设置或返回距离文档的位置(偏移)，跟父级没有关系。offset().left 获取距离文档左侧的距离， offset().top 获取距离文档顶部的距离</p><ul><li>scrollTop()</li></ul><p>设置或返回被卷去的头部。</p><p>同样有 scrollTop().left 和 scrollTop().top 两个属性。</p><h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><h5 id="注册事件"><a href="#注册事件" class="headerlink" title="注册事件"></a>注册事件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">element.事件(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)</span><br><span class="line"><span class="comment">//例:</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">click</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p><strong>on() 绑定事件</strong>：匹配元素上绑定一个或多个事件的处理函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">on</span>(events, [selector], fn)</span><br></pre></td></tr></table></figure><p>events：一个或多个用空格分割的事件类型；</p><p>selector：元素的子元素选择器；</p><p>fn：回调函数；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绑定多个事件，多个处理程序</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">on</span>(&#123;</span><br><span class="line">    <span class="attr">mouseenter</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>, <span class="string">&quot;skyblue&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">click</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        $(<span class="variable language_">this</span>).<span class="title function_">css</span>(<span class="string">&quot;background&quot;</span>,<span class="string">&quot;purple&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//如果绑定事件的处理程序相同:</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">in</span>(<span class="string">&quot;mouseover mouseout&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    $(<span class="variable language_">this</span>).<span class="title function_">toggleClass</span>(<span class="string">&quot;current&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以实现事件委派，把原来加给子元素的事件绑定到父元素上。</span></span><br><span class="line"><span class="comment">//点击事件绑定在ul上，但触发对象是li</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//on()可以给动态生成的元素绑定事件,而原来的 $(&quot;&quot;).事件(fn)不能给动态创建的元素绑定事件</span></span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> li = $(<span class="string">&quot;&lt;li&gt;我是后来创建的&lt;/li&gt;&quot;</span>);</span><br><span class="line">$(<span class="string">&quot;ul&quot;</span>).<span class="title function_">append</span>(li);</span><br></pre></td></tr></table></figure><p><strong>one() 绑定事件，只触发一次</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">one</span>(<span class="string">&quot;click&quot;</span>,<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>off() 解绑事件</strong> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">off</span>();  <span class="comment">//移除div身上的所有事件</span></span><br><span class="line">$(<span class="string">&quot;div&quot;</span>).<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>);   <span class="comment">//移除div身上的点击事件</span></span><br><span class="line">(<span class="string">&quot;ul&quot;</span>).<span class="title function_">off</span>(<span class="string">&quot;click&quot;</span>,<span class="string">&quot;li&quot;</span>);<span class="comment">//接触li的事件委托</span></span><br></pre></td></tr></table></figure><p>**trigger() 自动触发事件 ** ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">element.<span class="title function_">trigger</span>(<span class="string">&quot;type&quot;</span>);</span><br><span class="line"><span class="comment">//如：</span></span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">on</span>(<span class="string">&quot;click&quot;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br><span class="line">....    </span><br><span class="line">$(<span class="string">&quot;p&quot;</span>).<span class="title function_">trigger</span>(<span class="string">&quot;click&quot;</span>); <span class="comment">//此时自动触发事件</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//触发事件，但不触发元素的默认行为</span></span><br><span class="line">element.<span class="title function_">triggerHandler</span>(<span class="string">&quot;type&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><p>ECharts是一个使用JavaScript实现的开源可视化库，兼容大部分浏览器，底层依赖矢量图形库ZRender。</p><h2 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h2><p>xml 是可扩展的标记性语言。</p><p>作用：</p><ul><li>主要用于存储数据，这些数据具有自我描述性；</li><li>作为项目或者模块的配置文件；</li><li>作为网络传输数据的格式（现在改为使用 JSON 为主了）。</li></ul><p>语法</p><ul><li><p>文档声明</p><p>xml声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure><ul><li>version 是版本的意思， </li><li>encoding 是编码，</li><li>standalone&#x3D;”yes&#x2F;no” 表示这个 xml 文件是否是独立的 xml文件</li></ul></li><li><p>元素（标签） </p><p>元素是指从开始标签到结束标签的内容。（与html一样）</p><p>注意<strong>大小写敏感</strong>，元素都必须<strong>闭合</strong>，必须<strong>有根元素</strong></p><p>命名规则：</p><ul><li>可以包含字母，数字，其他字符（包括中文）；</li><li>不能以数字或标点符号开头；</li><li>不能包含空格；</li></ul><p>元素(标签) 分 单双标签：</p><ul><li>单标签： &lt; 标签名 属性&#x3D;”值“ 属性&#x3D;”值“ …. &#x2F;&gt;</li><li>双标签：&lt; 标签名 属性&#x3D;”值“ …&gt; 文本或子标签 &lt;&#x2F;标签名&gt;</li></ul></li><li><p>xml 属性 </p><p>与html非常类似，注意属性的值要用 引号” “ 包起来。</p></li><li><p>文本区域（CDATA 区）</p><p>说明此区域是纯文本内容，不需要xml语法解析</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[</span><br><span class="line">文本内容，不会被xml解析</span><br><span class="line">]]&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h3><p>dom4j 解析技术是第三方公司的技术，需要到其官网上下载dom4j的jar包，导入到idea的库中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要分四步操作:</span></span><br><span class="line"><span class="comment">// 第一步，通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象</span></span><br><span class="line"><span class="comment">// 第二步，通过 Document 对象。拿到 XML 的根元素对象</span></span><br><span class="line"><span class="comment">// 第三步，通过根元素对象。获取所有的 book 标签对象</span></span><br><span class="line"><span class="comment">// 第四小，遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readXML</span><span class="params">()</span> <span class="keyword">throws</span> DocumentException &#123;</span><br><span class="line"><span class="comment">// 第一步，通过创建 SAXReader 对象。来读取 xml 文件，获取 Document 对象</span></span><br><span class="line"><span class="type">SAXReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SAXReader</span>();</span><br><span class="line"><span class="type">Document</span> <span class="variable">document</span> <span class="operator">=</span> reader.read(<span class="string">&quot;src/books.xml&quot;</span>);</span><br><span class="line"><span class="comment">// 第二步，通过 Document 对象。拿到 XML 的根元素对象</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">root</span> <span class="operator">=</span> document.getRootElement();</span><br><span class="line"><span class="comment">// 打印测试</span></span><br><span class="line"><span class="comment">// Element.asXML() 它将当前元素转换成为 String 对象</span></span><br><span class="line"><span class="comment">// System.out.println( root.asXML() );</span></span><br><span class="line"><span class="comment">// 第三步，通过根元素对象。获取所有的 book 标签对象</span></span><br><span class="line"><span class="comment">// Element.elements(标签名)它可以拿到当前元素下的指定的子元素的集合</span></span><br><span class="line">List&lt;Element&gt; books = root.elements(<span class="string">&quot;book&quot;</span>);</span><br><span class="line"><span class="comment">// 第四小，遍历每个 book 标签对象。然后获取到 book 标签对象内的每一个元素，</span></span><br><span class="line"><span class="keyword">for</span> (Element book : books) &#123;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="comment">// System.out.println(book.asXML());</span></span><br><span class="line"><span class="comment">// 拿到 book 下面的 name 元素对象</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">nameElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 拿到 book 下面的 price 元素对象</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">priceElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;price&quot;</span>);</span><br><span class="line"><span class="comment">// 拿到 book 下面的 author 元素对象</span></span><br><span class="line"><span class="type">Element</span> <span class="variable">authorElement</span> <span class="operator">=</span> book.element(<span class="string">&quot;author&quot;</span>);</span><br><span class="line"><span class="comment">// 再通过 getText() 方法拿到起始标签和结束标签之间的文本内容</span></span><br><span class="line">System.out.println(<span class="string">&quot;书名&quot;</span> + nameElement.getText() + <span class="string">&quot; , 价格:&quot;</span> + priceElement.getText() + <span class="string">&quot;, 作者：&quot;</span> + authorElement.getText());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>JSON ( JavaScript Object Notation) 是一种轻量级的数据交换格式。易于人阅读和编写。同时也易于机器解析和生成。</p><p>JSON 采用完全独立于语言的文本格式，而且很多语言都提供了对 json 的支持（包括 C, C++, C#, Java, JavaScript, Perl, Python 等）。 使得 JSON 成为理想的数据交换格式。</p><ul><li>其语法格式简单，层次结构鲜明，现多用于作为 数据载体，在网络中进行数据传输。</li></ul><blockquote><p>轻量级是相较xml而言；</p><p>数据交换指的是客户端和服务器之间业务数据的传递格式</p></blockquote><p><strong>定义：</strong></p><ul><li>json由键值对组成，用大括号包围；</li><li>每个键都用双引号包起来；</li><li>键与值之间用冒号分割。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonObj = &#123;</span><br><span class="line">    <span class="string">&quot;key1&quot;</span>:<span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;key2&quot;</span>:<span class="string">&quot;abc&quot;</span>,</span><br><span class="line">    <span class="string">&quot;key3&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">    <span class="string">&quot;key4&quot;</span>:[<span class="number">11</span>,<span class="string">&quot;arr&quot;</span>,<span class="literal">false</span>],</span><br><span class="line">    <span class="string">&quot;key5&quot;</span>:&#123;</span><br><span class="line">        <span class="string">&quot;key5_1&quot;</span> : <span class="number">551</span>,</span><br><span class="line">        <span class="string">&quot;key5_2&quot;</span> : <span class="string">&quot;key5_2_value&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&quot;key6&quot;</span>:[&#123;</span><br><span class="line">            <span class="string">&quot;key6_1_1&quot;</span>:<span class="number">6611</span>,</span><br><span class="line">            <span class="string">&quot;key6_1_2&quot;</span>:<span class="string">&quot;key6_1_2_value&quot;</span></span><br><span class="line">        &#125;,&#123;</span><br><span class="line">            <span class="string">&quot;key6_2_1&quot;</span>:<span class="number">6621</span>,</span><br><span class="line">            <span class="string">&quot;key6_2_2&quot;</span>:<span class="string">&quot;key6_2_2_value&quot;</span></span><br><span class="line">        &#125;]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>访问：</strong></p><p>json本身是一个对象，访问： json对象.key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alert(typeof(jsonObj));<span class="comment">// object json 就是一个对象</span></span><br><span class="line">alert(jsonObj.key1); <span class="comment">//12</span></span><br><span class="line">alert(jsonObj.key2); <span class="comment">// abc</span></span><br><span class="line">alert(jsonObj.key3); <span class="comment">// true</span></span><br><span class="line">alert(jsonObj.key4);<span class="comment">// 得到数[11,&quot;arr&quot;,false]</span></span><br><span class="line"><span class="comment">// json 中 数组值的遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; jsonObj.key4.length; i++)&#123;</span><br><span class="line">alert(jsonObj.key4[i]);</span><br><span class="line">&#125;</span><br><span class="line">alert(jsonObj.key5.key5_1);<span class="comment">//551</span></span><br><span class="line">alert(jsonObj.key5.key5_2);<span class="comment">//key5_2_value</span></span><br><span class="line">alert( jsonObj.key6 );<span class="comment">// 得到 json 数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出来每一个元素都是 json 对象</span></span><br><span class="line"><span class="type">var</span> <span class="variable">jsonItem</span> <span class="operator">=</span> jsonObj.key6[<span class="number">0</span>];</span><br><span class="line">alert( jsonItem.key6_1_1 ); <span class="comment">//6611</span></span><br><span class="line">alert( jsonItem.key6_1_2 ); <span class="comment">//key6_1_2_value</span></span><br></pre></td></tr></table></figure><p><strong>方法：</strong></p><p>json有两种存在形式：</p><ul><li>json对象：用于操作json中的数据；</li><li>json字符串：用于客户端和服务器之间数据交换时；</li></ul><p>转换方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">json.stringify()   <span class="comment">//json对象 转换为 json字符串</span></span><br><span class="line">json.parse()<span class="comment">//json字符串 转换为 json对象</span></span><br></pre></td></tr></table></figure><p><strong>解析转换：</strong></p><blockquote><p>jackson：</p><p>Spring MVC 默认采用Jackson解析Json，尽管还有一些其它同样优秀的json解析工具，例如Fast Json、GSON，但是出于最小依赖的考虑，也许Json解析第一选择就应该是Jackson。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><hr><p>Fastjson：</p><p>Fastjson是阿里巴巴提供的一个Java语言编写的高性能功能完善的SON库，是目前ava语言中最快的 JSON库，可以实现Java对象和 JSON字符串的相互转换。但拓展性不高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java对象 转 json字符串</span></span><br><span class="line">String java对象 = JSON.toJSONString(对象);</span><br><span class="line"><span class="comment">//json字符串 转 java对象</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> JSON.parseObject(jsonStr,User.class); <span class="comment">//User为某一个类</span></span><br></pre></td></tr></table></figure></blockquote><p>gson的一些使用（还是建议使用jackson）：</p><p><strong>javaBean和json互转：</strong></p><p>使用GSON，它是Google提供的用来在Java对象和 JSON数据之间进行映射的Java类库。</p><ul><li>创建gosn对象</li><li>gosn.toJson（json对象)  </li><li>gson.fromJson（json字符串，javaBean类名.class)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1</span>,<span class="string">&quot;zzc&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建 Gson 对象实例</span></span><br><span class="line">    <span class="type">Gson</span> <span class="variable">gson</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Gson</span>();</span><br><span class="line">    <span class="comment">// toJson 方法可以把 java 对象转换成为 json 字符串</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">personJsonString</span> <span class="operator">=</span> gson.toJson(person);</span><br><span class="line">    System.out.println(personJsonString);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一个参数是 json 字符串</span></span><br><span class="line">    <span class="comment">// 第二个参数是转换回去的 Java 对象类型</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">person1</span> <span class="operator">=</span> gson.fromJson(personJsonString, Person.class);</span><br><span class="line">    System.out.println(person1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>list和json互转：</strong></p><ul><li>创建gosn对象</li><li>gosn.toJson（list)  </li><li>gson.fromJson（json字符串，list.getclass())</li></ul><p><strong>map和json互转：</strong></p><ul><li>创建gosn对象</li><li>gosn.toJson（map)  </li><li>gson.fromJson（json字符串， new TypeToken&lt;HashMap&lt;对应类，对应类&gt;&gt;(){}.getType() );</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a><strong>Vue</strong></h2><p><strong>Vue是一套前端框架，免除原生JavaScripte中的DOM操作，简化书写。</strong></p><blockquote><p><strong>基于MWM(Model-View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上。</strong></p><p><strong>其中 ViewModel 有Vue提供。</strong></p></blockquote><p>使用：</p><p>1.声明</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;/pro03-vue/script/vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a><strong>Tomcat</strong></h2><blockquote><p><strong>Web服务器：是一个应用程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让Web开发更加便捷。主要功能是 “提供网上信息浏览服务”。</strong></p></blockquote><p><strong>Tomcat ：是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet &#x2F; JSP 和少量JavaEE规范。</strong></p><ul><li><p>启动Tomcat服务器：</p><p>到bin目录下，双击startup.bat启动，双击shutdown.bat关闭</p></li><li><p>修改Tomcat的端口号：</p><p>mysql默认的端口号是3306，Tomcat默认的端口号是8080，HTTP协议默认的端口号是80；</p><p>修改：到conf目录下，修改server.xml配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在69行附近 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">port</span>=<span class="string">&quot;8080&quot;</span> <span class="attr">protocol</span>=<span class="string">&quot;HTTP/1.1&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">connectionTimeout</span>=<span class="string">&quot;20000&quot;</span></span></span><br><span class="line"><span class="tag">               <span class="attr">redirectPort</span>=<span class="string">&quot;8443&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 修改其中的port=&quot;8080&quot;即可 --&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p><strong>Tomcat 部署项目：将项目放置到webapps目录下，即部署完成。</strong></p><ul><li><strong>一般JavaWeb项目会被打成war包，然后将war包放到webapps目录下，Tomcat会自动解压缩war文件</strong></li></ul><p>第二种部署方式：</p><p>项目不需要放在webapps下，可以放在任何地方；</p><p>找到 Tomcat 下的 conf 目录\Catalina\localhost\ 下,创建配置文件，如abc.xml，配置文件内容如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Context 表示一个工程上下文 </span></span><br><span class="line"><span class="comment">path 表示工程的访问路径:/abc</span></span><br><span class="line"><span class="comment">docBase 表示你的工程目录在哪里</span></span><br><span class="line"><span class="comment">即url中输入path，也就是/abc,路径就会到docBase那里</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span> <span class="attr">path</span>=<span class="string">&quot;/abc&quot;</span> <span class="attr">docBase</span>=<span class="string">&quot; &quot;</span> /</span></span><br></pre></td></tr></table></figure></blockquote><ul><li>当浏览器地址栏输入访问地址为： http :&#x2F;&#x2F;ip:port&#x2F; 时，也就是没有工程名时，默认访问webapps下的ROOT工程；</li><li>当浏览器地址栏输入访问地址为： http :&#x2F;&#x2F;ip:port&#x2F; 工程名&#x2F; 时，也就是没有资源名时，默认访问工程下的index.html页面；</li></ul><hr><p><strong>在IDEA中创建Maven Web项目：</strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705819.jfif" alt="image-20220224192255613"></strong></p><ul><li><strong>编译后的 java字节码文件和resources的资源文件，放到WEB-INF 下的 classes目录下；</strong></li><li><strong>pom.xml中依赖坐标对应的jar包，放入WEB-INF下的Iib目录下；</strong><ul><li>WEB-INF是一个受服务器保护的目录，浏览器无法直接访问此目录的内容；</li></ul></li></ul><p><strong>创建方式：</strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705820.png" alt="image-20220224192858734"></strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705821.png" alt="image-20220224193548166"></strong></p><blockquote><p><strong>WEB-INF放到webapp目录下</strong></p></blockquote><hr><p><strong>在IDEA中使用Tomcat：</strong></p><ul><li><strong>方法一：集成本地Tomcat</strong></li></ul><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705822.png" alt="image-20220224194330615"></strong></p><ul><li><strong>方法二：Tomcat Maven插件</strong></li></ul><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705823.png" alt="image-20220224194749638"></strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Tomcat插件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">port</span>&gt;</span>80<span class="tag">&lt;/<span class="name">port</span>&gt;</span> <span class="comment">&lt;!--默认是8080--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">path</span>&gt;</span>/<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><hr><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a><strong>Servlet</strong></h2><blockquote><p>JavaWeb三大组件：Servlet、.Filter、Listener；</p></blockquote><p><strong>Servlet是 Java提供的一门 动态web资源开发技术。</strong></p><p><strong>Servlet是javaEE规范之一，也就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet。</strong></p><p>Servlet可以接收客户端发过来的请求，并响应数据给客户端；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Servlet</span></span><br></pre></td></tr></table></figure><hr><h3 id="使用servlet："><a href="#使用servlet：" class="headerlink" title="使用servlet："></a>使用servlet：</h3><ol><li><strong>创建Web项目，导入Servlet依赖坐标</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api <span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!-- Tomcat有servlet的jar包，所以这里的servlet不要带到运行环境去，因此使用provided;--&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p><strong>创建：定义一个类，实现Servlet接口，并重写接口中所有方法。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">service</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置：在类上使用@WebServlet注解，配置该Servlet的访问路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">Servlet</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>访问：启动Tomcat,浏览器输入URL访问该Servlet</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/web-demo/demo1</span><br></pre></td></tr></table></figure></li></ol><hr><p><strong>执行流程</strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705824.png" alt="image-20220228110919940"></strong></p><hr><p><strong>生命周期</strong></p><p><strong>Servlet运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：</strong></p><ol><li><p><strong>加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象</strong></p></li><li><p><strong>初始化：在Servlet实例化之后，容器将调用Servlet的 init()方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次</strong></p><blockquote><p><strong>可以在注解中修改init()调用的时机：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(urlPatterns=&quot;/demo&quot;,loadOnStartup=1)</span></span><br><span class="line"><span class="comment">//负整数：第一次被访问时创建 Servlet对象</span></span><br><span class="line"><span class="comment">//0或正整数：服务器启动时创建Servlet对象，数字越小优先级越高</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>请求处理&#x2F;服务：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。</strong></p></li><li><p><strong>服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放。在destroy()方法调用之后，容器会释放这个Servlet实例，该实例随后会被Java的垃圾收集器所回收</strong></p></li></ol><hr><p><strong>Servlet体系结构</strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705825.png" alt="image-20220228113253739"></strong></p><p><strong>开发B&#x2F;S架构的web项目，都是针对HTTP协议，所以自定义的Servlet都是继承HttpServlet。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/demo1&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletDemo1</span> <span class="keyword">implements</span> <span class="title class_">HttpServlet</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">((HttpServletRequest req,HttpServletResponse resp)</span>&#123;</span><br><span class="line"><span class="comment">//TOOD Get 请求方式处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req,HttpservletResponse resp)</span>&#123;</span><br><span class="line"><span class="comment">//TOOD Post 清求方式处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="ServletConfig类"><a href="#ServletConfig类" class="headerlink" title="ServletConfig类"></a>ServletConfig类</h3><p>ServletConfig类是Servlet程序的配置信息类。</p><ul><li>Servlet程序和ServletConfig对象都是由Tomcat负责创建；</li><li>Servlet程序默认第一次访问时创建，而每个Servlet程序创建时都会创建一个对应的ServletConfig对象。</li></ul><p>方法：</p><ul><li>getServletName() —— 获取Servlet程序的别名 servlet-name 的值</li><li>getInitParameter(“ “) —— 获取初始化参数 init-param （括号里写param-name的值，得到param-value值）</li><li>getServletContext() —— 获取ServletContext对象</li></ul><hr><blockquote><p>注： 如果<strong>重写了HttpServlet类的init方法</strong>，一定要**调用父类的init(ServletConfig)**，因为HttpServlet类的init方法里，保存了ServletConfig对象，不然的话，调用getInitParameter(“ “)方法会报错。</p></blockquote><p><strong>web.xml配置</strong>：设置servlet程序的别名，访问路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- servlet 标签给 Tomcat 配置 Servlet 程序 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签 Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-class 是 Servlet 程序的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--init-param 是初始化参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql://localhost:3306/test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给 servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个 Servlet 程序使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">url-pattern 标签配置访问地址 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">/ 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径 &lt;br/&gt;</span></span><br><span class="line"><span class="comment">/hello 表示地址为：http://ip:port/工程路径/hello &lt;br/&gt;</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ServletContext"><a href="#ServletContext" class="headerlink" title="ServletContext"></a>ServletContext</h3><ul><li>ServletContext是一个接口，它<strong>表示Servlet上下文对象</strong>；</li><li>一个 web工程中<strong>只有一个 ServletContext 对象实例</strong>；</li><li>ServletContext 对象是一个<strong>域对象</strong>；</li><li>ServletContext 是在 web工程部署启动的时候创建。在 web工程停止的时候销毁；</li></ul><blockquote><p>域对象： 是可以像Map一样存取数据的对象，这里的域指存取数据的操作范围，即整个web工程；</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ServletContext对象</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletConfig().getServletContext();</span><br><span class="line"><span class="comment">//直接get也可以，本质上也是调用getServletConfig().getServletContext();</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">context</span> <span class="operator">=</span> getServletContext();</span><br></pre></td></tr></table></figure><p>方法：</p><ul><li><p>getInitParameter(“…”) —— 获取 web.xml 中配置的上下文参数 context-param （括号里写param-name值，得到param-value值）</p></li><li><p>getContextPath() —— 获取当前的工程路径，格式: &#x2F;工程路径 </p></li><li><p>getRealPath(“&#x2F;“) —— 获取工程部署后在服务器硬盘上的绝对路径 </p><blockquote><p>getRealPath(“&#x2F;“) —— 工程部署的路径</p><p>getRealPath(“&#x2F;css”) —— 工程下 css 目录的绝对路径</p></blockquote></li><li><p>像 Map 一样存取数</p><table><thead><tr><th></th><th>存数据</th><th>取数据</th><th>删除数据</th></tr></thead><tbody><tr><td>Map</td><td>put()</td><td>get()</td><td>remove()</td></tr><tr><td>域对象</td><td>setAttribute()</td><td>getAttribute()</td><td>removeAttribute()</td></tr></tbody></table></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- web.xml中相关配置信息  --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个 web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议是 客户端和服务器之间通信时要发送的数据，需要遵守的规则； HTTP 协议中的数据又叫报文。</p><ul><li>请求 Request：客户端给服务器发送数据。<ul><li>GET请求</li><li>POST请求</li></ul></li><li>响应 Response：服务器给客户端回传数据。</li></ul><hr><p><strong>GET请求的组成：</strong></p><ul><li><p>请求行： 请求方式  请求的资源路径  请求的协议版本号</p><p>如： GET  &#x2F;servlet_1&#x2F;a.html  HTTP&#x2F;1.1</p></li><li><p>请求头：以键值对的形式组成</p><ul><li>Accept： 告诉服务器，客户端可以接收的数据类型；</li><li>Accept-Language：告诉服务器，客户端可以接收的语言类型，如：zh_CN指中文中国，en_US指英文美国；</li><li>User-Agent：就是浏览器的信息；</li><li>Accept-Encoding：告诉服务器，客户端可以接收的数据编码（压缩）格式</li><li>Host：表示请求的股务器ip和端口号</li><li>Connection:告诉服务器诗求连接如何处理<ul><li>Keep-Alive ：告诉服务器回传数据不要马上关闭，保持一小段时间的连接；</li><li>Closed：马上关闭</li></ul></li></ul></li></ul><p><strong>POST请求的组成：</strong></p><ul><li><p>请求行： 请求方式  请求的资源路径  请求的协议版本号</p></li><li><p>请求头：</p><ul><li><p>Accept：表示客户端可以接收的数据类型；</p></li><li><p>Accept-Language：表示客户端可以接收的语言类型；</p></li><li><p>Referer：表示请求发起时，浏览器地址栏中的地址（从哪来）</p></li><li><p>User-Agent：表示浏览器的信息</p></li><li><p>Content-Type：表示发送的数据的类型</p><blockquote><p>如：application&#x2F;x-www-form-ur lencoded ： 表示提交的数据格式是 name&#x3D;value&amp;name&#x3D;value,然后对其进行urI编码，使非英文内容转换为：%xx%xx</p><p>multipart&#x2F;form-data  ：表示以多段的形式提交数据给服务器 (以流的形式提交，用于上传)</p></blockquote></li><li><p>Content-Lnegth：表示发送的数据的长度</p></li><li><p>Cache-Control：表示如何控制缓存， no-cache 指不缓存</p></li></ul></li><li><p>空行 （请求头和请求体之间隔一空行）</p></li><li><p>请求体：发给服务器的数据</p></li></ul><blockquote><p><strong>区分</strong>GET请求和POST请求：</p><p>POST请求有：</p><ul><li>form 标签中 method&#x3D;post</li></ul><p>GET请求有：</p><ul><li>form 标签 method&#x3D;get</li><li>a标签</li><li>link标签引入css</li><li>Script标签引入js文件</li><li>img标签引入图片</li><li>iframe 引入html页面</li><li>在浏览器地址栏中输入地址后敲回车</li></ul></blockquote><hr><p><strong>响应 的组成：</strong></p><ul><li>响应行：响应的协议和版本号  状态码  状态描述符</li><li>响应头：以键值对形式组成<ul><li>Server：表示服务器的信息；</li><li>Content-Type：表示响应体的数据类型；</li><li>Content-Length：响应体的长度；</li><li>Date：请求响应的时间（格林时间）；</li></ul></li><li>空行</li><li>响应体：（就是回传给客户端的数据）</li></ul><p><strong>常用响应码：</strong></p><ul><li>200 —— 请求成功</li><li>302 —— 请求重定向</li><li>404 —— 表示请求服务器已收到，但所要的数据不存在&#x2F;请求地址错误</li><li>500 —— 表示服务器已经收到请求，但服务器内部错误（错误代码）</li></ul><hr><p><strong>MIME类型</strong></p><p>MIME类型 指的是HTTP协议中的数据类型 —— Multipurpose Internet Mail Extensions 多功能Internet邮件扩充服务。</p><p>格式：大类型&#x2F;小类型</p><p>常见的MIME类型：</p><table><thead><tr><th>文件</th><th>后缀</th><th>MIME类型</th></tr></thead><tbody><tr><td>超文本标记语言文本</td><td>.html   .htm</td><td>text&#x2F;html</td></tr><tr><td>普通文本</td><td>.txt</td><td>text&#x2F;plain</td></tr><tr><td>RTF文本</td><td>.rtf</td><td>application&#x2F;rtf</td></tr><tr><td>GIF图形</td><td>.gif</td><td>image&#x2F;gif</td></tr><tr><td>JPEG图形</td><td>.jpeg   .jpg</td><td>image&#x2F;jpeg</td></tr><tr><td>au声音文件</td><td>.au</td><td>audio&#x2F;basic</td></tr><tr><td>MIDI音乐文件</td><td>.mid   .midi</td><td>audio&#x2F;midi,  audio&#x2F;x-midi</td></tr><tr><td>RealAudio音乐文件</td><td>.ra    .ram</td><td>audio&#x2F;x-pn-realaudio</td></tr><tr><td>AVI文件</td><td>.avi</td><td>vidio&#x2F;mpeg</td></tr><tr><td>GZIP文件</td><td>.gz</td><td>video&#x2F;x-msvideo</td></tr><tr><td>TAR文件</td><td>.tar</td><td>application&#x2F;x-gzip</td></tr><tr><td>MPEG文件</td><td>v</td><td>application&#x2F;x-tar</td></tr></tbody></table><hr><h3 id="HttpServletRequest类"><a href="#HttpServletRequest类" class="headerlink" title="HttpServletRequest类"></a>HttpServletRequest类</h3><p>每次只要有请求进入 Tomcat 服务器，Tomcat 服务器就会把请求过来的 HTTP 协议信息解析好封装到 Request 对象中。 然后传递到 service 方法（doGet 和 doPost）中给我们使用。</p><p>而通过 HttpServletRequest 对象，可以获取到所有 请求 的信息。</p><p>方法：</p><ul><li>getRequestURI（） 获取请求的资源路径</li><li>getRequestURL（） 获取请求的统一资源定位符（绝对路径）</li><li>getRemoteHost（） 获取客户端的ip地址</li><li>getHeader（） 获取请求头</li><li>getParameter（） 获取请求的参数</li><li>getParameterValues（） 获取请求的参数（多个值的时候使用）</li><li>getMethod（）  获取请求的方式GET或POST</li><li>setAttribute(key,value)    设置域数据</li><li>getAttribute(key)   获取域数据</li><li>getRequestDispatcher（）  获取请求转发对象</li></ul><blockquote><p>如果doPost中获取数据出现中文乱码，可以设置请求体的字符集为UTF-8：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">req.setCharacterEncoding(<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//设置字符集要写在获取请求参数之前，否则不生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h3 id="HttpServletResponse类"><a href="#HttpServletResponse类" class="headerlink" title="HttpServletResponse类"></a>HttpServletResponse类</h3><p>HttpServletResponse 类和 HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个 Response 对象传递给 Servlet 程序去使用。</p><p>HttpServletRequest表示请求过来的信息，HttpServletResponse 表示所有响应的信息，；我们如果需要设置返回给客户端的信息，都可以通过 HttpServletResponse对象来进行设置。</p><p><strong>两个输出流：</strong></p><ul><li>字节流 getOutputStream()  ——  常用于下载（传递二进制数据）</li><li>字符流  getWriter()  —— 常用于回传字符串（常用）</li></ul><blockquote><p>两个流同时只能使用一个。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ResponseIOServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="comment">//resp.setContentType(&quot;text/html; charset=UTF-8&quot;);  用于解决响应中文乱码：它会同时设置服务器和客户端都使用UTF-8字符集，还设置了响应头；注：要在获取流对象之前使用才有效；    </span></span><br><span class="line">    <span class="comment">// 要求: 往客户端回传 字符串 数据。</span></span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">writer</span> <span class="operator">=</span> resp.getWriter();</span><br><span class="line">    writer.write(<span class="string">&quot;response&#x27;s content!!!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><p>是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问，叫请求 重定向。（因为之前的地址可能已经被废弃）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">&quot;新地址&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>请求转发&#x2F;内部转发：</strong></p><p>意思是：服务器收到请求后，从一个资源跳转到另一个资源。即<strong>服务器内部转发</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">&quot;demo07&quot;</span>).forward(request,response);</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203311638672.png" alt="image-20220329114857941"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//办事处1 —— Servlet1程序</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line"><span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line"><span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;在 Servlet1（柜台 1）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 给材料 盖一个章，并传递到 Servlet2（柜台 2）去查看</span></span><br><span class="line">req.setAttribute(<span class="string">&quot;key1&quot;</span>,<span class="string">&quot;柜台 1 的章&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 问路：Servlet2（柜台 2）怎么走</span></span><br><span class="line">    <span class="comment">// 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到 IDEA 代码的 web 目录</span></span><br><span class="line">    <span class="type">RequestDispatcher</span> <span class="variable">requestDispatcher</span> <span class="operator">=</span> req.getRequestDispatcher(<span class="string">&quot;/servlet2&quot;</span>);</span><br><span class="line">    <span class="comment">// RequestDispatcher requestDispatcher = req.getRequestDispatcher(&quot;http://www.baidu.com&quot;);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 走向 Sevlet2（柜台 2）</span></span><br><span class="line">    requestDispatcher.forward(req,resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//办事处2 —— Servlet2程序</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">    <span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> req.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;在 Servlet2（柜台 2）中查看参数（材料）：&quot;</span> + username);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查看 柜台 1 是否有盖章</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">key1</span> <span class="operator">=</span> req.getAttribute(<span class="string">&quot;key1&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;柜台 1 是否有章：&quot;</span> + key1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理自己的业务</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Servlet2 处理自己的业务 &quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="保存作用域"><a href="#保存作用域" class="headerlink" title="保存作用域"></a>保存作用域</h3><p>作用域一般有四个：</p><ul><li><p>page（页面级别，现在几乎不用)</p></li><li><p>request（一次请求响应范围） </p><blockquote><p>重定向中，客户端实际发起了两次请求；所以在第一次请求中在request的作用域中保存数据，数据不会保存到第二次请求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line">req.setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line">System.out.println(req.getAttribute(<span class="string">&quot;key&quot;</span>));<span class="comment">//打印null，不能得到结果</span></span><br></pre></td></tr></table></figure></li><li><p>session（一次会话范围）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line">req.getSession().setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line">System.out.println(req.getAttribute(<span class="string">&quot;key&quot;</span>));<span class="comment">//能得到结果</span></span><br></pre></td></tr></table></figure></li><li><p>application（整个应用程序范围）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里假设/Servlet_1和/Servlet_2是两个不同的用户</span></span><br><span class="line"><span class="comment">//在 /Servlet_1 中</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">application.setAttribute(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line">req.sendRedirect(<span class="string">&quot;/Servlet_2&quot;</span>);</span><br><span class="line"><span class="comment">//在 /Servlet_2 中</span></span><br><span class="line"><span class="type">ServletContext</span> <span class="variable">application</span> <span class="operator">=</span> req.getServletContext();</span><br><span class="line">System.out.println(application.getAttribute(<span class="string">&quot;key&quot;</span>));<span class="comment">//能得到结果</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="文件传输"><a href="#文件传输" class="headerlink" title="文件传输"></a>文件传输</h3><p><strong>文件上传：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url地址&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> <span class="attr">method</span>=<span class="string">&quot;提交方式&quot;</span> <span class="attr">name</span>=<span class="string">&quot;名称&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 如果要设置上传文件，需要加上 enctype=&quot;multipart/form-data&quot; ,然后在 input的属性type值为&quot;file&quot; --&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>multipart&#x2F;form-data表示提交的数据，以多段（每一个表单项一个数据段）的形式进行拼接，然后以二进制流的形式发送给服务器<br>查看http协议内容时，context-type部分有属性boundary：表示每段数据的分隔符，分隔符是由浏览器每次都随机生成，它就是每段上传数据的分界符。 </p></blockquote><p><strong>文件接收：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 上传文件的表单 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://192.168.31.74:8080/09_EL_JSTL/uploadServlet&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    头像：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span> &gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;上传&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fileupload类库的适用:</span></span><br><span class="line"><span class="comment">//需要导入两个jar包:commons-fileupload.jar 和 commons-io.jar</span></span><br><span class="line"><span class="comment">//解析上传的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Servlet_1</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,IOException &#123;</span><br><span class="line">        <span class="comment">//1 先判断上传的数据是否多段数据（只有是多段的数据，才是文件上传的）</span></span><br><span class="line">        <span class="keyword">if</span> (ServletFileUpload.isMultipartContent(req)) &#123;</span><br><span class="line">        <span class="comment">// 创建 FileItemFactory 工厂实现类</span></span><br><span class="line">        <span class="type">FileItemFactory</span> <span class="variable">fileItemFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>();</span><br><span class="line">        <span class="comment">// 创建用于解析上传数据的工具类 ServletFileUpload 类</span></span><br><span class="line">        <span class="type">ServletFileUpload</span> <span class="variable">servletFileUpload</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletFileUpload</span>(fileItemFactory);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 解析上传的数据，得到每一个表单项 FileItem</span></span><br><span class="line">            List&lt;FileItem&gt; list = servletFileUpload.parseRequest(req);</span><br><span class="line">            <span class="comment">// 循环判断，每一个表单项，是普通类型，还是上传的文件</span></span><br><span class="line">            <span class="keyword">for</span> (FileItem fileItem : list) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fileItem.isFormField()) &#123;</span><br><span class="line">                    <span class="comment">// 普通表单项</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 name 属性值：&quot;</span> + fileItem.getFieldName());</span><br><span class="line">                    <span class="comment">// 参数 UTF-8.解决乱码问题</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 value 属性值：&quot;</span> + fileItem.getString(<span class="string">&quot;UTF-8&quot;</span>));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 上传的文件</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;表单项的 name 属性值：&quot;</span> + fileItem.getFieldName());</span><br><span class="line">                    System.out.println(<span class="string">&quot;上传的文件名：&quot;</span> + fileItem.getName());</span><br><span class="line">                    fileItem.write(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span> + fileItem.getName()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文件下载：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 获取要下载的文件名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">downloadFileName</span> <span class="operator">=</span> <span class="string">&quot;2.jpg&quot;</span>;</span><br><span class="line">        <span class="comment">//2. 获取要下载的文件内容（通过ServletContext对象可以获取）</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> getServletContext();</span><br><span class="line">        <span class="comment">//获取要下载的文件类型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">mimeType</span> <span class="operator">=</span> servletContext.getMimeType(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//4.在回传前，通过响应头告诉客户端返回的数据类型</span></span><br><span class="line">        response.setContentType(mimeType);</span><br><span class="line">        <span class="comment">//5.告诉客户端收到的数据是用于下载的，还是适用响应头的</span></span><br><span class="line">        response.setHeader(<span class="string">&quot;Content-Disposition&quot;</span>,<span class="string">&quot;attachment;filename=文件名&quot;</span>);</span><br><span class="line">        <span class="comment">//输入流获取文件内容</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> servletContext.getResourceAsStream(<span class="string">&quot;/file/&quot;</span> + downloadFileName);</span><br><span class="line">        <span class="comment">//获取响应的输出流</span></span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">        <span class="comment">//读取输入流中全部数据，复制给输出流，输出给客户端</span></span><br><span class="line">        IOUtils.copy(resourceAsStream, outputStream);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h2><p>Filter表示过滤器，可以把对资源的请求拦截下来；</p><p>通常用过滤器完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等…</p><blockquote><p>JavaWeb三大组件：Servlet、.Filter、Listener；</p></blockquote><p>使用：实现Filter接口 ，并重写三个方法；注意是javax.servlet. 下的Filter接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span>       <span class="comment">//设置拦截路径, “/*” 指拦截全部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Filter_1</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">         <span class="comment">// 放行前逻辑(已被拦截)</span></span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);     <span class="comment">//放行</span></span><br><span class="line">        <span class="comment">// 放行后逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 销毁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Filter执行流程：</strong></p><p>执行放行前逻辑——放行——访问资源——执行放行后逻辑</p><hr><p><strong>Filter拦截路径配置</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(&quot;...&quot;)</span>   <span class="comment">//括号中设置拦截路径</span></span><br></pre></td></tr></table></figure><ul><li>拦截具体的资源： &#x2F;index.jsp   只有访问index.jsp时才会被拦截；</li><li>目录拦截：&#x2F;user&#x2F;*  访问&#x2F;user下的所有资源都会被拦截；</li><li>后缀名拦截： *.jsp    访问后缀名为jsp的资源都会被拦截；</li><li>拦截所有： &#x2F;*</li></ul><blockquote><p>如果要拦截多个页面或分散文件，要在括号例写urlPatterns属性，然后在里面写属性的值，逗号分割；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter(urlPatterns = &#123;&quot;...&quot;,&quot;...&quot;,&quot;...&quot;&#125;)</span>  </span><br></pre></td></tr></table></figure></blockquote><hr><p><strong>过滤器链</strong></p><p>一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。</p><p>例如：对同一应用，如果执行了2个过滤器，执行顺序为：Filter1的放行前逻辑，Filter1放行，Filter2放行前逻辑，Filter2放行，Filter2放行后逻辑，Filter1放行后逻辑。（类似递归）</p><blockquote><p>过滤器的执行顺序按 过滤器的类名的字典序排序；</p></blockquote><p><strong>FilterConfig类</strong></p><p>Filter过滤器的配置文件类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">filterConfig.getFilterName()  <span class="comment">//获取过滤器的名称</span></span><br><span class="line">filterConfig.getInitParameter(<span class="string">&quot;&quot;</span>)   <span class="comment">//获取过滤器中配置的初始化参数 </span></span><br></pre></td></tr></table></figure><h2 id="Listener"><a href="#Listener" class="headerlink" title="Listener"></a>Listener</h2><p>监听器，是在application，session，request三个对象创建、销毁或者往其中添加修改删属性时自动执行代码的功能组件。</p><p>Listener分类：JavaWeb中提供了8个监听器</p><table><thead><tr><th>监听器分类</th><th>监听器名称</th><th>作用</th></tr></thead><tbody><tr><td>ServletContext监听</td><td>ServletContextListener</td><td>用于对ServletContext对象进行监听(仓创建、销毁)</td></tr><tr><td></td><td>ServletContextAttributeListener</td><td>对ServletContext对象中属性的监听（增别改属性）</td></tr><tr><td>Session监听</td><td>HttpSessionListener</td><td>对Session对象的整体状态的监听(创建、销毁)</td></tr><tr><td></td><td>HttpSessionAttributeListener</td><td>对Session?对象中的属性监听（增删改属性）</td></tr><tr><td></td><td>HttpSessionBindingListener</td><td>监听对象于Sessionl的绑定和解除</td></tr><tr><td></td><td>HttpSessionActivationListener</td><td>对Session数据的钝化和活化的监听</td></tr><tr><td>Request监听</td><td>ServletRequestListener</td><td>对Requestx对象进行监听(创建、销毁)</td></tr><tr><td></td><td>ServletRequestAttributeListener</td><td>对Reque5t对象中属性的监听（增别改属性）</td></tr></tbody></table><p>使用</p><p>实现ServletContextListener接口，并重写两个方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">a</span> <span class="keyword">implements</span> <span class="title class_">ServletContextListener</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">      <span class="comment">//加载资源</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> &#123;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p><strong>会话</strong>：用户打开浏览器，访问wb服务器的资源，会话建立，直到有一方断开连接， 会话结束（浏览器关闭）。在一次会话中可以包含多次请求和响应</p><p><strong>会话跟踪</strong>：服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间<u>共享数据</u>。</p><blockquote><p>由于HTTP协议是无状态的，每次浏览器发出请求，服务器都会将请求视为新的请求，所以需要会话跟踪技术。</p></blockquote><ul><li>客户端会话跟踪技术：Cookie</li><li>服务端会话跟踪技术：Session</li></ul><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>客户端会话技术，将数据保存到客户端，以后客户端每次请求都携带Cookie数据进行访问。</p><blockquote><p>客户端第一次向服务端发送请求，服务器会生成一个cookie对象，和响应一起发给客户端；客户端之后向服务端发送请求时，会携带cookie一起发送，服务端识别cookie就会知道客户端的身份。</p></blockquote><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送:</span></span><br><span class="line"><span class="comment">//创建Cookie对象，设置数据</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;value&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送Cookie到客户端，使用response对象</span></span><br><span class="line">response.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取:</span></span><br><span class="line"><span class="comment">//获取客户端所有Cookie，使用request对象</span></span><br><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line"><span class="comment">//遍历数组，获取每一个Cookie对象</span></span><br><span class="line"><span class="comment">//使用Cookie对象方法获取数据</span></span><br><span class="line"><span class="keyword">for</span> (Cookie cookie : cookies)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cookie.getName();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;key&quot;</span>.equals(name))&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> cookie.getValue();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改Cookie的值</span></span><br><span class="line"><span class="comment">//方法一：创建一个同名的Cookie对象，直接覆盖</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(<span class="string">&quot;key&quot;</span>,<span class="string">&quot;newValue&quot;</span>);</span><br><span class="line">resp.addCookie(cookie);</span><br><span class="line"><span class="comment">//方法二：找到对应的Cookie对象，用setValue()修改</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> CookieUtils.findCookie(<span class="string">&quot;key2&quot;</span>, req.getCookies());</span><br><span class="line"><span class="keyword">if</span> (cookie != <span class="literal">null</span>) &#123;</span><br><span class="line">    cookie.setValue(<span class="string">&quot;newValue2&quot;</span>);</span><br><span class="line">    resp.addCookie(cookie);<span class="comment">//修改后还要通知客户端保存修改</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 原理：</p><p>Cookie的实现是基于HTTP协议的；<br>响应头：set-cookie<br>请求头：cookie</p><blockquote><p> 注：</p><p> Cookie存活时间：</p><ul><li><p>默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁。</p></li><li><p>setMaxAge(int seconds) ：设置Cookie存活时间</p><ul><li><p>正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储；到时间自动删除。</p></li><li><p>负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁；</p></li><li><p>零：删除对应Cookie；</p></li></ul></li></ul><p> Cookie存储中文：</p><ul><li>默认情况不能存储中文；如果要存中文，则需要进行转码：可用URL编码</li></ul></blockquote><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>服务端会话跟踪技术：将数据保存到服务端；</p><p>JavaEE提供HttpSession接口，来实现一次会话的多次请求之间的 数据共享功能。</p><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取Session对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> request.getSession();</span><br><span class="line"><span class="comment">//Session对象功能：</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name,Object o)</span> <span class="comment">//存储数据到session域中</span></span><br><span class="line">Object <span class="title function_">getAttribute</span><span class="params">(String name)</span> <span class="comment">//根据key,获取值</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttribute</span><span class="params">(String name)</span> <span class="comment">//根据key,删除该键值对</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isNew</span><span class="params">()</span> <span class="comment">//判断是不是刚创建的</span></span><br></pre></td></tr></table></figure><p>原理：</p><p> Session技术，底层是基于Cookie技术实现的。</p><p>如果客户端发送的请求没有携带cookie，则服务端会新创建一个session和cookie，cookie的key值session的id值相同，然后session保存在服务端，cookie返回给客户端。</p><p>如果客户端发送的请求携带了cookie，则服务端会通过cookie的key值找到对应保存的session，然后返回相应的cookie。</p><blockquote><p>注意事项</p><p>Session 钝化、活化：</p><ul><li>钝化：在服务器正常关闭后，Tomcats会自动将Session数据写入硬盘的文件中；</li><li>活化：再次启动服务器后，从文件中加载数据到Session中；</li></ul><p>Session销毁：</p><ul><li><p>默认30分钟无操作，销毁；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在web.xml中配置所有session的超时时长 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以使用session的方法设置单个</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMaxInactiveInterval</span><span class="params">(<span class="type">int</span> interval)</span> <span class="comment">//设置session的超时时间，单位为秒，设置负数表示永不超时</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getMaxInactiveInterval</span><span class="params">()</span>  <span class="comment">//获取超时间</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">invalidate</span><span class="params">()</span><span class="comment">//立即超时，销毁</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p><strong>Cookie和Session异同点：</strong></p><p>Cookie和Session都是来完成一次会话内多次请求间数据共享的；<br>区别：</p><ul><li>存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端；</li><li>安全性：Cookie不安全，Session安全；</li><li>数据大小：Cookie最大KB，Session无大小限制；</li><li>存储时间：Cookie可以长期存储，Session默认30分钟；</li><li>服务器性能：Cookie不占服务器资源，Session占用服务器资源；</li></ul><h2 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h2><ul><li><p><strong>概念：Java Server Pages —— Java服务端页面</strong></p></li><li><p><strong>一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容；</strong></p><p>主要用于代替Servlet程序回传html页面的数据，因为Servlet程序回传html页面非常繁琐，开发维护成本都较高。</p><p>JSP本质上就是一个Servlet程序，JSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet)，再编译，最终对外提供服务的其实就是字节码文件</p></li><li><p><strong>JSP &#x3D; HTML + Java</strong></p></li></ul><blockquote><p>JSP有很多缺点：</p><p>书写麻烦：特别是复杂的页面；<br>阅读麻烦；<br>复杂度高：运行需要依赖于各种环境，JRE，JSP容器，JavaEE；<br>占内存和磁盘：JSP会自动生成java和 .class文件占磁盘，运行的是 .class文件占内存；<br>调试困难：出错后，需要找到自动生成的，java文件进行调试；<br>不利于团队协作：前端人员不会java,后端人员不精HTML；</p><p>….</p><p>后续逐渐被ajax+html替代</p></blockquote><hr><p>步骤：</p><p>导入JSP坐标——创建jsp文件——编写html标签和java代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- jsp坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span><span class="comment">&lt;!-- tomcat有，注意要写成provided --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p><strong>page指令：</strong></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>属性：</p><ul><li>language ——  表示 jsp 翻译后是什么语言文件。只支持 java。</li><li>contentType —— 表示 jsp 返回的数据类型是什么。也是源码中 response.setContentType()参数值</li><li>pageEncoding —— 表示当前 jsp 页面文件本身的字符集。 </li><li>import —— 跟 java 源代码中一样。用于导包，导类。 </li><li>给out输出流使用的两个属性（不建议改）：<ul><li>autoFlush —— 设置当 out 输出流缓冲区满了之后，是否自动刷新冲级区。默认值是 true。</li><li>buffer —— 设置 out 缓冲区的大小。默认是 8kb。</li></ul></li><li>errorPage —— 设置当 jsp 页面运行时出错，自动跳转去的错误页面路径。路径一般以斜杠开头，表示请求地址为 “http :&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F; ”  映射到代码的Web目录</li><li>isErrorPage —— 设置当前 jsp 页面是否是错误信息页面。默认是 false。如果是 true 可以 获取异常信息。 </li><li>session ——  设置访问当前 jsp 页面，是否会创建 HttpSession 对象。默认是 true。 </li><li>extends —— 设置 jsp 翻译出来的 java类继承谁</li></ul><p><strong>脚本：</strong></p><p>JSP脚本：用于在JSP页面内定义Java代码</p><p>分为：</p><ul><li><p><strong>代码脚本 &lt;% … %&gt;</strong> </p><p>用于编写需要的功能。内容会直接放到 jspService()方法之中。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--<span class="number">2.</span>代码脚本----<span class="keyword">for</span> 循环语句--%&gt;</span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> cellspacing=<span class="string">&quot;0&quot;</span>&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;第 &lt;%=j + <span class="number">1</span>%&gt;行&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    &#125;</span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>表达脚本 &lt;%&#x3D; … %&gt;</strong></p><p>用于在jsp页面上输出数据。内容会放到out.print()中，作为out.print0的参数</p><blockquote><p>注：表达脚本中的表达式不能以分号结束。</p></blockquote></li><li><p>声明脚本 &lt;%! … %&gt;</p><p>可以给 jsp 翻译出来的 java 类定义属性和方法甚至是静态代码块，内部类等。</p><p>内容会放到 _jspService()方法之外，被类直接包含。</p><blockquote><p>注：声明脚本很少使用</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%!</span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; map;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%!</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String,Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>输出</strong></p><p>response.getWriter输出 和 out输出 都用于设置返回给客户端的内容。由于jsp翻译后，底层源码都是用out来输出的，所以一般统一用out来进行输出。</p><p><strong>注释：</strong></p><p>html注释： &lt; !–    – &gt;</p><p>java注释：&lt;% &#x2F;&#x2F; 单行 java 注释    &#x2F;* 多行 java 注释 *&#x2F; %&gt;</p><p>jsp注释： &lt;%–   –%&gt; </p><p>其中html注释和java注释会被翻译到java源代码中，jsp注释不会。</p><hr><h3 id="对象-1"><a href="#对象-1" class="headerlink" title="对象"></a>对象</h3><p><strong>jsp的内置对象</strong>：是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象。</p><p>request —— 请求对象<br>response —— 响应对象<br>pageContext —— jsp的上下文对象<br>session —— 会话对象<br>application —— ServletContext.对象<br>config —— ServletConfig对象<br>out —— jsp输出流对象<br>page —— 指向当前jsp的对象<br>exception —— 异常对象</p><hr><p><strong>jsp四大域对象：</strong></p><p>pageContext —— request —— session —— application</p><p>域对象可以像Map一样存取数据，其范围和Servlet的四个作用域相同。</p><hr><h3 id="常用标签-1"><a href="#常用标签-1" class="headerlink" title="常用标签"></a>常用标签</h3><p><strong>静态包含</strong>（常用）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">&quot;&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 例如  --&gt; </span><br><span class="line">&lt;%@ include file=<span class="string">&quot;/include/footer.jsp&quot;</span>%&gt;</span><br></pre></td></tr></table></figure><p>file属性指定要包含的jsp页面的路径，地址的第一个斜杠为 “ http :&#x2F;&#x2F;ip:port&#x2F;工程路径&#x2F; ” 映射到web目录。</p><blockquote><p>注：静态包含不会翻译被包含的jsp页面，而是直接把页面拷贝到包含的位置执行输出。</p></blockquote><p><strong>动态包含</strong>（少用）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">&quot;&quot;</span>&gt; &lt;/jsp:include&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 例如  --&gt; </span><br><span class="line">&lt;jsp:include page=<span class="string">&quot;/include/footer.jsp&quot;</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;username&quot;</span> value=<span class="string">&quot;bbj&quot;</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">&quot;password&quot;</span> value=<span class="string">&quot;root&quot;</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><p>page属性是指定要包含的 jsp页面的路径。</p><blockquote><p>注：动态包含会 直接翻译被包含的jsp页面，同时还可以传递参数。</p></blockquote><p><strong>转发标签</strong>（常用）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=<span class="string">&quot;&quot;</span>&gt; &lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><p>page属性设置请求转发的路径</p><p>相当于：request.getRequestDispatcher(“&#x2F;xxxx.jsp”).forward(request,reponse);</p><h3 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h3><p>Expression Language ，即表达式语言，用于简化 JSP页面内的java代码。</p><p>主要功能：获取数据；</p><p>语法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;表达式&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JavaWeb中的四大域对象：</p><ul><li>page：当前页面有效；</li><li>request：当前请求有效；</li><li>session：当前会话有效；</li><li>application：当前应用有效；</li></ul><p>——EL表达式获取数据，会依次从4个域中寻找，直到找到为止。（四个域的范围逐渐增大，即page范围最小，application最大）</p></blockquote><ul><li><p>empty运算</p><p>判断一个数据是否为空，如果为空则输出true。</p><blockquote><p>值为null，空串时，Object类型数组长度为0时，list集合中元素个数为0，map集合元素个数为0，这些情况均视为空。</p></blockquote><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% </span><br><span class="line">request.setAttribute(<span class="string">&quot;obj&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">%&gt;</span><br><span class="line">$&#123;empty obj&#125;</span><br></pre></td></tr></table></figure></li><li><p>关系运算： &#x3D;&#x3D; !&#x3D;  &lt; &gt; &lt;&#x3D;  &gt;&#x3D;</p></li><li><p>逻辑运算：&amp;&amp; || ！</p></li><li><p>算数运算： + - * &#x2F; %</p></li><li><p>三元运算</p></li><li><p>点运算 中括号运算：</p><p>点运算 输出Bean对象中某个属性的值；</p><p>中括号运算 输出有序集合中某个元素的值；</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;a.a.a&quot;</span>, <span class="string">&quot;aaaValue&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;b+b+b&quot;</span>, <span class="string">&quot;bbbValue&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;c-c-c&quot;</span>, <span class="string">&quot;cccValue&quot;</span>);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;map&quot;</span>, map);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; map[<span class="string">&#x27;a.a.a&#x27;</span>] &#125; &lt;br&gt;</span><br><span class="line">    $&#123; map[<span class="string">&quot;b+b+b&quot;</span>] &#125; &lt;br&gt;</span><br><span class="line">    $&#123; map[<span class="string">&#x27;c-c-c&#x27;</span>] &#125; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></li></ul><p><strong>11个隐含对象：</strong></p><table><thead><tr><th>变量</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>pageContext</td><td>PageContextImpl</td><td>获取jsp九大内置对象</td></tr><tr><td>pageScope</td><td>Map&lt;String,Object&gt;</td><td>获取pageContext域中的数据</td></tr><tr><td>requestScope</td><td>Map&lt;String,Object&gt;</td><td>获取Request域的数据</td></tr><tr><td>sessionScope</td><td>Map&lt;String,Object&gt;</td><td>获取Session域的数据</td></tr><tr><td>applicationScope</td><td>Map&lt;String,Object&gt;</td><td>获取ServletContext域的数据</td></tr><tr><td>param</td><td>Map&lt;String,String&gt;</td><td>获取请求参数的值</td></tr><tr><td>paramValues</td><td>Map&lt;String,String[]&gt;</td><td>获取多个请求参数的值</td></tr><tr><td>header</td><td>Map&lt;String,String&gt;</td><td>获取请求头的信息</td></tr><tr><td>headerValues</td><td>Map&lt;String,String[]&gt;</td><td>获取多个请求头的信息</td></tr><tr><td>cookie</td><td>Map&lt;String,Cookie&gt;</td><td>获取当前请求的Cookie信息</td></tr></tbody></table><p><strong>获取4个特定域的属性：</strong></p><table><thead><tr><th>pageScope</th><th>pageContext域</th></tr></thead><tbody><tr><td>requestScope</td><td>Request域</td></tr><tr><td>sessionScope</td><td>Session域</td></tr><tr><td>applicationScope</td><td>ServletContext域</td></tr></tbody></table><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        application.setAttribute(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;application&quot;</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">$&#123; applicationScope.key2 &#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><hr><p><strong>pageContext的使用</strong>：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">    request.getScheme() 它可以获取请求的协议</span><br><span class="line">    request.getServerName() 获取请求的服务器 ip 或域名</span><br><span class="line">    request.getServerPort() 获取请求的服务器端口号</span><br><span class="line">    getContextPath() 获取当前工程路径</span><br><span class="line">    request.getMethod() 获取请求的方式（GET 或 POST）</span><br><span class="line">    request.getRemoteHost() 获取客户端的 ip 地址</span><br><span class="line">    session.getId() 获取会话的唯一标识</span><br><span class="line">    --&gt;</span><br><span class="line">&lt;%</span><br><span class="line">        pageContext.setAttribute(<span class="string">&quot;req&quot;</span>, request);</span><br><span class="line">    %&gt;</span><br><span class="line">    &lt;%= request.getScheme() %&gt; &lt;br&gt;</span><br><span class="line">    <span class="number">1.</span>协议： $&#123; req.scheme &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">2.</span>服务器 ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">3.</span>服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">4.</span>获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">5.</span>获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">6.</span>获取客户端 ip 地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">7.</span>获取会话的 id 编号：$&#123; pageContext.session.id &#125;&lt;br</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure><h3 id="JSTL标签"><a href="#JSTL标签" class="headerlink" title="JSTL标签"></a>JSTL标签</h3><p>JSTL标准标签库（Jsp Standarded Tag Library），使用标签取代JSP页面上的Java代码。</p><p>步骤：</p><p>1.导入坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>taglibs<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>standard<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.在JSP页面上引入JSTL标签库：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">&quot;c&quot;</span> uri=<span class="string">&quot;http://java.sun.com /jsp/jstl/core&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>JSTL有五个功能不同的标签库：</p><table><thead><tr><th>功能范围</th><th>URI</th><th>前缀</th></tr></thead><tbody><tr><td>核心标签库（常用）</td><td>http :&#x2F;&#x2F;java.sun.com &#x2F;jsp&#x2F;jstl&#x2F;core</td><td>c</td></tr><tr><td>格式化</td><td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;fmt</td><td>fmt</td></tr><tr><td>函数</td><td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;functions</td><td>fn</td></tr><tr><td>数据库（不适用）</td><td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;sql</td><td>sql</td></tr><tr><td>XML（不适用）</td><td>http :&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;xml</td><td>x</td></tr></tbody></table><p>标签：</p><p>if</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;true或false&quot;</span>&gt;</span><br><span class="line">    ....</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">&quot;$&#123;status==0&#125;&quot;</span>&gt;</span><br><span class="line">    hello world!</span><br><span class="line">&lt;/c:<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure><p>forEach</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- items是被遍历的容器 <span class="keyword">var</span>是遍历生产的临时变量 --&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;brands&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;brand&quot;</span> varStatus=<span class="string">&quot;xx&quot;</span>&gt;</span><br><span class="line">    &lt;tr align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">        &lt;td&gt;$(xx.index)&lt;/td&gt;  &lt;!-- varStatus表示下标序号，xx.index表示从<span class="number">0</span>开始，xx.count表示从<span class="number">1</span>开始 --&gt;</span><br><span class="line">        &lt;td&gt;$(brand.brandName)&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;S(brand.companyName)&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$(brand.description)&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 相当于.. --&gt;</span><br><span class="line"><span class="keyword">for</span>(Brand brand : brands)&#123;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> brand.getld();</span><br><span class="line"><span class="type">String</span> <span class="variable">imgUrl</span> <span class="operator">=</span> brand.getlmgUrl();</span><br><span class="line"><span class="type">String</span> <span class="variable">brandName</span> <span class="operator">=</span> brand.getBrandName();</span><br><span class="line"><span class="type">String</span> <span class="variable">companyName</span> <span class="operator">=</span> brand.getCompanyName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- begin是开始数，end是结束数，step是步长 --&gt;</span><br><span class="line">&lt;c:forEach begin=<span class="string">&quot;0&quot;</span> end=<span class="string">&quot;10&quot;</span> step=<span class="string">&quot;1&quot;</span> <span class="keyword">var</span>=<span class="string">&#x27;i&#x27;</span>&gt;</span><br><span class="line">    $&#123;i&#125;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 相当于.. --&gt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">System.out.println(i);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h2><p><strong>MVC是一种分层开发的模式，其中：</strong></p><ul><li><strong>M：Model，业务模型，处理业务</strong></li><li><strong>V：View，视图，界面展示</strong></li><li><strong>C：Controller，控制器，处理请求，调用模型和视图</strong></li></ul><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705826.png" alt="image-20220228114916749"></strong></p><blockquote><p><strong>MVC只能实现模型到视图的单向展示</strong></p></blockquote><p><strong>三层架构</strong></p><p><strong>表现层：接收请求，封装数据，调用业务逻辑层，响应数据</strong></p><p><strong>业务逻辑层：对业务逻辑进行封装，组合数据访问层的基本功能，形成复杂的业务逻辑功能</strong></p><p><strong>数据访问层(持久层)：对数据库的CRUD基本操作</strong></p><p><strong><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191705827.png" alt="image-20220228115248548"></strong></p><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a><strong>AJAX</strong></h2><p><strong>概念：AJAX（Asynchronous JavaScript And XML）：异步的 javaScript 和 XML</strong></p><p><strong>AJAX作用</strong></p><ol><li><p><strong>与服务器进行数据交换： 通过AJAX可以给服务器发送请求，并获取服务器响应的数据。</strong></p><blockquote><p><strong>使用了AJAX和服务器进行通信，就可以使用 HTML+AJAX 来替换 JSP 页面了。</strong></p></blockquote></li><li><p><strong>异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验，等等…</strong></p><p>Ajax 请求的局部更新，浏览器地址栏不会发生变化， 局部更新不会舍弃原来页面的内容。</p></li></ol><blockquote><p><strong>同步：浏览器请求服务器 ，需要等待服务器处理并响应后，才能继续操作。</strong></p><p><strong>异步：浏览器请求服务器，服务器在处理时，浏览器可以做其他操作。</strong></p></blockquote><hr><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>服务端：Servlet程序</p><p>客户端：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. 创建核心对象</span></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> xhttp;</span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span></span><br><span class="line"><span class="language-javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// code for IE6, IE5</span></span></span><br><span class="line"><span class="language-javascript">        xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;</span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. 发送请求</span></span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/ajax-demo/ajaxServlet&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="title function_">send</span>();</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//3. 获取响应</span></span></span><br><span class="line"><span class="language-javascript">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">responseText</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><hr><h3 id="XMLHttpRequest对象"><a href="#XMLHttpRequest对象" class="headerlink" title="XMLHttpRequest对象"></a>XMLHttpRequest对象</h3><p><strong>方法：</strong></p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>abort()</td><td>取消当前请求</td></tr><tr><td>getAllResponseHeaders()</td><td>返回头部信息</td></tr><tr><td>getResponseHeader()</td><td>返回特定的头部信息</td></tr><tr><td>open(method, url, async, user, psw)</td><td>发送请求 —— method：请求类型 GET 或 POST；    url：文件位置；     async：true（异步）或 false（同步）；     user：可选的用户名称；     psw：可选的密码</td></tr><tr><td>send()</td><td>将请求发送到服务器，用于GET请求</td></tr><tr><td>send(string)</td><td>将请求发送到服务器，用于POST请求</td></tr><tr><td>setRequestHeader()</td><td>向要发送的报头添加标签&#x2F;值对</td></tr></tbody></table><p><strong>XMLHttpRequest属性：</strong></p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>定义当 readyState 属性发生变化时被调用的函数</td></tr><tr><td>readyState</td><td>保存XMLHttpRequest的状态</td></tr><tr><td>responseXML</td><td>以字符串返回响应数据</td></tr><tr><td>status</td><td>返回请求的状态号</td></tr><tr><td>statusText</td><td>返回状态文本（如 “OK” 或 “Not Found”）</td></tr></tbody></table><blockquote><p>readyState中的XMLHttpRequest的状态 ：</p><ul><li>0：请求未初始化</li><li>1：服务器连接已建立</li><li>2：请求已收到</li><li>3：正在处理请求</li><li>4：请求已完成且响应已就绪</li></ul><p>status中常见的 返回请求的状态：</p><ul><li>200: “OK”</li><li>403: “Forbidden”</li><li>404: “Not Found”</li></ul></blockquote><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>需求：在完成用户注册时，当用户名输入框失去焦点时，校验用户名是否在数据库已存在</p><ul><li><strong>前端完成的逻辑</strong><ol><li>给用户名输入框绑定光标失去焦点事件 <code>onblur</code></li><li>发送 ajax请求，携带username参数</li><li>处理响应：是否显示提示信息</li></ol></li><li><strong>后端完成的逻辑</strong><ol><li>接收用户名</li><li>调用service 查询User。此案例是为了演示前后端异步交互，所以此处我们不做业务逻辑处理</li><li>返回标记</li></ol></li></ul><p>后端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/selectUserServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectUserServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="comment">//1. 接收用户名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 调用service查询User对象，此处不进行业务逻辑处理，直接给 flag 赋值为 true，表明用户名占用</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//3. 响应标记</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;&quot;</span> + flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 给用户名输入框绑定 失去焦点事件</span></span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username&quot;</span>).<span class="property">onblur</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//2. 发送ajax请求</span></span><br><span class="line">    <span class="comment">// 获取用户名的值 </span></span><br><span class="line">    <span class="keyword">var</span> username = <span class="variable language_">this</span>.<span class="property">value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.1. 创建核心对象</span></span><br><span class="line">    <span class="keyword">var</span> xhttp;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">window</span>.<span class="property">XMLHttpRequest</span>) &#123;</span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// code for IE6, IE5</span></span><br><span class="line">        xhttp = <span class="keyword">new</span> <span class="title class_">ActiveXObject</span>(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.2. 发送请求</span></span><br><span class="line">    xhttp.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;http://localhost:8080/ajax-demo/selectUserServlet?username=&quot;</span>+username);</span><br><span class="line">    xhttp.<span class="title function_">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.3. 获取响应</span></span><br><span class="line">    xhttp.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">readyState</span> == <span class="number">4</span> &amp;&amp; <span class="variable language_">this</span>.<span class="property">status</span> == <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">//判断</span></span><br><span class="line">            <span class="keyword">if</span>(<span class="variable language_">this</span>.<span class="property">responseText</span> == <span class="string">&quot;true&quot;</span>)&#123;</span><br><span class="line">                <span class="comment">//用户名存在，显示提示信息</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//用户名不存在 ，q提示信息</span></span><br><span class="line">                <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;username_err&quot;</span>).<span class="property">style</span>.<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，简单的讲就是可以发送get、post请求。</p><p>Axios对原生的AJAX进行封装，简化书写。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>axios 使用是比较简单的，分为以下两步：</p><ul><li><p>引入 axios 的 js 文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用axios 发送请求，并获取响应结果</p><ul><li><p>发送 get 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>发送 post 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo1/aJAXDemo1&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="title function_">alert</span>(a.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><code>axios()</code> 是用来发送异步请求的，小括号中使用 js 对象传递请求相关的参数：</p><ul><li><code>method</code> 属性：用来设置请求方式的。取值为 <code>get</code> 或者 <code>post</code>。</li><li><code>url</code> 属性：用来书写请求的资源路径。如果是 <code>get</code> 请求，需要将请求参数拼接到路径的后面，格式为： <code>url?参数名=参数值&amp;参数名2=参数值2</code>。</li><li><code>data</code> 属性：作为请求体被发送的数据。也就是说如果是 <code>post</code> 请求的话，数据需要作为 <code>data</code> 属性的值。</li></ul><p><code>then()</code> 需要传递一个匿名函数。我们将 <code>then()</code> 中传递的匿名函数称为 &#x3D;&#x3D;回调函数&#x3D;&#x3D;，意思是该匿名函数在发送请求时不会被调用，而是在成功响应后调用的函数。而该回调函数中的 <code>resp</code> 参数是对响应的数据进行封装的对象，通过 <code>resp.data</code> 可以获取到响应的数据。</p><hr><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p><strong>1.后端实现</strong></p><p>定义一个用于接收请求的servlet，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/axiosServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AxiosServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;get...&quot;</span>);</span><br><span class="line">        <span class="comment">//1. 接收请求参数</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        System.out.println(username);</span><br><span class="line">        <span class="comment">//2. 响应数据</span></span><br><span class="line">        response.getWriter().write(<span class="string">&quot;hello Axios~&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;post...&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.前端实现</strong></p><ul><li><p>引入 js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li><li><p>发送 ajax 请求</p><ul><li><p>get 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>post 请求</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p><strong>整体页面代码如下：</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//1. get</span></span></span><br><span class="line"><span class="language-javascript">   <span class="comment">/* axios(&#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        method:&quot;get&quot;,</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        url:&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;).then(function (resp) &#123;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">        alert(resp.data);</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">    &#125;)*/</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//2. post  在js中&#123;&#125; 表示一个js对象，而这个js对象中有三个属性</span></span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">axios</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>:<span class="string">&quot;username=zhangsan&quot;</span></span></span><br><span class="line"><span class="language-javascript">    &#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="请求方法别名"><a href="#请求方法别名" class="headerlink" title="请求方法别名"></a>请求方法别名</h3><p>为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：</p><ul><li><p><code>get</code> 请求 ： <code>axios.get(url[,config])</code></p></li><li><p><code>delete</code> 请求 ： <code>axios.delete(url[,config])</code></p></li><li><p><code>head</code> 请求 ： <code>axios.head(url[,config])</code></p></li><li><p><code>options</code> 请求 ： <code>axios.option(url[,config])</code></p></li><li><p><code>post</code> 请求：<code>axios.post(url[,data[,config])</code></p></li><li><p><code>put</code> 请求：<code>axios.put(url[,data[,config])</code></p></li><li><p><code>patch</code> 请求：<code>axios.patch(url[,data[,config])</code></p></li></ul><p>而我们只关注 <code>get</code> 请求和 <code>post</code> 请求。</p><p>入门案例中的 <code>get</code> 请求代码可以改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">get</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet?username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>入门案例中的 <code>post</code> 请求代码可以改为如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.<span class="title function_">post</span>(<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,<span class="string">&quot;username=zhangsan&quot;</span>).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="携带JSON数据"><a href="#携带JSON数据" class="headerlink" title="携带JSON数据"></a>携带JSON数据</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsObject = &#123;<span class="attr">name</span>:<span class="string">&quot;张三&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">axios</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>:<span class="string">&quot;post&quot;</span>,</span><br><span class="line">    <span class="attr">url</span>:<span class="string">&quot;http://localhost:8080/ajax-demo/axiosServlet&quot;</span>,</span><br><span class="line">    <span class="attr">data</span>:jsObject  <span class="comment">//这里 axios 会将该js对象转换为 json 串的</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="keyword">function</span> (<span class="params">resp</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(resp.<span class="property">data</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ul><li>发送异步请求时，如果请求参数是 <code>JSON</code> 格式，那请求方式必须是 <code>POST</code>。因为 <code>JSON</code> 串需要放在请求体中。</li><li>axios将js对象转为json字符串，用了 js提供的 JSON对象，即 JSON.stringify (jsObject)。（了解即可）</li></ul></blockquote><h2 id="Thymeleaf"><a href="#Thymeleaf" class="headerlink" title="Thymeleaf"></a>Thymeleaf</h2><p>Thymeleaf 是（服务器端)视图模板技术,</p><p>优势：和springBoot完美契合。不经过服务器运算仍可以直接查看原始值，对前端友好。</p><hr><p><strong>物理视图：</strong></p><p>在Servlet中，将请求转发到一个HTML页面文件时，使用的<strong>完整的转发路径就是 物理视图</strong>。如：&#x2F;pages&#x2F;user&#x2F;login_success.html</p><p>由于html页面放在统一的目录下，所以转发地址会有相同的前缀 和 后缀，称为<strong>视图前缀，视图后缀</strong>。</p><p><strong>逻辑视图：</strong></p><p>物理视图 &#x3D; 视图前缀 + 逻辑视图 + 视图后缀</p><p>也就是说，逻辑视图 就是指转发路径中间不一样的部分（html页面名）。</p><hr><p>使用步骤：</p><ul><li><p>添加jar包（maven可直接添加依赖）；</p></li><li><p>配置两个 &lt; context-param &gt;: view-prefix,view-suffix</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在上下文参数中配置 视图前缀和视图后缀 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-prefix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/view/<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>view-suffix<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>.html<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>新建viewBaseServlet（有两个方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ViewBaseServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TemplateEngine templateEngine;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line">        <span class="comment">// 1.获取ServletContext对象</span></span><br><span class="line">        <span class="type">ServletContext</span> <span class="variable">servletContext</span> <span class="operator">=</span> <span class="built_in">this</span>.getServletContext();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2.创建Thymeleaf解析器对象</span></span><br><span class="line">        <span class="type">ServletContextTemplateResolver</span> <span class="variable">templateResolver</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServletContextTemplateResolver</span>(servletContext);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.给解析器对象设置参数</span></span><br><span class="line">        <span class="comment">// ①HTML是默认模式，明确设置是为了代码更容易理解</span></span><br><span class="line">        templateResolver.setTemplateMode(TemplateMode.HTML);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ②设置前缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewPrefix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-prefix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setPrefix(viewPrefix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ③设置后缀</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">viewSuffix</span> <span class="operator">=</span> servletContext.getInitParameter(<span class="string">&quot;view-suffix&quot;</span>);</span><br><span class="line"></span><br><span class="line">        templateResolver.setSuffix(viewSuffix);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ④设置缓存过期时间（毫秒）</span></span><br><span class="line">        templateResolver.setCacheTTLMs(<span class="number">60000L</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑤设置是否缓存</span></span><br><span class="line">        templateResolver.setCacheable(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ⑥设置服务器端编码方式</span></span><br><span class="line">        templateResolver.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4.创建模板引擎对象</span></span><br><span class="line">        templateEngine = <span class="keyword">new</span> <span class="title class_">TemplateEngine</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5.给模板引擎对象设置模板解析器</span></span><br><span class="line">        templateEngine.setTemplateResolver(templateResolver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">processTemplate</span><span class="params">(String templateName, HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.设置响应体内容类型和字符集</span></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html;charset=UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建WebContext对象</span></span><br><span class="line">        <span class="type">WebContext</span> <span class="variable">webContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WebContext</span>(req, resp, getServletContext());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.处理模板数据</span></span><br><span class="line">        templateEngine.process(templateName, webContext, resp.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/Notes/2022/04/14/Git/"/>
      <url>/Notes/2022/04/14/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>git 是一个<strong>分布式版本控制</strong>系统，</p><blockquote><p>版本控制 是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p></blockquote><blockquote><p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p><ol><li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>每个客户端保存的也都是整个完整的项目 (包含历史记录，更加安全)</li></ol></blockquote><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><strong>工作区——git add——&gt; 暂存区——git commit——&gt; 本地库</strong></p><blockquote><p>工作区：写代码； </p><p>暂存区：临时存储；</p><p>本地库：历史版本；</p></blockquote><p><strong>代码托管中心</strong></p><p>代码托管中心是基于网络服务器的远程代码仓库，一般称为 <strong>远程库</strong>。</p><blockquote><p>局域网：GitLab</p><p>互联网：GitHub，Gitee码云</p></blockquote><h3 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h3><p>初始化本地仓库：git init</p><p>查看本地库状态：<strong>git status</strong></p><p>添加暂存区：<strong>git add 文件名</strong> （<strong>git add .</strong>  &#x2F;&#x2F;将所有修改加入暂存区）</p><p>提交本地库：<strong>git commit -m “日志信息” 文件名</strong></p><blockquote><p>工作区的文件是git对象，不能看作是项目，要添加到暂存区，才能形成一个项目。</p></blockquote><p>查看简易版本信息：<strong>git reflog</strong>  (参看详细版本信息：<strong>git log</strong>)</p><p>版本穿梭：<strong>git reset –hard 版本号</strong></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在版本控制中，要同时推进多个任务，对每个任务就可以单独创建一个分支。</p><p>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己的分支时不会影响主线分支的运行。（分支底层是指针的引用）</p><p><strong>分支操作：</strong></p><p>创建分支：<strong>git branch 分支名</strong></p><p>查看分支：<strong>git branch -v</strong></p><p>切换分支：<strong>git checkout 分支名</strong></p><p>将指定分支合并到当前分支上：<strong>git merge 分支名</strong></p><blockquote><p>指定分支要提交本地库，合并后，当前分支才会修改。</p><p>合并冲突： </p><p>当两个分支修改了同一个文件，并都提交到本地库，那么合并时，系统发现一个文件出现两个版本，不知道应该选择哪一个，就是发生了冲突。需要手动修改，选择。</p></blockquote><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p><strong>git remote -v</strong> ：查看当前所有远程地址别名</p><p><strong>git remote add 别名 远程地址</strong>  ：添加远程库地址和别名</p><p>推送本地分支到远程仓库 ：<strong>git push 别名 分支</strong></p><p>拉取远程库到本地库 ： <strong>git pull 别名 分支</strong> （自动提交到本地库）</p><p>克隆远程库到本地库：<strong>git clone 远程地址</strong></p><blockquote><p>克隆结果：初始化本地仓库，创建别名</p></blockquote><h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p>远程仓库的所有人需要在仓库的设置-成员设置中邀请其他团队成员加入，其他成员才能将本地分支推送到远程库</p><p>跨团队协作</p><p>团队外的人要先用fork获取远程库，修改后在界面的pull requests发送拉取请求。</p><blockquote><p>SSH免密登录</p><p>生成 .ssh密钥目录： <strong>ssh-keygen -t rsa -C 账号邮箱</strong></p><p>在.ssh目录下会有私钥id_rsa，公钥id_rsa.pub，将公钥添加到github上即可。</p></blockquote><h3 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h3><p>环境准备：</p><p>先配置忽略文件 git.ignore，避免提交无用的文件，避免开发环境差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//内容如下</span><br><span class="line"># Compoled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line">#Blue files</span><br><span class="line">*.ctxt</span><br><span class="line">a</span><br><span class="line">#Mobile Tools for Java(J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>然后在 .gitconfig 中添加 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/123/git.ignore</span><br></pre></td></tr></table></figure><p>之后再idea设置的版本控制中设置git.exe路径。</p><p>初始化：</p><p>在工具栏的vcs中选择创建git仓库即可。</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>搜索—高级搜索功能：<a href="http://github.com/search/advanced">http://github.com/search/advanced</a>  或  搜索框中使用语法进行精确搜索</p><p>快捷面板：ctrl + K</p><p>仓库内对文件搜索： T键</p><p>文件内 行号跳转： L键</p><p>查看文件改动记录： B键</p><p>仓库详情页 打开 VSCode网页版： 。键d</p><p>打开 Gitpod ： 在地址前缀前加上 gitpod.io&#x2F;#&#x2F; </p><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202205081046166.png" alt="image-20220508104603843"></p><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>前置操作已完成，现在 —— 初始化及部署博客：</p><p>新建文件夹 blog， 在blog 中使用git命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init   //初始化本地博客</span><br><span class="line">hexo clean  //清理编译文件</span><br><span class="line">hexo g   //生成对应的html文件</span><br><span class="line">hexo s//本地预览运行</span><br></pre></td></tr></table></figure><p>修改 _config.yml 文件，在文件最后，修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 仓库ssh地址</span><br><span class="line">  branch: master</span><br><span class="line">  </span><br><span class="line">  //在17行左右，url下面，添加：</span><br><span class="line">  root: /仓库名</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>每次预览：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>每次上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">还要到gitee上更新pages服务，才会生效</span><br></pre></td></tr></table></figure><blockquote><p>主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 主题地址(github地址)</span><br></pre></td></tr></table></figure><p>修改 _config.yml 文件中的 theme: 主题文件名</p></blockquote><blockquote><p>源文件上传git：<br>git push -u origin main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">完整操作：</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin 地址</span><br><span class="line">git push -u origin main</span><br><span class="line">//推送到master分支不知为何，会出错</span><br></pre></td></tr></table></figure><p>恢复源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s/d   //本地预览或上传</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>常用hexo命令</p><p>常见命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>a</p></blockquote><h2 id="hexo-butterfly"><a href="#hexo-butterfly" class="headerlink" title="hexo-butterfly"></a>hexo-butterfly</h2><h3 id="扉页"><a href="#扉页" class="headerlink" title="扉页"></a>扉页</h3><ul><li>page front-matter  用于页面的配置</li></ul><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>页面标题（必须）</td></tr><tr><td>date</td><td>创建日期（必须）</td></tr><tr><td>type</td><td>标签类型（标签，分类，友情链接三个页面必须配置）</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>description</td><td>页面描述</td></tr><tr><td>keywords</td><td>页面关键字</td></tr><tr><td>comments</td><td>显示页面评论模块（默认true）</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td></td></tr><tr><td>katex</td><td></td></tr><tr><td>aside</td><td>显示侧边栏（默认true）</td></tr><tr><td>aplayer</td><td>在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td>代码框是否展开（默认根据配置文件）</td></tr></tbody></table><ul><li>post front-matter 文章页的扉页 ，用于文章页的配置</li></ul><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>页面标题（必须）</td></tr><tr><td>date</td><td>创建日期（必须）</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>tags</td><td>文章标签</td></tr><tr><td>categories</td><td>文章分类</td></tr><tr><td>keywords</td><td>文章关键字</td></tr><tr><td>description</td><td>页面描述</td></tr><tr><td>keywords</td><td>页面关键字</td></tr><tr><td>comments</td><td>显示页面评论模块（默认true）</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>cover</td><td>文章封面主图，可设 false&#x2F;图地址&#x2F;留空</td></tr><tr><td>toc</td><td>显示文章toc（默认为配置中的enable）</td></tr><tr><td>toc_number</td><td>显示toc_number</td></tr><tr><td>toc_style_simple</td><td>显示 toc 简洁模式</td></tr><tr><td>copyright_author</td><td>文章版权 作者</td></tr><tr><td>copyright_author_herf</td><td>文章版权 作者的链接</td></tr><tr><td>copyright_url</td><td>文章版权 文章的链接</td></tr><tr><td>copyright_info</td><td>文章版权 的版权声明</td></tr><tr><td>mathjax</td><td></td></tr><tr><td>katex</td><td></td></tr><tr><td>aside</td><td>显示侧边栏（默认true）</td></tr><tr><td>aplayer</td><td>在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td>代码框是否展开（默认根据配置文件）</td></tr></tbody></table><h3 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h3><p>主页的图——index_img:<br>默认是文章配图——default_top_img:<br>归档页的主图—— archive_img<br>标签页的主图——tag_img<br>标签页的文章配图——tag_per_img<br>分类页的主图——category_img<br>分类页的文章配图——category_per_img</p><p>其他页面和文章页的top_img： 可以到文章的扉页 配置——top_img: xxx</p><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><ul><li>在文章的扉页 添加 sticky：1 ，数字越大，置顶的优先级越大；</li></ul><h3 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h3><ul><li><p>在文章的扉页 添加  cover: 图片地址</p></li><li><p>可以在配置文件里配置默认图片， default_cover:  xxx</p><p>如果要配置多张图片，随机选择一张作为cover，写法为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/xxxxxx</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">  <span class="string">。。。。等等等</span></span><br></pre></td></tr></table></figure><h3 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h3><p>在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">二维码图片</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="string">text:微信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">二维码图片</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><h3 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h3><p>显示目录，在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure><h3 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h3><p>根据tags的比重来推荐，在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># 显示创建或更新日期，created 或 updated</span></span><br></pre></td></tr></table></figure><h3 id="文章锚点"><a href="#文章锚点" class="headerlink" title="文章锚点"></a>文章锚点</h3><p> 开启后，在文章中滚动时，文章链接会根据标题进行变化（每替换一次，都会留下一次历史记录，锚点过多，可能导致历史记录过多）</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">图片地址</span> <span class="string">如：</span> <span class="string">./img/avatar1.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span>  <span class="comment">#头像一直转圈</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> </span><br></pre></td></tr></table></figure><h3 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h3><p>在图片下显示描述信息，优先 title属性，然后是 alt属性</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 能否复制</span></span><br><span class="line">  <span class="attr">copyright:</span><span class="comment"># 复制内容后加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span><span class="comment">#复制文字大于限制时 加版权信息</span></span><br></pre></td></tr></table></figure><h3 id="脚页自定义文本"><a href="#脚页自定义文本" class="headerlink" title="脚页自定义文本"></a>脚页自定义文本</h3><p>custom_text:  支持HTML</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_text:</span>  <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://butterfly.js.org/&quot;&gt;blog&lt;/a&gt;!</span></span><br></pre></td></tr></table></figure><h3 id="插入自定义代码"><a href="#插入自定义代码" class="headerlink" title="插入自定义代码"></a>插入自定义代码</h3><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如；</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/footer.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/blog.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/cursors.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/opacity.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/scrollbar.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网站背景"><a href="#网站背景" class="headerlink" title="网站背景"></a>网站背景</h3><p>默认白色</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Website Background (設置網站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置圖片 或者 顔色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> </span><br></pre></td></tr></table></figure><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h3><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主页subtitle</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 关闭调用</span></span><br><span class="line">  <span class="comment"># source: 1  调用一言网的一句话（简体） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  调用一句网（简体） http://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  调用今日诗词（简体） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的内容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br></pre></td></tr></table></figure><h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><p>在页脚的custom_text也可以写代码，在此写下备案跳转链接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;div&gt;&lt;a</span> <span class="string">onclick=&quot;window.open(&#x27;&#x27;)&quot;&gt;&lt;/a&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><h3 id="引擎收录"><a href="#引擎收录" class="headerlink" title="引擎收录"></a>引擎收录</h3><blockquote></blockquote><h3 id="url持久化"><a href="#url持久化" class="headerlink" title="url持久化"></a>url持久化</h3><p>hexo默认生成的文章地址路径是： 网站名&#x2F;年&#x2F;月&#x2F;日&#x2F;文章名，它的url结构超过3层，较深，对搜索爬虫不友好。</p><p>安装：npm install hexo-abbrlink –save</p><p>修改配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"> <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#算法：crc16(default)and crc32</span></span><br><span class="line"> <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制：dec(default)and hex</span></span><br></pre></td></tr></table></figure><p>添加nofollow标签：</p><p>安装：npm install hexo-filter-nofollow –save</p><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h3><p>（可能有移植问题，不是很推荐）</p><p>Gallery相册图库</p><p>写法：</p><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 例如： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁纸&#x27; &#x27;/Gallery/wallpaper&#x27; https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;漫威&#x27; &#x27;关于漫威的图片&#x27; &#x27;/Gallery/marvel&#x27; https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;OH MY GIRL&#x27; &#x27;关于OH MY GIRL的图片&#x27; &#x27;/Gallery/ohmygirl&#x27; https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gallery相册</p><p>这是新的Gallery相册，会自动根据图片进行排版，书写也更方便，与markdown格式一样；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>tag-hide</p><p>可以将 一些内容隐藏起来，并提供按钮让用户点击显示；</p><p>注：内容不要用 h1~h6标题，会让目录有一些异常；</p><p>inline ——  只能隐藏文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>content: 文本内容</p></li><li><p>display: 按钮显示的文字(可选)</p></li><li><p>bg: 按钮的背景颜色(可选)</p></li><li><p>color: 按钮文字的颜色(可选)</p></li></ul><p>注：content部分不能用英文逗号，可用 <code>&amp;sbquo;</code> 代替</p><p>block ——  隐藏多个内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><ul><li>content: 文本内容</li><li>display: 按钮显示的文字(可选)</li><li>bg: 按钮的背景颜色(可选)</li><li>color: 按钮文字的颜色(可选)</li></ul><p>toggle —— 隐藏大量内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言</title>
      <link href="/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习"><a href="#C语言学习" class="headerlink" title="C语言学习"></a>C语言学习</h1><h2 id="1章-概述"><a href="#1章-概述" class="headerlink" title="1章 概述"></a>1章 概述</h2><p>注意点：</p><ol><li>一个函数的函数体可以没有变量定义和执行部分，函数可以是空函数。</li><li>一个C程序至少包含一个<u>主函数</u>，即<u>main函数</u>。</li><li>一个函数由两部分组成，分别是<u>函数的说明部分</u>和<u>函数体</u>。</li><li>C语言通过输入和输出函数 来进行输入输出。</li><li>主函数后的圆括号内可为空，但这个圆括号不能省略。</li></ol><h2 id="2章-数据类型、运算符、表达式"><a href="#2章-数据类型、运算符、表达式" class="headerlink" title="2章 数据类型、运算符、表达式"></a>2章 数据类型、运算符、表达式</h2><p>注意点：</p><ol><li>C语言中，数据基本类型有<u>整型，浮点型，字符型</u>；</li><li>能表示整型常量的进制有八、十、十六进制（二进制不行）；</li><li>ASCII码表：数值0——48；字母A——65；字母a——97；</li><li>所有变量，遵循<u>先定义后使用</u>的原则；</li><li>强制类型转换——将一个表达式转换成指定的类型；</li></ol><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table><p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p><hr><p><strong>浮点型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td></tr><tr><td>double</td><td>8字节</td><td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td></tr></tbody></table><p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p><ul><li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p><p>1.正无穷大：Double.POSITIVE_INFINITY</p><p>2.负无穷大：Double.NEGATIVE_INFINITY</p><p>3.NaN(不是一个数字)：Double.NaN</p><ul><li><p>检测一个特定值是否等于Double.NaN：</p></li><li><p>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</p></li></ul></li><li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p></li></ul><hr><p><strong>char</strong>类型</p><p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p><ul><li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p><p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p><p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p></li></ul><hr><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型也是算术类型，被用来定义在程序中只能赋予其一定的整数值的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br><span class="line"><span class="comment">//上面的宏定义可用枚举来表示</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p></li><li><p>可以在定义枚举类型时改变枚举元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure><p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p></li></ul><p><strong>关于枚举的遍历：</strong></p><p>在C 中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 规范是没有办法遍历枚举类型的。不过有特殊情况，即在枚举类型中的值是连续时 可以遍历，否则不能；</p><hr><h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td><strong>函数返回为空</strong> ：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td>2</td><td><strong>函数参数为空</strong>： C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td>3</td><td><strong>指针指向 void</strong> ：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>逻辑运算符</strong></p><p>假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr><tr><td>||</td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A || B) 为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr></tbody></table><p><strong>位运算符</strong></p><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p | q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p><blockquote><p>A &#x3D; 0011 1100</p><p>B &#x3D; 0000 1101</p><p>-—————-</p><p>A&amp;B &#x3D; 0000 1100</p><p>A|B &#x3D; 0011 1101</p><p>A^B &#x3D; 0011 0001</p><p>~A &#x3D; 1100 0011</p></blockquote><p><strong>赋值运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C &#x3D; A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+&#x3D;</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C +&#x3D; A 相当于 C &#x3D; C + A</td></tr><tr><td>-&#x3D;</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -&#x3D; A 相当于 C &#x3D; C - A</td></tr><tr><td>*&#x3D;</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *&#x3D; A 相当于 C &#x3D; C * A</td></tr><tr><td>&#x2F;&#x3D;</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td></tr><tr><td>%&#x3D;</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %&#x3D; A 相当于 C &#x3D; C % A</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移且赋值运算符</td><td>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移且赋值运算符</td><td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与且赋值运算符</td><td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td>^&#x3D;</td><td>按位异或且赋值运算符</td><td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td>|&#x3D;</td><td>按位或且赋值运算符</td><td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><p><strong>杂项运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回变量的大小。</td><td>sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>&amp;</td><td>返回变量的地址。</td><td>&amp;a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指向一个变量。</td><td>*a; 将指向一个变量。</td></tr><tr><td>? :</td><td>条件表达式（三元运算符）</td><td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table><h2 id="3章-顺序结构"><a href="#3章-顺序结构" class="headerlink" title="3章 顺序结构"></a>3章 顺序结构</h2><ol><li><p>printf函数包括“格式控制”和“输出列表”，其中“格式控制”包括：<u>格式说明、普通字符</u>；。</p><p>scanf函数包括“格式控制”和“地址列表”。</p></li><li><p>#define宏都是直接替换的，不会计算后再替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  P  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  S(a)   P*a*a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span>  ar;</span><br><span class="line">ar=S(<span class="number">3</span>+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,ar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为29</span></span><br><span class="line"><span class="comment">//s(3+5) = p*3+5*3+5 = 9+15+5 =29</span></span><br></pre></td></tr></table></figure></li><li><p>真  等价于  非0的数</p></li><li><p>数组中的元素具有相同的类型（数据类型，储存类型）</p></li><li><p>实型常量–指数形式：e&#x2F;E之前必须有数字，且e&#x2F;E后面必须为整数；如不能有e4，12e2.5</p></li><li><pre><code>\a:警告，蜂鸣声\b：退格，后退一个字符\f：换页\n：换行\r：回车，当前位置移到本行开头\t：水平制表符，当前位置移到下一个tab位置\v：垂直制表符，当前位置移到下一个垂直对齐点\加数字：数字为八进制，表示为数字对于的ASCII字符\x加数字：数字为十六进制，表示为数字对于的ASCII字符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 4章 选择结构</span><br><span class="line"></span><br><span class="line">1. switch括号内的表达式应为整数类型，即可以是int类型、char类型、枚举类型；</span><br><span class="line"></span><br><span class="line">2. 运算符优先级：</span><br><span class="line"></span><br><span class="line">   !(逻辑非) &gt; 算数运算 &gt; 关系运算 &gt; &amp;&amp;(逻辑与) &gt; ||(逻辑或) &gt; 赋值运算</span><br><span class="line"></span><br><span class="line">3. else与它前面最近的一个未配对的if 配对</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5章 循环结构</span><br><span class="line"></span><br><span class="line">1. ```c</span><br><span class="line">   int k = 0; </span><br><span class="line">   while(k++ &lt;= 2)&#123;</span><br><span class="line">   printf(&quot;%d &quot;,k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>执行结果为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>for( 表达式1；表达式2；表达式3) 中表达式2不成立后，依旧会执行完表达式3.</p></li></ol><h2 id="6章-数组"><a href="#6章-数组" class="headerlink" title="6章.数组"></a>6章.数组</h2><ol><li>全局或静态数组：未初始化的部分默认为0；<br>局部数组：如果有部分初始化，则剩下未初始化的部分为0；如完全没有初始化，则所有值均不确定。</li><li>“类型  数组名  [常量表达式]”  中常量表达式 可以包括 常量和符号常量。</li><li>二维数组中元素排列顺序为  ： 按行存放，即在内存中先存放第一行的元素，再存放第二行的元素。</li></ol><h4 id="输出“魔方阵”。"><a href="#输出“魔方阵”。" class="headerlink" title="输出“魔方阵”。"></a><strong>输出“魔方阵”。</strong></h4><p>所谓魔方阵是指这样的方阵，它的每一行、每一列和对角线之和均相等。例如，三阶魔方阵为</p><p>816</p><p>357<br>492<br>要求输出1～pow（n，2）的自然数构成的魔方阵。<br>解:魔方阵中各数的排列规律如下:<br>（1）将1放在第1行中间一列。<br>（2）从2开始直到n×n止各数依次按下列规则存放:每一个数存放的行比前一个数的<br>行数减1，列数加1（例如上面的三阶魔方阵，5在4的上一行后一列）。<br>（3）如果上一数的行数为1，则下一个数的行数为n（指最下一行）。例如，1在第1行，<br>则2应放在最下一行，列数同样加1。<br>（4）当上一个数的列数为n时，下一个数的列数应为1，行数减1。例如，2在第3行最<br>后一列，则3应放在第2行第1列。<br>（5）如果按上面规则确定的位置上已有数，或上一个数是第1行第n列时，则把下一个<br>数放在上一个数的下面。例如，按上面的规定，4应该放在第1行第2列，但该位置已被1<br>占据，所以4就放在3的下面。由于6是第1行第3列（即最后一列），故7放在6下面。</p><p>按此方法可以得到任何阶的魔方阵。注：魔方阵的阶数应为奇数。</p><h2 id="7章-函数"><a href="#7章-函数" class="headerlink" title="7章.函数"></a>7章.函数</h2><ol><li><p>变量作为实参向形参的数据传递方式是：单向值传递</p></li><li><p>函数的定义不可以嵌套，但调用可以嵌套</p></li><li><p>形参可以是常量，变量或表达式；</p></li><li><p>实参与对应的形参各占用独立的存储单元；</p></li></ol><p>函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><hr><p><strong>调用函数：</strong></p><ul><li><p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p></li><li><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p></li></ul><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>用牛顿迭代法求根。方程为ax3＋b2＋cx＋d＝0，系数a，b，c，d的值依次为1，2，<br>3，4，由主函数输入。求x在1附近的一个实根。求出根后由主函数输出。</p><p><strong>牛顿迭代公式：x &#x3D; x0 - f(x0) &#x2F; f ‘(x0)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">function</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c, <span class="type">float</span> d)</span> &#123;</span><br><span class="line">    <span class="type">float</span> x1 = <span class="number">1</span>, x0, f1, f2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        f1 = ((a * x0 + b) * x0 + c) * x0 + d;  <span class="comment">//将原公式化简，可减少计算时间</span></span><br><span class="line">        f2 = (<span class="number">3</span> * a * x0 + <span class="number">2</span> * b) * x0 + c;</span><br><span class="line">        x1 = x0 - f1 / f2;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x0) &gt;= <span class="number">1e-3</span>);</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f %f&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %10.7f&quot;</span>, function(a, b, c, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8章-指针运用"><a href="#8章-指针运用" class="headerlink" title="8章.指针运用"></a><strong>8章.指针运用</strong></h2><ol><li>&#96;&#96;&#96;<br>int a[5];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   则数组a中首元素的地址可表示为：a  </span><br><span class="line"></span><br><span class="line">2. C中，指针变量能够赋&lt;u&gt;地址值&lt;/u&gt;或&lt;u&gt;NULL&lt;/u&gt;&lt;u&gt;值&lt;/u&gt;（或&#x27;\0&#x27;，或0，或空值）；</span><br><span class="line"></span><br><span class="line">3. 指针 p++ 指 p = p + 1，因为++有赋值操作，p的值（存放的地址）会改变；</span><br><span class="line"></span><br><span class="line">   指针 p + 1 指访问下一个地址；p本身不变。</span><br><span class="line"></span><br><span class="line">4. * int  * p[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与[]结合,因为其优先级比 * 高,所以P 是一个数组,然后再与 * 结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以**P 是一个由返回整型数据的指针所组成的数组** </span><br><span class="line"></span><br><span class="line">   * int  ( *p)[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以**P 是一个指向由整型数据组成的数组的指针** </span><br><span class="line"></span><br><span class="line">   * int * * p; </span><br><span class="line"></span><br><span class="line">     //首先从P 开始,先与* 结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.</span><br><span class="line">   </span><br><span class="line">   * int p(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </span><br><span class="line">   </span><br><span class="line">   * Int ( *p)(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以**P 是一个指向有一个整型参数且返回类型为整型的函数的指针** </span><br><span class="line">   </span><br><span class="line">   * int * (* p(**int**))[3]; </span><br><span class="line">   </span><br><span class="line">     从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的 * 结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以**P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.** </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一些题解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 求素数</span><br><span class="line"></span><br><span class="line">令变量 i 从**2**开始，看是否能被N%后等于0，i  一直到**sqrt（N）**即可。</span><br><span class="line"></span><br><span class="line">#### 将ASCII码转为字符：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">char c1;</span><br><span class="line">c1 = 33;    //对应字符ASCII码的十进制数，不需加引号；</span><br><span class="line">printf(&quot;%c&quot;,c1);</span><br><span class="line">//32以前的字符无法正常输出；</span><br></pre></td></tr></table></figure></li></ol><p>将字符转为对应ASCII码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c 的 ASCII 为 %d&quot;</span>, c, c);</span><br><span class="line"><span class="comment">//%d显示整数，%c显示对应字符</span></span><br></pre></td></tr></table></figure><h4 id="一元二次方程"><a href="#一元二次方程" class="headerlink" title="一元二次方程"></a>一元二次方程</h4><p>求<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708726.png" alt="image-20210409140501637" style="zoom: 50%;" />的根：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,c,x1,x2,d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入方程的三个系数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        d=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*c);</span><br><span class="line">        x1=(-b+d)/(<span class="number">2</span>*a);</span><br><span class="line">        x2=(-b-d)/(<span class="number">2</span>*a);</span><br><span class="line">        <span class="keyword">if</span>(x1&lt;x2) </span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x2,x1); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x1,x2);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求两数的最大公约数："><a href="#求两数的最大公约数：" class="headerlink" title="求两数的最大公约数："></a>求两数的最大公约数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2, i, gcd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入两个正整数，以空格分隔: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt;= n1 &amp;&amp; i &lt;= n2; ++i)&#123;</span><br><span class="line">        <span class="comment">// 判断 i 是否为最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(n1%i==<span class="number">0</span> &amp;&amp; n2%i==<span class="number">0</span>)</span><br><span class="line">            gcd = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最大公约数是 %d&quot;</span>, n1, n2, gcd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> rem;<span class="comment">//余数，当余数为0的时候，最后的m即为最大公约数</span></span><br><span class="line"><span class="comment">//先用较小的数对较大的数取余，再用余数对较小的数求余，直到余数为零 </span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">rem = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = rem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m;<span class="comment">//将结果返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">return</span> fun(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>求两数最小公倍数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minMultiple;</span><br><span class="line">    minMultiple = (n1&gt;n2) ? n1 : n2;<span class="comment">// 判断两数较大的值，并赋值给 minMultiple</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( minMultiple%n1==<span class="number">0</span> &amp;&amp; minMultiple%n2==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最小公倍数为 %d&quot;</span>, n1, n2,minMultiple);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++minMultiple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：先记n1和n2的积为p，再求最大公约数x，则最小公倍数为p/x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = n1 * n2;</span><br><span class="line">    <span class="type">int</span> rem;</span><br><span class="line"><span class="keyword">while</span>(n2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">rem = n1 % n2;</span><br><span class="line">n1 = n2;</span><br><span class="line">n2 = rem;</span><br><span class="line">&#125;<span class="comment">//最后n1为最大公约数</span></span><br><span class="line">    <span class="type">int</span> minMultiple = p / n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><p>有三根柱子，有若干圆盘从下面开始按大到小顺序摆在第一根柱子上，将这些圆盘原封不动移到另一根（第三根）柱子上。<br>并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><strong>总体思想</strong><br>1.将 n-1个盘子先放到B座位上<br>2.将A座上地剩下的一个盘移动到C盘上<br>3.将n-1个盘从B座移动到C座上<br><strong>或者</strong><br>在1盘的基础上操作2盘，在2盘的基础上操作3盘………在n-1盘的基础上操作n盘</p><p>（1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hannuo</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> one ,<span class="type">char</span> two,<span class="type">char</span> three)</span> <span class="comment">//将n个盘从one座借助two转移到three</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        move(one, three);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hannuo(n<span class="number">-1</span>,one ,three,two);<span class="comment">//将 n-1个盘子从A借助c放到B座位上</span></span><br><span class="line">        move(one,three);<span class="comment">//将A座上地剩下的一个盘移动到C盘上</span></span><br><span class="line">        hannuo(n<span class="number">-1</span>,two,one,three);<span class="comment">//将n-1个盘借助A从B座移动到C座上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">char</span> y)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c---&gt;%c\n&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your number&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    hannuo(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）（上下两段代码一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">int</span> i,<span class="type">char</span> y)</span></span><br><span class="line">    <span class="title function_">printf</span><span class="params">(<span class="string">&quot;move disk %d:%c-&gt;%c\n&quot;</span>,i,x,y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> a,<span class="type">char</span> b, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">     move(a,<span class="number">1</span>,c);      <span class="comment">//将n个盘子从A移动到c</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">       hanoi(n<span class="number">-1</span>,a, c,b);<span class="comment">//将n-1个盘子从A借助C移动到B</span></span><br><span class="line">       move(a, n, c) ;<span class="comment">//将n个盘子从A移动到C</span></span><br><span class="line">       hanoi(n<span class="number">-1</span>,b, a,c) ;<span class="comment">//将n-1个盘子从B借助A移动到C</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3个字符串排序"><a href="#3个字符串排序" class="headerlink" title="3个字符串排序"></a>3个字符串排序</h4><p>输入3个字符串，按由小到大的顺序输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, a);</span><br><span class="line">    <span class="built_in">strcpy</span>(a,b);</span><br><span class="line">    <span class="built_in">strcpy</span>(b,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> n1[<span class="number">20</span>], n2[<span class="number">20</span>], n3[<span class="number">20</span>];</span><br><span class="line">    gets(n1);</span><br><span class="line">    gets(n2);</span><br><span class="line">    gets(n3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n2) &gt; <span class="number">0</span>) swap(n1, n2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n3) &gt; <span class="number">0</span>) swap(n1, n3);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n2, n3) &gt; <span class="number">0</span>) swap(n2, n3);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt; %s &lt; %s&quot;</span>,n1, n2, n3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C一些用法"><a href="#C一些用法" class="headerlink" title="C一些用法"></a>C一些用法</h1><ol><li><pre><code class="c">int *p[3];//定义了一个指针数组p，该数组含有三个元素;//每个元素都是基类型为int的指针<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">   char *s=&quot;\ta\017bc&quot;;</span><br><span class="line">   //则指针变量s指向的字符串所占的字节数是?</span><br><span class="line">   //6个，(包括结束符)</span><br><span class="line">   //\t  a  \017  b  c  \0</span><br></pre></td></tr></table></figure></code></pre></li><li><p>同类型的两个指针之间可以减运算，但不能加运算；</p><ul><li>两个相同指针变量相减可以获得在其之间相隔的同类型元素个数（可在某类型的数组中应用）；</li></ul></li><li><pre><code class="c">(j = 3, j++)//表达式的值为3，j为4；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```c</span><br><span class="line">   #define S(a,b) t=a;a=b;b=t</span><br><span class="line">   //宏就是符号定义，宏扩展时只是字符串替换，</span><br><span class="line">   //虽然变量t没定义，但此宏定义是正确的</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准</p></li><li><p>内外函数的两种理解.</p></li></ol><p>   (1)库函数是C语言的内部函数或自带函数,外部函数即程序员自定函数. </p><p>   (2)凡加写了extern 的函数是外部函数；一个函数声明为static或声明在另外一个函数内部，那么这个函数就是内部函数，它的声明在其他文件中不可见。</p><ol start="8"><li><strong>位运算符</strong>的操作数必须为<strong>整数类型</strong>；</li></ol><p>   （位运算符优先级比算数运算符低）</p><table><thead><tr><th>&amp;</th><th>（按位与）都为1，则得到1；有一个0，则得到0</th></tr></thead><tbody><tr><td>|</td><td>（按位或）有一个1，则得到1；都为0，则得到0</td></tr><tr><td>^</td><td>（按位异或）两着值不同，则得到1；值相同，则为0</td></tr><tr><td>~</td><td>（取反）~x：取反（得到x的补码）</td></tr></tbody></table><p>9. </p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0177</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %3d, x = %6d, x = %6o, x = %6x, x = %6u\n&quot;</span>, x, x, x, x, x);</span><br><span class="line"><span class="comment">//输出结果为:(0117以0开头，表示八进制数，即十进制的127，十六进制的7f)</span></span><br><span class="line"><span class="comment">//x = 127, x =    127, x =    177, x =     7f, x =    127</span></span><br></pre></td></tr></table></figure><ol start="10"><li><pre><code class="c">double a = 513.789215;printf(“a = %8.2f, a = %14.8f, a = %14.8lf\n”, a, a, a);//输出结果：a = 513.79，a = 513.78921500，a = 513.78921500//小数部分不够则补0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. ```c</span><br><span class="line">    int a = 0;</span><br><span class="line">    a += (a = 8);</span><br><span class="line">    //运算后a = 16</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;c<br>int a[4],*p &#x3D; a;<br>*p++;<br>*(–p);<br>&#x2F;&#x2F;上述两者都是指针p地址值的改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### C运算符的优先级</span><br><span class="line"></span><br><span class="line">![img](https://pic4.zhimg.com/v2-de212d1860ead5971c56d91194f94fa1_r.jpg?source=1940ef5c)</span><br><span class="line"></span><br><span class="line">#### 四舍五入</span><br><span class="line"></span><br><span class="line">例：对小数点后四舍五入：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//a是x四舍五入后的结果</span><br><span class="line">a = (int)(x+0.5)&gt;(int)x?(int)x+1:(int)x;</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="keyword">sizeof</span>(str);</span><br><span class="line"><span class="type">int</span> count2 = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">//sizeof会将\0一起计算，strlen只计算字符串本身长度</span></span><br></pre></td></tr></table></figure><h4 id="1-为类型起别名"><a href="#1-为类型起别名" class="headerlink" title="1.为类型起别名"></a>1.为类型起别名</h4><p>为常用的数据类型起一个别名，这样就实现简单的多态，如需要将int类型改为char时，只需修改定义的别名中的类型即可。</p><h4 id="2-求数中的一个数字"><a href="#2-求数中的一个数字" class="headerlink" title="2.求数中的一个数字"></a>2.求数中的一个数字</h4><p>要求一个数中的个位数字，可使用求模运算，如，149 % 10 &#x3D;  9；</p><h4 id="3-迭代自增用-i"><a href="#3-迭代自增用-i" class="headerlink" title="3.迭代自增用++i"></a>3.迭代自增用++i</h4><p>一般情况下，迭代自增请使用++ i （以减少不必要开销）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>; 语句<span class="number">2</span>; 语句<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  被执行的代码块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语句 1 在循环（代码块）开始前执行；</p><p>语句 2 定义运行循环（代码块）的条件；</p><p>语句 3 在循环（代码块）已被执行之后执行。</p><ul><li>循环里的 ++i 和 i++的结果是一样的，<strong>都要等代码块执行完毕才能执行</strong>，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因。</li></ul><h4 id="4-uthash"><a href="#4-uthash" class="headerlink" title="4.uthash"></a>4.uthash</h4><p>开源文件&lt;uthash.h&gt;    :    uthash 是C的比较优秀的开源代码，它实现了常见的hash操作函数，例如查找、插入、删除等待。该套开源代码采用宏的方式实现hash函数的相关功能，支持C语言的任意数据结构为key值，甚至可以采用多个值作为key，</p><h4 id="5-qsort"><a href="#5-qsort" class="headerlink" title="5.qsort"></a>5.qsort</h4><p>头文件&lt;stdlib.h&gt;  包含有    <strong>qsort</strong>    函数（即快速排序），用法：</p><p><strong>对int类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *) a - *(<span class="type">int</span> *) b;  </span><br><span class="line">    <span class="comment">//输入a，b：*(int *) a - *(int *) b为顺序排序，即从小到大排，b - a 则为逆序排序，即从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    qsort (arr, n , <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对char类型：（同上）</p><p>对double类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *a , <span class="type">const</span> <span class="type">void</span> *b )</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> *(<span class="type">double</span>*)a &gt; *(<span class="type">double</span>*)b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>对结构体类型以及字符串类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp1</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b-&gt;num - a-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp2</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;word, b-&gt;word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>qsort  ( )  包含：</p><ul><li>arr  :  指向要排序的数组的第一个元素的指针；</li><li>n : 对应数组中元素的个数；</li><li>sizeof ( int ) : 数组中每个的元素的大小，以字节为单位；</li><li>cmp：用来比较两个元素的函数</li></ul><h4 id="6-布尔类型"><a href="#6-布尔类型" class="headerlink" title="6.布尔类型"></a>6.布尔类型</h4><p>C语言中没有布尔类型，要使用true和false，需要导入头文件&lt;stdbool.h&gt;,或使用宏定义或枚举类来设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用宏定义布尔类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="comment">//定义一个布尔变量</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以用过枚举来定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    <span class="literal">true</span> = <span class="number">1</span>, falsse = <span class="number">0</span></span><br><span class="line">&#125;<span class="type">bool</span>;</span><br></pre></td></tr></table></figure><h4 id="7-字符串操作"><a href="#7-字符串操作" class="headerlink" title="7.字符串操作"></a>7.字符串操作</h4><p>C中的有关字符串操作的函数：</p><ul><li>需要头文件&lt;string.h&gt;</li></ul><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h4 id="8-动态分配"><a href="#8-动态分配" class="headerlink" title="8.动态分配"></a>8.动态分配</h4><ul><li>malloc用法，如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ul><li>calloc用法，如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;  关于效率问题，calloc函数由于给每一个空间都要初始化值，那必然效率较malloc要低，并且现实世界，很多情况的空间申请是不需要初始值的，这也就是为什么许多初学者更多的接触malloc函数的原因。</p><ul><li>realloc用于对动态内存进行扩容（即已申请的动态空间不够用，需进行空间扩容操作），如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> *pp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>（逗号前的p是指向原来空间的指针，逗号后是需要扩容的大小）</p><h4 id="9-amp-amp-和switch注意"><a href="#9-amp-amp-和switch注意" class="headerlink" title="9.&amp;&amp;和switch注意"></a>9.&amp;&amp;和switch注意</h4><ul><li><p>（…)&amp;&amp;(…)     如果前面的语句为0，则后面的语句不执行</p></li><li><p>switch中的case后不带break的话，会一直往后执行，直到遇到break；default写在中间，也会一直往后执行语句，直到遇到break或switch结束。</p></li></ul><h4 id="10-斐波那契数通项公式："><a href="#10-斐波那契数通项公式：" class="headerlink" title="10.斐波那契数通项公式："></a>10.斐波那契数通项公式：</h4><p><img src="https://gitee.com/ValcanoZz/notes_image/raw/master/img/202203191708728.png" alt="image-20210407141717675"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-math-h"><a href="#11-math-h" class="headerlink" title="11.math.h"></a>11.math.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">    <span class="comment">//返回x的自然对数（基数为e的对数）</span></span><br><span class="line">如：<span class="title function_">log</span><span class="params">(<span class="number">2.700000</span>)</span> = <span class="number">0.993252</span>    </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">    <span class="comment">//返回x的常用对数（基数为10的对数）</span></span><br><span class="line">如：<span class="title function_">log10</span><span class="params">(<span class="number">10000.000000</span>)</span> = <span class="number">4.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> *integer)</span></span><br><span class="line">    <span class="comment">//返回值为小数部分，并设置interger为整数部分</span></span><br><span class="line">如：x = <span class="number">8.123456</span>;</span><br><span class="line">   fractpart = <span class="built_in">modf</span>(x, &amp;intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;整数部分 = %lf\n&quot;</span>, intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;小数部分 = %lf \n&quot;</span>, fractpart);</span><br><span class="line">结果为：整数部分 = <span class="number">8.000000</span></span><br><span class="line">   小数部分 = <span class="number">0.123456</span> </span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">pow</span>(<span class="type">double</span> x,<span class="type">double</span> y)</span><br><span class="line">    <span class="comment">//返回x的y次幂</span></span><br><span class="line">如：<span class="built_in">pow</span>(<span class="number">8.0</span>, <span class="number">3</span>) </span><br><span class="line">   值 <span class="number">8.0</span> ^ <span class="number">3</span> = <span class="number">512.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的平方根</span></span><br><span class="line">如：<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br><span class="line">    值<span class="number">4.000000</span> 的平方根是 <span class="number">2.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">fabs</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的绝对值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">ceil</span>(<span class="type">double</span> x)    </span><br><span class="line">    <span class="comment">//返回大于或等于x的最小整数值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">floor</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回小于或等于x的最大整数值</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="built_in">fmod</span>(<span class="type">double</span> x,<span class="type">double</span> y)</span><br><span class="line">    <span class="comment">//返回x除以y的余数</span></span><br></pre></td></tr></table></figure><h4 id="12-负数补码，二-x2F-十-x2F-八进制转化"><a href="#12-负数补码，二-x2F-十-x2F-八进制转化" class="headerlink" title="12.负数补码，二&#x2F;十&#x2F;八进制转化"></a>12.负数补码，二&#x2F;十&#x2F;八进制转化</h4><p>补码来表示和存储。反码多应用于系统环境设置。</p><p>1、补码：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p><p>2、反码：反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数。</p><p>比如（7）+（-7）&#x3D;0</p><p>7 -&gt; 0000 0111（7的补码）</p><p>-7 -&gt; 1111 1001（-7的补码）</p><p>所以相加为1 0000 0000（超出的最高位默认去掉）</p><p>比如（2）+（-3）&#x3D;（-1）</p><p>2  -&gt; 0000 0010 （2的补码）</p><p>-3 -&gt; 1111 1101 （-3的补码）</p><p>相加为 1111 1111（-1的补码）</p><ul><li><p>1.<strong>负数的补码是在原码的基础上除符号位外其余位取反后+1</strong></p><p>例如：-8的原码为 1000 1000，通过原码求出它的反码，负数的反码就是 除符号为以外，其余的全部求反，-8 的反码为 1111 0111，其反码码 +1，就是它的补码， -8 的补码为 1111 1000</p><p><strong>或者</strong>：</p><p>2.<strong>先求出负数的绝对值的二进制，然后从右到左遍历，遇到第一个1时，将其左侧全部取反，右侧和它本身不变。</strong></p><p><strong>例如01100100 -&gt; 10011100</strong></p></li><li><p>十进制转二进制，如果十进制数是负数则取其反码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">15</span>], flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) flag = <span class="number">1</span>, x = -x;    <span class="comment">//这里使用了上述第二种取补码方式   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        arr[i] = x % <span class="number">2</span>;<span class="comment">//这里数组存储二进制数的1和0的顺序与其本身相反</span></span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="comment">// 负数 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)        </span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">1</span> &amp;&amp; i &lt; <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">7</span>; ++j)</span><br><span class="line">                    arr[j] = <span class="number">1</span> - arr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">convertDecimalToBinary</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> binaryNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> remainder, i = <span class="number">1</span>, step = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Step %d: %d/2, 余数 = %d, 商 = %d\n&quot;</span>, step++, n, remainder, n/<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        binaryNumber += remainder*i;</span><br><span class="line">        i *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制转十进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的n由1和0构成，以表示二进制数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">convertBinaryToDecimal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> decimalNumber = <span class="number">0</span>, i = <span class="number">0</span>, remainder;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        decimalNumber += remainder*<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decimalNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="输入常见问题"><a href="#输入常见问题" class="headerlink" title="输入常见问题"></a>输入常见问题</h4><h6 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h6><p>1、scanf的返回值</p><p>scanf通常返回的是成功赋值(从标准输入设备赋值到参数列表所指定的内存区域)的数据项数，如果出错或是遇到end of file，则返回EOF，比如：</p><p>scanf(“%d%d”, &amp;x, &amp;y);</p><p> scanf函数仅在每一个数据域均有数据，并按回车后结束</p><p>如果x和y都被成功读入，那么scanf的返回值就是2;<br>如果只有x被成功读入，返回值为1;<br>如果x和y都未被成功读入，返回值为0;<br>如果遇到错误或遇到end of file，返回值为EOF</p><p>2、scanf的处理机制</p><p>scanf以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf需要读取一个数据项，发现缓冲区当前是空的，那么程序就会在scanf代码处阻塞，等待用户输入，scanf函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf函数返回，程序继续执行。</p><p>3、scanf对不同类型输入的处理方式</p><p>首先，要明确一个概念：空白字符(white space)。一般，程序中所指的空白字符是指空格(space)，回车(enter)和指标符(table)。</p><p>3.1 整数%d</p><p>对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(“%d%d”,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。</p><p>3.2 字符串%s<br>scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\0’。</p><p>因此，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p><p>3.3 字符%c</p><p>scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。对此可以使用 getchar(char类型变量) ，来只读取一个字符。</p><p>1 2 4 8 16 32 64 128 256</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
