<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>java | ValcanoZz Blog</title><meta name="keywords" content="java"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一些用法2. HashMap和Hashtable相同点: hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口 不同点:  底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树  Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。  添加k">
<meta property="og:type" content="article">
<meta property="og:title" content="java">
<meta property="og:url" content="http://example.com/2022/04/14/Java/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="一些用法2. HashMap和Hashtable相同点: hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口 不同点:  底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树  Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。  添加k">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151629165.jpeg">
<meta property="article:published_time" content="2022-04-14T06:55:35.221Z">
<meta property="article:modified_time" content="2022-06-09T02:25:12.622Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151629165.jpeg"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2022/04/14/Java/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-09 10:25:12'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">11</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151629165.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-14T06:55:35.221Z" title="发表于 2022-04-14 14:55:35">2022-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-09T02:25:12.622Z" title="更新于 2022-06-09 10:25:12">2022-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/javaLearn/">javaLearn</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">50k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>185分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h2><h3 id="2-HashMap和Hashtable"><a href="#2-HashMap和Hashtable" class="headerlink" title="2. HashMap和Hashtable"></a>2. HashMap和Hashtable</h3><p><strong>相同点:</strong></p>
<p>hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口</p>
<p><strong>不同点:</strong></p>
<ol>
<li><p>底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树</p>
</li>
<li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p>
</li>
<li><p>添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p>
</li>
<li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p>
</li>
<li><p>扩容机制不同：当已用容量&gt;总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。</p>
</li>
<li><p>支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历</p>
</li>
<li><p>迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。</p>
</li>
<li><p>部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法</p>
</li>
<li><p>同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,</p>
<p>而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。sdfla</p>
</li>
</ol>
<h3 id="3-Arrays-asList"><a href="#3-Arrays-asList" class="headerlink" title="3.Arrays.asList"></a>3.Arrays.asList</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>( new 一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 是动态扩容的了。)</p>
<p>注意：</p>
<ul>
<li>不要将  原生数据类型的数组  作为参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());		<span class="comment">//输出结果为1，而不是3</span></span><br></pre></td></tr></table></figure>

<p>上述代码，遍历mylist的话，会得到一个带有hashCode 的对象。</p>
<p>（当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是<strong>数组对象</strong>本身）</p>
<p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 <strong>Integer</strong> 而不是 int。例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());</span><br></pre></td></tr></table></figure>

<ul>
<li><p>asList返回一个由指定数组生成的固定大小的List；</p>
<p>如果不new一个ArrayList，那么得到的list不能修改其大小，且Arrays的内部类ArrayList没有重写add等方法，用add会抛出异常</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);		<span class="comment">//异常</span></span><br></pre></td></tr></table></figure>





<h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h3><p>java允许将同一个类中的<strong>多个同名，同功能但参数个数不同的方法</strong>，封装成一个方法，即通过<strong>可变参数</strong>实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int... 表示接受的是可变参数，类型是int， 即可接受多个int；可变参数的实参可以为0到任意多个；</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以作为数组；</span></span><br><span class="line"><span class="comment">//可变参数可以和普通类型的参数一起放在形参列表，但可变参数必须放在最后；列表里可变参数只能一个</span></span><br><span class="line"><span class="comment">//可变参数的本质就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;接受的参数个数：&quot;</span> + nums.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="5-字符"><a href="#5-字符" class="headerlink" title="5.字符"></a>5.字符</h3><h4 id="1-字符分割"><a href="#1-字符分割" class="headerlink" title="1.字符分割"></a>1.字符分割</h4><p>使用了 <strong>split(string)</strong> 方法通过指定分隔符将字符串分割为数组：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        String[] temp = str.split(d);</span><br><span class="line">        <span class="keyword">for</span>(String x : temp)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure>

<p>使用 <strong>StringTokennizer</strong> 设置不同分隔符来分隔字符串，默认的分隔符是：<strong>空格、制表符（\t）、换行符(\n）、回车符（\r）</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;this is string , split by stringtokenizer&quot;</span>;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用空格作为分隔符</span></span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//用逗号做分隔</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(st2.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st2.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this</span><br><span class="line">is</span><br><span class="line">string</span><br><span class="line">,</span><br><span class="line">split</span><br><span class="line">by</span><br><span class="line">stringtokenizer</span><br><span class="line"></span><br><span class="line">this is string </span><br><span class="line"> split by stringtokenizer</span><br></pre></td></tr></table></figure>



<h4 id="2-字符大小写"><a href="#2-字符大小写" class="headerlink" title="2.字符大小写"></a><strong>2.字符大小写</strong></h4><p>toUpperCase() 方法将字符串从小写转为大写</p>
<p>tolowerCase() 方法将字符串从大写转为小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;string runoob&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strUpper</span> <span class="operator">=</span> str.toUpperCase();</span><br></pre></td></tr></table></figure>

<h4 id="3-测试两个字符串区域是否相等"><a href="#3-测试两个字符串区域是否相等" class="headerlink" title="3.测试两个字符串区域是否相等"></a><strong>3.测试两个字符串区域是否相等</strong></h4><p> regionMatches() 方法测试两个字符串区域是否相等：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Welcome to Microsoft&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;I work with microsoft&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">//第一个参数 true 表示忽略大小写区别</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str1.regionMatches(<span class="literal">true</span>, <span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>); </span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>) 表示将 str1 字符串从第<span class="number">11</span>个字符<span class="string">&quot;M&quot;</span>开始和 str2 字符串的第<span class="number">12</span>个字符<span class="string">&quot;M&quot;</span>开始逐个比较，共比较 <span class="number">9</span> 对字符，由于字符串区分大小写，所以结果为<span class="literal">false</span>。</span><br><span class="line">如果设置第一个参数为 <span class="literal">true</span> ，则表示忽略大小写区别，所以返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure>



<h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><h4 id="获取最大"><a href="#获取最大" class="headerlink" title="获取最大"></a>获取最大</h4><p>通过 Collections 类的 Collections.max() 和 Collections.min() 方法来查找数组中的最大和最小值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.max(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure>

<h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><p>使用List类的Arrays.toString方法和list.Addall（list.Addall（array1.aslist(array2））方法将两个数组合并</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">String b[] = &#123; <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(a));</span><br><span class="line">list.addAll(Arrays.asList(b));</span><br><span class="line">Object[] c = list.toArray();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure>

<h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p>通过 Java Util 类的 <strong>Arrays.fill(arrayname,value)</strong> 方法和<strong>Arrays.fill(arrayname ,starting index ,ending index ,value)</strong> 方法向数组中填充元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(array, <span class="number">100</span>);	<span class="comment">//全部填充 </span></span><br><span class="line">Arrays.fill(array, <span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>);		<span class="comment">//填充第3 - 第6 d</span></span><br></pre></td></tr></table></figure>

<h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">String[] extended = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">extended[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">extended[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"><span class="comment">//从names索引为0处 复制names.length长度的元素，到extend索引为0处</span></span><br><span class="line">System.arraycopy(names, <span class="number">0</span>, extended, <span class="number">0</span>, names.length);</span><br><span class="line"><span class="keyword">for</span> (String str : extended)&#123;</span><br><span class="line">    System.out.println(str);</span><br></pre></td></tr></table></figure>

<h4 id="数组差集，交集"><a href="#数组差集，交集" class="headerlink" title="数组差集，交集"></a>数组差集，交集</h4><p> 用<strong>removeAll</strong> () 方法来计算两个数组的差集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.removeAll(objArray2);		<span class="comment">//objArray中删去元素一样的，留下不一样的</span></span><br></pre></td></tr></table></figure>

<p>用 <strong>retainAll</strong> () 方法来计算两个数组的交集：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.retainAll(objArray2);		<span class="comment">//objArray中删去元素不一样的，留下一样的</span></span><br></pre></td></tr></table></figure>



<h3 id="7-时间处理"><a href="#7-时间处理" class="headerlink" title="7.时间处理"></a>7.时间处理</h3><h4 id="当前时间及格式化"><a href="#当前时间及格式化" class="headerlink" title="当前时间及格式化"></a>当前时间及格式化</h4><p>用simpleDateFormat类的format(date)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Date对象，获取当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是&quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd日 E HH 点 mm分 ss 秒&quot;</span>)</span><br><span class="line">System.out.pritntln(f.format(now));<span class="comment">//将当前时间格式化为指定的格式</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 <span class="number">2019</span> 年 <span class="number">10</span> 月 <span class="number">15</span> 日 星期一 09 点 <span class="number">26</span> 分 <span class="number">23</span> 秒</span><br></pre></td></tr></table></figure>

<p>SimpDateFormat自定义格式中常用字母及含义</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc0Mzc5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h4 id="获取年份月份等"><a href="#获取年份月份等" class="headerlink" title="获取年份月份等"></a>获取年份月份等</h4><p>用Calendar类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//cal.getTime 可获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> cal.get(Calendar.DATE);	<span class="comment">//日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;	<span class="comment">//月</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);		<span class="comment">//年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_WEEK);	<span class="comment">//一周中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dom</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);	<span class="comment">//一个月中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR);	<span class="comment">//一年中的第几天</span></span><br></pre></td></tr></table></figure>



<h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h3><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Vector)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.Vector 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArrayList)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 &quot;</span> + o.getClass() + <span class="string">&quot; 类的实例&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象是 java.util.ArrayList 类的实例</span><br></pre></td></tr></table></figure>

<h4 id="标签（Label）"><a href="#标签（Label）" class="headerlink" title="标签（Label）"></a>标签（Label）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OUTER:  <span class="comment">//定标签义，可以是任意标识符（一般放在迭代语句之前）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Even number: &quot;</span> + i);</span><br><span class="line">		<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span> OUTER;	<span class="comment">//在continue或break后使用标签，直接跳到标签处</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Varargs可变参数"><a href="#Varargs可变参数" class="headerlink" title="Varargs可变参数"></a>Varargs可变参数</h4><p>在一个形参的”类型”与”参数名”之间加上三个连续的”.”，就可以让它和不确定个实参相匹配。</p>
<p>本质上和字符串一样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumvarargs</span><span class="params">(<span class="type">int</span>... intArrays)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, i;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; intArrays.length; i++) &#123;</span><br><span class="line">        sum += intArrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumstring</span><span class="params">(<span class="type">int</span>[] intArrays)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





















<h2 id="Java练习"><a href="#Java练习" class="headerlink" title="Java练习"></a>Java练习</h2><h3 id="网上练习"><a href="#网上练习" class="headerlink" title="网上练习"></a>网上练习</h3><ol>
<li><p>JDK：java开发核心组件；JRE：java运行环境；JVM：java虚拟机</p>
</li>
<li><p>JDK，JRE，JVM的关系：</p>
<p>JDK &#x3D; JRE + Java的开发工具（javac.exe，java.exe，javadoc.exe)</p>
<p>JRE &#x3D; JVM + Java核心类库 </p>
</li>
<li><p>javac（java语言编译器）用于编译java源文件。</p>
</li>
<li><p>JDK工具中javadoc用于生成java文档，格式为HTML。</p>
</li>
<li><p>JVM运行于操作系统之上，依赖于操作系统；能够直接运行<strong>java字节码</strong>文件。</p>
</li>
<li><p>Java HotSpot是一种热编译技术，在运行Java代码时会被使用，只对程序的部分字节码进行优化。</p>
</li>
<li><p>环境变量PATH中包含多个路径时，路径之间用；（分号）分开。</p>
</li>
<li><p>CLASSPATH中的“ .  ” 表示当前目录。</p>
</li>
<li><p>JVM执行一个Java类时，大致流程为：</p>
<p>装载类—&gt;校验类—&gt;执行类中的代码</p>
</li>
<li><p>如果类的成员的访问权限设置为默认，则该成员被同一包中的类访问；</p>
</li>
<li><p>类具有封装性，但可以通过类的公共接口访问类中的数据；</p>
</li>
<li><p>super指的是当前对象的父类对象的内存地址；</p>
</li>
<li><p>尝试对null对象进行操作时，会产生NullPointerException类型的异常；</p>
</li>
<li><p>覆盖（重写）只能发生在父类与子类之间；</p>
<p>重载可以发生在同一个类中；</p>
</li>
<li><p>this和super不能用在main()方法中；</p>
</li>
<li><p>每一个Unicode码占用16个比特位；</p>
</li>
<li><p>封装：对外隐藏内部实现细节，增强程序的安全性；</p>
</li>
<li><p>自定义异常必须继承Exception，可以继承自Error；</p>
</li>
<li><p>使用JDBC（Java Data Base Connectivity）连接数据库的顺序：</p>
<p>导入驱动包 ——加载驱动——建立数据库的连接——发送并处理SQL语句——关闭连接</p>
</li>
</ol>
<p>19.java分了5片内存：寄存器，本地方法区，方法区，栈，堆。</p>
<p>​		栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；栈的存取速度要比堆快，次于CPU寄存器</p>
<p>  	 只要数据运算完成所在的区域结束，该数据就会被释放。</p>
<p>​		堆：用于存储数组和对象，也就是实体。</p>
<p> 		1：每一个实体都有内存首地址值。</p>
<p> 		2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p>
<p> 		3：垃圾回收机制。</p>
<h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><p>一、java入门</p>
<ol>
<li><p>java诞生：1995年5月；java特点：简单性，面向对象，安全性，跨平台性，支持多线程，分部性；</p>
</li>
<li><p>path环境变量的作用：使用jdk命令 &#x2F; 在任何目录下都可以使用javac和java命令；</p>
</li>
<li><p>java程序运行需要经过编译和运行两个步骤：<strong>编译器</strong>执行 <strong>.java文件</strong>，编译生成 .class的字节码文件，而<strong>Java虚拟机</strong>运行 <strong>.class文件</strong>；</p>
<p>java命令用于运行编译后的 .class文件，不需要文件后缀名；</p>
</li>
<li><p>JDK中可执行程序都放在bin目录下：Java编译器javac.exe 和 Java运行工具 java.exe；</p>
</li>
<li><p>一个java程序不一定要有main方法，需要独立运行的程序才要有main方法。</p>
</li>
</ol>
<p>二、java编程基础</p>
<ol>
<li>在Java中，浮点型数会被默认为double类型，所以给float赋值浮点型数据时，应该加F&#x2F;f，如 float &#x3D; 1F；</li>
<li>文档注释 格式： &#x2F;**      *&#x2F;</li>
</ol>
<p>三、面向对象</p>
<ol>
<li>public，static不能修饰局部变量；</li>
<li>构造方法不能被继承；</li>
<li>面向对象的三大特征：封装，继承，多态；</li>
<li>this关键字的作用：（简答题）<ul>
<li>this调用本类中的属性，即成员变量；</li>
<li>this调用本类的其他方法；</li>
<li>this调用本类的其他构造方法，调用时要放在构造方法的首行；</li>
</ul>
</li>
<li>成员变量和局部变量的区别：<ul>
<li>定义位置的区别：成员变量定义与方法之外，类之内；局部变量定义在方法之内；</li>
<li>生命周期：成员变量随着对象的创建而产生，随着对象的消失而消失；局部变量随着方法内的创建语句而产生，在代码运行至自己的作用域外即消失；</li>
<li>存储位置的区别：成员变量存储在堆中，局部变量存储在栈中；</li>
<li>初始值不同：成员变量有默认的初始值；局部变量没有，需要初始化才能使用；</li>
</ul>
</li>
<li>构造方法和普通成员方法的不同：<ul>
<li>构造方法与类名相同；</li>
<li>构造方法前没有返回类型的声明；</li>
<li>构造方法因为没有返回类型，所以不能返回任何值，但可以使用return来返回；</li>
</ul>
</li>
<li>面向对象的三特征：<ul>
<li>封装：将对象的属性和行为封装起来，不需要让外界知道具体的实现细节；</li>
<li>继承：描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类进行功能拓展；</li>
<li>多态：允许程序中出现重名现象，使同种类的多个对象，在接收到同一个消息时能产生不同反应和效果；（前提是有一个父类，多个子类）</li>
</ul>
</li>
<li>局部内部类只可以被final修饰，且只能访问被final修饰的局部变量；</li>
<li>super和this不能同时存在与同一个构造方法中；</li>
</ol>
<p>五、集合</p>
<ol>
<li>如果使用通配符“？”接收对象，则此对象只能接收，不能修改。</li>
</ol>
<p>六、IO</p>
<h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>src（source源文件）—package（包）—-class（类）</p>
<h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>IDEA 中代码模板位置：setting - Editor - Live Templates &#x2F; postfix Completion</p>
<p>常用模板：</p>
<ol>
<li><p>psvm ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sout</p>
</li>
</ol>
<h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>删除当前行：ctrl + y</p>
<p>复制当前行：ctrl + d</p>
<p>补全代码：at + &#x2F;</p>
<p>添加取消注释：ctrl + &#x2F;</p>
<p>生成方法：alt + insert</p>
<p>生成环绕方式：ctrl + alt + t （即 if … else ，do…while，try…catch 之类的）</p>
<p>查看类的的层级关系：ctrl + H</p>
<p>定位方法：ctrl + B</p>
<p>自动分配变量名：alt + 回车   &#x2F;   ctrl + alt + v  &#x2F; 在后面加 .var</p>
<p>显示所有快捷键：ctrl + j</p>
<p>使用单元测试工具 JUnit 来运行调试 单个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法上加上@Test，按Alt+Enter，点”将JUnit5加入到类路径中&quot;，之后方法右边会右绿色小箭头可以使用，之后在这个类中要使用JUnit5，只要加上@Test即可</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th align="left"><strong>功能点</strong></th>
<th align="left"><strong>Eclipse快捷键</strong></th>
<th align="left"><strong>IDEA快捷键</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>搜索</strong></td>
<td align="left">搜索文本</td>
<td align="left">Ctrl + F</td>
<td align="left">Ctrl + FCtrl + R 查找替换                                        Alt + P&#x2F;A 逐个&#x2F;全部替换                                       Alt + F3 查找当前选中词</td>
</tr>
<tr>
<td></td>
<td align="left">继续搜索</td>
<td align="left">Ctrl + K 向前        Ctrl + Shift + K 向后</td>
<td align="left">F3                                                                 Shift + F3</td>
</tr>
<tr>
<td></td>
<td align="left">搜索方法</td>
<td align="left">Ctrl + O</td>
<td align="left">Ctrl + F12</td>
</tr>
<tr>
<td></td>
<td align="left">搜索类</td>
<td align="left">Ctrl + Shift + T</td>
<td align="left">Ctrl + N</td>
</tr>
<tr>
<td></td>
<td align="left">搜索文件</td>
<td align="left">Ctrl + Shift + T</td>
<td align="left">Ctrl + Shift + N                                                         这两个都支持简单的正则表达式，还支持直接按大写字母的缩略，                                   例如：查找JsonTranscoder，只需要输入JT</td>
</tr>
<tr>
<td></td>
<td align="left">搜索所有引用处</td>
<td align="left">Ctrl + Alt + H</td>
<td align="left">Alt + F7</td>
</tr>
<tr>
<td></td>
<td align="left">搜索所有文本出现的位置</td>
<td align="left">Ctrl + H</td>
<td align="left">Ctrl + Shift + F</td>
</tr>
<tr>
<td><strong>编辑</strong></td>
<td align="left">自动代码补全</td>
<td align="left">Alt + &#x2F;</td>
<td align="left">Ctrl + J</td>
</tr>
<tr>
<td></td>
<td align="left">自动代码生成</td>
<td align="left"></td>
<td align="left">Alt + Insert</td>
</tr>
<tr>
<td></td>
<td align="left">快速修复错误</td>
<td align="left">Ctrl + 1</td>
<td align="left">Alt + Enter</td>
</tr>
<tr>
<td></td>
<td align="left">删除当前行</td>
<td align="left">Ctrl + D</td>
<td align="left">Ctrl + X</td>
</tr>
<tr>
<td></td>
<td align="left">复制到下一行</td>
<td align="left"></td>
<td align="left">Ctrl + D</td>
</tr>
<tr>
<td></td>
<td align="left">注释&#x2F;取消注释</td>
<td align="left">Ctrl + &#x2F;</td>
<td align="left">Ctrl + &#x2F;</td>
</tr>
<tr>
<td></td>
<td align="left">选中当前字</td>
<td align="left"></td>
<td align="left">Ctrl + W</td>
</tr>
<tr>
<td></td>
<td align="left">补全当前行</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + Enter神器，补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</td>
</tr>
<tr>
<td></td>
<td align="left">调出最近复制的N份内容</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + V</td>
</tr>
<tr>
<td></td>
<td align="left">查看最近编辑的文件</td>
<td align="left"></td>
<td align="left">Ctrl + E</td>
</tr>
<tr>
<td></td>
<td align="left">对比最近修改</td>
<td align="left"></td>
<td align="left">Alt + Shift + C</td>
</tr>
<tr>
<td></td>
<td align="left">格式化代码</td>
<td align="left">Ctrl + Shift + F</td>
<td align="left">Ctrl + Alt + L</td>
</tr>
<tr>
<td></td>
<td align="left">整理import</td>
<td align="left">Ctrl + Shift + O</td>
<td align="left">Ctrl + Alt + O</td>
</tr>
<tr>
<td><strong>跳转</strong></td>
<td align="left">显示方法层次</td>
<td align="left"></td>
<td align="left">Ctrl + Shift + H</td>
</tr>
<tr>
<td></td>
<td align="left">显示类、方法说明</td>
<td align="left">F2</td>
<td align="left">Ctrl + Q</td>
</tr>
<tr>
<td></td>
<td align="left">跳到方法定义处</td>
<td align="left"></td>
<td align="left">Ctrl + B</td>
</tr>
<tr>
<td></td>
<td align="left">跳到方法实现处</td>
<td align="left"></td>
<td align="left">Ctrl + Alt + B</td>
</tr>
<tr>
<td></td>
<td align="left">跳到上&#x2F;下一方法</td>
<td align="left"></td>
<td align="left">Alt + Up&#x2F;Down</td>
</tr>
<tr>
<td></td>
<td align="left">上&#x2F;下一查看处</td>
<td align="left">Alt + &lt;-Alt + -&gt;</td>
<td align="left">Ctrl + Alt + Up&#x2F;Down</td>
</tr>
<tr>
<td></td>
<td align="left">跳到指定行</td>
<td align="left">Ctrl + L</td>
<td align="left">Ctrl + G</td>
</tr>
<tr>
<td><strong>重构</strong></td>
<td align="left">改名</td>
<td align="left">Alt + Shift + R</td>
<td align="left">Shift + F6</td>
</tr>
<tr>
<td></td>
<td align="left">其他常用</td>
<td align="left"></td>
<td align="left">Ctrl + F6 修改方法签名                                          Ctrl + Shift + F6 修改参数的类型                       Ctrl + Shift + V引入局部变量                              Ctrl + Shift + P 引入参数                              Ctrl + Shift + F 引入类变量                                     Ctrl + Shift + M 引入方法                         Ctrl + Shift + C 引入常量</td>
</tr>
<tr>
<td><strong>运行</strong></td>
<td align="left">启动调试</td>
<td align="left"></td>
<td align="left">Alt + Shift + F9</td>
</tr>
<tr>
<td></td>
<td align="left">启动运行</td>
<td align="left"></td>
<td align="left">Alt + Shift + F10</td>
</tr>
<tr>
<td></td>
<td align="left">单步进入</td>
<td align="left">F5</td>
<td align="left">F7</td>
</tr>
<tr>
<td></td>
<td align="left">单步跳过</td>
<td align="left">F6</td>
<td align="left">F8</td>
</tr>
<tr>
<td></td>
<td align="left">跳过</td>
<td align="left">F8</td>
<td align="left">F9</td>
</tr>
<tr>
<td></td>
<td align="left">执行选中语句</td>
<td align="left"></td>
<td align="left">Alt + F8</td>
</tr>
<tr>
<td><strong>窗口</strong></td>
<td align="left">调出界面</td>
<td align="left"></td>
<td align="left">Ctrl + Alt + S调出Settings界面                                 Ctrl + Alt + Shift + S调出项目Setting界面</td>
</tr>
<tr>
<td></td>
<td align="left">关闭界面</td>
<td align="left"></td>
<td align="left">Ctrl + F4 或 ESC</td>
</tr>
<tr>
<td></td>
<td align="left">打开窗口</td>
<td align="left"></td>
<td align="left">Alt + 窗口编号(例如项目窗口编号是1)</td>
</tr>
<tr>
<td></td>
<td align="left">最大化窗口</td>
<td align="left">Ctrl + M</td>
<td align="left">Ctrl + Shift + F12</td>
</tr>
<tr>
<td></td>
<td align="left">隐藏窗口</td>
<td align="left"></td>
<td align="left">Shift + ESC</td>
</tr>
<tr>
<td></td>
<td align="left">关闭当前文件</td>
<td align="left"></td>
<td align="left">Ctrl + F4</td>
</tr>
<tr>
<td></td>
<td align="left">垂直分屏</td>
<td align="left"></td>
<td align="left">Ctrl + | (自定义的)</td>
</tr>
<tr>
<td></td>
<td align="left">调整窗口位置</td>
<td align="left"></td>
<td align="left">Ctrl + M 将当前光标处显示到屏幕中央</td>
</tr>
<tr>
<td></td>
<td align="left">切换窗口</td>
<td align="left"></td>
<td align="left">Ctrl + Tab</td>
</tr>
</tbody></table>
<h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p>
<p>编写 Java 程序时，应注意以下几点：</p>
<ul>
<li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li>
<li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li>
<li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>
<li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li>
<li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p>
<p>关于 Java 标识符，有以下几点需要注意：</p>
<ul>
<li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li>
<li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>
<li>关键字不能用作标识符</li>
<li>标识符是大小写敏感的</li>
<li>合法标识符举例：age、$salary、_value、__1_value</li>
<li>非法标识符举例：123abc、-salary</li>
</ul>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>Java可以使用修饰符来修饰类中 方法和属性。主要有两类修饰符：</p>
<ul>
<li>访问控制修饰符 : default, public , protected, private</li>
<li>非访问控制修饰符 : final, abstract, static, synchronized</li>
</ul>
<h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul>
<li><p><strong>public</strong> : <strong>对所有类可见（对外公开）</strong>。使用对象：类、接口、变量、方法</p>
</li>
<li><p><strong>protected</strong> : 对<strong>所有子类 和 同一包内的类 可见</strong>。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>
</li>
<li><p><strong>default</strong> (即默认，什么也不写）: 在<strong>同一包内可见</strong>。使用对象：类、接口、变量、方法。</p>
</li>
<li><p><strong>private</strong> : 仅在<strong>类本身内可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p>
</li>
</ul>
<p>可以通过以下表来说明访问权限：</p>
<table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">当前类</th>
<th align="left">同一包内</th>
<th align="left">子孙类(不同包)</th>
<th align="left">其他包</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>public</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
</tr>
<tr>
<td align="left"><code>protected</code></td>
<td align="left">Y</td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>default</code></td>
<td align="left">Y</td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left"><code>private</code></td>
<td align="left"><strong>Y</strong></td>
<td align="left">N</td>
<td align="left">N</td>
<td align="left">N</td>
</tr>
</tbody></table>
<h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h5><p><strong>类变量，也叫静态变量，是该类的所有对象共享的变量，</strong>任何一个该类的对象去访问&#x2F;修改它，取到&#x2F;修改的都是相同的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure>

<p>jdk8以前，静态变量放在静态域（方法区），jdk8以后放在<strong>堆中</strong>，当这个类加载的时候会在堆生成这个类的class对象，静态变量就放在class实例的尾部。</p>
<p><strong>访问方式</strong>：类名.类变量名 或者 对象名.类变量名</p>
<p>（类变量在类加载时就初始化了，而不管new几次对象，类只会加载一次，类变量的生命周期与类相同）</p>
<hr>
<p><strong>类方法</strong>，也叫静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问方式</strong>：类名.类方法名 或者 对象名.类方法名</p>
<p>当方法中不涉及任何和对象相关的成员（包括this，super），则可以设计成静态方法，提高开发效率；如：工具类中的方法utils：Math类、Collections集合</p>
<hr>
<h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol>
<li><p>这个关键字是一个修饰符，可以修饰类，方法，变量。</p>
</li>
<li><p>被final修饰的类是一个<strong>最终类，不可以被继承</strong>。</p>
</li>
<li><p>被final修饰的方法是一个<strong>最终方法，不可以被重写</strong>。</p>
</li>
<li><p>被final修饰的变量是一个<strong>常量，只能赋值一次</strong>。</p>
</li>
</ol>
<p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 <strong>_</strong> 连接。</p>
<p>注意点：</p>
<ul>
<li>final修饰的属性在定义时，必须赋初值，且不能再修改，可以在如下位置<strong>赋值</strong>：<ul>
<li><strong>定义时；</strong></li>
<li><strong>在构造器中</strong></li>
<li><strong>在代码块中</strong></li>
</ul>
</li>
<li>如果final修饰的<strong>属性是静态</strong>的，则只能在定义时和在静态代码块中赋值，<strong>不能在构造器中赋值</strong>；</li>
<li>final类不能继承，但可以实例化对象；</li>
<li>如果类不是final类，但含有final方法，则该方法虽不能重写，但能被继承</li>
<li>final类中，没有必要再将用final修饰方法；</li>
<li><strong>final不能修饰构造器；</strong></li>
<li><strong>final和static搭配使用，不会导致类加载；</strong></li>
<li>包装类（Integer，Double，Float，Boolean等都是final），String也是final类；</li>
</ul>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>这些保留字不能用于常量、变量、和任何标识符的名称。</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">关键字</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">访问控制</td>
<td align="left">private</td>
<td align="left">私有的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">protected</td>
<td align="left">受保护的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">public</td>
<td align="left">公共的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left">类、方法和变量修饰符</td>
<td align="left">abstract</td>
<td align="left">声明抽象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">class</td>
<td align="left">类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">extends</td>
<td align="left">扩充,继承</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">final</td>
<td align="left">最终值,不可改变的</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">implements</td>
<td align="left">实现（接口）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">interface</td>
<td align="left">接口</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">native</td>
<td align="left">本地，原生方法（非 Java 实现）</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">new</td>
<td align="left">新,创建</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">static</td>
<td align="left">静态</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">strictfp</td>
<td align="left">严格,精准</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">synchronized</td>
<td align="left">线程,同步</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">transient</td>
<td align="left">短暂</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">volatile</td>
<td align="left">易失</td>
</tr>
<tr>
<td align="left">程序控制语句</td>
<td align="left">break</td>
<td align="left">跳出循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">case</td>
<td align="left">定义一个值以供 switch 选择</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">continue</td>
<td align="left">继续</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">default</td>
<td align="left">默认</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">do</td>
<td align="left">运行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">else</td>
<td align="left">否则</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">for</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">if</td>
<td align="left">如果</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">instanceof</td>
<td align="left">实例</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">return</td>
<td align="left">返回</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">switch</td>
<td align="left">根据值选择执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">while</td>
<td align="left">循环</td>
</tr>
<tr>
<td align="left">错误处理</td>
<td align="left">assert</td>
<td align="left">断言表达式是否为真</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">catch</td>
<td align="left">捕捉异常</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">finally</td>
<td align="left">有没有异常都执行</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throw</td>
<td align="left">抛出一个异常对象</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">throws</td>
<td align="left">声明一个异常可能被抛出</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">try</td>
<td align="left">捕获异常</td>
</tr>
<tr>
<td align="left">包相关</td>
<td align="left">import</td>
<td align="left">引入</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">package</td>
<td align="left">包</td>
</tr>
<tr>
<td align="left">基本类型</td>
<td align="left">boolean</td>
<td align="left">布尔型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">byte</td>
<td align="left">字节型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">char</td>
<td align="left">字符型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">double</td>
<td align="left">双精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">float</td>
<td align="left">单精度浮点</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">int</td>
<td align="left">整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">long</td>
<td align="left">长整型</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">short</td>
<td align="left">短整型</td>
</tr>
<tr>
<td align="left">变量引用</td>
<td align="left">super</td>
<td align="left">父类,超类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">this</td>
<td align="left">本类</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">void</td>
<td align="left">无返回值</td>
</tr>
<tr>
<td align="left">保留关键字</td>
<td align="left">goto</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">const</td>
<td align="left">是关键字，但不能使用</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">null</td>
<td align="left">空</td>
</tr>
</tbody></table>
<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><strong>作用：</strong></p>
<ol>
<li>区分相同名字的类</li>
<li>当类很多时，可以很好的管理类（Java API文档）</li>
<li>控制访问范围</li>
</ol>
<p><strong>包的基本语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure>

<p>包本质上，就是创建不同的文件夹&#x2F;目录来保存类文件</p>
<p><strong>包的命名规则：</strong></p>
<p>只能包含数字、字母、下划线、小圆点，不能数字开头，不能用关键字或保留字</p>
<p><strong>命名规范：</strong> 小写字母 + 小圆点 </p>
<p>一般是    <strong>com.公司名.项目名.业务模块名</strong></p>
<p><strong>常用的包：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*		<span class="comment">//lang包是基本包，默认导入</span></span><br><span class="line">java.util.*		<span class="comment">//util包是系统提供的工具包，工具类</span></span><br><span class="line">java.net.*		<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*		<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure>

<p><strong>引入包：</strong> <strong>使用 import 关键字</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javautil.Scanner;</span><br></pre></td></tr></table></figure>

<p><strong>注意事项：</strong></p>
<ul>
<li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只能声明一句package；</li>
</ul>
<h3 id="注解"><a href="#注解" class="headerlink" title="注解@"></a>注解@</h3><p>注解（Annotation），也叫元数据（Metadata），用于修饰包，类，方法，属性，构造器，局部变量等数据信息；</p>
<p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息；</p>
<p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等；而在JavaEE中，注解有更大的作用，如：配置应用程序的任何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等；</p>
<p><strong>使用：</strong></p>
<p>三个基本的Annotaton：</p>
<ol>
<li><p><strong>@Override：限定某个方法，是重写父方法的，该注解只能用于方法；</strong></p>
<ul>
<li><p>@Override 表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错；</p>
</li>
<li><p>@Override 只能用来修饰方法</p>
</li>
<li><p>查看@Override注解源码@Target(ElementType. METHOD)，说明只能修饰方法；</p>
</li>
<li><p>@Target是修饰注解的注解，称为元注解</p>
</li>
</ul>
</li>
<li><p><strong>@Deprecated：用于表示某个程序元素（类&#x2F;方法等）已过时；</strong></p>
<ul>
<li>@Target(vlaue &#x3D; {CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</li>
<li>@Deprecated的作用：新旧版本的兼容和过度</li>
</ul>
</li>
<li><p><strong>@SuppressWarnings：抑制编译器警告；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以指定的警告类型有 (可以查看黄色警告光标，看是什么类型的警告)</p>
<p>all，抑制所有警告 </p>
<p>boxing，抑制与封装&#x2F;拆装作业相关的警告 </p>
<p>cast，抑制与强制转型作业相关的警告 </p>
<p> dep-ann，抑制与淘汰注释相关的警告</p>
<p>deprecation，抑制与淘汰的相关警告  </p>
<p>fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告  </p>
<p>finally，抑制与未传回 finally 区块相关的警告 </p>
<p> hiding，抑制与隐藏变数的区域变数相关的警告 </p>
<p> incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告 </p>
<p> javadoc，抑制与 javadoc 相关的警告 </p>
<p> nls，抑制与非 nls 字串文字相关的警告 </p>
<p> null，抑制与空值分析相关的警告 </p>
<p> rawtypes，抑制与使用 raw 类型相关的警告 </p>
<p>resource，抑制与使用 Closeable 类型的资源相关的警告 </p>
<p>restriction，抑制与使用不建议或禁止参照相关的警告</p>
<p> serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p>
<p>static-access，抑制与静态存取不正确相关的警告 </p>
<p>static-method，抑制与可能宣告为 static 的方法相关的警告 </p>
<p> super，抑制与置换方法相关但不含 super 呼叫的警告 </p>
<p> synthetic-access，抑制与内部类别的存取未最佳化相关的警告 </p>
<p> sync-override，抑制因为置换同步方法而遗漏同步化的警告 </p>
<p>unchecked，抑制与未检查的作业相关的警告 </p>
<p>unqualified-field-access，抑制与栏位存取不合格相关的警告 </p>
<p>unused，抑制与未用的程式码及停用的程式码相关的警告</p>
</blockquote>
</li>
</ol>
<p> 补充说明：查看源码时，有个：@interface，表明是一个注解类，跟interface是不一样的          </p>
<hr>
<p><strong>四种元注解：</strong></p>
<ol>
<li>Retention  ：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li>
</ol>
<ol start="2">
<li>Target ： 指定注解可以在哪些地方使用 </li>
<li>Documented ：指定该注解是否会在 javadoc 体现</li>
<li>Inherited ：子类会继承父类注</li>
</ol>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><table>
<thead>
<tr>
<th align="left">基本类型</th>
<th align="left">引用类型(包装类)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">Character</td>
</tr>
</tbody></table>
<p>此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p>
<h4 id="包装类与其他的转换"><a href="#包装类与其他的转换" class="headerlink" title="包装类与其他的转换"></a>包装类与其他的转换</h4><p><strong>包装类与基本类型的相互转换</strong></p>
<p>jdk5后可以自动装箱和拆箱，自动装箱底层调用的是valueOf 方法，比如：Integer.valueOf()；</p>
<p>手动装箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(n);</span><br></pre></td></tr></table></figure>

<p>手动拆箱：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>包装类与String类型的相互转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 —&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;	<span class="comment">//方法一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();	<span class="comment">//方法二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);<span class="comment">//方法三</span></span><br><span class="line"><span class="comment">//String —&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4); <span class="comment">//构造器</span></span><br></pre></td></tr></table></figure>





<h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>Integer和Character常用方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer.MIN_VALUE 	<span class="comment">//返回最小值</span></span><br><span class="line">Integer.MAX_VALUE	<span class="comment">//返回最大值</span></span><br><span class="line">    </span><br><span class="line">Character.isDigit(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//判断是否是数字</span></span><br><span class="line">Character.isLetter(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//判断是不是字母</span></span><br><span class="line">Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是大写</span></span><br><span class="line">Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是小写</span></span><br><span class="line">Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//是不是空格</span></span><br><span class="line">    </span><br><span class="line">Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)	<span class="comment">//转成大写</span></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)	<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure>

<p><strong>关于Integer的数据存放位置：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">127</span>;<span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//Integer.valueOf(n),如果传入的值在-128 ~ 127，直接返回等于这个数值的对象。如果超过了范围，则new一个Integer对象</span></span><br><span class="line"><span class="comment">//即-128 ~ 127范围内的数字，都已经有一个自己的对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;		<span class="comment">//valueOf源码</span></span><br><span class="line">	<span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">		<span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i9 == i10);<span class="comment">//F，对象不同</span></span><br><span class="line"></span><br><span class="line">Integer i11=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> i12=<span class="number">127</span>;</span><br><span class="line">System.out.println(i11==i12); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//只要有基本数据类型，判断的是值是否相同</span></span><br></pre></td></tr></table></figure>



<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>int</td>
<td>4字节</td>
<td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td>
</tr>
<tr>
<td>short</td>
<td>2字节</td>
<td>-32 768 ~ 32 767</td>
</tr>
<tr>
<td>long</td>
<td>8字节</td>
<td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td>
</tr>
<tr>
<td>byte</td>
<td>1字节</td>
<td>-128 ~ 127</td>
</tr>
</tbody></table>
<p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p>
<p><strong>Java没有无符号形式的int,long,short,byte类型。</strong></p>
<p>（可以将有符号整数解释为无符号数，但需要非常仔细）</p>
<hr>
<p><strong>浮点型</strong></p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4字节</td>
<td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td>
</tr>
<tr>
<td>double</td>
<td>8字节</td>
<td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td>
</tr>
</tbody></table>
<p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p>
<ul>
<li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p>
<p>1.正无穷大：Double.POSITIVE_INFINITY</p>
<p>2.负无穷大：Double.NEGATIVE_INFINITY</p>
<p>3.NaN(不是一个数字)：Double.NaN</p>
<ul>
<li>检测一个特定值是否等于Double.NaN：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isNaN(x))		<span class="comment">//检查x是否是一个数</span></span><br></pre></td></tr></table></figure>

<ul>
<li>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</li>
</ul>
</li>
<li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，命令System.out.plantln(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p>
</li>
</ul>
<hr>
<p><strong>char</strong>类型</p>
<p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p>
<ul>
<li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p>
<p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p>
<p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p>
</li>
<li><p>java中，char类型描述了UTF-16编码中的一个代码单元，但辅助字符编码为一对连续的代码单元（即不止一个代码单元），所以<strong>建议不要在程序中使用char类型，除非确实要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</strong></p>
</li>
</ul>
<hr>
<h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a><strong>变量与常量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明与初始化</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12.0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//对于局部变量，如果可以从初始值推断出它的类型，可以不声明类型，只用关键字var即可：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>；  <span class="comment">//i is an int</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>  <span class="comment">//a is a string</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>常量</strong></p>
<p>利用关键字<strong>final</strong>指示常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//final表示这个变量只能被赋值一次，习惯上常量名用全大写</span></span><br></pre></td></tr></table></figure>

<p><strong>类常量</strong>：使某个常量在一个类的多个方法中使用，用关键字<strong>static final</strong>设置类常量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Constant&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line">	<span class="comment">//类常量的定义位于main的外部</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">	....</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h4><p>枚举类型的变量只能存储这个类型声明中给定的某个枚举值，或特殊值null（表示这个变量没有设置任何值）</p>
<hr>
<h4 id="关系运算boolean"><a href="#关系运算boolean" class="headerlink" title="关系运算boolean"></a><strong>关系运算boolean</strong></h4><ul>
<li><p>&amp;&amp;和||运算符按照短路方式求值，如果第一个操作数已能确定表达式的值，第二个操作数就不会进行计算。</p>
</li>
<li><p>&amp;和|不采用短路方式求值，即两个操作数都会进行计算。</p>
</li>
</ul>
<p>&amp;：对应位都为1则结果为1，否则为0；</p>
<p>|：对应位都为0则结果为0，否则为1；</p>
<p>^：对应位值相同则为0，否则为1；</p>
<p>~：按位取反每一位；</p>
<p>位模式左移：&gt;&gt;</p>
<p>右移：&lt;&lt;</p>
<p>运算符&gt;&gt;&gt;会用0填充高位，不存在&lt;&lt;&lt;</p>
<hr>
<h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a><strong>子串</strong></h4><p>String类的substring方法：从字符串中<strong>提取</strong>出一个子串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.substring(<span class="number">0</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="comment">//substring方法中第二个参数是不想复制的第一个位置，即复制0，1，2位</span></span><br><span class="line"><span class="comment">//substring有个优点，就是子串b的长度容易计算，为3-0 = 3，即第2个参数减第1个参数</span></span><br></pre></td></tr></table></figure>

<p>java可以用+号<strong>连接</strong>两个字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br></pre></td></tr></table></figure>

<p>静态join方法：将多个字符串放在一起，用<strong>界定符分开</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String all = String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);</span><br><span class="line">//结果：all = &quot;S/M/L/XL&quot;</span><br></pre></td></tr></table></figure>

<p>repeat方法：将字符串<strong>复制n次</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//结果：a = &quot;javajavajava&quot;</span></span><br></pre></td></tr></table></figure>

<p>java没有提供<strong>修改字符串</strong>的方法，因此要通过其他操作来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a = a.substring(<span class="number">0</span>,<span class="number">3</span>) +<span class="string">&quot;p!&quot;</span>;</span><br><span class="line"><span class="comment">//结果为a = help!</span></span><br></pre></td></tr></table></figure>

<p>（尽管通过这种方式修改字符串效率不高，但不可变字符串有其他的优点：编译器可以让字符串共享，即原始字符串与复制字符串共享相同的字符（地址））。</p>
<p><strong>检测字符串是否相等</strong>：equals方法——s.equals(t）——其中s和t可以是字符串变量，也可以是字符串字面量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(a);</span><br><span class="line"><span class="comment">//如果相等，返回true，否则返回false</span></span><br><span class="line"><span class="comment">//不要使用==运算符来检测两字符串！==只能确定两个字符串是否存放在同一位置，但只有字符串字面量是共享的，而+获substring等操作得到的字符串并不共享。</span></span><br></pre></td></tr></table></figure>





<hr>
<p>localDate类的程序：（显示当前月的日历）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">data</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">//下面获得当前的月份和日期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> data.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> data.getDayOfMonth();</span><br><span class="line">        <span class="comment">//将data设置为这个月的第一天，并得到这一天为星期几</span></span><br><span class="line">        data = data.minusDays(today - <span class="number">1</span>);</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> data.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();</span><br><span class="line">        <span class="comment">//打印日历的表头和第一行缩进</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入循环，使data遍历月的每一天，并打印日期；</span></span><br><span class="line">        <span class="keyword">while</span>(data.getMonthValue() == month)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,data.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfMonth() == today)&#123;      <span class="comment">// 如果data是当前日期，则用*标记；</span></span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            data = data.plusDays(<span class="number">1</span>);    <span class="comment">// 接下来将data推进到下一天，如果到达新一周，则换行打印</span></span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfWeek().getValue() == <span class="number">1</span>) System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mon Tue Wed Thu Fri Sat Sun</span><br><span class="line">              <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span> </span><br><span class="line"> <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>*</span><br><span class="line"> <span class="number">26</span>  <span class="number">27</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">30</span> </span><br></pre></td></tr></table></figure>



<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>main方法时虚拟机调用</li>
<li>jvm需要调用类的main()方法，所以该方法的访问权限必须是public</li>
<li>jvm在执行main()方法时不必创建对象，所以main()为static</li>
<li>main()接受String类型的参数数组，该数组中保存执行java命令时传递给所运行的类的参数</li>
</ol>
<p>在main()方法中，可以直接调用main方法所在类的静态方法和静态变量，但不能访问非静态的方法和变量，必须创建该类的一个实例对象后，才能这个对象去访问；</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类（Class）和对象（object"><a href="#类（Class）和对象（object" class="headerlink" title="类（Class）和对象（object)"></a>类（Class）和对象（object)</h3><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态</p>
<p>(类包含：<strong>属性，方法，构造器，代码块，内部类</strong>)</p>
<p>一个类可以包含以下类型变量：</p>
<ul>
<li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>
<li><strong>成员变量</strong>（非静态变量）：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>
<li><strong>类变量</strong>（静态变量）：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li>
</ul>
<blockquote>
<p>类什么时候会被加载？</p>
<ol>
<li>创建对象实例时；</li>
<li>创建子类对象实例，父类也会被加载；</li>
<li>使用类的静态成员</li>
</ol>
</blockquote>
<hr>
<p><strong>代码块：</strong>又称初始化块，类似于方法，将语句封装在方法体中，用{}包起来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">	代码</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//修饰符可选，但只能写static</span></span><br><span class="line"><span class="comment">// ; 号可写可不写</span></span><br></pre></td></tr></table></figure>

<p><strong>静态代码块</strong>，作用就是对类初始化，随着类的加载而执行，且<strong>只会执行一次</strong>，如果<strong>是普通代码块，每创建一个对象都会执行一次</strong>（如果只是使用类的静态成员，普通代码不会执行）；</p>
<hr>
<p><strong>对象</strong>：对象是类的一个示例，有状态和行为。软件对象的状态就是属性，行为通过方法体现</p>
<p><strong>创建对象</strong></p>
<p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p>
<ul>
<li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li>
<li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li>
<li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用顺序：</strong></p>
<ol>
<li><strong>调用静态代码块和静态属性初始化（有多个则顺序调用）；</strong></li>
<li><strong>调用普通代码块和普通属性的初始化；</strong></li>
<li><strong>调用构造方法；</strong></li>
</ol>
<hr>
<p><strong>源文件声明规则</strong></p>
<p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>
<ul>
<li>一个源文件中只能有一个 public 类</li>
<li>一个源文件可以有多个非 public 类</li>
<li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li>
<li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li>
<li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li>
<li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>
</ul>
<h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>好处：</p>
<p>1：提高了代码的复用性。</p>
<p>2：提高了代码的拓展性和维护性，让类与类之间产生了关系，提供了另一个特征多态的前提。</p>
<ul>
<li><p><strong>一般类只能单继承；内部类实现多继承；接口可以多继承；</strong></p>
</li>
<li><p>子类继承了所有的属性和方法，<strong>非私有的</strong>属性和方法可以在子类<strong>直接访问</strong>，但是<strong>私有的</strong>属性和方法要通过父类提供的<strong>公共方法去访问</strong>；</p>
</li>
<li><p><strong>子类必须调用父类的构造器，完成父类的初始化；</strong></p>
</li>
</ul>
<ol>
<li><strong>对与成员变量：</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关键字：</span><br><span class="line"><span class="built_in">this</span>：是本类类型的对象引用</span><br><span class="line"><span class="comment">//this从本类中开始查找，没有才从父类中找</span></span><br><span class="line"><span class="built_in">super</span>：是子类所属的父类中的内存空间引用</span><br><span class="line"><span class="comment">//super直接从父类中查找</span></span><br><span class="line"><span class="comment">//super不能访问父类的private属性或方法</span></span><br></pre></td></tr></table></figure>

<p>注意：<strong>子父类中通常是不会出现同名成员变量的</strong>，因为父类中只要定义了，子类就不用在定义，直接继承过来用。（当有属性&#x2F;方法<strong>重名时</strong>，<strong>只能用super访问父类的重名属性&#x2F;方法</strong>；super的访问不限于直接父类，如果爷爷类也有与本类重名的属性&#x2F;方法，也能用super去访问；即<strong>多个基类中都有重名的成员，super的访问遵循就近原则</strong>）</p>
<ol start="2">
<li><strong>成员函数：</strong></li>
</ol>
<p>当子父类可以出现一样的方法，即可以覆盖（重写）函数（当一个类的功能需要修改时，可以通过覆盖来实现）</p>
<ol start="3">
<li><strong>构造函数</strong></li>
</ol>
<p>子类的构造函数运行时，一定会先运行父类的构造函数；</p>
<p>原因：子类的构造函数中的第一行，都有一条隐身的语句super()，而这个super（）是在调用父类中空参数的构造函数；</p>
<blockquote>
<p>因为子类继承父类，会继承父类中的数据，所以必须要看到父类对自己数据进行初始化的过程</p>
</blockquote>
<p>子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p>
<blockquote>
<p>注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</p>
<p>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</p>
<p>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p>
</blockquote>
<p><strong>在方法覆盖（重写）时，注意：</strong></p>
<ol>
<li><p>子类覆盖父类时，必须要保证，<strong>子类方法的权限必须大于等于父类方法权限</strong>可以实现继承。否则，编译失败。</p>
</li>
<li><p>覆盖时，要么<strong>都静态</strong>，要么<strong>都不静态</strong>。 (静态只能覆盖静态，或者被静态覆盖)</p>
</li>
<li><p>子类中重写父类的方法，必须与父类的那个方法：<strong>名称，返回类型，参数一样</strong>；</p>
</li>
</ol>
<p><strong>而对于重载：只要同一类中，且方法名一致，参数列表不一样即可，对返回类型，修饰符无要求；</strong></p>
<p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p>
<p>此时可以用到final;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：这个关键字是一个修饰符，可以修饰类，方法，变量。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：被<span class="keyword">final</span>修饰的类是一个最终类，不可以被继承。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：被<span class="keyword">final</span>修饰的方法是一个最终方法，不可以被覆盖。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：被<span class="keyword">final</span>修饰的变量是一个常量，只能赋值一次。</span><br></pre></td></tr></table></figure>

<p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p>
<p><strong>创建子类对象时的调用顺序：</strong></p>
<ol>
<li>父类的静态代码块和静态属性</li>
<li>子类的静态代码块和静态属性</li>
<li>父类的普通代码块和普通属性初始化；</li>
<li>父类的构造方法；</li>
<li>子类的普通代码块和普通属性初始化；</li>
<li>子类的构造方法；</li>
</ol>
<h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现 细节部分 包装、隐藏起来的方法。</p>
<p>也就是说：<strong>将数据和对数据的操作封装起来，程序的其他部分只有通过被允许的操作才能对数据进行修改。</strong></p>
<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>
<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>
<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>
<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>
<p><strong>封装的优点：</strong></p>
<ol>
<li><p>良好的封装能够减少耦合。</p>
</li>
<li><p>类内部的结构可以自由修改。</p>
</li>
<li><p>可以对成员变量进行更精确的控制。</p>
</li>
<li><p>隐藏信息，实现细节。</p>
</li>
</ol>
<hr>
<p><strong>实现Java封装的步骤：</strong></p>
<ol>
<li><p>修改属性的可见性来<strong>限制对属性的访问</strong>（一般限制为<strong>private</strong>）,例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">person</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>
<p><strong>访问权限控制：public &gt; protected &gt; 包 &gt; private</strong> </p>
</li>
<li><p>对每个值属性<strong>提供对外的公共方法访问</strong>，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>static关键字</strong>：可对数据进行静态修饰</p>
<blockquote>
<ol>
<li><p><strong>被静态修饰的成员，可以直接被类名所调用。</strong>也就是说，静态的成员多了一种调用方式。<strong>类名.静态方式。</strong></p>
</li>
<li><p><strong>静态随着类的加载而加载，而且优先于对象存在。</strong></p>
</li>
<li><p><strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p>
</li>
<li><p><strong>静态方法中不能使用this，super关键字。</strong></p>
</li>
</ol>
<p>   因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p>
</blockquote>
<p>成员变量和静态变量的区别：</p>
<p>1，成员变量所属于对象，所以也称为<strong>实例变量</strong>。</p>
<p>   静态变量所属于类，所以也称为<strong>类变量</strong>。</p>
<p>2，成员变量存在于<strong>堆内存</strong>中。</p>
<p>   静态变量存在于<strong>方法区</strong>中。</p>
<p>3，成员变量随着对象创建而存在，随着对象被回收而消失。</p>
<p>   静态变量随着类的加载而存在，随着类的消失而消失。</p>
<p>4，成员变量只能被对象所调用。</p>
<p>   静态变量可以被对象调用，也可以被类名调用。</p>
<p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p>
<h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>实现多态的三个必要条件：<strong>继承，重写（重载也是），向上转型</strong>；</p>
<p><strong>向上转型：子类对象被父类引用；</strong></p>
<p><strong>向下转型：向下转型是子类对象被父类引用之后，再把父类引用强转成子类；</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//向上转型</span></span><br><span class="line">        b.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird)b;<span class="comment">//向下转型</span></span><br><span class="line">        bird.run();</span><br><span class="line">        bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>向下转型的意义：当多个子类继承同一个父类或接口时，可以写一个公用的方法，方法传入的形参为父类或接口，这样每个子类实参就可以传入这个父类形参中，进而实现公用性。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="comment">//传入子类的实参引用</span></span><br><span class="line">        sleep(b);</span><br><span class="line">        sleep(tom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法的参数是父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(Animal A)</span>&#123;</span><br><span class="line">        A.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用例子： </p>
<ol>
<li><p><strong>多态参数：</strong>可以<strong>在方法实参中使用父类，然后调用方法时传入子类，即向上转型</strong></p>
</li>
<li><p><strong>多态数组：</strong>数组的定义类型为父类，里面保存的实际元素类型为子类类型</p>
<p>如果要调用数组中子类特有的方法，可以使用<strong>类型判断+向下转型</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu[] f = <span class="keyword">new</span> <span class="title class_">Fu</span>[n];</span><br><span class="line"><span class="keyword">if</span>(f[i] instancef Zi)&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> (Zi)f[i];</span><br><span class="line">    z.方法();</span><br><span class="line">    <span class="comment">//两句直接写成：((Zi)f[i]).方法();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>多态 体现在：<strong>父类引用变量可以指向子类对象</strong></p>
<p>多态的定义格式：</p>
<blockquote>
<p>父类类型 变量名 &#x3D; new 子类类型（）；</p>
</blockquote>
<p>多态成员特点：</p>
<ol>
<li>多态成员<strong>变量</strong>：编译类型 运行类型 <strong>都看左边</strong></li>
<li>多态成员<strong>方法</strong>：<strong>编类型看左边，运行类型看右边</strong></li>
</ol>
<p><strong>java的动态绑定机制</strong></p>
<ul>
<li><strong>当调用对象方法时，该方法会和对象的内存地址&#x2F;运行类型绑定；</strong></li>
<li><strong>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"><span class="comment">//f是父类Fu中的值，只能取到父中的值</span></span><br><span class="line"><span class="comment">//f表面是Fu，实际类型是Zi，所以调用到的方法是重写后的方法，</span></span><br><span class="line"><span class="comment">//方法里所用到的值，是当前类的值，即调用的方法在哪个类，就用哪那个类的值；</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>instanceof关键字：</strong>用于判断对象是否属于某种数据类型（返回值为布尔类型）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   Fu f1=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        Fu f2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">if</span>(f1 <span class="keyword">instanceof</span> Zi)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Zi的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Son的类型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>多态的转型：</strong></p>
<p>向上转型：多态本身就是向上转型过的过程</p>
<ul>
<li>使用格式：父类类型 变量名&#x3D;new 子类类型();</li>
</ul>
<blockquote>
<p>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。</p>
</blockquote>
<p>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型</p>
<ul>
<li>使用格式：子类类型 变量名&#x3D;（子类类型） 父类类型的变量；</li>
</ul>
<blockquote>
<p>适用场景：当要使用子类特有功能时。</p>
</blockquote>
<hr>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整嵌套了另一个结构，被嵌套的类被称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。</p>
<p>内部类最大的特点是<strong>可以直接访问外部类的所有成员，包括私有属性</strong>。</p>
<p>按定义的位置：</p>
<ol>
<li>定义<strong>在局部位置</strong>（方法&#x2F;代码块）：<ul>
<li><strong>局部内部类</strong></li>
<li><strong>匿名内部类</strong></li>
</ul>
</li>
<li>定义<strong>在成员位置</strong>：<ul>
<li><strong>成员内部类</strong>（不加static）&#x2F; 普通内部类</li>
<li><strong>静态内部类</strong>（加static）</li>
</ul>
</li>
</ol>
<hr>
<h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>在类里面作为一个字段直接定义即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里 B 类为 A 类的普通内部类，在这种定义方式下，普通内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="comment">//不在外部类内部，要用：外部类对象.new 内部构造器()；的方式创建对象</span></span><br><span class="line">        a.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一个类的静态成员独立于这个类的任何一个对象存在，只要在具有访问权限的地方，我们就可以通过 <strong>类名.静态成员名</strong> 的形式来访问这个静态成员，同样的，静态内部类也是作为一个外部类的静态成员而存在，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。</p>
<p>与静态成员一样，静态内部类 无法访问外部类的非静态成员。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在同一个外部类中，且同样是静态的，可以直接new</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不在外部类内部，用：外部类名.静态成员名 进行访问</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类没有名字，定义在外部类的局部位置（方法&#x2F;代码块）</p>
<p>某个类实现接口&#x2F;抽象类，但只使用一次，可以使用匿名内部类（简化开发）  </p>
<p>语法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">	类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>基于接口的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;	<span class="comment">//接口</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;	<span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//anonymity的编译类型是IA，运行类型是匿名内部类</span></span><br><span class="line">        <span class="comment">//匿名内部类其实在底层会分配一个名字，不会显示出来</span></span><br><span class="line">        <span class="comment">//jdk底层在创建匿名内部类anomymity$1,立刻就创建了其实例，并把地址返回给anomymity;</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">anonymity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="comment">//查看一下运行类型，即在原名字后加$1: anomymity$1</span></span><br><span class="line">        system.out.println(anomymity.getclass());</span><br><span class="line">        <span class="comment">//匿名内部类anomymity$1使用一次就回收掉，但anonymity是一个对象，仍可以反复调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于类的匿名内部类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;		<span class="comment">//A可以为普通类或抽象类</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名内部类可以直接当作实参直接传递，简洁高效</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	<span class="comment">//当做实参直接传递，简洁高效</span></span><br><span class="line">	f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">	<span class="comment">//传统方法</span></span><br><span class="line">	f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在外部类的局部位置，有名字。</p>
<p>不能添加访问修饰符，但可以使用final修饰（跟局部变量一样）</p>
<p>作用域：仅在定义它的方法或代码块中</p>
<ul>
<li><p>访问方式：</p>
<ul>
<li>局部内部类访问外部类的成员：直接访问</li>
<li>外部类访问局部内部类的成员：<strong>在它的作用域中创建对象</strong>，再访问；</li>
</ul>
</li>
<li><p>外部其他类不能访问局部内部类（地位相当于是一个局部变量）</p>
</li>
<li><p>如果外部类和局部内部类的成员<strong>同名</strong>，默认遵循就近原则，如果想访问外部类成员，可以用：<strong>外部类名. this. 成员名</strong> ，去访问</p>
</li>
</ul>
<h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，</p>
<p>如果一个类中<strong>没有包含足够的信息来描绘一个具体的对象</strong>，这样的类就是<strong>抽象类</strong>。</p>
<p>抽象类除了<strong>不能实例化对象</strong>之外，类的<strong>其它功能依然存在</strong>，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>
<p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承，才能被使用</strong>。</p>
<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>
<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
<p><strong>使用abstract class来定义抽象类。</strong></p>
<p>抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>
<p>Abstract 关键字同样可以用来声明抽象方法，<strong>抽象方法只包含一个方法名，而没有方法体。</strong></p>
<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明抽象方法会造成以下两个结果：</p>
<ul>
<li>如果一个类<strong>包含抽象方法</strong>，那么该类<strong>必须是抽象类</strong>。</li>
<li>任何<strong>子类必须重写父类的抽象方法</strong>，<strong>或者声明自身为抽象类</strong>。</li>
</ul>
<p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>
<p> <strong>抽象类总结规定</strong></p>
<ol>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li>
<li>抽象关键字abstract 和 final, private, static不共存</li>
</ol>
<p>设计模式：</p>
<p>解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span>&#123; <span class="comment">//此功能如果不需要复写，可加final限定</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">//不确定的功能部分，提取出来，通过抽象方法实现</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;毫秒是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>; <span class="comment">//抽象不确定的功能，让子类复写实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123; &lt;font color=red &gt;<span class="comment">//子类复写功能方法&lt;/font&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;<span class="number">1000</span>; y++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>







<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface），在JAVA中是一个抽象类型，是抽象方法的集合，</p>
<p>接口通常以interface来声明。一个类通过继承接口，从而继承接口中的抽象方法。</p>
<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>
<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>
<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>
<p><strong>接口声明：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口 允许继承 多个其他接口</span></span><br></pre></td></tr></table></figure>

<p><strong>接口实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>接口与类相似点：</strong></p>
<ul>
<li>一个接口可以有多个方法。</li>
<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>
<li>接口的字节码文件保存在 .class 结尾的文件中。</li>
<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>
</ul>
<p><strong>接口与类的区别：</strong></p>
<ul>
<li>接口不能用于实例化对象。</li>
<li>接口没有构造方法。</li>
<li>接口中所有的方法必须是抽象方法。</li>
<li>接口不能包含成员变量，除了 static 和 final 变量。</li>
<li>接口不是被类继承了，而是要被类实现。</li>
<li>接口支持多继承。</li>
</ul>
<p><strong>接口特性：</strong></p>
<ul>
<li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</p>
</li>
<li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</p>
<ul>
<li><p>使用static可以 在继承多接口时，如果存在多个同名变量，可以使用接口名.变量名来区分；</p>
</li>
<li><p>使用final，让接口中的变量不可更改，否则，每个实现接口的类都可以改变这个变量的值，就违背了OCP原则；</p>
</li>
</ul>
</li>
<li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p>
</li>
<li><p>接口的修饰符只能是public和默认。</p>
</li>
</ul>
<p><strong>抽象类和接口的区别：</strong></p>
<ol>
<li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p>
</li>
<li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</p>
</li>
<li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p>
</li>
<li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>
</li>
</ol>
<p>注：</p>
<ol>
<li><p>JDK 1.8 以后，接口里可以有静态方法和方法体了。</p>
</li>
<li><p>JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。</p>
</li>
<li><p>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p>
</li>
</ol>
<hr>
<p><strong>实现接口和继承类的区别</strong></p>
<p>当子类继承了父类，就自动拥有父类的功能，是 is-a的关系</p>
<p>如果子类<strong>需要扩展功能</strong>，可以通过实现接口的方式扩展，是like - a 的关系，可以理解 ” 实现接口“ 是对java单继承机制的补充；</p>
<p>继承的价值只要是：解决代码的复用性和可维护性。</p>
<p>接口的价值主要是：<strong>设计好各种规范</strong>（方法），让其它子类去实现，更加灵活。且接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）。</p>
<hr>
<p><strong>接口与多态</strong></p>
<p>接口也能利用动态参数 和 多态数组</p>
<p>接口存在多态传递现象</p>
<hr>
<p>在重写接口中声明的方法时，需要注意以下规则：</p>
<ul>
<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>
<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>
<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>
</ul>
<p>在实现接口的时候，也要注意一些规则：</p>
<ul>
<li>一个类可以同时实现多个接口。</li>
<li>一个类只能继承一个类，但是能实现多个接口。</li>
<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>
</ul>
<p><strong>标记接口：</strong></p>
<p>最常用的继承接口是没有包含任何方法的接口。</p>
<p>标记接口是没有任何方法和属性的接口。它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>
<p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>
<p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p>
<ul>
<li><p>建立一个公共的父接口：</p>
<p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>
</li>
<li><p>向一个类添加数据类型：</p>
<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>
</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的两种实现：</p>
<ol>
<li>自定义枚举类；</li>
<li>使用enum关键字实现枚举；</li>
</ol>
<hr>
<p> 枚举是一个特殊的类，一般表示一组常量，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ...&#123;</span><br><span class="line">	... , ... , ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用enum，要求将定义常量<strong>对象写在最前面</strong>;</li>
<li>直接使用： <strong>常量名（实参列表）</strong>; 如果使用无参构造器，则实参列表和小括号都可以省略；</li>
<li>如果有多个常量&#x2F;对象,使用<strong>逗号间隔</strong>即可；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//使用enum，要求将定义常量对象写在最前面</span></span><br><span class="line">    <span class="comment">//直接使用： 常量名（实参列表）</span></span><br><span class="line">    <span class="comment">//如果有多个常量/对象,使用逗号间隔即可；</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>values(), ordinal() 和 valueOf() 方法:</strong></p>
<p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>（所以使用enum关键字后，就<strong>不能再继承其他类</strong>了，因为enum隐式继承了Enum类）</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li><strong>values() 返回枚举类中所有的值。</strong></li>
<li><strong>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</strong></li>
<li><strong>valueOf()方法返回指定字符串值的枚举常量。</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举类成员:</strong></p>
<p>枚举跟普通类一样可以用<strong>自己的变量、方法和构造函数</strong>，构造函数只能使用 <strong>private</strong> 访问修饰符，让外部无法调用。</p>
<p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p>
<hr>
<p><strong>自定义枚举类</strong></p>
<ol>
<li>将构造器私有化，防止外部直接new；</li>
<li>去掉set方法，防止属性被修改；</li>
<li>在枚举类内部，直接创建固定的对象；</li>
<li>对外暴露对象：对枚举对象&#x2F;属性使用public + final + static共同修饰，实现底层优化； </li>
<li>枚举对象名通常全部大写（这是常量的命名规范）；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = neme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h3><p>包是Java语言提供的一种区别类名字命名空间的机制，它是类的一种文件组织和管理方式、是一组功能相似或相关的类或接口的集合。</p>
<p>Java package提供了访问权限和命名的管理机制。</p>
<p>一、<strong>包的作用</strong> </p>
<ol>
<li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 </li>
<li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li>
<li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li>
</ol>
<p>二、<strong>包的定义</strong><br>在一个.java文件中可以一个public类和多个非public类，如果要将这些类组织在一个包当中，则在.java文件中除注释以外的第一行使用关键字package即可实现。</p>
<p>当需要调用此包中的类时，就可以使用关键字import进行导入。在定义包的时候，应该注意几点: </p>
<ol>
<li>为了尽量使包名保持唯一性，包名通常采用小写、按倒写互联网址的形式进行定义。</li>
<li>在进行命名包时，应该避免使用与系统发生冲突的名字。</li>
</ol>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常：程序执行中发生的不正常情况</p>
<p>异常分为两大类：</p>
<ol>
<li><strong>Error</strong>（错误）：JVM无法解决的严重问题，如：JVM系统内部错误，资源耗尽等严重情况</li>
<li><strong>Exception</strong>：其他因编程错误或外在因素导致的一般性问题，可以使用针对性代码进行处理；Exception分为两大类：<strong>运行时异常</strong>（程序运行时发生的异常），<strong>编程时异常</strong>（编程时，编译器检查出的异常，编译器要求必须处理）</li>
</ol>
<p><strong>常见的运行时异常：</strong></p>
<ol>
<li><p>**NullPointerException  空指针异常 **</p>
<p>如：当应用程序试图在需要对象的地方使用 null 时，会抛出该异常；</p>
</li>
<li><p>**ArithmeticException  数学运算异常 **</p>
<p>如：当出现异常的运算条件时，抛出此异常，比如整数除以零时；</p>
</li>
<li><p><strong>ArrayIndexOutOfBoundsException</strong> <strong>数组下标越界异常</strong></p>
<p>用非法索引访问数组时抛出的异常，比如索引为负或大于等于数组大小，则该索引为非法索引；</p>
</li>
<li><p><strong>ClassCastException</strong> <strong>类型转换异常</strong></p>
<p>当试图将对象强制转换为不是实例的子类时，抛出该异常；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastException_</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line">		<span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b;<span class="comment">//向下转型，这里是 OK</span></span><br><span class="line">		<span class="type">C</span> <span class="variable">c2</span> <span class="operator">=</span> (C)b;<span class="comment">//这里抛出 ClassCastException</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NumberFormatException</strong> <strong>数字格式不正确异常</strong></p>
<p>当程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常（使用此异常可以确保输入满足条件的数字）</p>
</li>
</ol>
<p><strong>常见的编译异常：</strong></p>
<ol>
<li>SQLException ：操作数据库时，查询表可能发生异常</li>
<li>IOException ：操作文件时，发生的异常</li>
<li>FileNotFoundException ：当操作一个不存在的文件时，发生异常</li>
<li>ClassNotFoundException：加载类，而该类不存在时，异常</li>
<li>EOFException：操作文件时，到文件末尾，发生异常</li>
<li>IllegalArguementException：参数异常</li>
</ol>
<hr>
<p><strong>异常处理机制</strong></p>
<ol>
<li><p><strong>try - catch - finally</strong></p>
<p>程序员在代码中捕获发生的异常，自行处理</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能有异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//当异常发生时，系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//得到异常对象后，程序员自己处理</span></span><br><span class="line">    <span class="comment">//如果没有发生异常，catch代码块不执行</span></span><br><span class="line">    <span class="comment">//可以有多个catch语句，捕获不同的异常，要求子类异常写在前，父类异常在后（只会匹配一个catch）</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块有没有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将释放资源的代码放在finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>就算在catch中ruturn了，但因为finally必须执行，所以catch的return中的语句会执行，但不会立即返回（return）；</li>
<li>如果catch中 ruturn  i  ；但finally中又用到了 变量 i  ，底层会保存临时变量temp &#x3D; i ，执行完finally后，catch返回temp（finally有return的话则在finally中return）；</li>
</ul>
</li>
<li><p><strong>throws</strong></p>
<p>将发生的异常抛出，交给调用者（方法）处理，最高级的处理者是JVM（JVM会直接打印异常信息，退出）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> XXException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要和父类的一致或其异常类型的子类型；</li>
</ul>
</li>
<li><p><strong>自定义异常</strong></p>
<p>自定义异常 需要继承 Excption或RuntimeException；如果继承Exception属于编译异常， 继承RuntimeException属于运行异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line">		<span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line">		<span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line">			<span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;  <span class="comment">//构造器</span></span><br><span class="line">		<span class="built_in">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>throw和throws的区别</p>
<table>
<thead>
<tr>
<th></th>
<th>意义</th>
<th>位置</th>
<th>后面跟的是</th>
</tr>
</thead>
<tbody><tr>
<td>throws</td>
<td>异常处理的一种方式</td>
<td>方法声明处</td>
<td>异常类型</td>
</tr>
<tr>
<td>throw</td>
<td>手动生成异常对象的关键字</td>
<td>方法体中</td>
<td>异常对象</td>
</tr>
</tbody></table>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合主要有 单列集合 和 双列集合：</p>
<ul>
<li><p>Collection接口有两个重要的子接口List，Set，它们实行的都是单列集合；</p>
</li>
<li><p>Map接口的实现子类，是双列集合，从存放K - V；</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707036.png" alt="image-20211003183537824"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707037.png" alt="image-20211003183548688"></p>
<hr>
<p><strong>如何选择</strong>集合实现类：判断存储的类型：单列&#x2F;双列</p>
<ul>
<li><p>一组对象（单列）：Collection接口</p>
<ul>
<li><p>允许重复：List</p>
<ul>
<li>增删多：LinkedList（底层是双向链表）</li>
<li>查改多：ArrayList（底层是可变数组）</li>
</ul>
</li>
<li><p>不允许重复：Set</p>
<ul>
<li><p>无序：HashSet（底层HashMap）</p>
</li>
<li><p>排序：TreeSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>插入和取出顺序一致：LinkedHashSet（维护数组和双向链表）</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>一组键值对（双列）：Map</p>
<ul>
<li><p>键无序：HashMap（底层：维护了一个哈希表：数组+链表+红黑树）</p>
</li>
<li><p>键排序：TreeMap</p>
</li>
<li><p>键插入和取出顺序一致：LinkedHashMap</p>
</li>
<li><p>读取文件：Properties</p>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h3><p>Collection接口的常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll（All都是指多个元素）</p>
<p>遍历方式：</p>
<ol>
<li>使用 <strong>Iterator</strong> 迭代器（快捷模板：while-&gt;itit）</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//先得到col对应的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">	System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在调用iterator.next()之前必须先用iterator.hasNext()进行检测，不然，如果下一条记录无效，且直接调用next方法会抛出NoSuchElementException异常</p>
</li>
<li><p>当退出while循环后，iterator迭代器指向最后的元素，如果要再次遍历，需重置迭代器：ite &#x3D; col.iterator();</p>
</li>
<li><p>iterator迭代器的remove方法是迭代过程中唯一能 线性安全地 删除集合元素的方法，因为iterator在遍历过程中，会锁定集合中的元素。</p>
</li>
<li><p>不能直接使用集合的remove方法：因为集合中会有变量modCount记录修改次数，当调用remove方法时，modCount ++，而迭代开始时，会先把modCount 记录下来，在调用iterator.next时会检查修改次数是否一致，如果不一致，则会报错ConcurrentModificationException；</p>
<blockquote>
<p>注：由于hasnext是检查当前已经迭代的数量是否等于集合大小，如果删除倒数第二个数据，集合size–，就会使size &#x3D;&#x3D; 已经迭代的个数，所以会漏掉最后一项数据，即最后一遍循环不执行，iterator.next不执行，也就不会报错。</p>
</blockquote>
</li>
</ul>
<ol start="2">
<li><p>使用for循环增强</p>
<p>增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名 ： 集合名/数组名)&#123;</span><br><span class="line">	访问元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul>
<li>元素有序（添加和取出的顺序一致），有索引</li>
<li>元素可重复</li>
</ul>
<p>List接口常用方法：add，add（index，Object），get，indexOf，lastIndexOf，remove，set，subList（fromIndex，toIndex）(注意fromIndex &lt;&#x3D; subList &lt; toIndex)</p>
<p>ArrayList和Vector基本等同，区别在线程是否安全</p>
<p>ArrayList类：效率较高，但线程不安全</p>
<p>创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为0，第一次添加，则扩容elementData 为10，后面再次扩容，则扩容为原来的1.5倍 + 1；如果使用指定大小的构造器，则初始elementData 为指定大小，再次扩容，则为原来的1.5倍 + 1。</p>
<hr>
<p>Vector类：线程安全，效率比ArrayList低</p>
<p>Vector类的操作方法带有synchronized。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= elementCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vector扩容：无参构造，默认10；扩容为原来的2倍</p>
<hr>
<p>LinkList类：底层实现了双向链表和双端队列的特点，线程不安全，没有实现同步；</p>
<ul>
<li>LinkList维护了两个属性：first指向首节点，last指向尾节点，</li>
<li>每个节点（Node对象）又维护了三个属性：prev指向前一个，next指向下一个，item存放数值；</li>
</ul>
<hr>
<h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul>
<li>无序（添加和取出的顺序不一致，但存放位置是固定的），没有索引</li>
<li>不允许重复元素，所以最多包含一个null</li>
</ul>
<p>Set常用方法，因为也是Collection的子接口，所以常用方法和Collection接口一样</p>
<p>遍历方式：迭代器，增强for（但不能使用索引方式来获取）</p>
<p><strong>HashSet类</strong></p>
<p>HashSet实现了Set接口，实际上是HashMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的构造器</span></span><br><span class="line">pUblic <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">	map = <span class="keyword">new</span> <span class="title class_">HashMap</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>LinkedHashSet类</strong></p>
<p>LinkedHashSet是HashSet的子类，底层是LinkedHashMap，底层中维护了一个hash表和双向链表；</p>
<p><strong>LinkedHashMap类</strong></p>
<p>LinkedHashMap中有<strong>头节点head和尾节点tail</strong>（指向第一个添加的节点和最后添加的节点），还创建了<strong>Entry类</strong>来存放节点，它继承自HashMap.Node类，<strong>每个节点有before和after属性</strong>。</p>
<ul>
<li>LinkedHashMap根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElenment</span><br><span class="line">newElement.pre = tail;</span><br><span class="line">tail = newElement;</span><br><span class="line"><span class="comment">//新加入节点和末尾节点相连；</span></span><br><span class="line"><span class="comment">//这样，遍历LinkedHashMap时也能确保插入顺序和遍历顺序一致</span></span><br></pre></td></tr></table></figure>



<h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map中用于保存具有映射关系的数据：Key - Value</p>
<p>key不允许重复，只能有一个key为null；value允许重复，可以有多个null；</p>
<p><strong>遍历方式：</strong></p>
<p><strong>containsKey：查找键是否存在</strong></p>
<p><strong>keySet：获取所有的键</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">ks</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object key : ks)&#123;</span><br><span class="line">	System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> ks.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>entrySet：获取所有的关系k - v</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line">	<span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">	Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">	System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> ite.next();</span><br><span class="line">	<span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">	Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">	System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValues());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p><strong>values：获取所有的值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">val</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object value : val)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> val.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>HashMap类</strong></p>
<p>如果添加相同的key，则会<strong>覆盖原来的key - value，相当于修改了value</strong>；</p>
<p>底层没有实现同步，<strong>线程不安全</strong>；</p>
<p>HashMap底层：<strong>数组+链表+红黑树</strong>（不保证映射顺序）</p>
<ol>
<li>先获取元素的哈希值（hashcode方法）；</li>
<li>对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置；（用（length-1）&amp;hash得到数组下标）</li>
<li>如果该位置上没有其他元素，则直接存放，如果有，则需要进行equals判断，如果相等，则不添加，如果不等，则以链表的方式添加；</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算hash值的算法，“扰动函数”</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">	<span class="type">int</span> h;</span><br><span class="line">	<span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩容机制：</p>
<ol>
<li>第一次添加时，table数组扩容到<strong>16</strong>，临界值（threshold）是16 * <strong>加载因子（loadFactor &#x3D; 0.75）</strong>&#x3D; 12；</li>
<li>如果table数组使用到临界值12，就会扩容到16*2 &#x3D; 32，新的临界值为32 * 0.75 &#x3D; 24；</li>
<li>在Java8中，如果一条链表的<strong>元素个数到达TREEIFY_THRESHOLD（默认是8），且table大小&gt;&#x3D;MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树）</strong>；（table是HashMap的一个数组，类型是Node[]）</li>
<li>如果链表的元素个数达到8以上，但table不足64，会将元素加入链表后，对table进行一次扩容。</li>
</ol>
<hr>
<p><strong>Hashtable类</strong></p>
<p>存放的元素的键值对：K - V ，键和值都<strong>不能为null</strong>，否则会抛出NullPointerException；</p>
<p>是<strong>线程安全</strong>的（效率比HashMap低）</p>
<p>（使用方法和HashMap基本一样）</p>
<hr>
<p><strong>Properties类</strong></p>
<p>Properties类<strong>继承自Hashtable类并实行了Map接口</strong>；键和值同样<strong>不能为null</strong>，否则会抛出NullPointerException；</p>
<p>特点：可以用于<strong>从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</strong>（工作中，xxx.properties文件<strong>通常为配置文件</strong>）</p>
<hr>
<p>一道<strong>练习</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(p1);<span class="comment">//OK</span></span><br><span class="line">set.add(p2);<span class="comment">//OK</span></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//name被修改过，找不到，删除失败</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure>





<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型又称参数化类型。</p>
<p>java中的泛型<strong>只在编译阶段有效</strong>，在编译之后程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型声明</span></span><br><span class="line">interface 接口&lt;T&gt; &#123;&#125;	<span class="comment">//泛型接口</span></span><br><span class="line">class 类&lt;K,V&gt;&#123;&#125;	<span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>&#123;&#125;<span class="comment">//泛型方法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化,在类名后面指定类型参数的值</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li><p>T，E …只能是引用类型，不能是基本数据类型</p>
</li>
<li><p>在给泛型指定具体类型后，可以传入该类型的子类类型</p>
</li>
<li><p>要注意，在静态方法中使用泛型，必须将静态方法定义成泛型方法。因为静态方法访问在类上定义的泛型，不能引用不确定的数据类型。</p>
</li>
<li><p>如果在创建对象时，没有指定类型，默认为Object</p>
</li>
<li><p>泛型接口的类型，在<strong>继承接口</strong>或<strong>实现接口</strong>时确定</p>
</li>
<li><p>java中不能创建一个确切的泛型类型的数组；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//这样是不允许的</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>];<span class="comment">//这样可以</span></span><br><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];<span class="comment">//这样也可以</span></span><br></pre></td></tr></table></figure>

<p>解释：由于JVM泛型的擦除机制，在运行时JVM不知道泛型信息，可以将一个确切数据类型的数据加入，但在取出数据时却还要做一次类型转换，所以有可能出现ClassCastException。如果可以进行泛型数组的声明，则这种情况不会在编译期进行警告和错误，只有到运行时才出错，所有对泛型数据的声明进行限制可以防止运行时的错误发生；</p>
<p>而使用通配符，最后取出数据要做显式的类型转换，所以没问题；</p>
</li>
</ul>
<hr>
<p><strong>泛型上下边界</strong></p>
<p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行<strong>上下边界的限制</strong>，如：类型实参只准传入某种类型的父类或某种类型的子类。</p>
<p><strong>泛型通配符 &lt;?&gt;</strong> ：支持任意泛型类型</p>
<p><strong>&lt; ? extends A &gt;</strong> ：支持<strong>A类以及A类的子类</strong>，规定了泛型的上限</p>
<p><strong>&lt; ? super A&gt;</strong> ：支持<strong>A类以及A类的父类</strong>，不限于直接父类，规定了泛型的下限</p>
<h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>创建文件</strong>的三种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：new File(String pathname) </span></span><br><span class="line">   <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">   <span class="comment">//上面的file1对象，在java程序中，只是一个对象，只有执行了CreatNewFile方法，才会在磁盘创建该文件</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;creat successful&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法二：new File(File parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录文件+之路径构建</span></span><br><span class="line">   <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file1.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法三：new File(String parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录+子目录构建</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName1);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>获取文件的相关信息：</strong></p>
<p>getName()，length()，</p>
<p>getAbsolutePath()：获取绝对路径</p>
<p>getParent()：获取父目录</p>
<p>exist()：文件是否存在</p>
<p>isFile()：是不是文件</p>
<p>isDirectory()：是不是目录</p>
<hr>
<p><strong>目录的操作和文件删除：</strong></p>
<p>mkdir：创建一级目录</p>
<p>mkdirs：创建多级目录</p>
<p>delete：删除空目录或空文件</p>
<h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><p>I&#x2F;O 是Input &#x2F; Output 的缩写，用于处理数据传输，如：读写文件、网络通讯等；</p>
<p><strong>输入input</strong>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</p>
<p><strong>输出output</strong>：将程序（内存)中的数据输出到磁盘等存储设备中；</p>
<p><strong>分类：</strong></p>
<ul>
<li>按操作的数据单位不同：字节流文件（二进制文件），字符流文件（文本文件）；</li>
<li>按数据流的流向不同：输入流，输出流；</li>
<li>按流的角色的不同：节点流，处理流（包装流）；</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<p>由上面四个类派生出来的子类名称 都是以其父类名作为子类名后缀</p>
<p>体系图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/20200307125658523.png" alt="img"></p>
<h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次接受一个字节的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//接受单个直接的数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read()无参时会返回单个字节的数据</span></span><br><span class="line">        <span class="comment">//读取完毕，会返回-1</span></span><br><span class="line">        <span class="keyword">while</span>((readData = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);<span class="comment">//转为char显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();<span class="comment">//记得要关闭文件流，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字节数据一次接受多个数据，效率更高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile2</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次读取8个字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//一次最多读取8字节，返回读取读取字节的数量</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);<span class="comment">//再加一个true，表示写入内容追加到文件末尾，不加true，则表示覆盖原来的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        fos.write(str.getBytes(),<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="FileReader-和-FileWriter"><a href="#FileReader-和-FileWriter" class="headerlink" title="FileReader 和 FileWriter"></a>FileReader 和 FileWriter</h4><p>FileReader —&gt; InputStreamReader —&gt;Reader</p>
<p>FileReader  —&gt;  InputStreamReader —&gt;Reader</p>
<p>使用方法跟上面的差不多</p>
<p>注意：<strong>对于字符流，记得操作完后要关闭文件流，或使用flush()，否则更新内容不会保存</strong></p>
<hr>
<h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流 ：从一个特定的数据源读写数据，如FileReader，FileWriter；</p>
<p>处理流（包装流）：是连接在已存在的流（节点流&#x2F;处理流）之上，提供了更方便，更强大的读写功能，如BufferedReader，BufferedWriter。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707038.png" alt="image-20211007204910829"></p>
<p>节点流是底层流，直接跟数据源相接。</p>
<p>处理流包装节点流，既可以<strong>消除不同节点流的实现差异，也可以提供更方便的方法</strong>；处理流使用了修饰器设计模式，<strong>不会直接与数据源相连</strong>。</p>
<p>处理流对性能的提高：主要<strong>以增加缓冲的方式来提高输入输出的效率</strong>；</p>
<hr>
<p>（BufferedReader，BufferedWriter是字符流，不要去操作二进制文件（声音、视频、pdf等），可能造成文件损坏）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedReader</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));<span class="comment">//将</span></span><br><span class="line">    String line;<span class="comment">//按行读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;	<span class="comment">//读取完毕，返回null</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();	<span class="comment">//关闭外层流即可，以为底层会去关闭内层的流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedWriter</span></span><br><span class="line">	<span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">    bw.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    bw.newLine();	<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">    bw.write(<span class="string">&quot;hello,hello,world&quot;</span>);</span><br><span class="line">    bw.close();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>BufferedInputStream 和 BufferedOutputStream</strong></p>
<p>（是字节流，创建时，内部会创建一个缓冲区数组）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用BufferedInputStream 和 BufferedOutputStream将一个二进制文件的内容拷贝到另一个文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;  <span class="comment">//因为对象为空会被自动回收，但此时对象还在，需要手动关闭</span></span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p><strong>ObjectOutputStream ：提供 序列化功能 ObjectInputStream ：提供 反序列化</strong></p>
<hr>
<p>序列化：在保存数据时，保存数据的值和数据类型</p>
<p>反序列化：恢复数据时，恢复数据的值和数据类型</p>
<p>想要让对象支持序列化机制，其类应该是可序列化的，必须实现两个接口之一：<strong>Serializable</strong>（是一个标记接口，没有方法）或  Externalizable（有方法需要实现，所以一般实现Serializable接口）</p>
<hr>
<p>注意：</p>
<ul>
<li>读写顺序要一致；</li>
<li>要求对象实现Serializable</li>
<li>为了提高版本的兼容性，序列化的类中建议添加SerialVersionUID</li>
<li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li>
<li>序列化对象时，要求其属性的类型也实现序列化接口</li>
<li>序列化具备可继承性，即实现了序列化的类，它的子类默认也实现了序列化</li>
</ul>
<hr>
<h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><table>
<thead>
<tr>
<th></th>
<th>类型</th>
<th>默认设备</th>
</tr>
</thead>
<tbody><tr>
<td>System.in	标准输入</td>
<td>InputStream</td>
<td>键盘</td>
</tr>
<tr>
<td>System.out	标准输出</td>
<td>PrintStream</td>
<td>显示器</td>
</tr>
</tbody></table>
<h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong>和<strong>OutputStreamWriter</strong></p>
<p>可以将字节流转换成字符流，同时可以指定编码格式（如：utf-8，gbk等）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="comment">//把 FileInputStream 转成 InputStreamReader，并指定编码</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流只有输出流，没有输入流</p>
<p><strong>PrintStream</strong> 和  <strong>PrintWriter</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line"><span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印输出(当s为空时，print方法会打印&quot;null&quot;);</span></span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改打印流输出的位置/设备</span></span><br><span class="line"><span class="comment">//这里修改，打印到 e:\\f1.txt</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;e:\\f1.txt&quot;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="properties类"><a href="#properties类" class="headerlink" title="properties类"></a>properties类</h4><p>专门用于<strong>读写配置文件</strong>的集合类</p>
<p>配置文件的格式：<strong>键&#x3D;值</strong></p>
<p>（不用空格，值不需要引号，默认类型时String）</p>
<hr>
<p>常用方法：</p>
<p><strong>load</strong>：加载配置文件的键值对到Properties对象；</p>
<p><strong>list</strong>：将数据显示到指定设备；</p>
<p><strong>getProperty（key）</strong>：根据键 取 值</p>
<p><strong>setProperty（key，value）</strong>：设置键值对</p>
<p><strong>store</strong>：键Properties对象中的键值对存储到配置文件（在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">   p.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">   p.list(System.out); <span class="comment">//将K-V显示到控制台</span></span><br><span class="line">   p.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line">   p.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>







<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul>
<li><p>进程：一个独立的正在执行的程序；</p>
<p>多进程：在操作系统中，同时运行多个程序；</p>
<ul>
<li>多进程好处：可以充分利用CPU，提高CPU使用率；</li>
</ul>
</li>
<li><p>线程：一个进程的最基本的执行单位，执行路径；</p>
<p>多线程：在同一个进程（应用程序）中同时执行多个线程</p>
<ul>
<li>多线程好处：提高进程的执行使用率，提高CPU的使用率</li>
</ul>
</li>
<li><p>并发：同一时刻，多个任务交替执行；</p>
<p>并行：同一时刻，多个任务同时执行，多核cpu可以实现并行；</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>在同一个时间点，一个CPU中只能有一个线程在执行；</li>
<li>多线程会降低效率，但可以提高CPU使用率；</li>
<li>一个进程如果有多条执行路径，则称为多线程程序；</li>
<li>Java虚拟机的启动至少开启两条进程：主线程和垃圾回收线程；</li>
<li>一个线程可以理解为进程的子任务；</li>
</ol>
<h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ol>
<li>继承Thread类，重写run方法；</li>
<li>实现Runnable接口，重写run方法；</li>
</ol>
<p>（Thread类实现了Runnable接口，Runnable接口里面只有一个方法run() ）</p>
<ul>
<li>调用start方法，才是真正开启了一个子线程，调用run方法不会开启新的线程（所处的线程还是执行调用的那个线程）</li>
<li>start() 方法调用了start0()方法， start0()方法是本地方法，由JVM调用，底层是C&#x2F;C++实现， start0()真正实现多线程的效果。</li>
<li>start() 方法调用start() 方法后，该线程不一定会立即执行，只是将线程变成了可运行的状态。具体什么时候执行，取决于CPU，由CPU统一调度。</li>
</ul>
<p><strong>方法一：继承Thread类</strong></p>
<p>当一个类继承了Thread类，该类就可以当作线程使用，并在run方法里写上自己的业务代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;	<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread01.start();<span class="comment">//开启线程</span></span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);	<span class="comment">//让主线程休眠1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>方法二：实现Runnable接口</strong></p>
<p>可能一个类已经继承了某个父类，再继承Thread类来创建线程显然不可能。此时可以通过实现Runnable接口来创建进程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;	<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">//不能用aa.start()来调用start，</span></span><br><span class="line">        <span class="comment">//应该创建Thread对象，把对象aa（需要实现了Runnable）放进Thread；</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(aa);</span><br><span class="line">        thead.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>继承Thread 和 实现Runnable 的区别</strong></p>
<p>从本质上来讲是没有区别的；</p>
<p>不过实现Runnable接口的方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制（建议使用Runnable）</p>
<hr>
<p><strong>线程终止</strong></p>
<ol>
<li>当线程完成任务后，会自动退出；</li>
<li>可以通过<strong>使用变量</strong>来控制run方法退出的方式来停止线程，即<strong>通知方式</strong></li>
</ol>
<hr>
<h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><strong>setName</strong>  ： 设置线程名称，赋值给name；</p>
<p><strong>getName</strong> ： 返回该线程的名称；</p>
<p><strong>start</strong>：使该线程开始执行（JVM底层调用该线程的start0方法）；</p>
<p><strong>run</strong>：调用该线程对象的run方法；</p>
<p><strong>setPriority</strong>：更改线程的优先级；</p>
<p><strong>getPriority</strong>：获取线程的优先级；</p>
<p><strong>sleep</strong>：让当前正在执行的线程在指定的毫秒数内休眠（线程的静态方法，使当前线程暂停休眠）</p>
<p><strong>interrupt</strong>：中断线程（不是终止线程，一般用于中断线程的休眠状态）；</p>
<p><strong>yield</strong>：线程的礼让。让出CPU，让其他线程先执行，但礼让的时间不确定，也不一定能礼让成功；</p>
<p><strong>join</strong>：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务；（t1.join() ）</p>
<hr>
<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>用户线程和守护线程：</strong></p>
<ul>
<li>用户线程：也叫工作线程</li>
<li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。（常见的守护线程：垃圾回收机制）</li>
</ul>
<p>使用<strong>setDaemon</strong>方法将普通线程设为守护线程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure>

<p>守护线程的优先级非常低；</p>
<p><strong>TimerTask</strong></p>
<p>守护线程经常要做一些周期性的操作，如：每5分钟执行某操作，每天12点执行某操作等；此时可以用到Java的计时器的工具类：Timer和TimerTask</p>
<h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>JDK中用<strong>Thread.State</strong>枚举了线程的六种状态：</p>
<ol>
<li><strong>NEW</strong>：（new）尚未启动的线程 处于此状态</li>
<li><strong>RUNNABLE</strong>：（runnable）在java虚拟机中执行的线程 处于此状态</li>
<li><strong>BLOCKED</strong>：（blocked）被阻塞等待监视器锁定的线程 处于此状态</li>
<li><strong>WAITING</strong>：正在等待另一个线程执行特定动作的线程 处于此状态</li>
<li><strong>TIMED_WAITING</strong>：正在等待另一个线程执行动作达到指定等待时间的线程 处于此状态</li>
<li><strong>TERMINATED</strong>：已退出的线程 处于此状态</li>
</ol>
<p>线程状态转换图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707039.png" alt="image-20211006205038275"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707040.png" alt="image-20211007085636266"></p>
<h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>在多线程编程中，为了防止部分数据被多个线程同时访问，所有就使用同步访问计数，保证数据在任何 同一时刻，最多被一个线程访问，以保证数据的完整性</p>
<p>实现同步的方法：<strong>Synchronized &#x2F; Lock</strong></p>
<p><strong>Synchronized</strong></p>
<ul>
<li><p>同步代码块</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;	<span class="comment">//需要对象的锁，才能操作同步代码</span></span><br><span class="line">    被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>同步方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">     被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态同步方法的锁是加在当前类本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> vodi <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>同步方法如果没有使用static修饰，默认锁对象是this，如果方法由static修饰，默认锁对象：当前类.class</p>
<p><strong>Lock</strong></p>
<p>Lock 是一种比 Synchroized更加灵活的一种加锁方式，使用的时候必须显示的加锁 ：lock.lock ，然后 在释放锁的时候我们也需要显示的 lock.unlock 调用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>互斥锁：</strong></p>
<p>保证共享数据操作的完整性；每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，都只能有一个线程访问该对象；</p>
<p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问；</p>
<p><strong>死锁：</strong></p>
<p>多个线程都占用了对方的锁资源，但不肯让出资源，导致了死锁（必须要避免死锁发生）</p>
<p><strong>释放锁：</strong></p>
<ol>
<li>当前线程的同步方法，同步代码块执行结束；</li>
<li>当前线程在同步方法，同步代码块中遇到break，return；</li>
<li>当前线程在同步方法，同步代码块中出现了未处理的Error或Exception，导致异常结束；</li>
<li>当前线程在同步方法，同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁；</li>
</ol>
<p>注意：下面操作不会释放锁</p>
<ol>
<li>线程执行同步方法，同步代码块时，程序调用了Thread.sleep()，Thread.yied()方法暂停当前线程的执行，不会释放锁；</li>
<li>线程执行同步代码块时，其他线程调用了该线程的suspend() 方法将该线程挂起，该线程不会释放锁；（尽量避免使用suspend() 和resume() 来控制程序，方法不再推荐使用）</li>
</ol>
<h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>java.net包中包含的类和接口，提供了低层次的通信细节，因此我们专注于网络程序开发，而不用考虑通信的细节。</p>
<p><strong>java.net</strong>包中提供了两种常见的网络协议的支持：<strong>TCP和UDP</strong>；</p>
<p>而对于IP地址，java中的<strong>InetAddress类</strong>表示<strong>互联网协议（IP）地址</strong>；</p>
<hr>
<h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>无构造方法</p>
<p>常用方法：</p>
<p>**type[] getAddress( )**：返回此InetAddress对象的原始IP地址</p>
<p>**static Inetaddress getByName(String host)**：在给定主机名的情况下确定主机的IP地址</p>
<p>**String getHostAddress( )**：返回IP地址字符串（以文本表现形式）</p>
<p>**String getHostName( )**：获取此IP地址的主机名</p>
<p>**static InetAddress getLocalHost( )**：返回本地主机</p>
<blockquote>
<p>127.0.0.1：本地主机，主要用于测试。</p>
<p>别名：Localhost</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">// 获取此 IP 地址的主机名。</span></span><br><span class="line">System.out.println(inetAddress.getHostName());</span><br><span class="line"><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line">System.out.println(inetAddress.getHostAddress());</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="comment">//14.215.177.39</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a>InetSocketAddress类</h3><p>InetSocketAddress类实现了<strong>IP套接字地址（IP地址+端口号）</strong></p>
<p>注意：</p>
<ul>
<li>编写的程序要占用端口号的话 只占用1024以上的端口号，<strong>1024以下的端口号不要去占用，因为系统有可能会随时征用。端口号本身又分为TCP端口和UDP端口，TCP的8888端口和UDP的8888端口是完全不同的两个端口。TCP端口和UDP端口都有65536个</strong>。（端口的表示是一个16位的二进制整数，2个字节，对应十进制的<strong>0~65535</strong>）(ssh 22, ftp 21, smtp, 25, http 80, tomcat 2020, mysql 3306, oracle 1521, sqlserver 1433)</li>
</ul>
<blockquote>
<p><strong>DOS命令查看端口：</strong></p>
<ul>
<li>查看所有端口：netstat  -ano</li>
<li>查看指定端口：netstat  -ano|findstr “端口号”</li>
<li>查看指定端口的进程：tasklist|findstr “端口号”</li>
</ul>
</blockquote>
<p>InetSocketAddress类：</p>
<p><strong>构造方法</strong>：</p>
<p><strong>InetSocketAddress ( InetAddress addr, int port)</strong> ：根据IP地址和端口号创建套接字地址。</p>
<p>**InetSocketAddress ( int port)**：创建套接字地址，其中IP地址为通配符地址，端口号为指定值。</p>
<p>**InetSocketAddress ( String hostname, int port)**：根据主机名和端口号创建套接字地址。</p>
<p>常用方法：</p>
<p>**InetAddress getAddress( )**：获取InetAddress（IP对象)</p>
<p><strong>String</strong> getHostName( )：获取主机名</p>
<p>**int getPort( )**：获取端口号</p>
<hr>
<h3 id="TCP网络编程："><a href="#TCP网络编程：" class="headerlink" title="TCP网络编程："></a>TCP网络编程：</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要<strong>严格区分为客户端（Client）与服务端（Server）。</strong></p>
<p><strong>两端通信时步骤</strong>：</p>
<ol>
<li>服务端程序，需要<strong>事先启动</strong>，等待客户端的连接。</li>
<li>客户端主动连接服务器端，连接成功才能实现通信。服务端不可以主动连接客户端。</li>
</ol>
<p>java提供了两个类用于实现TCP通信程序：</p>
<ol>
<li>客户端：用 java.net.Socket类实现。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li>
<li>服务端：用 java.netServerSocket类实现。创建ServerSocket对象，相当于开启一个服务，等待客户端的连接。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707041.png" alt="image-20211011200948784"></p>
<h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket类实现客户端套接字，套接字指的是两台设备间通讯的端点。</p>
<p><strong>构造方法：</strong></p>
<p>**public Socket ( String host, int port)**：创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。</p>
<blockquote>
<p>回送地址（127.0.0.1）是本机回送地址（Loopback   Address），主要用于网络让江测试以及本地机进程间通讯，无论什么程序，一旦使用回送地址发送数据，会立即返回，不进行任何网络传输。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<p>**public InputStream getInputStream( )**：返回此套接字的输入流</p>
<ul>
<li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li>
<li>关闭生成的InputStream也将关闭相关的Socket。</li>
</ul>
<p>**public OutputStream getOutputStream( )**：返回此套接字的输出流</p>
<ul>
<li>如果此Socket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li>
<li>关闭生成的OutputStream也将关闭相关的Socket。</li>
</ul>
<p>**public void closs( )**：关闭此套接字</p>
<ul>
<li>一旦一个socket被关闭，它不可再使用。</li>
<li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li>
</ul>
<p><strong>public void shutdownOutput( )</strong> ： 禁用此套接字的输出流。</p>
<ul>
<li>任何先前写出的数据将被发送，随后终止输出流。</li>
</ul>
<hr>
<h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p><code>ServerSocket</code>类实现了服务器套接字，该对象等待通过网络的请求。</p>
<p><strong>构造方法：</strong></p>
<p>**public ServerSocket( int port)**：创建ServerSocket对象，并将其绑定到一个指定的端口号上，参数port就是端口号。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<p>**public Socket accept( )**：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直柱塞直到建立连接。</p>
<p>注意：</p>
<ul>
<li>服务器是没有IO流的，服务器可以获取到请求的客户端对象socket；</li>
<li>使用每个客户端socket中提供的IO流和客户端进行交互；</li>
<li>服务器使用客户端的字节输入流读取客户端发送的数据；</li>
<li>服务器使用客户端的字节输出流给客户端回写数据；</li>
</ul>
<hr>
<p>示例：客户端向客户端发送消息，服务端向客户端回写消息</p>
<p>客户端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建Socket对象，它的第一个参数需要的是服务端的IP，第二个参数是服务端的端口</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、获取一个输出流，用于写出要发送的数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">//==========================解析回复==================================</span></span><br><span class="line">            <span class="comment">//4、首先必须通知服务器，我已经输出完毕了，不然服务端不知道什么时候输出完毕</span></span><br><span class="line">            <span class="comment">//服务端的while循环会一直执行，会阻塞</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            <span class="comment">///5、获取输入流，用于读取服务端回复的数据</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自服务端的消息：&quot;</span> + baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//6、释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建服务端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、调用accept接收到来自于客户端的socket</span></span><br><span class="line">            socket = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待客户端接入</span></span><br><span class="line">            <span class="comment">//3、获取socket的输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        不建议这样写：因为如果我们发送的数据有汉字，用String的方式输出可能会截取汉字，产生乱码</span></span><br><span class="line"><span class="comment">//        int len=0;</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        while ((len=is.read(buffer))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//            System.out.println(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、读取输入流中的数据</span></span><br><span class="line">            <span class="comment">//ByteArrayOutputStream的好处是它可以根据数据的大小自动扩充</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于客户端&quot;</span> + socket.getInetAddress().getHostName()</span><br><span class="line">                    + <span class="string">&quot;的消息：&quot;</span> + baos.toString());</span><br><span class="line">            <span class="comment">//===========================回复==========================================</span></span><br><span class="line">            <span class="comment">//5、获取一个输出流，写出回复给客户端</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//6、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//7、关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p><code>java.net</code>包提供了两个类DatagramSocket类和DatagramPacket类</p>
<ul>
<li><code>DatagramSocket</code>类：表示用于发送和接收数据报的套接字</li>
<li><code>DatagramPacket</code>类：表示数据报的数据包。</li>
</ul>
<hr>
<h4 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h4><p><strong>构造方法：</strong></p>
<p>**protected DatagramSocket()**：构造数据报套接字并将其绑定到本地主机上的任何可用端口。</p>
<p>**protected DatagramSocket(int port)**：构造数据报套接字并将其绑定到本地主机上的指定端口。</p>
<p>**protected DatagramSocket(int port, InetAddress laddr)**：创建一个数据报套接字，绑定到指定的本地地址。</p>
<hr>
<h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p><strong>构造方法：</strong></p>
<p><strong>DatagramPacket( byte[] buf, int offset, int length)</strong> ：构造一个DatagramPacket对象用于接受指定长度的数据报 包到缓冲区。</p>
<p>**DatagramPacket（ byte[] buf, int offset, int length, InetAddress address, int port)**：构造用于发送指定长度的数据报包 到指定主机的指定端口号上。</p>
<p><strong>常用方法：</strong></p>
<p><strong>byte[] getData()</strong> ：返回数据报包中的数据。</p>
<p>**InetAddress getAddress()**：返回该数据报发送或接收数据报的计算机的IP地址。</p>
<p>**int getLength()**：返回要发送的数据的长度或接收到的数据的长度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        String msg=<span class="string">&quot;你好，很高兴认识你！&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">        <span class="comment">//2、创建一个包（要发送给谁）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inet,<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//3、发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket，开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//2、创建一个包接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        <span class="comment">//3、接收数据</span></span><br><span class="line">        socket.receive(packet);<span class="comment">//阻塞式接收</span></span><br><span class="line">        <span class="comment">//将数据包转换为字符串输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p><strong>如果是TCP中先启动客户端会报错；而UDP中先启动发送方不会报错，但会正常退出；</strong></p>
<p>案例：在线咨询功能，学生和老师一对一交流（多线程）</p>
<p>发送方：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//创建一个流 用于录入键盘的数据</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//发送数据目的地的IP</span></span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="comment">//发送数据目的地的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPSender</span><span class="params">(String toIP, <span class="type">int</span> toPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toIP = toIP;</span><br><span class="line">        <span class="built_in">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        bfr = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));<span class="comment">//从键盘录入数据到流中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环发送数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bfr.readLine();<span class="comment">//从流中读取数据</span></span><br><span class="line">                <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(toIP);</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length, inet, toPort);</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                <span class="comment">//如果发送了拜拜，则退出发送</span></span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bfr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bfr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//接收方自己所在的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromPort;</span><br><span class="line">    <span class="comment">//数据发送者的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPReceiver</span><span class="params">(<span class="type">int</span> fromPort, String msgFrom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromPort = fromPort;</span><br><span class="line">        <span class="built_in">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(fromPort);<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                socket.receive(packet);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(msgFrom + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;<span class="comment">//如果接收到的数据为拜拜，则退出接收</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>学生线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">7777</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>老师线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">8888</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>位于java.net包下</p>
<p><strong>构造方法：</strong><br>**URL(String spec)**：根据 String 表示形式创建 URL 对象。<br><strong>URL(String protocol, String host, int port, String file)</strong> ：根据指定协议名、主机名、端口号和文件名创建 URL 对象。<br>**URL(String protocol, String host, String file)**： 根据指定的协议名、主机名和文件名创建 URL。</p>
<p><strong>常用方法：</strong></p>
<p>**String getProtocol()**：获取此 URL的协议名称。</p>
<p><strong>String getHost()</strong> ：获取此 URL 的主机名。</p>
<p><strong>int getPort()</strong> ：获取此 URL 的端口号。</p>
<p><strong>String getPath()</strong> ：获取此 URL 的文件路径。</p>
<p>**String getFile()**：获取此 URL 的文件名。</p>
<p>**String getQuery()**：获取此 URL的查询部分。</p>
<p><strong>URLConnection openConnection()</strong> ：返回一个URLConnection实例，表示与URL引用的远程对象的URL </p>
<ul>
<li>URLConnection类中又有一个方法：<br><strong>InputStream getInputStream()</strong> ：返回从此打开的连接读取的输入流。</li>
</ul>
<p>演示案例：URL下载网络资源</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//下载地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://img.t.sinajs.cn/t6/style/images/global_nav/WB_logo.png?id=1404211047727&quot;</span>);</span><br><span class="line">        <span class="comment">//连接到这个资源 HTTP</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;weibo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        urlConnection.disconnect();<span class="comment">//断开连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到一张图片：微博t</span></span><br></pre></td></tr></table></figure>





<p>a</p>
<table>
<thead>
<tr>
<th>x</th>
<th>f1(x)</th>
<th>f2(x)</th>
<th>f3(x)</th>
<th>f4(x)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>0</td>
<td>2</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>5</td>
<td>10</td>
<td>21</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>10</td>
<td>30</td>
<td>22</td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>30</td>
<td>32</td>
<td>23</td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>20</td>
<td>40</td>
<td>24</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>x</th>
<th>F1(x)</th>
<th>F2(x)</th>
<th>F3(x)</th>
<th>F4(x)</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>11</td>
<td>11</td>
<td>20</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>12</td>
<td>13</td>
<td>31</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>16</td>
<td>30</td>
<td>33</td>
</tr>
<tr>
<td>4</td>
<td>14</td>
<td>21</td>
<td>41</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td>15</td>
<td>26</td>
<td>43</td>
<td>61</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//n为项目</span></span><br><span class="line">   	<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; maxMomey; j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> maxMomey - j;</span><br><span class="line">        temp = F[j][i - <span class="number">1</span>] + f[k][i] </span><br><span class="line">        F[j][i] = max&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote>
<p><strong>java程序有三个阶段：</strong></p>
<ul>
<li>代码阶段&#x2F;编译阶段</li>
<li><strong>Class类阶段（加载阶段）：当new一个对象时（类实例化），会在堆里加载一个Class类，里面存放类的成员变量，构造器，成员方法</strong>(通过类加载器ClassLoader从.class字节码文件中加载数据，体现了反射)；会<strong>在方法区生成该类的字节码二进制数据&#x2F;元数据</strong>；</li>
<li>运行阶段</li>
</ul>
</blockquote>
<h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul>
<li>反射机制允许程序在<strong>运行期</strong>借助Reflection API 取得<strong>任何类的内部信息</strong>（比如成员变量，构造器，成员方法等），并能<strong>操作对象的属性及方法</strong>，反射在设计模式和框架底层都会用到；</li>
<li>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，反射可以通过这个对象得到类的结构。</li>
<li>功能：<ul>
<li>在运行时<strong>判断</strong>任意一个<strong>对象所属的类</strong>；</li>
<li>在运行时<strong>构造</strong>任意一个<strong>类的对象</strong>；</li>
<li>在运行时<strong>得到</strong>任意一个<strong>类所具有的成员变量和方法</strong>；</li>
<li>在运行时<strong>调用</strong>任意一个<strong>对象的成员变量和方法</strong>；</li>
<li>生成<strong>动态代理</strong>；</li>
</ul>
</li>
</ul>
<hr>
<h4 id="反射的主要类"><a href="#反射的主要类" class="headerlink" title="反射的主要类"></a>反射的主要类</h4><p>java.lang.<strong>Class</strong>：代表一个<strong>类</strong>，Class对象表示某个类加载在堆中的对象；</p>
<p>java.lang.<strong>reflect.Method</strong>：代表类的<strong>方法</strong>，Method对象表示某个类的方法；</p>
<p>java.lang.<strong>reflect.field</strong>：代表类的成员<strong>变量</strong>，Field对象表示某个类的成员变量；</p>
<p>java.lang.<strong>reflect.Constructor</strong>：代表类的<strong>构造方法</strong>，Constructor对象表示构造器；</p>
<hr>
<p>反射优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活。</p>
<p>反射缺点：使用反射基本是解释执行，对执行速度有影响；</p>
<p>反射调用优化：Method和Field，Constructor对象都有setAccessible方法； 使用setAccessible（true）可以访问安全检查的开关；</p>
<hr>
<p>使用反射：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//2. 使用反射机制解决</span></span><br><span class="line">        <span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line">        <span class="comment">//(3) 通过 cls 得到你加载的类的&quot;methodName&quot;的方法对象</span></span><br><span class="line">        <span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">        method1.invoke(o); <span class="comment">//传统方法: 对象.方法() ; 反射机制: 方法.invoke(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量</span></span><br><span class="line">        <span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(nameField.get(o)); <span class="comment">// 传统写法: 对象.成员变量 , 反射: 成员变量对象.get(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象 表示构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getConstructor(); <span class="comment">//()中可以指定构造器参数类型, 返回无参构造器</span></span><br><span class="line">        System.out.println(constructor);   <span class="comment">//打印方法名，无参</span></span><br><span class="line">        Constructor&lt;?&gt; constructor2 = cls.getConstructor(String.class); <span class="comment">//这里传入的String.class就是String类的Class对象</span></span><br><span class="line">        System.out.println(constructor2);<span class="comment">// 打印方法名，有参 (String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol>
<li>Class类也继承Object类；</li>
<li>Class类对象不是new出来的，而是<strong>系统创建</strong>的；</li>
<li>对于每个类的Class类对象，在<strong>内存中只有一份</strong>，因为<strong>类只加载一次</strong>；</li>
<li>每个类的实例 都知道自己是由哪个Class实例生成的；</li>
<li>通过Class对象可以<strong>完整地得到一个类的完整结构;</strong></li>
<li>Class对象<strong>存放在堆中</strong>；</li>
<li>类的 字节码二进制数据&#x2F;元数据 是放在<strong>方法区</strong>的（包括类的方法代码，变量名，方法名，访问权限，返回值等）；</li>
</ol>
<h4 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h4><p>**static Class forName (String name)**：返回指定类名name的Class对象；</p>
<p><strong>Object newInstance( )</strong> ：调用缺省构造函数，返回该Class对象的一个实例；</p>
<p><strong>getName( )</strong> ：返回此Class对象所表示的实体（类，接口，数组类，基本类型等）名称；</p>
<p>**Class[] getInterfaces( )**：获取当前Class对象的接口；</p>
<p>**ClassLoader getClassLoader( )**：返回该类的类加载器；</p>
<p><strong>Class getSuperclass( )</strong> ：返回此Class所表示的试题的超类的Class；</p>
<p><strong>Constructor[] getConstructors( )</strong> ：返回一个包含某些Constructor对象的数组；</p>
<p>**Field[] getDeclaredFields( )**：返回Field对象的一个数组；</p>
<p><strong>Method getMethod( )</strong> ：返回一个Method对象，此对象的形参类型为paramType；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.leaning.Car&quot;</span>;</span><br><span class="line">       <span class="comment">//1 . 获取到 Car 类 对应的 Class 对象</span></span><br><span class="line">       Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">       <span class="comment">//2. 输出 cls</span></span><br><span class="line">       System.out.println(cls); <span class="comment">//显示 cls 对象, 是哪个类的 Class 对象 com.leaning.Car</span></span><br><span class="line">       System.out.println(cls.getClass());<span class="comment">//输出 cls 运行类型 java.lang.Class</span></span><br><span class="line">       <span class="comment">//3. 得到包名</span></span><br><span class="line">       System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">       <span class="comment">//4. 得到全类名</span></span><br><span class="line">       System.out.println(cls.getName());</span><br><span class="line">       <span class="comment">//5. 通过 cls 创建对象实例</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">       System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">       <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//得到属性的赋值：宝马</span></span><br><span class="line">       <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">       brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//奔驰</span></span><br><span class="line">       Field[] fields = cls.getFields();   <span class="comment">//得到所有的属性(字段)</span></span><br><span class="line">       <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">           System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol>
<li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName( ) 获取，如：**Class cls &#x3D; Class.forName(“java.lang.Cat”)**；</p>
<p>应用场景：<strong>多用于配置文件，读取类全路径，加载类</strong>；</p>
</li>
<li><p>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高；如：<strong>Class cls &#x3D; Cat.class</strong>；</p>
<p>应用场景：多用于<strong>参数传递</strong>，比如通过反射得到对应构造器对象；</p>
</li>
<li><p>前提：已知某个类的实例，调用该实例的getClass() 方法获取Class对象，如：<strong>Class cls &#x3D; 对象.getClass()</strong>; &#x2F;&#x2F;运行类型</p>
<p>应用场景：通过创建好的对象，获取Class对象；</p>
</li>
<li><p>先得到类加载器，再<strong>通过类加载器得到Class对象</strong>：</p>
<p>ClassLoader cl&#x3D;对象.getClass().getClassLoader()；</p>
<p>Class cls &#x3D; cl.loadClass(“类的全类名”)；</p>
</li>
<li><p>基本数据（int, char, boolean, float, double, byte, long, short）得到Class类对象：</p>
<p>Class cls &#x3D; <strong>基本数据类型.class</strong></p>
</li>
<li><p>基本数据类型对应的包装类，可以通过 .TYPE得到Class对象：Class cls &#x3D; <strong>包装类.type</strong></p>
</li>
</ol>
<hr>
<h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><strong>静态加载</strong>：<strong>编译时加载相关的类</strong>，如果没有则报错，依赖性强；</p>
<p><strong>动态加载</strong>：<strong>运行时加载需要的类</strong>，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性；</p>
<hr>
<p><strong>类加载时机</strong>：</p>
<ul>
<li>当创建对象时（new）&#x2F;&#x2F;静态加载</li>
<li>当子类被加载时，父类也加载 &#x2F;&#x2F;静态加载</li>
<li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li>
<li>通过反射 &#x2F;&#x2F;动态加载</li>
</ul>
<hr>
<p><strong>类加载的三个阶段：</strong></p>
<p>Java源码 —(javac编译)—&gt; 字节码文件 —(java运行)—&gt; <strong>加载 –&gt; 连接（验证，准备，解析）–&gt; 初始化</strong></p>
<ul>
<li><p><strong>加载阶段</strong>：将类的字节码从不同的数据源（可能是Class文件，jar包，网络）转化为二进制字节流加载到内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成；</p>
</li>
<li><p><strong>连接阶段</strong>：将类的二进制数据合并到JRE中；</p>
<ul>
<li><p><strong>验证</strong>：</p>
<p>目的：是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。</p>
<p>包括：文件格式验证（是否以魔数oxcafebabe开头），元数据验证，字节码验证，符号引用验证；</p>
<p>可以考虑使用 -Xverify : none参数来关闭大部分的类验证措施，缩短虚拟机 类加载的时间；</p>
</li>
<li><p><strong>准备</strong>：</p>
<p>JVM会在该阶段对静态变量分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;	<span class="comment">//n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;	<span class="comment">//n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>解析</strong>：</p>
<p>到这里，才真正开始执行类中定义的Java程序代码，此阶段是执行 &lt; clinit &gt; ( ) 方法的过程；</p>
<p>&lt; clinit &gt; ( ) 方法 是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<strong>静态变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句，并进行合并；</p>
<p>虚拟机会保证一个类的&lt; clinit &gt; ( ) 方法在多线程环境中被正确地<strong>加锁、同步</strong>；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">	<span class="comment">//因为有同步机制，能保证某个类在内存中, 只有一份 Class 对象</span></span><br><span class="line">	<span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">		<span class="comment">//.... </span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>初始化阶段</strong>：JVM负责对类进行初始化，这里主要是指静态成员；</p>
</li>
</ul>
<h3 id="反射获取类结构信息"><a href="#反射获取类结构信息" class="headerlink" title="反射获取类结构信息"></a>反射获取类结构信息</h3><ul>
<li><p>java.lang.<strong>Class</strong>类</p>
<ol>
<li>getName：获取全类名</li>
<li>getSimpleName：获取简单类名</li>
<li>getFields：获取所有public修饰的属性，包括本类以及父类的</li>
<li>getDeclaredFields：获取本类中所有属性</li>
<li>getMethods：获取所有public修饰的方法，包括本类以及父类的</li>
<li>getDeclaredMethods：获取本类中所有方法</li>
<li>getConstructors：获取本类中所有public修饰的构造器</li>
<li>getDeclaredConstructors：获取本类中所有构造器</li>
<li>getPackage：以Package形式返回 包信息</li>
<li>getSuperClass：以Class形式返回父类信息</li>
<li>getInterfaces：以Class[] 形式返回接口信息</li>
<li>getAnnotations：以Annotation[] 形式返回注解信息</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Field</strong>类</p>
<ol>
<li><p>getModifiers：以int形式返回修饰符</p>
<p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p>
</li>
<li><p>getType：以Class形式返回 类型</p>
</li>
<li><p>getName：返回属性名</p>
</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Method</strong>类</p>
<ol>
<li><p>getModifiers：以int形式返回修饰符</p>
<p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p>
</li>
<li><p>getReturnType：以Class形式获取 返回类型</p>
</li>
<li><p>getParameterTypes：以Class[] 返回参数类型数组</p>
</li>
</ol>
</li>
<li><p>java.lang.reflect.<strong>Constructor</strong>类</p>
<ol>
<li>getModifiers：以int形式返回修饰符</li>
<li>getName：返回构造器名（全名）</li>
<li>getParameterTypes：以Class[] 形式返回参数类型数组</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="comment">//第一组方法 API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//homework.OrangeJuice</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//OrangeJuice</span></span><br><span class="line">        <span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以 Package 形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//package homework</span></span><br><span class="line">        <span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);<span class="comment">//class homework.Drink</span></span><br><span class="line">        <span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第2，3，4组api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是 0 ， public 是 1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里只输出名</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">reflect</span> <span class="variable">reflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">reflect</span>();</span><br><span class="line">        reflect.api_01();</span><br><span class="line">        reflect.api_02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><p>方式一：调用类中的public修饰的无参构造器</p>
<p>方式二：调用类中的指定构造器</p>
<p>方式三：Class类相关方法：newInstance，getConstructor，getDecalaredConstructor</p>
<p>方式四：Constructor类相关方式：setAccessible，newInstance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 先获取到 User 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;leaning.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通过 public 的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3. 通过 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//3.2 创建实例，并传入实参</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hsp</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;屏平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;屏平 = &quot;</span> + hsp);</span><br><span class="line">        <span class="comment">//4. 通过非 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//4.1 得到 private 的构造器对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">        <span class="comment">//4.2 创建实例</span></span><br><span class="line">        <span class="comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2 = &quot;</span> + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">//User 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;灿灿灿&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;<span class="comment">//无参 public</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;<span class="comment">//public 的有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;<span class="comment">//private 有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="反射访问类中成员"><a href="#反射访问类中成员" class="headerlink" title="反射访问类中成员"></a>反射访问类中成员</h3><p><strong>访问属性：</strong></p>
<ol>
<li><p>根据属性名获取Field对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> class对象.getDeclaredField(属性名);</span><br></pre></td></tr></table></figure>
</li>
<li><p>爆破：f.setAccessible (true);   &#x2F;&#x2F;f是Field</p>
</li>
<li><p>访问：</p>
<p>f.set(o值)； &#x2F;&#x2F;o表示对象</p>
<p>syso(f.get(o))；&#x2F;&#x2F;o表示对象</p>
<p>（如果是静态属性，则set和get中的参数o可以写成null）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;leaning.Student2&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student</span></span><br><span class="line">        System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line">        <span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">        System.out.println(o);<span class="comment">//</span></span><br><span class="line">        System.out.println(age.get(o));<span class="comment">//返回 age 属性的值</span></span><br><span class="line">        <span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//name.set(o, &quot;小郑&quot;);</span></span><br><span class="line">        name.set(<span class="literal">null</span>, <span class="string">&quot;小郑~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">        System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//获取属性值, 要求 name 是 static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>访问方法：</strong></p>
<ol>
<li><p>根据方法名和参数列表获取Method方法对象：Method m &#x3D; class.getDeclaredMethod(方法名，XX.class)；&#x2F;&#x2F;得到本类的所有方法</p>
</li>
<li><p>获取对象：Object o &#x3D; class.newInstance()；</p>
</li>
<li><p>爆破：m.setAccessible(true)；</p>
</li>
<li><p>访问：Object.returnValue &#x3D; m.invoke(o，实参列表)； &#x2F;&#x2F;o就是对象</p>
<p>（如果是静态方法，则invoke的参数o，可以写成null）</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Boss 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;leaning.Boss&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用 public 的 hi 方法</span></span><br><span class="line">        <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">        <span class="comment">//3.1 得到 hi 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//3.2 调用</span></span><br><span class="line">        hi.invoke(o, <span class="string">&quot;调用了hi方法&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 调用 private static 方法</span></span><br><span class="line">        <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class);</span><br><span class="line">        <span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">        <span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null</span></span><br><span class="line">        System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line">        <span class="comment">//5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示一个返回的案例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal2</span> <span class="operator">=</span> m1.invoke(o);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal2 的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;<span class="comment">//静态方法</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;<span class="comment">//普通 public 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>（String能使用正则表达式，如</p>
<p>string.replaceAll(“aaa”, “AAA”);  	</p>
<p>string.matches(“1(38|39)\d{8}”)；（返回true或false） </p>
<p>String[] split &#x3D; string.split(“#|-|~|\\d+”); </p>
<p>（stirng都是指一个字符串）</p>
<p>)</p>
<h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String content;	<span class="comment">//目标串</span></span><br><span class="line">String regStr;	<span class="comment">//模式串</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);	<span class="comment">//创建模式对象，参数如果加上Pattern.CASE_INSENSITIVE,表示不区分大小写</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);	<span class="comment">//创建匹配器matcher，按照 正则表达式的规则 去匹配content字符串;</span></span><br></pre></td></tr></table></figure>

<p>正则表达式中的（）表示分组，第一个（）表示第一组..</p>
<p>底层：</p>
<ul>
<li><p>根据指定的表达式规则，定位到满足规则的子字符串；</p>
</li>
<li><p>找到后，将子字符串的开始索引值和结束索引值+1记录到 int[] groups;</p>
</li>
<li><p>同时记录oldLast的值为子字符串的结束索引值+1，即下一次执行find时，就从oldLast开始；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//源码</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (group &lt; <span class="number">0</span> || group &gt; groupCount())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;No group &quot;</span> + group);</span><br><span class="line">        <span class="keyword">if</span> ((groups[group * <span class="number">2</span>] == -<span class="number">1</span>) || (groups[group * <span class="number">2</span> + <span class="number">1</span>] == -<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> getSubSequence(groups[group * <span class="number">2</span>], groups[group * <span class="number">2</span> + <span class="number">1</span>]).toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//group(0)表示匹配到的子字符串</span></span><br><span class="line"><span class="comment">//group(1)表示匹配到的子字符串的第一组子串</span></span><br><span class="line"><span class="comment">//group(2)表示匹配的子字符串的第二组子串</span></span><br><span class="line"><span class="comment">//...但是分组的数不能越界，否则报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;第 1 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>指定字符字符重复0到多次</td>
<td>(abc)*</td>
<td>仅包含任意个abc字符串</td>
</tr>
<tr>
<td>+</td>
<td>指定字符重复1到多次</td>
<td>(abc)+</td>
<td>仅包含至少一个abc字符串</td>
</tr>
<tr>
<td>？</td>
<td>指定字符重复0或1次</td>
<td>abc？</td>
<td>ab或abc</td>
</tr>
<tr>
<td>{n}</td>
<td>只能输入n个字符</td>
<td>[abcd]{3}</td>
<td>由abcd中字母组成的任意长度为3的字符串</td>
</tr>
<tr>
<td>{n,}</td>
<td>指定至少n个匹配</td>
<td>[abcd]{3,}</td>
<td>由abcd中字母组成的任意长度不小于3的字符串</td>
</tr>
<tr>
<td>{n,m}</td>
<td>指定至少n个到m个之间的匹配</td>
<td>[abcd]{3,5}</td>
<td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td>
</tr>
</tbody></table>
<hr>
<h4 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h4><p>有选择性的匹配字符：|</p>
<p>|：匹配之前或之后的表达式</p>
<p>如：ab|cd ：匹配ab或cd</p>
<hr>
<h4 id="分组组合和方向应用符"><a href="#分组组合和方向应用符" class="headerlink" title="分组组合和方向应用符"></a>分组组合和方向应用符</h4><p>在表达式分组中:</p>
<p><strong>（表达式）</strong>：非命名捕获，编号为0的第一个捕获是整个表达式模式匹配的文本，其他捕获则根据括号顺序从1开始编号；</p>
<p>**(?&lt; name&gt;表达式)**：命名捕获，将匹配到的子字符串捕获到一个组名或编号name中。name不能包含任何标点符号，不能以数字开头，可以使用单引号代替&lt;&gt;</p>
<hr>
<p><strong>（?:表达式）</strong>：</p>
<p>非捕获匹配（即匹配但不存储）,例：“industr(?:y|ies)”效果与”industry|intdustries“相同，但更经济；</p>
<p><strong>（?&#x3D;表达式）</strong>：</p>
<p>是非捕获匹配 ，例：“Windows(?&#x3D;95|98|NT)”匹配“Windows 95”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”；</p>
<p><strong>（?!表达式）</strong>：</p>
<p>非捕获匹配，例：“Windows(?!95|98|NT)”匹配“Windows 3.1”中的“Windows”，但不匹配“Windows 98”中的“Windows”；</p>
<hr>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>对于已经有特殊的含义的字符，想要匹配这些字符，就需要加上转义符号：**\\**（java中使用两个\，其他语言使用一个\）；</p>
<p>需要用到转义符号的字符有： <strong>.  *  +  ( )  $  &#x2F; \  ?  [ ]  ^  { }</strong></p>
<hr>
<p><strong>字符匹配符</strong></p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>[ ]</td>
<td>可接收的字符列表</td>
<td>[efgh]</td>
<td>efgh中任意一个字符</td>
</tr>
<tr>
<td>[^ ]</td>
<td>不可接收的字符列表</td>
<td>[^abc]</td>
<td>除了a，b，c之外的任意一个字符，包括特殊符号</td>
</tr>
<tr>
<td>-</td>
<td>连字符</td>
<td>A-Z</td>
<td>任意单个大写字符</td>
</tr>
<tr>
<td>.</td>
<td>匹配除\n外的任何字符</td>
<td>a..b</td>
<td>以a开头，b结尾，中间任意2个字符</td>
</tr>
<tr>
<td>\\d</td>
<td>匹配单个数字字符，相当于[0-9]</td>
<td>\\d{3}(\\d)?</td>
<td>包含3个或4个数字的字符串</td>
</tr>
<tr>
<td>\\D</td>
<td>匹配单个非数字字符，相当于[ ^ 0-9 ]</td>
<td>\\D(\\d)*</td>
<td>以单个非数字字符开头，后接任意个数字</td>
</tr>
<tr>
<td>\\w</td>
<td>匹配单个数字，大小写字母，相当于[0-9a-zA-Z]</td>
<td>\\w{4}</td>
<td>长度为4的数字字母字符串</td>
</tr>
<tr>
<td>\\W</td>
<td>匹配单个非数字，大小写字母，相当于[ ^ 0-9a-zA-Z]</td>
<td>\\W+\\d{2}</td>
<td>以至少一个非数字字母字符开头，2个数字结尾</td>
</tr>
<tr>
<td>\\s</td>
<td>匹配任何空白字符（空格，制表符）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>指定起始字符</td>
<td>^[0-9]+[a-z]*</td>
<td>至少一个数字开头，后接任意小写字母</td>
</tr>
<tr>
<td>$</td>
<td>指定结束字符</td>
<td>^[0-9] [a-z]+$</td>
<td>以一个数字开头，后接至少一个小写字母结尾</td>
</tr>
<tr>
<td>\\b</td>
<td>匹配目标字符串的边界</td>
<td>can\\b</td>
<td>边界指空格或结束位置，如：can<strong>can</strong>  c<strong>can</strong></td>
</tr>
<tr>
<td>\\B</td>
<td>匹配目标字符串的非边界</td>
<td>can\\B</td>
<td>如：<strong>can</strong>can can</td>
</tr>
</tbody></table>
<hr>
<h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>Pattern类，Matcher类，PatternSyntaxException</p>
<p>Pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建对象，应调用其公共静态方法，它接收一个正则表达式作为参数，返回一个Pattern对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure>

<p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法或获得一个Matcher对象；</p>
<p>PatternSyntaxException是一个非强制性异常类，它表示一个正则表达式模式中的语法错误；</p>
<hr>
<h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>分组：</p>
<p>正则表达式中的 一个括号的部分可以看成是一个分组&#x2F;子表达式；</p>
<p>捕获：</p>
<p>分组匹配到的内容，会保存到以数字编号或显示命名的组里，方便后面引用；</p>
<p><strong>反向引用：</strong></p>
<p>圆括号（分组）的内容被捕获后，可以在这个括号后被使用；这种引用可以在内部使用，也可以在外部使用；</p>
<p>内部：<strong>\\分组号</strong></p>
<p>外部：**$分组号**</p>
<p>如：要匹配两个连续的相同数字： (\\d)\\1</p>
<p>​	要匹配五个连续的相同数字：(\\d)\\1{4}</p>
<p>​	要匹配个位与千位相同，十位与百位相同的数(5225,1551)：(\\d)(\\d)\\2\\1</p>
<p>程序案例：<strong>结巴去重</strong></p>
<p>把 类似 : “我….我要….学学学学….编程 java!”</p>
<p>通过正则表达式 修改成 “我要学编程 java” ；（即没有连续重复的字符）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;我....我要....学学学学....编程 java!&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 去掉所有的. </span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">      content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">//2. 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">      <span class="comment">// 思路</span></span><br><span class="line">      <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">      <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">      <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line">       pattern = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>);<span class="comment">//分组的捕获内容记录到$1</span></span><br><span class="line">       matcher = pattern.matcher(content);</span><br><span class="line">       <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">      <span class="comment">//使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">       content = matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure>

<p>简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 使用一条语句 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure>







<h3 id="元字符-详细说明"><a href="#元字符-详细说明" class="headerlink" title="元字符-详细说明"></a>元字符-详细说明</h3><table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>\</td>
<td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</strong></td>
</tr>
<tr>
<td><strong>^</strong></td>
<td><strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></td>
</tr>
<tr>
<td><strong>$</strong></td>
<td><strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></td>
</tr>
<tr>
<td>*****</td>
<td><strong>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</strong></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td><strong>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</strong></td>
</tr>
<tr>
<td><strong>{*n*}</strong></td>
<td>*<strong>n*</strong> <strong>是非负整数。正好匹配 *n* 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</strong></td>
</tr>
<tr>
<td><strong>{*n*,}</strong></td>
<td>*<strong>n*</strong> <strong>是非负整数。至少匹配 *n* 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*“。</strong></td>
</tr>
<tr>
<td><strong>{*n*,*m*}</strong></td>
<td>*<strong>m*</strong> <strong>和 *n* 是非负整数，其中 *n* &lt;&#x3D; *m*。匹配至少 *n* 次，至多 *m* 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于  ‘o?’。注意：您不能将空格插入逗号和数字之间。</strong></td>
</tr>
<tr>
<td><strong>?</strong></td>
<td><strong>当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</strong></td>
</tr>
<tr>
<td><strong>.</strong></td>
<td><strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></td>
</tr>
<tr>
<td><strong>(*pattern*)</strong></td>
<td><strong>匹配 *pattern* 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</strong></td>
</tr>
<tr>
<td><strong>(?:*pattern*)</strong></td>
<td><strong>匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’  更经济的表达式。</strong></td>
</tr>
<tr>
<td><strong>(?&#x3D;*pattern*)</strong></td>
<td><strong>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows  2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><strong>(?!*pattern*)</strong></td>
<td><strong>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows  3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td>
</tr>
<tr>
<td><em><strong>x*</strong></em><em>|*y*</em>*</td>
<td><strong>匹配 *x* 或 *y*。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></td>
</tr>
<tr>
<td><strong>[*xyz*]</strong></td>
<td><strong>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</strong></td>
</tr>
<tr>
<td><strong>[^*xyz*]</strong></td>
<td><strong>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</strong></td>
</tr>
<tr>
<td><strong>[*a-z*]</strong></td>
<td><strong>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</strong></td>
</tr>
<tr>
<td><strong>[^*a-z*]</strong></td>
<td><strong>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</strong></td>
</tr>
<tr>
<td><strong>\b</strong></td>
<td><strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\B</strong></td>
<td><strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></td>
</tr>
<tr>
<td><strong>\c*x*</strong></td>
<td><strong>匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或  a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</strong></td>
</tr>
<tr>
<td><strong>\d</strong></td>
<td><strong>数字字符匹配。等效于  [0-9]。</strong></td>
</tr>
<tr>
<td><strong>\D</strong></td>
<td><strong>非数字字符匹配。等效于  [^0-9]。</strong></td>
</tr>
<tr>
<td><strong>\f</strong></td>
<td><strong>换页符匹配。等效于  \x0c 和 \cL。</strong></td>
</tr>
<tr>
<td><strong>\n</strong></td>
<td><strong>换行符匹配。等效于  \x0a 和 \cJ。</strong></td>
</tr>
<tr>
<td><strong>\r</strong></td>
<td><strong>匹配一个回车符。等效于  \x0d 和 \cM。</strong></td>
</tr>
<tr>
<td><strong>\s</strong></td>
<td><strong>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\S</strong></td>
<td><strong>匹配任何非空白字符。与  [^ \f\n\r\t\v] 等效。</strong></td>
</tr>
<tr>
<td><strong>\t</strong></td>
<td><strong>制表符匹配。与  \x09 和 \cI 等效。</strong></td>
</tr>
<tr>
<td><strong>\v</strong></td>
<td><strong>垂直制表符匹配。与  \x0b 和 \cK 等效。</strong></td>
</tr>
<tr>
<td><strong>\w</strong></td>
<td><strong>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\W</strong></td>
<td><strong>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</strong></td>
</tr>
<tr>
<td><strong>\x*n*</strong></td>
<td><strong>匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</strong></td>
</tr>
<tr>
<td><strong>*num*</strong></td>
<td><strong>匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</strong></td>
</tr>
<tr>
<td><strong>*n*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。</strong></td>
</tr>
<tr>
<td><strong>*nm*</strong></td>
<td><strong>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 *nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。</strong></td>
</tr>
<tr>
<td><strong>\nml</strong></td>
<td><strong>当 *n* 是八进制数  (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。</strong></td>
</tr>
<tr>
<td><strong>\u*n*</strong></td>
<td><strong>匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</strong></td>
</tr>
</tbody></table>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>采用一定的方法保证在整个软件系统中，<strong>对某个类，只能存在一个对象实例，且该类只提供一个取得其对象实例的方法</strong>。</p>
<p><strong>步骤：</strong></p>
<ul>
<li><strong>构造器私有化，防止直接new；</strong></li>
<li><strong>在类的内部创建对象；</strong></li>
<li><strong>向外暴露一个静态的公共方法</strong></li>
</ul>
<p>饿汉式和懒汉式<strong>区别</strong>：</p>
<ol>
<li>创建时机不同，<strong>饿汉式是在类加载就创建了对象实例</strong>，而<strong>懒汉式是使用时才创建</strong>；</li>
<li><strong>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</strong>；</li>
<li><strong>饿汉式存在资源浪费问题</strong>，如果使用时一个对象实例都没使用，饿汉式创建的对象就浪费了；</li>
</ol>
<p>饿汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了能在静态方法中返回这个对象，使用static</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;饿汉&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是一个引用，还没有创建对象</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Instance ins;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="comment">//若对象还未创建，才去创建，即第一次调用了这个方法，对象才会被创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">null</span>)&#123;</span><br><span class="line">            ins = <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>





<h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>**equals（object o)**：指示其他对象是否与此对象相等</p>
<p><strong>finalize()</strong></p>
<p>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。</p>
<p>**getclass()**：返回此 <code>Object</code>的运行时类。 </p>
<p>**hashcode()**：返回对象的哈希码值</p>
<p>**toString()**：返回对象的字符串表示形式</p>
<p>**clone()**：创建并返回此对象的一个副本</p>
<p><strong>notify()</strong></p>
<p><strong>notifyAll()</strong></p>
<p><strong>wait()</strong></p>
<hr>
<p><strong>&#x3D;&#x3D;与equals的对比</strong>：</p>
<p>&#x3D;&#x3D;是一个比较运算符</p>
<ul>
<li><strong>&#x3D;&#x3D; 判断基本类型时，判断值是否相等</strong></li>
<li><strong>&#x3D;&#x3D; 判断引用类型时，判断地址是否相等</strong>，即是不是同一个对象</li>
</ul>
<p><strong>equals</strong>是Objects类中的方法，<strong>只能判断引用类型，默认判断地址是否相等</strong>，不过其<strong>子类往往重写该方法，用于判断内容是否相等</strong>，如Integer, String</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((integer)obj).intValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>hashcode方法</strong></p>
<ol>
<li>提高具有哈希结构的容器的效率；</li>
<li>两个引用，如果指向同一个对象，则哈希值肯定是一样的；</li>
<li>两个引用，如果指向不同的对象，则哈希值不一样；</li>
<li>哈希值主要根据地址号 计算得来的，不能完全将哈希值等价与地址</li>
</ol>
<p>重写hahscode：</p>
<hr>
<p><strong>toString方法</strong></p>
<p>Object的toString方法默认返回：全类名 + @ + 哈希值的十六进制；子类往往重写toString方法，用于返回对象的属性信息；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>finalize方法</strong></p>
<ul>
<li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</p>
</li>
<li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法；</p>
</li>
<li><p>垃圾回收机制的调用，是由系统来决定 ( 即有自己的 GC 算法 ) ，也可以通过 System.gc() 主动触发垃圾回收机制</p>
<p>（实际开发中，几乎不会用到finalize）</p>
</li>
</ul>
<hr>
<h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p><strong>reverse（List）</strong>：反转List中元素的顺序；</p>
<p><strong>shuffle（List</strong>）：对List中元素进行随机排序；</p>
<p><strong>swap（List， int ，int）</strong>：交换List中两个元素的位置</p>
<p>Object max（Collection）：返回给定集合中最大元素</p>
<p><strong>Object max（Collection，Comparator）</strong>：根据Comparator指定的顺序，返回最大元素；</p>
<p>min跟max一样</p>
<p><strong>int frequency（Collection， Object）</strong>：返回指定集合中指定元素的出现次数</p>
<p><strong>void copy（List dest，List src）</strong>：将src复制到dest中</p>
<p><strong>boolean replaceAll（List list，Object oldVal，Object newVal）</strong>：使用新值，替换掉List中所有旧值</p>
<hr>
<p><strong>sort（）：</strong></p>
<p>Map, Set, List等集合中，都提供了一个排序方法：**sort()**，不过要保证集合中的对象是可比较的；</p>
<p>让对象是 可比较的， 可以让对象实现 <strong>Comparable&lt; T&gt;接口</strong>，然后重写里面的**compareTo()**方法，</p>
<p><strong>compareTo（Object o）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line">	<span class="comment">//降序</span></span><br><span class="line">	<span class="comment">//return o.age - this.age;</span></span><br><span class="line">	<span class="comment">//升序</span></span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>负整数</td>
<td>当前对象的值 <strong>&lt;</strong> 比较对象的值 ， 位置排在前</td>
</tr>
<tr>
<td>零</td>
<td>当前对象的值 <strong>&#x3D;</strong> 比较对象的值 ， 位置不变</td>
</tr>
<tr>
<td>正整数</td>
<td>当前对象的值 <strong>&gt;</strong> 比较对象的值 ， 位置排在后</td>
</tr>
</tbody></table>
<p><strong>比较器的使用：</strong></p>
<p>(例题可看 笔记（数据结构 ) —堆 692.前k个高频词)</p>
<p>想要排序集合中的其他元素，可以使用Comparator :</p>
<ul>
<li>Collertions.sort ( list , Comparator&lt; T&gt; ) ;</li>
<li>list.sort ( Comparator&lt; T&gt;) ;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序1</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序2</span></span><br><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>





<h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> hh.nextInt();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.next  -&gt;  输入字符串</span></span><br><span class="line"><span class="comment">//.nextDouble  -&gt;  输入双精度浮点数</span></span><br><span class="line"><span class="comment">//其他类型 输入样式 相似</span></span><br></pre></td></tr></table></figure>

<p>当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。</p>
<p>如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">string</span> <span class="variable">line</span> <span class="operator">=</span>  s.nextLine;</span><br></pre></td></tr></table></figure>

<p>Scanner类主要提供了两个方法来扫描输入：</p>
<p>1）**hasNextXx()**：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。</p>
<p>2）**nextXxx()**：获取下一个输入项。Xxx的含义同上。</p>
<p>默认情况下，Scanner使用空白（包括空格、Tab空白和回车）作为多个输入项的分隔符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="comment">//System.in代表键盘输入</span></span><br><span class="line">	<span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//使用回车作为分隔符</span></span><br><span class="line">    sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure>

<p>String 类是<strong>被 final 修饰的，即 String 类不能被继承</strong>。</p>
<p>其中有一个很重要的数组，char 数组，用来保存字符串的，既然是用 final 关键字来修饰的，那就代表 <strong>String 是不可变的</strong>（不能指向新地址，但char[]里面的单个字符可改）</p>
<p>在源代码中，substring，replace 最后都是通过 new String(xxx) 来产生了一个新的 String 对象，最原始的字符串并没有改变。</p>
<p>（String实现了serializable接口，说明可以串行化（可以在网络上传输），实现了comparable接口，说明String对象可以比较；）</p>
<p>而<strong>StringBuilder</strong>中的字符可变</p>
<p>比如使用append方法，返回的依然是 StringBuffer 对象本身，说明他确实是值改变了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该方法实际调用的是 StringBuilder 的父方法。该父方法，会先检测容量够不够，不够的话会进行扩容，然后调用 String 的 getChars 方法。注意，最后返回的依旧是 StringBuffer 对象</p>
<p><strong>关于字符串相加：</strong><br>使用“+”对两个字符串相加的过程：</p>
<p>String 对象的操作符“+”其实被赋予了特殊的含义，该操作符是 Java 中仅有的两个重载过的操作符。</p>
<p>String 对象在进行“+”操作的时候，其实是调用了StringBuilder 对象的 append() 方法来加以构造</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;	<span class="comment">//a1指向常量区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;	<span class="comment">//也指向常量区</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> b + c;	<span class="comment">//指向堆中的String对象</span></span><br><span class="line"><span class="comment">//a1 == a</span></span><br><span class="line"><span class="comment">//a != d</span></span><br><span class="line"><span class="comment">//a1 != d</span></span><br></pre></td></tr></table></figure>

<p>看 String a，“hello” + “world” 在 String 编译期间进行优化，优化结果为 “helloworld”，而该值在常量池中已经存有一份，因此 a 也指向了该常量池中的字符串，因此 a1 和 a 相等;</p>
<p>在对 b 和 c 进行相加的过程中：1. xia你创建StringBuilder sb &#x3D; StringBuilder()；2. 执行sb.append(“hello”);  再执行一次sb.append(“world”)； 3. String d &#x3D; sb.toString();</p>
<p>很明显 d 对象指向的是堆中的 String 对象，而 a1 则指向的是常量池中的字符串，两者引用明显不同，</p>
<p><strong>小结：String s &#x3D; “ab” + “cd”：常量相加，看的是池；String s &#x3D; a + b :  变量相加，是在堆中</strong></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707042.png" alt="image-20211002201859440"></p>
<hr>
<p><strong>创建</strong>的两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="comment">//一，先从常量池查看是否有“ssss”数据空间，如果有，直接指向；没有则重新创建，然后指向。s最终指向的是常量池的空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line"><span class="comment">//二，先在堆中创建空间，里面维护了value属性，指向常量池的“ssss”空间。如果常量池没有，重新创建，有的话则直接通过value指向。s最终指向的是堆中的空间地址。</span></span><br></pre></td></tr></table></figure>

<p>构造器 参数列表有多种：(String s)， (char[] a ), (char[] a, int startIndex, int count), (byte[] b) ….</p>
<p>int **indexOf(int ch) : ** <strong>lastIndexOf(int ch) :</strong></p>
<p>返回指定字符第一次(最后一次)出现处的索引</p>
<p>int **indexOf(String str) ** <strong>&#x2F; lastIndexOf(String str)</strong></p>
<p>返回指定 子字符串 第一次出现处的索引</p>
<p>char <strong>cahrAt(int index) :</strong></p>
<p>返回index’位置上的字符</p>
<p><strong>concat( String s) :</strong>  拼接字符串</p>
<p>boolean <strong>endsWith(String suffix) :</strong></p>
<p>判断此字符串是否以指定的字符串结尾</p>
<p>boolean <strong>startsWith(String prefix) :</strong></p>
<p>判断此字符串是否以指定的字符串开始</p>
<p>int <strong>length() :</strong>  返回此字符串的长度</p>
<p>boolean <strong>equals (Object anObject) :</strong></p>
<p>将此字符串与指定的字符串比较</p>
<p><strong>equaIsIgnoreCase</strong> :忽略大小写的判断内容相等</p>
<p>boolean <strong>isEmpty() :</strong></p>
<p>此字符串长度为0时返回true</p>
<p>boolean <strong>contains(CharSequence cs) :</strong></p>
<p>判断是否包含指定的字符序列</p>
<p>String <strong>toLowerCase() :</strong></p>
<p>将String中的所有字符都转换为小写（使用默认语言环境的规则）</p>
<p>String <strong>toUpperCase() :</strong></p>
<p>将String中的所有字符都转换为大写</p>
<p>static <strong>String valueOf(int i) :</strong></p>
<p>返回int参数的字符串表示形式</p>
<p>char[] <strong>toCharArray() :</strong></p>
<p>将此字符串转换为一个字符数组</p>
<p>String <strong>replace(CharSequence oldstr, CharSequence newstr) :</strong></p>
<p>返回新的字符串，用newstr替换所有的oldstr</p>
<p>String[] <strong>split(String regex) :</strong></p>
<p>根据参数regex（regex是一个正则表达式，用于限定分隔规则）将此字符串分割为若干个字符串</p>
<p>String <strong>substring(itn beginIndex) :</strong> </p>
<p>返回一个新字符串，从指定的beginIndex开始，直至末尾</p>
<p>String <strong>substring(itn beginIndex， int endIndex) :</strong> </p>
<p>返回一个新字符串，从指定的beginIndex到endIndex - 1</p>
<p>String <strong>trim() :</strong></p>
<p>返回一个新字符串，它去除了原字符串 首尾的空格</p>
<p><strong>format（String s, …）</strong>：格式化字符串，%s 字符串，%c 字符 … </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(s, ....);</span><br><span class="line"><span class="comment">//format的第一个参数是要格式化的字符串，后面是要替换s中占位符%的变量；</span></span><br><span class="line">system.out.println(<span class="string">&quot;s = &quot;</span> + info);</span><br></pre></td></tr></table></figure>

<p>Strng方法练习：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span> &#123;<span class="comment">//定义一个静态方法，获取变量的类型，通过类Main来调用它</span></span><br><span class="line">		<span class="keyword">return</span> o.getClass().getName();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice!&quot;</span>);<span class="comment">//这里全部使用String类的构造方法来初始化字符串对象</span></span><br><span class="line">		String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice&quot;</span>);</span><br><span class="line">		String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">		String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">		String s5=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">		String s6=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot; abcd &quot;</span>);</span><br><span class="line">		String s7=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a123a123b456&quot;</span>);</span><br><span class="line">		<span class="type">char</span>[] str=s1.toCharArray();</span><br><span class="line">		<span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;↓↓↓String类的一些常用方法如下↓↓↓&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1的长度为：&quot;</span> + s1.length());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符&#x27;J&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&#x27;J&#x27;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;从指定的索引2开始搜索，返回字符串&#x27;a1&#x27;在字符串s7中第一次出现的索引：&quot;</span> + s7.indexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">2</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符&#x27;a&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;从指定的索引8开始反向搜索，返回字符串&#x27;a1&#x27;在字符串s7中最后一次出现的索引：&quot;</span>+s7.lastIndexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;获取字符串s1中第3个位置上的字符：&quot;</span> + s1.charAt(<span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串开始：&quot;</span> + s1.startsWith(<span class="string">&quot;我喜欢&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串结尾：&quot;</span> + s1.endsWith(<span class="string">&quot;nice&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.equals(s2));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.equalsIgnoreCase(s4));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.compareTo(s2));</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.compareToIgnoreCase(s4));</span><br><span class="line">		<span class="comment">/*compareTo(String anotherString)方法将当前字符串与参数字符串进行比较，</span></span><br><span class="line"><span class="comment">		如果相同，则返回0。</span></span><br><span class="line"><span class="comment">		不相同时，从两个字符串第1个字符开始比较，返回第一个不相等的字符差，按照字典顺序</span></span><br><span class="line"><span class="comment">		另一种情况，某个字符串和其子串进行比较，返回它们的长度差。</span></span><br><span class="line"><span class="comment">		compareToIgnoreCase(str)与compareTo的区别是忽略了大小写*/</span></span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s5的长度是否为0：&quot;</span> + s5.isEmpty());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;字符串s1中是否包含指定的序列：&quot;</span> + s1.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s4连接到s3的结尾：&quot;</span> + s3.concat(s4));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s4的所有字符转为小写：&quot;</span> + s4.toLowerCase());</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s3的所有字符转为大写：&quot;</span> + s3.toUpperCase());</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将int类型转为字符串，并获取a的变量类型：&quot;</span> + Main.getType(String.valueOf(a)));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.print(<span class="string">&quot;将字符串s1转为字符数组str：&quot;</span>);<span class="comment">//见代码第13行</span></span><br><span class="line">		System.out.println(str);</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;将字符串s2中的&#x27;Java&#x27;全部替换为&#x27;Python&#x27;：&quot;</span> + s2.replace(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;截取字符串s1从第3个位置开始到结尾：&quot;</span> + s1.substring(<span class="number">3</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;截取字符串s1从0个位置开始到第7个位置结尾：&quot;</span> + s1.substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">		System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;去掉字符串s6首尾的空格：&quot;</span> + s6.trim());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删；是一个final类，不能被继承；</p>
<p>很多方法与String相同，StringBuffer是一个容器；</p>
<p>StringBuffer中的char[] value<strong>没有加final</strong>，所以可以增删字符，且<strong>放在堆中</strong></p>
<hr>
<p><strong>String与StringBuffer的转换</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//一，使用构造器，返回的是StringBuffer对象，对s没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//二，使用append方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb2 =sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//使用StringBuffer的toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb3.toString();</span><br><span class="line"><span class="comment">//使用构造器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb3);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>StringBuffer方法</strong></p>
<p><strong>append( String s)</strong> ：末尾增添字符串</p>
<p><strong>delete( int start, int end)</strong> ：删，将start到end的内容删掉，不包括end</p>
<p><strong>replace( int start, int end, String s)</strong> ：改，将start到end的内容换掉，不包括end</p>
<p><strong>insert（int index， String s)</strong> ：插，在索引n处插入字符串，索引n后的内容自动后移</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(s);	<span class="comment">//传入一个空的字符串，但这里没问题</span></span><br><span class="line"><span class="comment">//底层调用了父类的AbstractStingBuffer的appendNull方法，加入一个字符串“null”。</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//构造器传入空的字符串，会出现异常；因为底层调用的父类构造器传入的参数是字符串的长度+16，而字符串为空，显然会出现异常</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>StringBulider类</strong></p>
<p>StringBulider提供一个与 StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计作为StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。</p>
<p>StringBuilder类的方法和StringBuffer类的一样</p>
<hr>
<p><strong>String，StringBuffer，StringBuilder的比较</strong></p>
<ul>
<li>String：不可变字符序列，效率低，但复用率高</li>
<li>StringBuffer：可变序列，效率较高，线程安全</li>
<li>StringBuilder：可变序列，效率最高，线程不安全</li>
</ul>
<p>所以，如果字符串存在大量修改操作：在<strong>单线程时用StringBuilder</strong>，在<strong>多线程时用StringBuffer</strong>；如果字符串<strong>很少修改，且被多个对象引用，使用String</strong>。</p>
<h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p><strong>数组转List</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(arr).contains(<span class="number">3</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(array).contains(<span class="number">3</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的转换，拆开：</span></span><br><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; integers = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(array);</span><br><span class="line"><span class="comment">//区别:原始数据类型int的数组调用asList之后得到的List只有一个元素，这个元素就是元素类型的数组。而封装类Integer数组调用asList是把数组中每个元素加到了List中。</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.fill() ;填充数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">4</span>);<span class="comment">//给所有值赋值4</span></span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//给第2位（0开始）到第4位（不包括）赋值6</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.sort(); &#x2F;&#x2F;数组排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intArray);</span><br><span class="line"><span class="comment">//数字排序：从小到大；</span></span><br><span class="line"><span class="comment">//字符串排序：先大写后小写（ASCII码）</span></span><br><span class="line"></span><br><span class="line"> Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"><span class="comment">//严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"><span class="comment">//反向排序， Reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER); Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"><span class="comment">//忽略大小写反向排序 Case-insensitive reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//选择数组指定位置进行排序：给第0位（0开始）到第3位（不包括）排序</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)  &#x2F;&#x2F;自定义数组排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> o1 - o2; <span class="comment">//返回&gt;0或&lt;0会影响排序结果</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>Arrays.toString(); &#x2F;&#x2F;将数组中的内容全部打印出来</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(arr);<span class="comment">//直接将数组打印输出</span></span><br><span class="line"><span class="comment">//输出：[I@7852e922 (数组的地址)</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部转为字符串输出</span></span><br><span class="line"><span class="comment">//System.out.print(str);</span></span><br><span class="line"><span class="comment">//输出：[3, 2, 1, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.toString(deepArray)); <span class="comment">//[[I@1540e19d, [I@677327b6]</span></span><br><span class="line">out.println(Arrays.deepToString(deepArray)); <span class="comment">//[[1, 3], [2, 4]]</span></span><br><span class="line"><span class="comment">//对于多维数组，需要使用deepToString</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.equals(); &#x2F;&#x2F;比较数组元素是否相等</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] deepArray2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.equals(deepArray1, deepArray2)); <span class="comment">//false</span></span><br><span class="line">out.println(Arrays.deepEquals(deepArray1, deepArray2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对多维数组，同样要用deepEquals</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.binarySearch(); &#x2F;&#x2F;二分查找法找指定元素的索引值（下标）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.binarySearch(arr, <span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （下标索引值从0开始）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">36</span>)</span><br><span class="line"><span class="comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">40</span>)</span><br><span class="line"><span class="comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span></span><br></pre></td></tr></table></figure>

<p><strong>Arrays.copeOf() 和Arrays.copeOfRange(); &#x2F;&#x2F;截取数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[10, 20, 30] （截取arr数组的3个元素赋值给新数组arr1）</span></span><br><span class="line"><span class="type">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span></span><br></pre></td></tr></table></figure>

<p> <strong>对数组元素采用指定的方法计算</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelPrefix(array, (x,y)-&gt;(x+y)); <span class="comment">//[3, 13, 17, 17, 19]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelSetAll(array, (x)-&gt;(x*x)); <span class="comment">//[0, 1, 4, 9, 16]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">Arrays.setAll(array, (x)-&gt;(x%<span class="number">3</span>));</span><br><span class="line">out.println(Arrays.toString(array)); <span class="comment">//[0, 1, 2, 0, 1], 与parallelSetAll相比只是不并行</span></span><br></pre></td></tr></table></figure>

<p><strong>自定义排序规则</strong></p>
<p><code>Arrays.sort</code>方法和<code>Collections.sort</code>方法都提供了一个可以接收<code>Comparator</code>实例作为第二个参数的版本。</p>
<p>像Comparator、Runable等这&#x3D;一些接口有一个特点就是只有一个抽象方法（其他的都是static或者default的方法），比如继承Comparator接口只需要重写compare方法，继承Runnable接口只需要重写run方法，这种类型的接口被称为函数式接口，可以被lambda表达式所代替。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line">Arrays.sort(names, comp);</span><br></pre></td></tr></table></figure>

<p>或者更简单些：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure>









<h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p><strong>add()</strong></p>
<p>将元素插入指定位置的动态数组中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.add（<span class="type">int</span> index，E element）</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure>

<p><strong>insert(itn index, object value)</strong></p>
<p>将元素插入到索引处(不过其有一定的限制性,必须在数组长度以内插入数组)</p>
<p><strong>addAll()</strong></p>
<p>将给定集合中的所有元素添加到 arraylist 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.addAll(<span class="type">int</span> index, Collection c)</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure>

<p><strong>clear()</strong></p>
<p>用于删除动态数组中的所有元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clear()</span><br></pre></td></tr></table></figure>

<p><strong>clone()</strong></p>
<p>用于拷贝一份动态数组，属于浅拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clone()</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：sites为已设置好的数组，使用clone将其拷贝给clonesites;</span></span><br><span class="line">ArrayList&lt;String&gt; cloneSites = (ArrayList&lt;String&gt;)sites.clone();</span><br></pre></td></tr></table></figure>

<p><strong>拓展：</strong></p>
<p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存， 所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p>
<p>浅拷贝对应的就是深拷贝，深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p>
<p><strong>contains()</strong></p>
<p>判断元素是否在动态数组中。</p>
<p>存在于动态数组中，则返回 true。</p>
<p>不存在于动态数组中，则返回 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.contains(Object obj)</span><br></pre></td></tr></table></figure>

<p><strong>set()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.set(<span class="type">int</span> index,E element) ;</span><br><span class="line">修改指定索引处的元素，返回被修改的元素。</span><br></pre></td></tr></table></figure>

<p><strong>get()</strong></p>
<p>通过索引值获取动态数组中的元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.get(<span class="type">int</span> index)</span><br></pre></td></tr></table></figure>

<p><strong>indexOf()</strong></p>
<p><strong>remove()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arraylist.remove(<span class="type">int</span> index) ;</span><br><span class="line">移除此集合中指定位置上的元素。返回被删除的元素。</span><br><span class="line">arraylist.remove(Object o) ;</span><br><span class="line">删除指定的元素，返回删除是否成功    </span><br></pre></td></tr></table></figure>

<p><strong>size()</strong></p>
<p>返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p>
<p><strong>isEmpty()</strong></p>
<p><strong>subList()</strong></p>
<p><strong>sort()</strong></p>
<p><strong>toArray()</strong></p>
<p><strong>toString()</strong></p>
<p><strong>ensureCapacity()</strong></p>
<p><strong>lastIndexOf()</strong></p>
<p><strong>retainAll()</strong></p>
<p><strong>containAll()</strong></p>
<p><strong>trimToSize()</strong></p>
<p><strong>removeRange()</strong></p>
<p> <strong>replaceAll()</strong></p>
<p><strong>removeIf()</strong></p>
<p><strong>forEach()</strong></p>
<h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p><strong>add(E e)</strong> 将指定元素添加到此列表的结尾。</p>
<p><strong>add(int index, E element)</strong> 在此列表中指定的位置插入指定的元素。</p>
<p><strong>get(int index)</strong> 返回此列表中指定位置处的元素。</p>
<p><strong>getFirst()</strong> 返回此列表的第一个元素。</p>
<p><strong>getLast</strong>() 返回此列表的最后一个元素。</p>
<p><strong>remove(int index)</strong> 移除此列表中指定位置处的元素。</p>
<p><strong>remove()</strong> 获取并移除此列表的头（第一个元素）。</p>
<p><strong>remove(Object o)</strong> 从此列表中移除首次出现的指定元素（如果存在）。</p>
<p><strong>size()</strong>   返回此列表的元素数。</p>
<p><strong>push(E e)：</strong>与addFirst一样，实际上它就是addFirst；</p>
<p><strong>pop()  :</strong> removeFirst一样，实际上它就是removeFirst；</p>
<p><strong>E poll()：</strong>查询并移除第一个元素；</p>
<p><strong>peek()  :</strong> 获取第一个元素，但是不移除；</p>
<p> <strong>offer(E e)：</strong>在链表尾部插入一个元素；</p>
<p><strong>isEmpty :</strong> 判空</p>
<p><strong>contains(Object o) ：</strong>是否包含</p>
<h3 id="Hashset类"><a href="#Hashset类" class="headerlink" title="Hashset类"></a>Hashset类</h3><h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p>HashMap的每次增删查改都是O(1)，但这个常数操作比较大，是没数组的查询快的。</p>
<p><strong>put(key, value) ：</strong>将键&#x2F;值 映射 存放到Map集合中（如果key重复，则会覆盖原先的value值）</p>
<p><strong>get(key) ：</strong>返回指定键 所映射的值，没有该key对应的值则返回null</p>
<p><strong>getOrDefault ( key, defaultvalue) :</strong> 当集合中有这个key时，就返回key对应的value，没有这个key的话，返回默认值；</p>
<p><strong>size( ) ：</strong>返回Map集合中的 key-value的组数</p>
<p><strong>clear( )：</strong>清空Map集合</p>
<p><strong>isEmpty( )：</strong>判空，集合中为空则返回true</p>
<p><strong>remove（key）：</strong>删除集合中键为key的数据，并返回对应的value值</p>
<p>getOrDefault( key, defaultValue) :  返回key对应的value值，如果没有该key值，就返回默认值defaultValue</p>
<p><strong>values（）：</strong>返回Map集合中所有value组成的以Collection数据类型格式数据（一般用于遍历HashMap集合中value值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">Collection&lt;Integer&gt; con = map.values();</span><br><span class="line"><span class="keyword">for</span> (Integer score : con) &#123;</span><br><span class="line">	System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>keyset（）：</strong>返回Map集合中所有key组成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key作为元素转存入一个set集合。</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历HashMap集合中的key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">	System.out.println(key + <span class="string">&quot; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>entrySet（）：</strong> 将Map集合每个key-value转换为一个Entry对象，并返回由所有的Entry对象组成的Set集合</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每一组key-value变为一个entry对象存入set集合</span></span><br><span class="line">Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : set)&#123;</span><br><span class="line">	System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable定义了四个构造方法。第一个是默认构造方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable()</span><br></pre></td></tr></table></figure>

<p>第二个构造函数创建指定大小的哈希表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size)</span><br></pre></td></tr></table></figure>

<p>第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。</p>
<p>填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size,float fillRatio)</span><br></pre></td></tr></table></figure>

<p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表。</p>
<p>哈希表的容量被设置为M的两倍。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(Map m)</span><br></pre></td></tr></table></figure>



<p>Hashtable中除了从Map接口中定义的方法外，还定义了以下方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>void clear( )</strong>  将此哈希表清空，使其不包含任何键。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>Object clone( )</strong> 创建此哈希表的浅表副本。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>boolean contains(Object value)</strong>  测试此映射表中是否存在与指定值关联的键。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>boolean containsKey(Object key)</strong> 测试指定对象是否为此哈希表中的键。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>boolean containsValue(Object value)</strong> 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>Enumeration elements( )</strong> 返回此哈希表中的值的枚举。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>Object get(Object key)</strong>  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>boolean isEmpty( )</strong> 测试此哈希表是否没有键映射到值。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>Enumeration keys( )</strong>  返回此哈希表中的键的枚举。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>Object put(Object key, Object value)</strong> 将指定 key 映射到此哈希表中的指定 value。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>void rehash( )</strong> 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>Object remove(Object key)</strong> 从哈希表中移除该键及其相应的值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>int size( )</strong>  返回此哈希表中的键的数量。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>String toString( )</strong> 返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 “, “ （逗号加空格）分隔开的、括在括号中的一组条目。</td>
</tr>
</tbody></table>
<h3 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h3><p>TreeMap中的值有序排列，每次增删改查的时间复杂度都是O(logN)；<br>创建时传入Comparator可自定义排序规则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure>

<p>基本的put, get, remove, containskey都一样；</p>
<ul>
<li>fristKey()  返回排序后的第一个</li>
<li>lastKey()   返回排序后的最后一个</li>
<li>floorKey(key1)  返回小于等于key1的最近的key</li>
<li>ceilingKey(key1)  返回大于等于key1的最近的key</li>
</ul>
<h3 id="Deque类"><a href="#Deque类" class="headerlink" title="Deque类"></a>Deque类</h3><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p>
<ul>
<li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li>
</ul>
<p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure>


<p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p>
<p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p>
<p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure>


<p>创建 ArrayDeque实例:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure>

<p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure>


<p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p>
<p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()</p>
<p>方法具体说明：</p>
<p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>


<p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p>
<p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure>

<p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>获取元素：</strong></p>
<p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p>
<p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure>


<p>执行完代码后firstElement的值是: “first element”。</p>
<p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p>
<p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure>


<p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p>
<p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure>




<p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure>

<p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure>


<p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p>
<p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure>


<p>执行完代码后size大小是2，因为Deque中包含两个元素。</p>
<p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p>
<p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p>
<p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><p>Properties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个<strong>字符串</strong>。</p>
<p>这个类的优势是可以从流中加载属性集，或者把属性集报错到流中。</p>
<p>除了从 Hashtable 中所定义的方法，Properties 还定义了以下方法：</p>
<table>
<thead>
<tr>
<th align="left"><strong>序号</strong></th>
<th align="left"><strong>方法描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>String getProperty(String key)</strong>  用指定的键在此属性列表中搜索属性。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>String getProperty(String key, String defaultProperty)</strong> 用指定的键在属性列表中搜索属性。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>void list(PrintStream streamOut)</strong>  将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>void list(PrintWriter streamOut)</strong> 将属性列表输出到指定的输出流。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>void load(InputStream streamIn) throws IOException</strong>  从输入流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>Enumeration propertyNames( )</strong> 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>Object setProperty(String key, String value)</strong>  调用 Hashtable 的方法 put。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>void store(OutputStream streamOut, String description)</strong>  以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</td>
</tr>
</tbody></table>
<h3 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h3><p>Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>











<h3 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h3><h5 id="xxxValue"><a href="#xxxValue" class="headerlink" title="xxxValue()"></a>xxxValue()</h5><p>以xxx类型返回指定的数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxValue()	</span><br><span class="line">byteValue()  	<span class="comment">//以byte类型返回指定的数值</span></span><br><span class="line"><span class="comment">//有byte,double,float,int,long,short</span></span><br><span class="line"><span class="comment">//此函数不接受参数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 返回 byte 原生数据类型</span></span><br><span class="line">      System.out.println( x.doubleValue() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：5.0</span><br></pre></td></tr></table></figure>

<h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h5><p>用于两个相同数据类型的比较；</p>
<p>两个不同类型的数据不能用此方法来比较。</p>
<ul>
<li>如果指定的数与参数<strong>相等返回0</strong>。</li>
<li>如果指定的数<strong>小于</strong>参数<strong>返回 -1</strong>。</li>
<li>如果指定的数<strong>大于</strong>参数<strong>返回 1</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(referenceName)</span></span><br><span class="line"><span class="comment">//referenceName -- 可以是一个 Byte, Double, Integer, Float, Long 或 Short 类型的参数。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="type">Interger</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">		System.out.println(x.compareTo(<span class="number">3</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：1</span><br></pre></td></tr></table></figure>

<h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>判断 Number 对象与方法的参数是否相等（类型和数值）</p>
<ul>
<li>如果Number 对象不为 Null，且与方法的参数类型与数值都相等返回 True，否则返回 False。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object x)</span> <span class="comment">//x为任何对象</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(x.equals(y));</span><br><span class="line">        System.out.println(x.equals(z));</span><br><span class="line">        System.out.println(x.equals(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回给定参数的原生 Number 对象值，</p>
<p>参数可以是原生数据类型，如String等。</p>
<p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的对象值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> Double.valueOf(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Float</span> <span class="variable">a</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;444&quot;</span>, <span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">80.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure>

<h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>返回以一个字符串表示的 Number 对象值。</p>
<p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串参数作为有符号的十进制整数进行解析。</p>
<p>如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span>Integer.parseInt(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure>

<h3 id="Math数学类"><a href="#Math数学类" class="headerlink" title="Math数学类"></a>Math数学类</h3><p>在源文件顶部加上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure>

<p>Math类</p>
<h4 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h4><p>返回参数的<strong>绝对值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line">                        </span><br><span class="line">        System.out.println(Math.abs(a));</span><br><span class="line">        System.out.println(Math.abs(d));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure>

<h4 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h4><p>返回参数的算术平方根。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;sqrt(%.3f) 为 %.3f%n&quot;</span>, x, Math.sqrt(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt(<span class="number">11.635</span>) 为 <span class="number">3.411</span></span><br></pre></td></tr></table></figure>



<h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>返回一个最接近的int ,long型值，”<strong>四舍五入</strong>“，算法为**Math.floor(x+0.5)**；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        System.out.println(Math.round(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure>

<h4 id="min-和max"><a href="#min-和max" class="headerlink" title="min()和max()"></a>min()和max()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Math.min(<span class="number">12</span>,<span class="number">30</span>)); </span><br><span class="line">        System.out.println(Math.max(<span class="number">12</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h4 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h4><p>返回一个随机数，随机数范围为 0.0 &lt;&#x3D; x &lt; 1.0。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println( Math.random() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5444085967267008</span><br></pre></td></tr></table></figure>

<h4 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h4><p>返回第一个参数的第二个参数次方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2.76</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;pow(%.3f, %.3f) 为 %.3f%n&quot;</span>, x, y, Math.pow(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(11.635, 2.760) 为 874.008</span><br></pre></td></tr></table></figure>

<h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><p>返回自然数底数e的参数次方</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;exp(%.3f) 为 %.3f%n&quot;</span>, x, Math.exp(x));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">exp(<span class="number">11.635</span>) 为 <span class="number">112983.831</span></span><br></pre></td></tr></table></figure>

<h4 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h4><p>返回参数的自然数底数的对数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;log(%.3f) 为 %.3f%n&quot;</span>, x, Math.log(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">log(<span class="number">11.635</span>) 为 <span class="number">2.454</span></span><br></pre></td></tr></table></figure>

<h4 id="rint"><a href="#rint" class="headerlink" title="rint()"></a>rint()</h4><p>返回最接近参数的整数值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">100.500</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">100.200</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.rint(d));</span><br><span class="line">        System.out.println(Math.rint(e)); </span><br><span class="line">        System.out.println(Math.rint(f)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101.0</span><br><span class="line">100.0</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure>

<h4 id="floor-x2F-ceil"><a href="#floor-x2F-ceil" class="headerlink" title="floor()&#x2F;ceil()"></a>floor()&#x2F;ceil()</h4><p>floor()：对一个数进行下舍入，返回给定参数最大的整数，该整数小于或等给定的参数。</p>
<p>ceil()：对一个数进行上舍入，返回值大于或等于给定的参数，类型为双精度浮点型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> -<span class="number">90</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.floor(d));</span><br><span class="line">        System.out.println(Math.floor(f));</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.ceil(d));</span><br><span class="line">        System.out.println(Math.ceil(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><p><strong>枚举</strong></p>
<table>
<thead>
<tr>
<th>1</th>
<th><strong>boolean hasMoreElements( )</strong></th>
<th>测试此枚举是否包含更多的元素。</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td><strong>Object nextElement( )</strong></td>
<td>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td>
</tr>
</tbody></table>
<h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：</p>
<ul>
<li>Vector 是同步访问的。</li>
<li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li>
</ul>
<p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p>
<p>Vector 类支持 <strong>4 种构造方法</strong>。</p>
<p>第一种构造方法创建一个默认的向量，默认大小为 10：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector()</span><br></pre></td></tr></table></figure>

<p>第二种构造方法创建指定大小的向量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size)</span><br></pre></td></tr></table></figure>

<p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size,int incr)</span><br></pre></td></tr></table></figure>

<p>第四种构造方法创建一个包含集合 c 元素的向量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(Collection c)</span><br></pre></td></tr></table></figure>



<p>Vector还拥有以下方法：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void add(int index, Object element)   在此向量的指定位置插入指定的元素。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">boolean add(Object o)   将指定元素添加到此向量的末尾。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">int capacity()  返回此向量的当前容量。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">void clear()  从此向量中移除所有元素。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">Object clone()  返回向量的一个副本。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void copyInto(Object[] anArray)   将此向量的组件复制到指定的数组中。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">Object elementAt(int index)  返回指定索引处的组件。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">Enumeration elements()  返回此向量的组件的枚举。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">boolean equals(Object o)  比较指定对象与此向量的相等性。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">Object get(int index)  返回向量中指定位置的元素。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">int hashCode()  返回此向量的哈希码值。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">boolean isEmpty()  测试此向量是否不包含组件。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">Object lastElement()  返回此向量的最后一个组件。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">Object remove(int index)   移除此向量中指定位置的元素。</td>
</tr>
<tr>
<td align="left">27</td>
<td align="left">boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。</td>
</tr>
<tr>
<td align="left">28</td>
<td align="left">boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。</td>
</tr>
<tr>
<td align="left">29</td>
<td align="left">void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。</td>
</tr>
<tr>
<td align="left">30</td>
<td align="left">boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。</td>
</tr>
<tr>
<td align="left">31</td>
<td align="left">void removeElementAt(int index)  删除指定索引处的组件。</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。</td>
</tr>
<tr>
<td align="left">33</td>
<td align="left">boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。</td>
</tr>
<tr>
<td align="left">34</td>
<td align="left">Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。</td>
</tr>
<tr>
<td align="left">35</td>
<td align="left">void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。</td>
</tr>
<tr>
<td align="left">36</td>
<td align="left">void setSize(int newSize)   设置此向量的大小。</td>
</tr>
<tr>
<td align="left">37</td>
<td align="left">int size()   返回此向量中的组件数。</td>
</tr>
<tr>
<td align="left">38</td>
<td align="left">List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。</td>
</tr>
<tr>
<td align="left">39</td>
<td align="left">Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。</td>
</tr>
<tr>
<td align="left">40</td>
<td align="left">Object[] toArray(Object[] a)  返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。</td>
</tr>
<tr>
<td align="left">41</td>
<td align="left">String toString()  返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。</td>
</tr>
<tr>
<td align="left">42</td>
<td align="left">void trimToSize()   对此向量的容量进行微调，使其等于向量的当前大小。</td>
</tr>
</tbody></table>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// initial size is 3, increment is 2</span></span><br><span class="line">      <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial size: &quot;</span> + v.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Capacity after four additions: &quot;</span> +</span><br><span class="line">          v.capacity());</span><br><span class="line"></span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">5.45</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">6.08</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">7</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">9.4</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First element: &quot;</span> +</span><br><span class="line">         (Integer)v.firstElement());</span><br><span class="line">      System.out.println(<span class="string">&quot;Last element: &quot;</span> +</span><br><span class="line">         (Integer)v.lastElement());</span><br><span class="line">      <span class="keyword">if</span>(v.contains(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)))</span><br><span class="line">         System.out.println(<span class="string">&quot;Vector contains 3.&quot;</span>);</span><br><span class="line">      <span class="comment">// enumerate the elements in the vector.</span></span><br><span class="line">      <span class="type">Enumeration</span> <span class="variable">vEnum</span> <span class="operator">=</span> v.elements();</span><br><span class="line">      System.out.println(<span class="string">&quot;\nElements in vector:&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(vEnum.hasMoreElements())</span><br><span class="line">         System.out.print(vEnum.nextElement() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上实例编译运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial size: <span class="number">0</span></span><br><span class="line">Initial capacity: <span class="number">3</span></span><br><span class="line">Capacity after four additions: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">7</span></span><br><span class="line">Current capacity: <span class="number">9</span></span><br><span class="line">First element: <span class="number">1</span></span><br><span class="line">Last element: <span class="number">12</span></span><br><span class="line">Vector contains <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Elements in vector:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5.45</span> <span class="number">6.08</span> <span class="number">7</span> <span class="number">9.4</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>









<h3 id="Bitset类"><a href="#Bitset类" class="headerlink" title="Bitset类"></a>Bitset类</h3><p>Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。</p>
<p>BitSet定义了两个构造方法。</p>
<p>第一个构造方法创建一个默认的对象：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet()</span><br></pre></td></tr></table></figure>

<p>第二个方法允许用户指定初始大小。所有位初始化为0。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet(int size)</span><br></pre></td></tr></table></figure>





<p>BitSet中实现了Cloneable接口中定义的方法如下表所列：</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void and(BitSet set) 对此目标位 set 和参数位 set 执行逻辑与操作。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">void andNot(BitSet set) 清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">int cardinality( ) 返回此 BitSet 中设置为 true 的位数。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">void clear( ) 将此 BitSet 中的所有位设置为 false。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">void clear(int index) 将索引指定处的位设置为 false。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">void clear(int startIndex, int endIndex) 将指定的 startIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Object clone( ) 复制此 BitSet，生成一个与之相等的新 BitSet。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">boolean equals(Object bitSet) 将此对象与指定的对象进行比较。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">void flip(int index) 将指定索引处的位设置为其当前值的补码。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">void flip(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">boolean get(int index) 返回指定索引处的位值。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">BitSet get(int startIndex, int endIndex) 返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">int hashCode( ) 返回此位 set 的哈希码值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">boolean intersects(BitSet bitSet) 如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true。</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left">boolean isEmpty( ) 如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">int length( ) 返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1。</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left">int nextClearBit(int startIndex) 返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left">int nextSetBit(int startIndex) 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left">void or(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑或操作。</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">void set(int index) 将指定索引处的位设置为 true。</td>
</tr>
<tr>
<td align="left">21</td>
<td align="left">void set(int index, boolean v)  将指定索引处的位设置为指定的值。</td>
</tr>
<tr>
<td align="left">22</td>
<td align="left">void set(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。</td>
</tr>
<tr>
<td align="left">23</td>
<td align="left">void set(int startIndex, int endIndex, boolean v) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。</td>
</tr>
<tr>
<td align="left">24</td>
<td align="left">int size( ) 返回此 BitSet 表示位值时实际使用空间的位数。</td>
</tr>
<tr>
<td align="left">25</td>
<td align="left">String toString( ) 返回此位 set 的字符串表示形式。</td>
</tr>
<tr>
<td align="left">26</td>
<td align="left">void xor(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑异或操作。</td>
</tr>
</tbody></table>
<h3 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map 接口中键和值一一映射. 可以通过键来获取值。</p>
<ul>
<li>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</li>
<li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li>
<li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li>
<li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li>
<li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li>
</ul>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">void clear( )  从此映射中移除所有映射关系（可选操作）。</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">int hashCode( ) 返回此映射的哈希码值。</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">Set keySet( ) 返回此映射中包含的键的 Set 视图。</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">int size( ) 返回此映射中的键-值映射关系数。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">Collection values( ) 返回此映射中包含的值的 Collection 视图。</td>
</tr>
</tbody></table>
<h3 id="system类"><a href="#system类" class="headerlink" title="system类"></a>system类</h3><p><strong>exit  退出当前程序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">//表示程序退出，0表示一个正常的状态</span></span><br></pre></td></tr></table></figure>

<p><strong>arraycopy ：复制数组元素</strong>，比较适合底层调用，一般使用Arrays.copyOf 完成复制数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line"><span class="comment">//src: 源数组</span></span><br><span class="line"><span class="comment">//srcPos: 从源数组的哪个索引开始拷贝</span></span><br><span class="line"><span class="comment">//dest: 目标数组</span></span><br><span class="line"><span class="comment">//destPos：源数组的数据拷贝到目标数组的哪个索引处</span></span><br><span class="line"><span class="comment">//length： 从源数组拷贝多少数据</span></span><br></pre></td></tr></table></figure>

<p><strong>currentTimeMillens ： 返回当前时间距离1970-1-1的毫秒数</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillens();</span><br></pre></td></tr></table></figure>

<p><strong>gc：运行垃圾回收机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure>





<h3 id="大数类型"><a href="#大数类型" class="headerlink" title="大数类型"></a>大数类型</h3><p><strong>BigInteger类：适合保存比较大的整型</strong></p>
<p><strong>BigDecimal类：适合保存进度更高的浮点型（小数）</strong></p>
<p>方法（算术）：</p>
<p>add  加</p>
<p>subtract   减</p>
<p>multiply    乘</p>
<p>divide    除</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigInter.add(bigInteger2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigInter.subtract(bigInteger2);	 <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigInter.multiply(bigInteger2);	 <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigInter.divide(bigInteger2);	 <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100.11&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigDecimal.add(bigDecimal2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigDecimal.subtract(bigDecimal2);	 <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigDecimal.multiply(bigDecimal2);	 <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING);	 <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"><span class="comment">//因为除法可能会出现除不尽的情况，所以调用divide方法时，可以指定精度（在参数列表加上BigDecimal.ROUND_CEILING，如果出现无限循环小数，就会保留分子的进度）</span></span><br></pre></td></tr></table></figure>







<h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>第三代日期类（jdk8加入）</p>
<p>LocalDate（日期&#x2F;年月日）</p>
<p>LocalTime（时间&#x2F;时分秒）</p>
<p>LocalDateTime（时间&#x2F;年月日时分秒）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"><span class="comment">//输出：2021-10-03T16:20:05.137</span></span><br></pre></td></tr></table></figure>

<p>使用DateTimeFormatter对象来进行格式化（ofPattern方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期 = &quot;</span> + format);</span><br><span class="line"><span class="comment">//输出：格式化的日期 = 2021-10-03 16:22:05</span></span><br></pre></td></tr></table></figure>

<p>日期类还有plus增加时间的某个部分，minus查看一年前和一年后的日期 …等等（具体看API文档）</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/14/Java/">http://example.com/2022/04/14/Java/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/java/">java</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151629165.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2022/04/14/Leetcode%E5%88%B7%E9%A2%98/"><img class="prev-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151639264.jpeg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">算法题</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2022/04/14/Java%E2%80%94SSM&amp;Maven/"><img class="next-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151630621.jpeg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Java—SSM&amp;Maven</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2022/05/01/JVM/" title="JVM"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151632260.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-01</div><div class="title">JVM</div></div></a></div><div><a href="/Notes/2022/05/13/Java%E2%80%94SpringBoot-MybatisPlus/" title="Java—SpringBoot&MybatisPlus"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232143584.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">Java—SpringBoot&MybatisPlus</div></div></a></div><div><a href="/Notes/2022/04/14/Java%E2%80%94SSM&Maven/" title="Java—SSM&Maven"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151630621.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">Java—SSM&Maven</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%94%A8%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">一些用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HashMap%E5%92%8CHashtable"><span class="toc-number">1.1.</span> <span class="toc-text">2. HashMap和Hashtable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Arrays-asList"><span class="toc-number">1.2.</span> <span class="toc-text">3.Arrays.asList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">4.可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AD%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">5.字符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AD%97%E7%AC%A6%E5%88%86%E5%89%B2"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.字符分割</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%AD%97%E7%AC%A6%E5%A4%A7%E5%B0%8F%E5%86%99"><span class="toc-number">1.4.2.</span> <span class="toc-text">2.字符大小写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%B5%8B%E8%AF%95%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%BA%E5%9F%9F%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.测试两个字符串区域是否相等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%95%B0%E7%BB%84"><span class="toc-number">1.5.</span> <span class="toc-text">6.数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%9C%80%E5%A4%A7"><span class="toc-number">1.5.1.</span> <span class="toc-text">获取最大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6"><span class="toc-number">1.5.2.</span> <span class="toc-text">数组合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%A1%AB%E5%85%85"><span class="toc-number">1.5.3.</span> <span class="toc-text">数组填充</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%89%A9%E5%AE%B9"><span class="toc-number">1.5.4.</span> <span class="toc-text">数组扩容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%B7%AE%E9%9B%86%EF%BC%8C%E4%BA%A4%E9%9B%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">数组差集，交集</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">7.时间处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E5%8F%8A%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="toc-number">1.6.1.</span> <span class="toc-text">当前时间及格式化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B9%B4%E4%BB%BD%E6%9C%88%E4%BB%BD%E7%AD%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">获取年份月份等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.</span> <span class="toc-text">8.方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.1.</span> <span class="toc-text">instanceof关键字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E7%AD%BE%EF%BC%88Label%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">标签（Label）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Varargs%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">Varargs可变参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java%E7%BB%83%E4%B9%A0"><span class="toc-number">2.</span> <span class="toc-text">Java练习</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E4%B8%8A%E7%BB%83%E4%B9%A0"><span class="toc-number">2.1.</span> <span class="toc-text">网上练习</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E7%BB%83%E4%B9%A0"><span class="toc-number">2.2.</span> <span class="toc-text">作业练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IDEA%E4%BD%BF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">IDEA使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA"><span class="toc-number">3.1.</span> <span class="toc-text">新建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF"><span class="toc-number">3.2.</span> <span class="toc-text">模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E6%8D%B7%E9%94%AE"><span class="toc-number">3.3.</span> <span class="toc-text">快捷键</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9"><span class="toc-number">4.</span> <span class="toc-text">基础内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">4.1.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.2.</span> <span class="toc-text">修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">访问控制修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">非访问控制修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#static"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#final"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">final</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">4.3.</span> <span class="toc-text">关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85"><span class="toc-number">4.4.</span> <span class="toc-text">包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E8%A7%A3"><span class="toc-number">4.5.</span> <span class="toc-text">注解@</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">基本类型和引用类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B8%8E%E5%85%B6%E4%BB%96%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.6.2.</span> <span class="toc-text">包装类与其他的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.3.</span> <span class="toc-text">包装类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.4.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">4.6.5.</span> <span class="toc-text">变量与常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.6.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97boolean"><span class="toc-number">4.6.7.</span> <span class="toc-text">关系运算boolean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E4%B8%B2"><span class="toc-number">4.6.8.</span> <span class="toc-text">子串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#main%E6%96%B9%E6%B3%95"><span class="toc-number">4.7.</span> <span class="toc-text">main方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%EF%BC%88Class%EF%BC%89%E5%92%8C%E5%AF%B9%E8%B1%A1%EF%BC%88object"><span class="toc-number">5.1.</span> <span class="toc-text">类（Class）和对象（object)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BB%A7%E6%89%BF"><span class="toc-number">5.2.</span> <span class="toc-text">1.继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B0%81%E8%A3%85"><span class="toc-number">5.3.</span> <span class="toc-text">2.封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%9A%E6%80%81"><span class="toc-number">5.4.</span> <span class="toc-text">3.多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.5.</span> <span class="toc-text">内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.5.1.</span> <span class="toc-text">成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.5.2.</span> <span class="toc-text">静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.5.3.</span> <span class="toc-text">匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.5.4.</span> <span class="toc-text">局部内部类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.6.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.7.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">5.8.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85-1"><span class="toc-number">5.9.</span> <span class="toc-text">包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8"><span class="toc-number">6.</span> <span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">7.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.1.</span> <span class="toc-text">Collection接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.</span> <span class="toc-text">List接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.3.</span> <span class="toc-text">Set接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.4.</span> <span class="toc-text">Map接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81"><span class="toc-number">9.</span> <span class="toc-text">IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File%E7%B1%BB"><span class="toc-number">9.1.</span> <span class="toc-text">File类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E6%B5%81%E5%88%86%E7%B1%BB"><span class="toc-number">9.2.</span> <span class="toc-text">IO流分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#FileInputStream"><span class="toc-number">9.2.1.</span> <span class="toc-text">FileInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileOutputStream"><span class="toc-number">9.2.2.</span> <span class="toc-text">FileOutputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FileReader-%E5%92%8C-FileWriter"><span class="toc-number">9.2.3.</span> <span class="toc-text">FileReader 和 FileWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E6%B5%81%E5%92%8C%E5%A4%84%E7%90%86%E6%B5%81"><span class="toc-number">9.2.4.</span> <span class="toc-text">节点流和处理流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">9.2.5.</span> <span class="toc-text">对象流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">9.2.6.</span> <span class="toc-text">标准输入输出流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">9.2.7.</span> <span class="toc-text">转换流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">9.2.8.</span> <span class="toc-text">打印流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#properties%E7%B1%BB"><span class="toc-number">9.2.9.</span> <span class="toc-text">properties类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.</span> <span class="toc-text">多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.1.</span> <span class="toc-text">进程和线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">10.2.</span> <span class="toc-text">线程实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.</span> <span class="toc-text">线程常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-number">10.4.</span> <span class="toc-text">守护线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">10.5.</span> <span class="toc-text">线程生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">10.6.</span> <span class="toc-text">同步机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">10.7.</span> <span class="toc-text">锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">11.</span> <span class="toc-text">网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#InetAddress%E7%B1%BB"><span class="toc-number">11.1.</span> <span class="toc-text">InetAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InetSocketAddress%E7%B1%BB"><span class="toc-number">11.2.</span> <span class="toc-text">InetSocketAddress类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%EF%BC%9A"><span class="toc-number">11.3.</span> <span class="toc-text">TCP网络编程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket%E7%B1%BB"><span class="toc-number">11.3.1.</span> <span class="toc-text">Socket类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ServerSocket%E7%B1%BB"><span class="toc-number">11.3.2.</span> <span class="toc-text">ServerSocket类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">11.4.</span> <span class="toc-text">UDP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramSocket%E7%B1%BB"><span class="toc-number">11.4.1.</span> <span class="toc-text">DatagramSocket类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DatagramPacket%E7%B1%BB"><span class="toc-number">11.4.2.</span> <span class="toc-text">DatagramPacket类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL%E7%B1%BB"><span class="toc-number">11.5.</span> <span class="toc-text">URL类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">12.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">12.1.</span> <span class="toc-text">反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E7%9A%84%E4%B8%BB%E8%A6%81%E7%B1%BB"><span class="toc-number">12.1.1.</span> <span class="toc-text">反射的主要类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">Class类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Class%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">12.2.1.</span> <span class="toc-text">Class类的常用方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96Class%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.2.2.</span> <span class="toc-text">获取Class对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">12.3.</span> <span class="toc-text">类加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%BB%93%E6%9E%84%E4%BF%A1%E6%81%AF"><span class="toc-number">12.4.</span> <span class="toc-text">反射获取类结构信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">12.5.</span> <span class="toc-text">反射创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E6%88%90%E5%91%98"><span class="toc-number">12.6.</span> <span class="toc-text">反射访问类中成员</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-1"><span class="toc-number">13.1.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">13.2.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%AE%9A%E7%AC%A6"><span class="toc-number">13.2.1.</span> <span class="toc-text">限定符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E7%AC%A6"><span class="toc-number">13.2.2.</span> <span class="toc-text">选择匹配符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%BB%84%E7%BB%84%E5%90%88%E5%92%8C%E6%96%B9%E5%90%91%E5%BA%94%E7%94%A8%E7%AC%A6"><span class="toc-number">13.2.3.</span> <span class="toc-text">分组组合和方向应用符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6"><span class="toc-number">13.2.4.</span> <span class="toc-text">特殊字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%AC%A6"><span class="toc-number">13.2.5.</span> <span class="toc-text">定位符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">13.3.</span> <span class="toc-text">常用类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E5%BC%95%E7%94%A8"><span class="toc-number">13.4.</span> <span class="toc-text">反向引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E5%AD%97%E7%AC%A6-%E8%AF%A6%E7%BB%86%E8%AF%B4%E6%98%8E"><span class="toc-number">13.5.</span> <span class="toc-text">元字符-详细说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">Lambda表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.1.</span> <span class="toc-text">单例设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">15.2.</span> <span class="toc-text">模板设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-number">16.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">16.1.</span> <span class="toc-text">Object类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collections%E7%B1%BB"><span class="toc-number">16.2.</span> <span class="toc-text">Collections类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Scanner%E7%B1%BB"><span class="toc-number">16.3.</span> <span class="toc-text">Scanner类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#String%E7%B1%BB"><span class="toc-number">16.4.</span> <span class="toc-text">String类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#StringBuffer%E7%B1%BB"><span class="toc-number">16.5.</span> <span class="toc-text">StringBuffer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Arrays%E7%B1%BB"><span class="toc-number">16.6.</span> <span class="toc-text">Arrays类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList%E7%B1%BB"><span class="toc-number">16.7.</span> <span class="toc-text">ArrayList类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinkedList%E7%B1%BB"><span class="toc-number">16.8.</span> <span class="toc-text">LinkedList类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashset%E7%B1%BB"><span class="toc-number">16.9.</span> <span class="toc-text">Hashset类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HashMap%E7%B1%BB"><span class="toc-number">16.10.</span> <span class="toc-text">HashMap类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hashtable%E7%B1%BB"><span class="toc-number">16.11.</span> <span class="toc-text">Hashtable类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TreeMap%E7%B1%BB"><span class="toc-number">16.12.</span> <span class="toc-text">TreeMap类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Deque%E7%B1%BB"><span class="toc-number">16.13.</span> <span class="toc-text">Deque类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Properties-%E7%B1%BB"><span class="toc-number">16.14.</span> <span class="toc-text">Properties 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Iterator%E7%B1%BB"><span class="toc-number">16.15.</span> <span class="toc-text">Iterator类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Number%E7%B1%BB"><span class="toc-number">16.16.</span> <span class="toc-text">Number类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#xxxValue"><span class="toc-number">16.16.0.1.</span> <span class="toc-text">xxxValue()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#compareTo"><span class="toc-number">16.16.0.2.</span> <span class="toc-text">compareTo()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#equals"><span class="toc-number">16.16.0.3.</span> <span class="toc-text">equals()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#valueOf-NaN"><span class="toc-number">16.16.0.4.</span> <span class="toc-text">valueOf()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#toString-NaN"><span class="toc-number">16.16.0.5.</span> <span class="toc-text">toString()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#parseInt"><span class="toc-number">16.16.0.6.</span> <span class="toc-text">parseInt()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Math%E6%95%B0%E5%AD%A6%E7%B1%BB"><span class="toc-number">16.17.</span> <span class="toc-text">Math数学类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abs"><span class="toc-number">16.17.1.</span> <span class="toc-text">abs()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sqrt"><span class="toc-number">16.17.2.</span> <span class="toc-text">sqrt()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#round"><span class="toc-number">16.17.3.</span> <span class="toc-text">round()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#min-%E5%92%8Cmax"><span class="toc-number">16.17.4.</span> <span class="toc-text">min()和max()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#random"><span class="toc-number">16.17.5.</span> <span class="toc-text">random()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pow"><span class="toc-number">16.17.6.</span> <span class="toc-text">pow()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exp"><span class="toc-number">16.17.7.</span> <span class="toc-text">exp()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log"><span class="toc-number">16.17.8.</span> <span class="toc-text">log()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rint"><span class="toc-number">16.17.9.</span> <span class="toc-text">rint()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#floor-x2F-ceil"><span class="toc-number">16.17.10.</span> <span class="toc-text">floor()&#x2F;ceil()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Enumeration"><span class="toc-number">16.18.</span> <span class="toc-text">Enumeration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vector%E7%B1%BB"><span class="toc-number">16.19.</span> <span class="toc-text">Vector类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitset%E7%B1%BB"><span class="toc-number">16.20.</span> <span class="toc-text">Bitset类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E6%8E%A5%E5%8F%A3-1"><span class="toc-number">16.21.</span> <span class="toc-text">Map接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#system%E7%B1%BB"><span class="toc-number">16.22.</span> <span class="toc-text">system类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">16.23.</span> <span class="toc-text">大数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%B1%BB"><span class="toc-number">16.24.</span> <span class="toc-text">日期类</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By ValcanoZz</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><div><a onclick="window.open('')"></a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>