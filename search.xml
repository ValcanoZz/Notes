<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法2.0</title>
      <link href="/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/"/>
      <url>/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><p>关于右移 &gt;&gt; 和 &gt;&gt;&gt;</p><ul><li>&gt;&gt; 是带符号右移，用符号位补位</li><li>&gt;&gt;&gt; 是不带符号右移，用0补位</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.MIN_VALUE 的十进制和二进制</span></span><br><span class="line">-<span class="number">2147483648</span></span><br><span class="line"><span class="number">10000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//Integer.MIN_VALUE &gt;&gt; 1 的十进制和二进制</span></span><br><span class="line">-<span class="number">1073741824</span></span><br><span class="line"><span class="number">11000000000000000000000000000000</span></span><br><span class="line"><span class="comment">//Integer.MIN_VALUE &gt;&gt;&gt; 1 的十进制和二进制</span></span><br><span class="line"><span class="number">1073741824</span></span><br><span class="line"><span class="number">01000000000000000000000000000000</span></span><br></pre></td></tr></table></figure><p>例1：打印一个数字的32位二进制形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    System.out.print((n &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span> ? <span class="string">&#x27;0&#x27;</span> : <span class="string">&#x27;1&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2： Integer.MIN_VALUE，即 -2^31^，它的负数还是它自己。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h2><p>leetcode25. </p><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p><blockquote><p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><ul><li>链表中的节点数目为 <code>n</code></li><li><code>1 &lt;= k &lt;= n &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li></ul></blockquote><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 3</span><br><span class="line">输出：[3,2,1,4,5]</span><br></pre></td></tr></table></figure><p>思路：这道题不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091520079.png" alt="image-20220609152053978"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091521871.png" alt="image-20220609152109809"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206091521279.png" alt="image-20220609152128213"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> getKGroupEnd(start, k);</span><br><span class="line">    <span class="keyword">if</span> (end == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    head = end;</span><br><span class="line">    reverse(start, end);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">lastEnd</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="keyword">while</span> (lastEnd.next != <span class="literal">null</span>)&#123;</span><br><span class="line">        start = lastEnd.next;</span><br><span class="line">        end = getKGroupEnd(start, k);</span><br><span class="line">        <span class="keyword">if</span> (end == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(start, end);</span><br><span class="line">        lastEnd.next = end;</span><br><span class="line">        lastEnd = start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getKGroupEnd</span><span class="params">(ListNode start, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (--k != <span class="number">0</span> &amp;&amp; start != <span class="literal">null</span>)&#123;</span><br><span class="line">        start = start.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(ListNode start, ListNode end)</span>&#123;</span><br><span class="line">    end = end.next;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> start;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != end)&#123;</span><br><span class="line">        next = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    start.next = end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表求和"><a href="#链表求和" class="headerlink" title="链表求和"></a>链表求和</h2><p>给定两个用链表表示的整数，每个节点包含一个数位。</p><p>这些数位是反向存放的，也就是个位排在链表首部。</p><p>编写函数对这两个整数求和，并用链表形式返回结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(7-&gt;1-&gt;6) + (5-&gt;9-&gt;2)，即617 + 295</span><br><span class="line">输出：2-&gt;1-&gt;9，即912</span><br></pre></td></tr></table></figure><blockquote><p>假设这些数位是正向存放的，又该如何解决呢? （翻转链表，或使用栈，将数字压入栈中，再依次取出相加）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：(6-&gt;1-&gt;7) + (2-&gt;9-&gt;5)，即617 + 295</span><br><span class="line">输出：9-&gt;1-&gt;2，即912</span><br></pre></td></tr></table></figure></blockquote><p>思路：同时遍历两个链表，逐位相加，并且加上上一位的进位，对于短的链表，可以认为其后是若干0。最后，如果遍历结束后进位不为0，还要再加一个节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumber</span><span class="params">(ListNode head1,ListNode head2)</span>&#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>, tail = <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">//表示进位</span></span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> || head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> head1 != <span class="literal">null</span> ? head1.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> head2 != <span class="literal">null</span> ? head2.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> n1 + n2 + carry;  <span class="comment">//每一位数都等于两个链表节点的值以及进位的和</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            head = tail = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (head1 != <span class="literal">null</span>) head1 = head1.next;</span><br><span class="line">        <span class="keyword">if</span> (head2 != <span class="literal">null</span>) head2 = head2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表遍历结束后，如还有进位，则需要再加一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>leetcode21. </p><p>将两个升序链表合并为一个新的 <strong>升序</strong> 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [1,2,4], l2 = [1,3,4]</span><br><span class="line">输出：[1,1,2,3,4,4]</span><br></pre></td></tr></table></figure><p>思路1：迭代，谁小就指向谁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoList</span><span class="params">(ListNode head1, ListNode head2)</span>&#123;</span><br><span class="line">    <span class="comment">//先建立一个哨兵节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> ans;</span><br><span class="line">    <span class="keyword">while</span> (head1 != <span class="literal">null</span> &amp;&amp; head2 != <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="comment">//谁小就指向谁</span></span><br><span class="line">        <span class="keyword">if</span> (head1.val &lt;= head2.val)&#123;</span><br><span class="line">            pre.next = head1;</span><br><span class="line">            head1 = head1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre.next = head2;</span><br><span class="line">            head2 = head2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当有一方遍历完，且另一链表剩下部分是有序的，则pre可以直接指向剩下的部分</span></span><br><span class="line">    pre.next = head1 != <span class="literal">null</span> ? head1 : head2;</span><br><span class="line">    <span class="keyword">return</span> ans.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路2：递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并有序链表数组"><a href="#合并有序链表数组" class="headerlink" title="合并有序链表数组"></a>合并有序链表数组</h3><p>leetcode 剑指offer II 078. 合并排序链表</p><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><h2 id="morris遍历"><a href="#morris遍历" class="headerlink" title="morris遍历"></a>morris遍历</h2><p>morris遍历二叉树，时间复杂度O(N)，空间复杂度O(1)。</p><h3 id="遍历过程"><a href="#遍历过程" class="headerlink" title="遍历过程"></a>遍历过程</h3><p>设cur为当前节点，一开始cur指向树的根节点，循环执行以下流程：</p><ol><li><p>如果cur无左树，cur &#x3D; cur.right；</p></li><li><p>如果cur有左树，找到左树最右的节点，记为mostright；</p><ol><li><p>如果mostright的右指针指向null，使mostright.right &#x3D; cur，cur &#x3D; cur.left；</p></li><li><p>如果mostright的右指针指向cur，mostright.right &#x3D; null，cur &#x3D; cur.right （由于有2.1的操作，所以mostright的右指针可能是指向cur的）</p></li></ol></li></ol><p>当cur为null时，流程结束。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">     <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">     <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">         <span class="comment">//看cur是否有左树</span></span><br><span class="line">         mostRight = cur.left;</span><br><span class="line">         <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">             <span class="comment">//找cur的左树的最右节点</span></span><br><span class="line">             <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                 mostRight = mostRight.right;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">//情况2.1</span></span><br><span class="line">             <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                 mostRight.right = cur;</span><br><span class="line">                 cur = cur.left;</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">//情况2.2</span></span><br><span class="line">                 mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                 cur = cur.right;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//情况1</span></span><br><span class="line">             cur = cur.right;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="前中后遍历"><a href="#前中后遍历" class="headerlink" title="前中后遍历"></a>前中后遍历</h3><p>morris特点：有左树的节点会遍历两次，其他节点均只遍历一次。即符合2.1情况的节点是第一个遍历，符合2.2情况的节点是第二次遍历。 </p><blockquote><p>比如，递归遍历二叉树会经过节点三次，在不同的经过时机进行打印，就是前序、中序、后序遍历二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的x序遍历</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == NULL)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历，即第一次经过</span></span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    <span class="comment">//中序遍历，即第二次经过</span></span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="comment">//后序遍历，即第三次经过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>而morris的遍历时机：</p><ul><li>前序遍历：在第一次遍历节点时打印</li><li>中序遍历：对于会遍历两次的节点，在其第二次遍历时打印，其他的照常打印。</li><li>后序遍历：对于会遍历两次的节点，分别逆序打印其左树的右边界，最后在逆序打印整棵树的右边界(根节点的右边界)（右边界是指这个节点一直向右走下去的路径，包括它自己）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">morris</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">mostRight</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        mostRight = cur.left;</span><br><span class="line">        <span class="keyword">if</span> (mostRight != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (mostRight.right != <span class="literal">null</span> &amp;&amp; mostRight.right != cur) &#123;</span><br><span class="line">                mostRight = mostRight.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况2.1</span></span><br><span class="line">            <span class="keyword">if</span> (mostRight.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">//System.out.print(cur.val + &quot; &quot;); //先序遍历</span></span><br><span class="line">                mostRight.right = cur;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//情况2.2</span></span><br><span class="line">                mostRight.right = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">//System.out.print(cur.val + &quot; &quot;); //中序遍历</span></span><br><span class="line">                <span class="comment">//printEdge(cur.left);    //后序遍历，打印左树的右边界,</span></span><br><span class="line">                <span class="comment">//注：由于后序遍历是打印节点的右边界，应该在最右节点的右节点为null，不然它的右节点还会指向其他地方，致使多打印</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//情况1</span></span><br><span class="line">            <span class="comment">//System.out.print(cur.val + &quot; &quot;); //先序、中序遍历都要这个打印</span></span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//printEdge(head);  //后序遍历，打印整个树的右边界(即根节点的右边界)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历需要：逆序打印节点的右边界</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printEdge</span><span class="params">(Node head)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">tail</span> <span class="operator">=</span> reverseEdge(head);  <span class="comment">//翻转链表</span></span><br><span class="line">    <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">        System.out.print(cur.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseEdge(tail); <span class="comment">//再翻转回来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历需要：翻转右边界(链表)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title function_">reverseEdge</span><span class="params">(Node from)</span>&#123;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (from != <span class="literal">null</span>)&#123;</span><br><span class="line">        next = from.right;</span><br><span class="line">        from.right = pre;</span><br><span class="line">        pre = from;</span><br><span class="line">        from = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>由于图本身的数据结构表达多种多样，为了不用在和图有关的算法上使用不同种数据结构去实现。所以可以考虑只使用一种兼容性好的结构，用到的时候，将题目中的数据结构转换为常用的这个结构，就不用考虑多种结构的算法实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> in;  <span class="comment">//入读</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> out; <span class="comment">//出度</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Node&gt; nexts; <span class="comment">//点集：直接邻居，从自己出发能到达的第一个节点</span></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;Edge&gt; edges; <span class="comment">//边集：从自己出去的边的集合</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">        in = <span class="number">0</span>;</span><br><span class="line">        out = <span class="number">0</span>;</span><br><span class="line">        nexts = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//边</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> weight;<span class="comment">//权重</span></span><br><span class="line">    <span class="keyword">public</span> Node from;</span><br><span class="line">    <span class="keyword">public</span> Node to;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Edge</span><span class="params">(<span class="type">int</span> weight, Node from, Node to)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">        <span class="built_in">this</span>.from = from;</span><br><span class="line">        <span class="built_in">this</span>.to = to;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Graph</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, Node&gt; nodes;</span><br><span class="line">    <span class="keyword">public</span> HashSet&lt;Edge&gt; edges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Graph</span><span class="params">()</span> &#123;</span><br><span class="line">        nodes = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设有一个图的数据结构为 [weight，from，to]，则以下是结构的转换过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Graph <span class="title function_">createGraph</span><span class="params">(Integer[][] matrix)</span>&#123;</span><br><span class="line">    <span class="type">Graph</span> <span class="variable">graph</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Graph</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">weight</span> <span class="operator">=</span> matrix[i][<span class="number">0</span>];</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">from</span> <span class="operator">=</span> matrix[i][<span class="number">1</span>];</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">to</span> <span class="operator">=</span> matrix[i][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果点集中没有这个点，就新建一个加进去</span></span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(from))&#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(from));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!graph.nodes.containsKey(to))&#123;</span><br><span class="line">            graph.nodes.put(from, <span class="keyword">new</span> <span class="title class_">Node</span>(to));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//得到from点和to点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">fromNode</span> <span class="operator">=</span> graph.nodes.get(from);</span><br><span class="line">        <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> graph.nodes.get(to);</span><br><span class="line">        <span class="comment">//建边</span></span><br><span class="line">        <span class="type">Edge</span> <span class="variable">newEdge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Edge</span>(weight, fromNode, toNode);</span><br><span class="line">        <span class="comment">//to点是from点的直接邻居</span></span><br><span class="line">        fromNode.nexts.add(toNode);</span><br><span class="line">        fromNode.out++;</span><br><span class="line">        toNode.in++;</span><br><span class="line">        <span class="comment">//新边是from点的出边</span></span><br><span class="line">        fromNode.edges.add(newEdge);</span><br><span class="line">        graph.edges.add(newEdge);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>深度优先遍历DFS和广度优先遍历BFS</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从node出发，进行宽度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue&lt;Node&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    queue.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">//出队列时打印</span></span><br><span class="line">        System.out.println(cur.value);</span><br><span class="line">        <span class="comment">//将所有没加入过的直接邻居 加入集合和队列中</span></span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next))&#123;</span><br><span class="line">                set.add(next);</span><br><span class="line">                queue.add(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Node&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    stack.add(node);</span><br><span class="line">    set.add(node);</span><br><span class="line">    System.out.println(node.value);</span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">for</span> (Node next : cur.nexts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(next)) &#123;</span><br><span class="line">                <span class="comment">//先将当前元素入栈，再入栈直接邻居，然后beak</span></span><br><span class="line">                <span class="comment">//目的是为了保留元素，以便回来往其他方向深度搜索</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                stack.push(next);</span><br><span class="line">                set.add(next);</span><br><span class="line">                <span class="comment">//入栈时打印</span></span><br><span class="line">                System.out.println(next.value);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p><blockquote><p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p></blockquote><p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现<code>一次</code>。</li><li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p><p><strong>代码思想为：</strong></p><p>新建node类，包含节点数值和它的指向；</p><p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p><p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p><p>重复上述操作，直到栈为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Node&gt; <span class="title function_">sortedTopology</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">    <span class="comment">//key为某个node，value为剩余的入度</span></span><br><span class="line">    HashMap&lt;Node, Integer&gt; inMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Queue&lt;Node&gt; zeroInQueue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录每个点的入度，并将入度为0的点加入队列</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123;</span><br><span class="line">        inMap.put(node, node.in);</span><br><span class="line">        <span class="keyword">if</span> (node.in == <span class="number">0</span>)&#123;</span><br><span class="line">            zeroInQueue.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//result存放拓扑排序的结果</span></span><br><span class="line">    List&lt;Node&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (!zeroInQueue.isEmpty())&#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> zeroInQueue.poll();</span><br><span class="line">        result.add(cur);</span><br><span class="line">        <span class="comment">//遍历cur的直接邻居，使其入度-1，并将入度变为0的节点加入队列</span></span><br><span class="line">        <span class="keyword">for</span> (Node next: cur.nexts)&#123;</span><br><span class="line">             inMap.put(next, inMap.get(next) - <span class="number">1</span>);</span><br><span class="line">             <span class="keyword">if</span> (inMap.get(next) == <span class="number">0</span>)&#123;</span><br><span class="line">                 zeroInQueue.add(next);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><h3 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a>普里姆(prim)算法</h3><p>（从顶点 考虑）</p><ol><li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li><li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li><li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li><li>重复步骤2，3，知道V-S为空集</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101100065.png" alt="image-20220610110015537"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//prim最小生成树算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">primMST</span><span class="params">(Graph graph)</span> &#123;</span><br><span class="line">    <span class="comment">//解锁的边进入小根堆</span></span><br><span class="line">    PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Edge&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge o1, Edge o2)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    HashSet&lt;Node&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//外层for循环，是为了预防森林，没有森林的话可以去掉</span></span><br><span class="line">    <span class="keyword">for</span> (Node node : graph.nodes.values()) &#123; <span class="comment">//随便一个点开始</span></span><br><span class="line">        <span class="comment">//node是开始点</span></span><br><span class="line">        <span class="keyword">if</span> (!set.contains(node)) &#123;</span><br><span class="line">            set.add(node);</span><br><span class="line">            priorityQueue.addAll(node.edges); <span class="comment">//将开始点的所有边加入最小堆</span></span><br><span class="line">            <span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll(); <span class="comment">//弹出现有的最小边</span></span><br><span class="line">                <span class="type">Node</span> <span class="variable">toNode</span> <span class="operator">=</span> edge.to;  <span class="comment">//看to点是否在集合中，不在的话也将它的边加入最小堆</span></span><br><span class="line">                <span class="keyword">if</span> (!set.contains(toNode)) &#123;</span><br><span class="line">                    set.add(toNode);</span><br><span class="line">                    result.add(edge);   <span class="comment">//加入结果集</span></span><br><span class="line">                    priorityQueue.addAll(toNode.edges);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="克鲁斯卡尔-kruskal-算法"><a href="#克鲁斯卡尔-kruskal-算法" class="headerlink" title="克鲁斯卡尔(kruskal)算法"></a><strong>克鲁斯卡尔(kruskal)算法</strong></h3><p>（从边 考虑）</p><ol><li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li><li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li><li>直到图中所有的顶点都在同一个顶点集为止</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101102846.png" alt="image-20220610110252139"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line">    <span class="comment">//用并查集实现kruskal算法 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Edge&gt; <span class="title function_">kruskalMST</span><span class="params">(Graph graph)</span>&#123;</span><br><span class="line"><span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>();</span><br><span class="line">unionFind.makeSets(graph.nodes.values());</span><br><span class="line"><span class="comment">// 从小的边到大的边，依次弹出，小根堆！</span></span><br><span class="line">PriorityQueue&lt;Edge&gt; priorityQueue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Edge&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Edge o1, Edge o2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> o1.weight - o2.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="keyword">for</span> (Edge edge : graph.edges) &#123; <span class="comment">// M 条边</span></span><br><span class="line">priorityQueue.add(edge);  <span class="comment">// O(logM)</span></span><br><span class="line">&#125;</span><br><span class="line">Set&lt;Edge&gt; result = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (!priorityQueue.isEmpty()) &#123; <span class="comment">// M 条边</span></span><br><span class="line"><span class="type">Edge</span> <span class="variable">edge</span> <span class="operator">=</span> priorityQueue.poll(); <span class="comment">// O(logM)</span></span><br><span class="line"><span class="keyword">if</span> (!unionFind.isSameSet(edge.from, edge.to)) &#123; <span class="comment">// O(1)</span></span><br><span class="line">result.add(edge);</span><br><span class="line">unionFind.union(edge.from, edge.to);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Union-Find Set，并查集</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"><span class="comment">// key 某一个节点， value key节点往上的节点</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Node, Node&gt; fatherMap;</span><br><span class="line"><span class="comment">// key 某一个集合的代表节点, value key所在集合的节点个数</span></span><br><span class="line"><span class="keyword">private</span> HashMap&lt;Node, Integer&gt; sizeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">()</span> &#123;</span><br><span class="line">fatherMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Node&gt;();</span><br><span class="line">sizeMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Node, Integer&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">makeSets</span><span class="params">(Collection&lt;Node&gt; nodes)</span> &#123;</span><br><span class="line">fatherMap.clear();</span><br><span class="line">sizeMap.clear();</span><br><span class="line"><span class="keyword">for</span> (Node node : nodes) &#123;</span><br><span class="line">fatherMap.put(node, node);</span><br><span class="line">sizeMap.put(node, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到这个集合的代表</span></span><br><span class="line"><span class="keyword">private</span> Node <span class="title function_">findFather</span><span class="params">(Node n)</span> &#123;</span><br><span class="line">Stack&lt;Node&gt; path = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(n != fatherMap.get(n)) &#123;</span><br><span class="line">path.add(n);</span><br><span class="line">n = fatherMap.get(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!path.isEmpty()) &#123;</span><br><span class="line">fatherMap.put(path.pop(), n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断两个点是否在同一个集合中</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(Node a, Node b)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> findFather(a) == findFather(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将两个点并入同一个集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(Node a, Node b)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">null</span> || b == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Node</span> <span class="variable">aDai</span> <span class="operator">=</span> findFather(a);</span><br><span class="line"><span class="type">Node</span> <span class="variable">bDai</span> <span class="operator">=</span> findFather(b);</span><br><span class="line"><span class="keyword">if</span> (aDai != bDai) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">aSetSize</span> <span class="operator">=</span> sizeMap.get(aDai);</span><br><span class="line"><span class="type">int</span> <span class="variable">bSetSize</span> <span class="operator">=</span> sizeMap.get(bDai);</span><br><span class="line"><span class="keyword">if</span> (aSetSize &lt;= bSetSize) &#123;</span><br><span class="line">fatherMap.put(aDai, bDai);</span><br><span class="line">sizeMap.put(bDai, aSetSize + bSetSize);</span><br><span class="line">sizeMap.remove(aDai);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fatherMap.put(bDai, aDai);</span><br><span class="line">sizeMap.put(aDai, aSetSize + bSetSize);</span><br><span class="line">sizeMap.remove(bDai);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="暴力递归-从左往右的尝试模型"><a href="#暴力递归-从左往右的尝试模型" class="headerlink" title="暴力递归-从左往右的尝试模型"></a>暴力递归-从左往右的尝试模型</h2><blockquote><p>尝试就是接解题的步骤，也可以说尝试就是暴力递归。</p><p>从左往右，就是坐标逐步往后移动，解决问题。</p></blockquote><p>例1：打印一个字符串的全部子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例1：打印一个字符串的全部子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process1</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> index, List&lt;String&gt; ans, String path)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (index == str.length) &#123;</span><br><span class="line">ans.add(path);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">no</span> <span class="operator">=</span> path;</span><br><span class="line">process1(str,  index + <span class="number">1</span>, ans, no);</span><br><span class="line"><span class="type">String</span> <span class="variable">yes</span> <span class="operator">=</span> path + String.valueOf(str[index]);</span><br><span class="line">process1(str, index + <span class="number">1</span>, ans, yes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：打印一个字符串的全排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process2</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, ArrayList&lt;String&gt; res)</span> &#123;</span><br><span class="line">       <span class="comment">//在终止位置加入</span></span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">res.add(String.valueOf(str));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; str.length; j++) &#123;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">process2(str, i+<span class="number">1</span>,res);</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例3：打印一个字符串的全排列，要求不要出现重复的排列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">process3</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i, ArrayList&lt;String&gt; res)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line">res.add(String.valueOf(str));</span><br><span class="line">&#125;</span><br><span class="line">       <span class="comment">//用于判断本次循环中是否出现了重复字母，即这个字母的情况已经罗列过了，可以剪枝掉</span></span><br><span class="line"><span class="type">boolean</span>[] visit = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; str.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!visit[str[i] - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">visit[str[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">swap(str, i, j);</span><br><span class="line">process2(str, i+<span class="number">1</span>,res);</span><br><span class="line">swap(str, i, j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例4：（facebook面试题）</p><p>规定1和A对应、2和B对应、3和C对应……那么一个数字字符串比如”111”就可以转化为：  “AAA”、”KA”和”AK”；<br>给定一个只有数字字符组成的字符串str, 返回有多少转化结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//di&#x27;gui</span></span><br><span class="line"><span class="comment">//i之前的位置，如何转化已经做过决定，不用再关心</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">process4</span><span class="params">(<span class="type">char</span>[] str, <span class="type">int</span> i)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (i == str.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;0&#x27;</span>) &#123;<span class="comment">//单独的‘0’是无效的，0只能和10和20在一起才有效</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字母最多到26，所以要考虑十几和二十几的情况</span></span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> process4(str,  i + <span class="number">1</span>);  <span class="comment">//i自己作为单独的数，后续有多少种方案</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length) &#123;</span><br><span class="line">res += process4(str, i + <span class="number">2</span>);  <span class="comment">//i和i+1作为一个二位数，后续有多少种方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (str[i] == <span class="string">&#x27;2&#x27;</span>) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> process4(str,  i + <span class="number">1</span>);<span class="comment">//i自己作为单独的数，后续有多少种方案</span></span><br><span class="line"><span class="comment">//i和i+1这个数，不能超过26</span></span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span> &lt; str.length &amp;&amp; (str[i+<span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i+<span class="number">1</span>] &lt;= <span class="string">&#x27;6&#x27;</span>)) &#123;</span><br><span class="line">res += process4(str, i + <span class="number">2</span>); <span class="comment">//i和i+1作为一个二位数，后续有多少种方案</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str[i] == &#x27;3&#x27; ~ &#x27;9&#x27;</span></span><br><span class="line"><span class="keyword">return</span> process4(str, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JAVA方法"><a href="#JAVA方法" class="headerlink" title="JAVA方法"></a>JAVA方法</h1><h2 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random"></a>Math.random</h2><p>Math.random会<strong>等概率</strong>地返回Double类型的 [0, 1) 的随机数，应用：</p><ul><li><p>随机返回 [0, k) 的数： Math.random() * k</p></li><li><p>随机返回 [0, k] 的整数： (int) Math.random() * (k+1)</p></li><li><p>设x属于 [0, 1) ，原本 x 在[0, x) 上出现的概率是 x，如果要将出现的概率改为 x^2^ ： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.max(Math.random(), Math.random())</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-5随机到1-7随机"><a href="#1-5随机到1-7随机" class="headerlink" title="1-5随机到1-7随机"></a>1-5随机到1-7随机</h3><p>例1：设有一个方法f1()，它等概率返回 [1,5]，现要求将其改成等概率返回 [1,7] 的方法：</p><p>思路：先将f1改成 01等概率方法f2，则f2可以表示一位二进制位，已知三个二进制位可表示 [0,7]，所以利用位运算可以得到一个等概率的3位二进制数，再将等于0的机会均分给其他的数即可。</p><blockquote><p>改造成01等概率，有奇数个则将某个数的概率均分给其他数，有偶数个直接平分即可。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//f1()功能：随机返回 [1,5]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (Math.random() * <span class="number">5</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f2()功能：将f1()改造成随机返回 0、1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans = f1();</span><br><span class="line">        &#125; <span class="keyword">while</span> (ans == <span class="number">3</span>);</span><br><span class="line">        <span class="comment">//将等于3的概率均分给1245</span></span><br><span class="line">        <span class="comment">//当f()为12时返回0， 为45时返回1</span></span><br><span class="line">        <span class="keyword">return</span> ans &lt; <span class="number">3</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//f3()功能：将f2的结果作为一个二进制位，三位即可返回[0,7]，再将等于0的概率均分给其他数，即可等概率得到[1，7]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ans = (f2() &lt;&lt; <span class="number">2</span>) + (f2() &lt;&lt; <span class="number">1</span>) + f2();</span><br><span class="line">        &#125; <span class="keyword">while</span> (ans == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//f3也可以先等到[0,6]，再+1</span></span><br></pre></td></tr></table></figure><h3 id="01不等概率到01等概率"><a href="#01不等概率到01等概率" class="headerlink" title="01不等概率到01等概率"></a>01不等概率到01等概率</h3><p>例2：设方法f1()返回0的概率是p，返回1的概率是1- p，只使用f1()，写出能等概率返回01的方法。</p><p>思路：调用俩次f1，组成一个二位的二进制数，则01和10的概率均为 p(1- p)，而00概率p^2^，11概率(1- p)^2^。所以取01和10作为 0和1返回，00和11直接舍去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//01不等概率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Math.random() &gt; <span class="number">0.7</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//01等概率</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">int</span> ans;</span><br><span class="line">       <span class="keyword">do</span>&#123;</span><br><span class="line">           ans = f1();</span><br><span class="line">       &#125;<span class="keyword">while</span> (ans == f1());</span><br><span class="line">       <span class="comment">//f1调用两次，当第一次等于第二次时，重新选值。</span></span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="对数器"><a href="#对数器" class="headerlink" title="对数器"></a>对数器</h3><p>对数器：有一个能随机生成符合要求的数组的方法，一个用于复制的方法，一个验证正误的方法；</p><p>在比赛中，一般只会给出一两道简单的例子，不能验证算法是否正确，所以就可以用对数器进行大量例子验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个值和长度都随机的数组</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lenAndValueRandom(<span class="type">int</span> maxLen, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() + maxLen);  <span class="comment">//长度随机，范围在[0, maxLen-1]</span></span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           ans[i] = (<span class="type">int</span>) (Math.random() * maxValue);  <span class="comment">//值随机，范围在[0,maxValue-1]</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//复制一份，用于出错后比较</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] copy(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">       <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">           ans[i] = arr[i];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> ans;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//判断使用了算法的数组是否达到预期要求</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">       <span class="comment">//具体内容根据题目要求而定</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//写出来的算法，需要验证</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">algorithm1</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">       <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">10000</span>; <span class="comment">//测试次数</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">           <span class="type">int</span>[] arr1 = lenAndValueRandom(maxLen, maxValue);</span><br><span class="line">           <span class="type">int</span>[] arr2 = copy(arr1);</span><br><span class="line">           <span class="comment">//当算法不符合要求时，根据情况进行打印，可以方便分析</span></span><br><span class="line">           <span class="keyword">if</span> (!judge(arr1))&#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;算法出错了&quot;</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> k : arr2) &#123;</span><br><span class="line">                   System.out.print(k + <span class="string">&quot; &quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">for</span> (<span class="type">int</span> k : arr1) &#123;</span><br><span class="line">                   System.out.print(k + <span class="string">&quot; &quot;</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="动态数组"><a href="#动态数组" class="headerlink" title="动态数组"></a>动态数组</h2><p>动态数组每次容量不够时，ArrayList会扩容至1.5倍，而Vector容量会扩至2倍，并将旧数据拷贝进去；不管是ArrayList还是Vector，多次扩容的时间代价是一个等比数列，所以扩容的时间复杂度是O(N)，当每一步扩容均摊到算法计算过程中，可以当作常数操作，所以使用动态数组不影响时间复杂度。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/Notes/2022/06/05/%E9%97%AE%E9%A2%981/"/>
      <url>/Notes/2022/06/05/%E9%97%AE%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<ol><li><p>get请求的参数中带有英文点号，导致的请求错误：</p><p>在Spring MVC框架中，会将地址中的最后一个点号截断为后缀名，从而判断其请求消费的内容类型，在不改变此策略的情况下，修改请求方式与地址也能达到正确处理的目标。</p><p>如果请求的url中带有含有 英文点号 的参数，如地址、邮箱等，可以在请求方式中最后再加一个点号，或者修改后端的MVC框架策略，或者将 @PathVariable改为@RequestParam</p></li><li><p>vue中设置 &lt;form @submit.prevent&gt; ，取消表单提交后的默认跳转</p></li><li></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>英语学习</title>
      <link href="/Notes/2022/05/16/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/"/>
      <url>/Notes/2022/05/16/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="六级便携版（1500词汇）"><a href="#六级便携版（1500词汇）" class="headerlink" title="六级便携版（1500词汇）"></a>六级便携版（1500词汇）</h3><ol><li><p>assume </p><blockquote><p>vt. 假定，承担，呈现</p><p>vi. 多管闲事</p></blockquote></li><li><p>facility</p><blockquote><p>n. 设备，灵巧</p></blockquote></li><li><p>perspective</p><blockquote><p>n. 观点，想法； </p><p>​远景，前途；</p><p>​希望，透视图；</p></blockquote></li><li><p>monopoly</p><blockquote><p>n. 垄断；垄断者；专卖权</p></blockquote></li><li><p>sheer</p><blockquote><p>adj. 完全的；陡峭的； 轻的，透明的</p><p>adv. 垂直地，陡峭地；</p><p>vi. 避开</p></blockquote></li><li><p>convention</p><blockquote><p>n. 大会； 协定； 惯例；公约</p></blockquote></li><li><p>ascribe</p><blockquote><p>vt. 归因于，归咎于</p></blockquote></li><li><p>despise</p><blockquote><p>vt. 轻视，鄙视</p></blockquote></li><li><p>loom</p><blockquote><p>n. 织布机； 若隐若现的景象；</p><p>vi. 隐约出现，隐约可见</p></blockquote></li><li><p>assimilate</p><blockquote><p>vi&amp;vt. 吸收，消化，同化</p></blockquote></li><li><p>paradox</p><blockquote><p>n. 悖论</p></blockquote></li><li><p>imitate</p><blockquote><p>vt. 模仿</p></blockquote></li><li><p>demonstrate</p><blockquote><p>vt. 证明，演示；</p><p>vi. 示威；</p></blockquote></li><li><p>setback</p><blockquote><p>n. 挫折； </p><p>​    退步；</p></blockquote></li><li><p>fabricate</p><blockquote><p>vt. 编造，虚构；</p></blockquote></li><li><p>strain</p><blockquote><p>n. 张力；拉紧；</p><p>​    血缘；</p><p>​    负担；</p><p>​    扭伤；</p><p>vi. 拉紧； 尽力；</p></blockquote></li><li><p>luxury</p><blockquote><p>n. 奢侈； 奢侈品</p><p>adj. 奢侈的</p></blockquote></li><li><p>candidate</p><blockquote><p>n. 候选人，报考者</p></blockquote></li><li><p>constant</p><blockquote><p>adj. 不变的，恒定的；</p><p>​       经常的；</p><p>n. 常数；恒量</p></blockquote></li><li><p>arrogant</p><blockquote><p>adj. 自大的，傲慢的；</p></blockquote></li><li><p>harmony</p><blockquote><p>n. 协调，融洽，和睦；</p></blockquote></li><li><p>dignity</p><blockquote><p>n. 尊严，高贵</p></blockquote></li><li><p>casual</p><blockquote><p>adj. 随意的； 偶然的；</p><p>​       临时的，非正式的；</p><p>n. 临时工人；便装；待命士兵；</p></blockquote></li><li><p>casualty</p><blockquote><p>n. 伤亡人员，受害者；损毁物；</p><p>​     急诊室；</p></blockquote></li><li><p>premier</p><blockquote><p>adj. 最初的，第一的；</p><p>n. 总理，首相；</p></blockquote></li><li><p>recipe</p><blockquote><p>n. 食谱；处方[医]；秘诀；</p></blockquote></li><li><p>authorize</p><blockquote><p>vt. 授权，批准；委托</p></blockquote></li><li><p>lure</p><blockquote><p>n. 诱惑物，诱惑；</p><p>vt. 诱惑；</p></blockquote></li><li><p>emergency</p><blockquote><p>n.紧急情况，非常时刻</p></blockquote></li><li><p>proceed</p><blockquote><p>vi. 开始，继续进行；</p><p>​      发生，进行；</p></blockquote></li><li><p>conspicuous</p><blockquote><p>adj. 显眼的；醒目的；</p></blockquote></li><li><p>propel</p><blockquote><p>vt. 推进；驱动，驱策；</p><p>​      激励；</p></blockquote></li><li><p>controversy</p><blockquote><p>n. 争论，辩论</p></blockquote></li><li><p>privilege</p><blockquote><p>n. 荣幸；特权；</p><p>vt. 给予特权；</p></blockquote></li><li><p>substitute</p></li></ol><pre><code>&gt; vi.&amp;vt. 替代</code></pre><ol start="36"><li>spoil</li></ol><pre><code>&gt;  vt. 溺爱；糟蹋；掠夺；&gt;&gt; vi. 变坏；掠夺；腐败；</code></pre><ol start="37"><li>accommodate</li></ol><pre><code>&gt;  vt. 容纳； 向..提供住处；&gt;&gt; ​       使适应；</code></pre><ol start="38"><li>artery</li></ol><pre><code>&gt;  n. 动脉；&gt;&gt; ​      主干道，主流；</code></pre><ol start="39"><li>spouse</li></ol><pre><code>&gt;  n. 配偶&gt;&gt; vt. 和...结婚</code></pre><ol start="40"><li>feeble</li></ol><pre><code>&gt;  adj. 微弱的；虚弱的；</code></pre><ol start="41"><li><p>nourish</p><blockquote><p> vt. 滋养，喂养</p></blockquote></li><li><p>foremost</p><blockquote><p> adj. 最先的，最重要的</p><p> adv. 首先，居于首位的</p></blockquote></li><li><p>ponder</p><blockquote><p> vt. 仔细考虑；衡量</p><p> vi. 沉思；考虑</p></blockquote></li><li><p>marsh</p><blockquote><p> n. 湿地；沼泽</p><p> adj. 沼泽的；生长在沼泽地的</p></blockquote></li><li><p>patron</p></li></ol><pre><code>&gt; n. 赞助人；主顾</code></pre><ol start="46"><li>desirable</li></ol><pre><code>&gt;  adj. 令人满意的； 有吸引力的；</code></pre><ol start="47"><li><p>dispatch</p><blockquote><p> n. 派遣；急件</p><p> vt. 派遣；[计算机]分派</p></blockquote></li><li><p>aspiration</p></li></ol><pre><code>&gt;  *n.* 强烈的愿望, 志向, 抱负</code></pre><ol start="49"><li><p>convict</p><blockquote><p> <em>vt.</em> 宣判有罪</p><p> <em>n.</em> 囚犯</p></blockquote></li><li><p>stack</p><blockquote><p> n. 堆；堆叠</p><p> vt. 使堆叠；把…堆积起来</p><p> vi. 堆积，堆叠</p></blockquote></li><li><p>attribute</p><blockquote><p><em>vt.</em> 认为…是；归因于…</p><p>​ 认为某事[物]属于某人[物]</p><p><em>n.</em> 属性，特性</p></blockquote></li><li><p>invert</p><blockquote><p>vt. 使…转化；使…颠倒</p><p>n. 倒置物；倒悬者</p><p>adj. 转化的</p></blockquote></li><li><p>preclude</p><blockquote><p>vt. 妨碍， 阻止</p></blockquote></li><li><p>radical</p><blockquote><p>adj. 根本的；彻底的</p><p>​激进的，激进派的</p></blockquote></li><li><p>preliminary</p><blockquote><p><em>adj.</em> 初步的, 预备的, 开端的</p><p><em>n.</em> 准备工作, 初步行动</p></blockquote></li><li><p>subconscious</p><blockquote><p>adj. 下意识的</p></blockquote></li><li><p>strategy</p><blockquote><p>n. 战略，策略；</p></blockquote></li><li><p>maneuver</p><blockquote><p>n. 策略；演习；调遣；机动</p><p>vi. 调遣；演习；用计谋；机动</p><p>vt. 演习；调遣；用计；机动</p></blockquote></li><li><p>apparatus</p><blockquote><p><em>n.</em> 运动器械, 器具, 仪器</p><p>​机构, 组织</p><p>​器官</p></blockquote></li><li><p>grope</p><blockquote><p>vi. 探索</p></blockquote></li><li><p>encounter</p><blockquote><p>vt. 遭遇，邂逅</p><p>n. 突然遇到</p></blockquote></li><li><p>ascend</p><blockquote><p>vi. 上升；登高；追溯</p><p>vt. 攀登，上升</p></blockquote></li><li><p>ascertain</p><blockquote><p><em>vt.</em> 弄清, 确定, 查明</p></blockquote></li><li><p>elaborate</p><blockquote><p><em>vi.</em> 详尽说明</p><p><em>vt.</em> 详细制定</p><p><em>adj.</em> 复杂的；精心制作的</p></blockquote></li><li><p>suspend</p><blockquote><p>v. 延迟； 使悬浮，竞赛</p></blockquote></li><li></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java—SpringBoot&amp;MybatisPlus</title>
      <link href="/Notes/2022/05/13/Java%E2%80%94SpringBoot-MybatisPlus/"/>
      <url>/Notes/2022/05/13/Java%E2%80%94SpringBoot-MybatisPlus/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot2"><a href="#SpringBoot2" class="headerlink" title="SpringBoot2"></a>SpringBoot2</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>SpringBoot 对 spring 的简化，也是其核心功能和优点：</p><ul><li>起步依赖</li><li>自动配置</li><li>辅助功能（内置服务器….）</li></ul><p>具体体现在：</p><ul><li>parent</li><li>starter</li><li>引导类</li><li>内嵌tomcat</li></ul><h3 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h3><p>由于依赖的版本之间有一定的固定搭配，所以 SpringBoot 制作了多个技术版本搭配的列表，就叫做 parent。所以 ，使用parent可以帮助开发者进行版本的统一管理。</p><p>在pom.xml中继承了一个坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><p>打开后，可以看到主要有两组信息：</p><ul><li><p>第一组是 各式各样的依赖版本号属性;</p></li><li><p>第二组是 各式各样的的依赖坐标信息，其中依赖坐标定义是应用了第一组信息中定义的依赖版本属性值； 且是在<dependencyManagement> 标签中，所以这些定义的依赖还未导入，SpringBoot会在starter中导入一些固定的依赖组合。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 第一组信息 版本属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.16.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.9.7<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    .....</span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 第二组信息 依赖坐标 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h3><p>依赖坐标的使用往往有一些固定的组合方式，SpringBoot 定义了starter： starter是指使用某种技术时 依赖的固定搭配格式，也是一种最佳解决方案。 使用starter可以帮助开发者减少依赖配置。</p><p>​所以，实际开发中如果需要用什么技术，先去找有没有这个技术对应的starter：</p><ul><li>如果有对应的starter，直接写starter，而且无需指定版本，版本由parent提供；</li><li>如果没有对应的starter，再手写坐标；</li></ul><blockquote><p>SpringBoot 对于 starter 的名称都是如下格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">命名规则：spring-boot-starter-技术名称</span><br></pre></td></tr></table></figure><p>所有的starter中都会依赖一个starter，叫做spring-boot-starter，它是所有的SpringBoot的starter的基础依赖，里面定义了SpringBoot相关的基础配置。</p></blockquote><p>小结：</p><ol><li>开发SpringBoot程序需要导入坐标时通常导入对应的starter</li><li>每个不同的starter根据功能不同，通常包含多个依赖坐标</li><li>使用starter可以实现快速配置的效果，达到简化配置的目的</li></ol><h3 id="引导类"><a href="#引导类" class="headerlink" title="引导类"></a>引导类</h3><p>程序运行的入口是 SpringBoot工程创建时自带的有main方法的那个类，运行这个类就可以启动SpringBoot工程的运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">xxxApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(xxxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring程序运行的基础是需要创建自己的Spring容器对象（IoC容器）并将所有的对象交给Spring的容器管理，也就是一个一个的Bean。而SpringBoot本身是为了加速Spring程序的开发的，所以创建了这个 引导类，它是所有功能的入口。</p><h3 id="内嵌tomcat"><a href="#内嵌tomcat" class="headerlink" title="内嵌tomcat"></a>内嵌tomcat</h3><p>在导入的依赖中：</p><ul><li>spring-boot-starter-web<ul><li>spring-boot-starter-tomcat<ul><li>tomcat-embed-core（tomcat内嵌核心）</li></ul></li></ul></li></ul><p>就是 tomcat-embed-core 把tomcat功能引入到程序中。</p><p><strong>内嵌Tomcat运行原理</strong>：Tomcat服务器是一款使用java语言开发的软件，那么tomcat的运行肯定也是以对象的形式运行的，即tomcat可以交给Spring容器管理。</p><blockquote><p>更换内嵌的tomcat：</p><ul><li>tomcat(默认)：apache出品，粉丝多，应用面广，负载了若干较重的组件</li><li>jetty：更轻量级，负载性能远不及tomcat</li><li>undertow：负载性能勉强跑赢tomcat</li></ul><p>只有加入对应的依赖坐标，并排除tomcat坐标即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>SpringBoot将配置信息集中在一个文件 application.properties 中写，不管是服务器的配置，还是数据库的配置，都是写在一起的。</p><blockquote><p>配置的书写有格式和规范，具体的可以参考官方文档（的附录Application Properties）：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#application-properties</a></p><p>导入的spring-boot-starter-web依赖提供了 配置书写 的提示。</p></blockquote><p>支持的配置文件格式：（一般使用 yml格式）</p><ul><li>properties格式</li><li>yml格式</li><li>yaml格式</li></ul><blockquote><p>yaml只是后缀名和yml不一样，其实是同一种格式，虽然 .yaml 才是YAML官方认定的文件拓展名，但实际上，未认定的 .yml 用的人用多得多。</p></blockquote><p>如果三个文件共存的话，不同的配置都会生效，而相同、冲突的配置类型的 优先级从高到低：.properties  &gt;  .yml  &gt;  .yaml</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>YAML（YAML Ain’t Markup Language），一种数据序列化格式。</p><ul><li><p>具有容易阅读、容易与脚本语言交互、以数据为核心，重数据轻格式的特点。</p></li><li><p>具有严格的语法格式要求：</p><ol><li>大小写敏感</li><li>属性层级关系使用多行描述，<strong>每行结尾使用冒号”:” 结束</strong></li><li>使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）</li><li>属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）</li><li>#号 表示注释</li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常见的数据书写格式</span></span><br><span class="line"></span><br><span class="line"><span class="attr">boolean:</span> <span class="literal">TRUE</span>  <span class="comment">#TRUE,true,True,FALSE,false，False均可</span></span><br><span class="line"><span class="attr">float:</span> <span class="number">3.14</span>    <span class="comment">#6.8523015e+5  #支持科学计数法</span></span><br><span class="line"><span class="attr">int:</span> <span class="number">123</span>       <span class="comment">#0b1010_0111_0100_1010_1110    #支持二进制、八进制、十六进制</span></span><br><span class="line"><span class="attr">null:</span> <span class="string">~</span>        <span class="comment">#使用~表示null</span></span><br><span class="line"><span class="attr">string:</span> <span class="string">HelloWorld</span>      <span class="comment">#字符串可以直接书写</span></span><br><span class="line"><span class="attr">string2:</span> <span class="string">&quot;Hello World&quot;</span>  <span class="comment">#可以使用双引号包裹特殊字符</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2018-02-17</span>        <span class="comment">#日期必须使用yyyy-MM-dd格式</span></span><br><span class="line"><span class="attr">datetime:</span> <span class="number">2018-02-17T15:02:31+08:00</span>  <span class="comment">#时间和日期之间使用T连接，最后使用+代表时区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此外，还可以表示数组，用减号作为数据开始符号</span></span><br><span class="line"><span class="attr">subject:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">enterprise:</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">itcast</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">16</span></span><br><span class="line">    <span class="attr">subject:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">Java</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">前端</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">大数据</span></span><br><span class="line"><span class="attr">likes:</span> [<span class="string">java</span>,<span class="string">前端，大数据</span>]<span class="comment">#数组书写缩略格式</span></span><br><span class="line"><span class="comment">#对象数组格式一</span></span><br><span class="line"><span class="attr">users:</span> </span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">   <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span></span><br><span class="line"><span class="comment">#对象数组格式二</span></span><br><span class="line"><span class="attr">users:</span> </span><br><span class="line">  <span class="bullet">-</span>  </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Tom</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span>   </span><br><span class="line">    <span class="attr">name:</span> <span class="string">Jerry</span></span><br><span class="line">    <span class="attr">age:</span> <span class="number">5</span>    </span><br><span class="line"><span class="attr">users2:</span> [ &#123; <span class="string">name:Tom</span> , <span class="string">age:4</span> &#125; , &#123; <span class="string">name:Jerry</span> , <span class="string">age:5</span> &#125; ]<span class="comment">#对象数组缩略格式</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p><strong>读取单个数据：</strong></p><p>yaml中保存的单个数据，可以使用Spring中的注解直接读取，使用**@Value** 可以读取单个数据，属性名引用方式：<font color="#ff0000"><b>${一级属性名.二级属性名……}</b></font></p><p><strong>读取全部数据：</strong></p><p>SpringBoot提供了一个对象叫 Environment，使用自动装配注解可以将所有的yaml数据封装到这个对象中，然后使用 具体方法getProperties（String），参数填写属性名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Environment env;</span><br><span class="line"></span><br><span class="line">env.getProperty(<span class="string">&quot;xxx&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>读取对象数据：</strong></p><p>由于单一数据读取太麻烦，Environment又封装的太厉害。所以一般都是将一组数据封装成一个对象。</p><p>步骤：</p><ol><li>定义一个对象，并将该对象纳入Spring管控的范围，也就是定义成一个bean；</li><li>然后使用注解@ConfigurationProperties指定该对象加载哪一组yaml中配置的信息。（需要告知加载的数据前缀）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;book&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">book:</span></span><br><span class="line">  <span class="attr">id:</span> <span class="number">12</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">abcd</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zzc</span></span><br><span class="line">  <span class="attr">description:</span> <span class="string">hhhhh</span></span><br></pre></td></tr></table></figure><p><strong>数据的引用：</strong></p><p>对于重复出现的数据，可以使用 ${} 进行引用：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">center:</span></span><br><span class="line"><span class="attr">dataDir:</span> <span class="string">D:/usr/local/fire/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">D:/usr/local/fire/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">D:/usr/local/fire/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">D:/usr/local/fire/msgDir</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用引用减少重复书写</span></span><br><span class="line"><span class="attr">baseDir:</span> <span class="string">D:/usr/local/fire</span></span><br><span class="line"><span class="attr">center:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">$&#123;baseDir&#125;/data</span></span><br><span class="line">    <span class="attr">tmpDir:</span> <span class="string">$&#123;baseDir&#125;/tmp</span></span><br><span class="line">    <span class="attr">logDir:</span> <span class="string">$&#123;baseDir&#125;/log</span></span><br><span class="line">    <span class="attr">msgDir:</span> <span class="string">$&#123;baseDir&#125;/msgDir</span></span><br></pre></td></tr></table></figure><blockquote><p>注：如果需要解析转义字符，需要用双引号包裹起来作为字符 才能解析。</p></blockquote><h2 id="SpringBoot整合"><a href="#SpringBoot整合" class="headerlink" title="SpringBoot整合"></a>SpringBoot整合</h2><p>SpringBoot整合其他技术，都是先导入对应的starter或坐标，再去使用对应技术。</p><h3 id="整合JUnit"><a href="#整合JUnit" class="headerlink" title="整合JUnit"></a>整合JUnit</h3><p>JUnit的依赖默认导入了。</p><p>使用注解@SpringBootTest替换了原来的两个注解。如果要手动加载引导类，就写上属性 classes &#x3D; 引导类.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tests</span> &#123;</span><br><span class="line">    <span class="comment">//注入你要测试的对象</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//执行要测试的对象对应的方法</span></span><br><span class="line">        bookDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p>原来的Spring整合Mybatis的步骤需要有：</p><ul><li>导入坐标</li><li>Spring核心配置：SpringConfig</li><li>MyBatis要交给Spring接管的bean：MyBatisConfig</li><li>数据源对应的bean</li><li>数据库连接信息：jdbc.properties</li></ul><p>而使用 SpringBoot 整合 Mybatis，只需要：</p><ul><li><p>创建模块时勾选对应技术：Mybatis和Mysql</p><p>或者手工导入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">dependencies&gt;</span><br><span class="line">    <span class="comment">&lt;!--1.导入对应的starter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">zzc</span></span><br></pre></td></tr></table></figure></li></ul><p>到此，就配置完毕了。之后只需书写 实体类和映射接口(Dao)即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//映射接口</span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Springboot05MybatisApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">contextLoads</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(bookDao.getById(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整合MybatisPlus"><a href="#整合MybatisPlus" class="headerlink" title="整合MybatisPlus"></a>整合MybatisPlus</h3><ul><li><p>导入对应的starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>第三方提供的starter，命名为：**-spring-boot-starter 或者  **-boot-starter</p></blockquote></li><li><p>配置数据源信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#2.配置相关信息</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></li></ul><p>同样两步配置完毕，之后写MybatisPlus的程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射接口 </span></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><h3 id="整合Druid"><a href="#整合Druid" class="headerlink" title="整合Druid"></a>整合Druid</h3><ul><li><p>导入对应坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>修改数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br></pre></td></tr></table></figure><p>在数据源配置中的type属性，用于指定数据源类型（默认指定的数据源时HiKari）</p><blockquote><p>如果数据源需要进行个性化的配置，就需要导入对应数据源的starter，如导入Druid的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">druid:</span></span><br><span class="line">      <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">      <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC</span></span><br><span class="line">      <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">password:</span> <span class="string">root</span></span><br></pre></td></tr></table></figure></blockquote></li></ul><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>国人开发的Mybatis的便捷版。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ol><li><p>导入相关的starter：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置数据源：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/mybatisplus_db?serverTimezone=UTC</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">zzc</span></span><br></pre></td></tr></table></figure></li><li><p>创建数据层的 Dao&#x2F;Mapper 接口</p><p>接口继承BaseMapper接口 —— BaseMapper接口中提供了许多常用方法，我们只需要从容器中获取Mapper就可以了，不用自己去编写sql语句。</p><blockquote><p>扫描：可以直接在接口上加@Mapper，或者在启动类上设置扫描@MapperScan(“xxx”)</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> <span class="keyword">extends</span> <span class="title class_">BaseMapper</span>&lt;Book&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h3 id="常用设置"><a href="#常用设置" class="headerlink" title="常用设置"></a>常用设置</h3><h4 id="表的映射规则"><a href="#表的映射规则" class="headerlink" title="表的映射规则"></a>表的映射规则</h4><p>默认情况下，MP操作的表名就是实体类的类名，但如果表名与类名不一致就需要设置映射规则。</p><p><strong>单独设置：</strong> 在实体类上加上 @TableName</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableName(&quot;tbl_book&quot;)</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局设置：</strong> 一般一个项目的表名的前缀有统一风格，可以通过 .yml 配置文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">table-prefix:</span> <span class="string">tbl_</span><span class="comment">#设置表名通用前缀</span></span><br></pre></td></tr></table></figure><h4 id="主键生成策略"><a href="#主键生成策略" class="headerlink" title="主键生成策略"></a>主键生成策略</h4><p>默认情况下，使用MP插入数据时，主键生成策略是基于雪花算法的自增id。</p><p>如果需要使用别的策略，可以：</p><p><strong>单独设置：</strong> 在代表主键的字段上加上 @TableId，使用其type属性指定主键生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="comment">//设置主键自增长</span></span><br><span class="line">    <span class="meta">@TableId(type = IdType.AUTO)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>全局设置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">id-type:</span> <span class="string">auto</span><span class="comment">#设置主键id字段的生成策略 为参照数据库设定的策略，默认是使用 基于雪花算法的自增id</span></span><br></pre></td></tr></table></figure><h4 id="字段映射"><a href="#字段映射" class="headerlink" title="字段映射"></a>字段映射</h4><p>默认MP会根据实体类的属性名去映射表的列名。</p><p>如果列名和实体类的属性不一致，可以用 @TableField 设置映射关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TableField(&quot;address&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String addressStr;</span><br></pre></td></tr></table></figure><h4 id="驼峰映射"><a href="#驼峰映射" class="headerlink" title="驼峰映射"></a>驼峰映射</h4><p>默认情况下MP会开启字段名列名的驼峰映射，即将驼峰命名的属性翻译成下划线命名，如：userName会翻译成 user_name</p><h4 id="sql执行日志"><a href="#sql执行日志" class="headerlink" title="sql执行日志"></a>sql执行日志</h4><p>配置sql日志输出，即打印对应的sql执行语句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="comment"># 日志</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ul><li>insert()  —— 插入数据</li><li>delete() —— 删除数据</li><li>update() —— 更新数据</li></ul><h3 id="条件构造器Wrapper"><a href="#条件构造器Wrapper" class="headerlink" title="条件构造器Wrapper"></a>条件构造器Wrapper</h3><p>wrapper是一个接口，用于更方便的构造条件。</p><p>继承体系：</p><ul><li>wrapper<ul><li>AbstractWrapper<ul><li>QueryWrapper</li><li>UpdateWrapper</li></ul></li></ul></li></ul><blockquote><p><code>AbstractWrapper</code>提供了许多构造where条件的方法；</p><p><code>QueryWrapper</code>额外提供了针对Select语法的<code>select</code>方法；</p><p><code>UpdateWrapper</code>额外提供了用于针对set语法的<code>set</code>方法；</p></blockquote><h4 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h4><p>完整的AbstractWrapper方法参照官方文档：<a href="https://baomidou.com/pages/10c804/#abstractwrapper">条件构造器 | MyBatis-Plus (baomidou.com)</a></p><blockquote><p>常用AbstractWrapper方法：</p><p>eq：equals，等于</p><p>gt：greater than ，大于 &gt;</p><p>ge：greater than or equals，大于等于≥</p><p>lt：less than，小于&lt;</p><p>le：less than or equals，小于等于≤</p><p>between：相当于SQL中的BETWEEN</p><p>like：模糊匹配。like(“name”,”黄”)，相当于SQL的name like ‘%黄%’</p><p>likeRight：模糊匹配右半边。likeRight(“name”,”黄”)，相当于SQL的name like ‘黄%’</p><p>likeLeft：模糊匹配左半边。likeLeft(“name”,”黄”)，相当于SQL的name like ‘%黄’</p><p>notLike：notLike(“name”,”黄”)，相当于SQL的name not like ‘%黄%’</p><p>isNull</p><p>isNotNull</p><p>and：SQL连接符AND</p><p>or：SQL连接符OR</p><p>in: in(“age”,{1,2,3})相当于 age in(1,2,3)</p><p>groupBy: groupBy(“id”,”name”)相当于 group by id,name</p><p>orderByAsc :orderByAsc(“id”,”name”)相当于 order by id ASC,name ASC</p><p>orderByDesc :orderByDesc (“id”,”name”)相当于 order by id DESC,name DESC</p></blockquote><p>例1：</p><p>SQL语句如下： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">USER </span><br><span class="line">WHERE </span><br><span class="line">age &gt; 18 AND address = &#x27;狐山&#x27;</span><br></pre></td></tr></table></figure><p>用Wrapper写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWrapper01</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">QueryWrapper</span> <span class="variable">wrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line">    wrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>);</span><br><span class="line">    wrapper.eq(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;狐山&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2：</p><p>SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">USER </span><br><span class="line">WHERE </span><br><span class="line">id IN(1,2,3) AND </span><br><span class="line">age BETWEEN 12 AND 29 AND </span><br><span class="line">address LIKE &#x27;%山%&#x27;</span><br></pre></td></tr></table></figure><p>用Wrapper写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWrapper02</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; wrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    wrapper.in(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    wrapper.between(<span class="string">&quot;age&quot;</span>,<span class="number">12</span>,<span class="number">29</span>);</span><br><span class="line">    wrapper.like(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;山&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(wrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例3：</p><p>SQL语句如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">id,user_name,PASSWORD,NAME,age,address </span><br><span class="line">FROM </span><br><span class="line">USER </span><br><span class="line">WHERE </span><br><span class="line">id IN(1,2,3) AND </span><br><span class="line">age &gt; 10 </span><br><span class="line">ORDER BY </span><br><span class="line">age DESC</span><br></pre></td></tr></table></figure><p>用Wrapper写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testWrapper03</span><span class="params">()</span>&#123;</span><br><span class="line">    QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.in(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">    queryWrapper.gt(<span class="string">&quot;age&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    queryWrapper.orderByDesc(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br><span class="line">    System.out.println(users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="QueryWrapper"><a href="#QueryWrapper" class="headerlink" title="QueryWrapper"></a>QueryWrapper</h4><p>QueryWrapper的 select() 可以设置 要&#x2F;不要查询的列名：</p><ul><li><p>select（String s…. ）—— 形参为要查询的列名</p></li><li><p>select(Class&lt;T&gt; entityClass, Predicate&lt;TableFieldInfo&gt; predicate)  —— 第一个参数为实体类的class字节码对象，第二个参数是Predicate类型，用于过滤要查询的字段（主键除外）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql语句: SELECT id,user_name FROM USER    查address，而id作为主键默认会查</span></span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;();</span><br><span class="line">    queryWrapper.select(User.class, <span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;TableFieldInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(TableFieldInfo tableFieldInfo)</span> &#123;</span><br><span class="line">            <span class="comment">//返回true为要查询，false为不查询</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;user_name&quot;</span>.equals(tableFieldInfo.getColumn());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure></li><li><p>select(Predicate&lt;TableFieldInfo&gt; predicate)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sql语句: SELECT id,user_name,PASSWORD,NAME,age FROM USER 即不查address字段，其他都查</span></span><br><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">User</span>());</span><br><span class="line">    queryWrapper.select(<span class="keyword">new</span> <span class="title class_">Predicate</span>&lt;TableFieldInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(TableFieldInfo tableFieldInfo)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> !<span class="string">&quot;address&quot;</span>.equals(tableFieldInfo.getColumn());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    List&lt;User&gt; users = userMapper.selectList(queryWrapper);</span><br></pre></td></tr></table></figure></li></ul><h4 id="UpdateWrapper"><a href="#UpdateWrapper" class="headerlink" title="UpdateWrapper"></a>UpdateWrapper</h4><p>UpdateWrapper的set方法来设置要更新的列及其值，不用传入一个类，同时这种方式也可以使用Wrapper去指定更复杂的更新条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UPDATE USER </span></span><br><span class="line"><span class="comment">//    SET age = 99 </span></span><br><span class="line"><span class="comment">//    where id &gt; 1</span></span><br><span class="line">UpdateWrapper&lt;User&gt; updateWrapper = <span class="keyword">new</span> <span class="title class_">UpdateWrapper</span>&lt;&gt;();</span><br><span class="line">    updateWrapper.gt(<span class="string">&quot;id&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    updateWrapper.set(<span class="string">&quot;age&quot;</span>,<span class="number">99</span>);</span><br><span class="line">    userMapper.update(<span class="literal">null</span>,updateWrapper);</span><br></pre></td></tr></table></figure><h4 id="Lambda条件构造器"><a href="#Lambda条件构造器" class="headerlink" title="Lambda条件构造器"></a>Lambda条件构造器</h4><p>MP提供了一个Lambda条件构造器可以让我们直接以实体类的方法引用的形式来指定列名。这样就可以避免在条件构造中 写错列名 了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QueryWrapper&lt;User&gt; queryWrapper = <span class="keyword">new</span> <span class="title class_">QueryWrapper</span>();</span><br><span class="line"><span class="comment">//queryWrapper.gt(&quot;age&quot;,18);</span></span><br><span class="line"><span class="comment">//queryWrapper.eq(&quot;address&quot;,&quot;狐山&quot;);</span></span><br><span class="line">queryWrapper.gt(User::getAge,<span class="number">18</span>);</span><br><span class="line">queryWrapper.eq(User::getAddress,<span class="string">&quot;狐山&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="自定义SQL"><a href="#自定义SQL" class="headerlink" title="自定义SQL"></a>自定义SQL</h3><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><ol><li>配置分页查询拦截器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.4.0之前的版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">/* @Bean</span></span><br><span class="line"><span class="comment">    public PaginationInterceptor paginationInterceptor()&#123;</span></span><br><span class="line"><span class="comment">        return  new PaginationInterceptor();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3.4.0之后版本</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="meta">@Bean</span></span><br><span class="line">   <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">       <span class="type">MybatisPlusInterceptor</span> <span class="variable">mybatisPlusInterceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">       mybatisPlusInterceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">       <span class="keyword">return</span> mybatisPlusInterceptor;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>接口：IPage， 实现类：Page</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分页功能</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetPage</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">IPage</span> <span class="variable">page</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Page</span>(<span class="number">2</span>,<span class="number">5</span>);<span class="comment">//第2页，每页5条</span></span><br><span class="line">    bookDao.selectPage(page, <span class="literal">null</span>);<span class="comment">//第二个参数为wrapper</span></span><br><span class="line">    page.getCurrent();<span class="comment">//当前页码值</span></span><br><span class="line">    page.getSize();<span class="comment">//每页显示数</span></span><br><span class="line">    page.getTotal();<span class="comment">//数据总量</span></span><br><span class="line">    page.getPages();<span class="comment">//总页数</span></span><br><span class="line">    page.getRecords();<span class="comment">//详细数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="代码生成器"><a href="#代码生成器" class="headerlink" title="代码生成器"></a>代码生成器</h3><p>MP提供了一个代码生成器，可以让我们一键生成实体类，Mapper接口，Service，Controller等全套代码 。使用方式如下</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatisplus代码生成器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.baomidou<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--模板引擎--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.freemarker<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>生成</li></ol><p>​修改相应配置后执行以下代码即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.DataSourceConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.GlobalConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.PackageConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.StrategyConfig;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;</span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratorTest</span> &#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generate</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">AutoGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AutoGenerator</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="type">GlobalConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GlobalConfig</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">projectPath</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>);</span><br><span class="line"><span class="comment">// 设置输出到的目录</span></span><br><span class="line">config.setOutputDir(projectPath + <span class="string">&quot;/src/main/java&quot;</span>);</span><br><span class="line">config.setAuthor(<span class="string">&quot;sangeng&quot;</span>);</span><br><span class="line"><span class="comment">// 生成结束后是否打开文件夹</span></span><br><span class="line">config.setOpen(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局配置添加到 generator 上</span></span><br><span class="line">generator.setGlobalConfig(config);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置</span></span><br><span class="line"><span class="type">DataSourceConfig</span> <span class="variable">dataSourceConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceConfig</span>();</span><br><span class="line">dataSourceConfig.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/test?characterEncoding=utf-8&amp;serverTimezone=UTC&quot;</span>);</span><br><span class="line">dataSourceConfig.setDriverName(<span class="string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);</span><br><span class="line">dataSourceConfig.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">dataSourceConfig.setPassword(<span class="string">&quot;zzc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据源配置添加到 generator</span></span><br><span class="line">generator.setDataSource(dataSourceConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包配置, 生成的代码放在哪个包下</span></span><br><span class="line"><span class="type">PackageConfig</span> <span class="variable">packageConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PackageConfig</span>();</span><br><span class="line">packageConfig.setParent(<span class="string">&quot;com.zzc.MPgenerator&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包配置添加到 generator</span></span><br><span class="line">generator.setPackageInfo(packageConfig);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略配置</span></span><br><span class="line"><span class="type">StrategyConfig</span> <span class="variable">strategyConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StrategyConfig</span>();</span><br><span class="line"><span class="comment">// 下划线驼峰命名转换</span></span><br><span class="line">strategyConfig.setNaming(NamingStrategy.underline_to_camel);</span><br><span class="line">strategyConfig.setColumnNaming(NamingStrategy.underline_to_camel);</span><br><span class="line"><span class="comment">// 开启lombok</span></span><br><span class="line">strategyConfig.setEntityLombokModel(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 开启RestController</span></span><br><span class="line">strategyConfig.setRestControllerStyle(<span class="literal">true</span>);</span><br><span class="line">generator.setStrategy(strategyConfig);</span><br><span class="line">generator.setTemplateEngine(<span class="keyword">new</span> <span class="title class_">FreemarkerTemplateEngine</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始生成</span></span><br><span class="line">generator.execute();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动填充"><a href="#自动填充" class="headerlink" title="自动填充"></a>自动填充</h3><p>在进行插入或更新操作时，对字段自动填充。</p><p>使用：</p><ol><li><p>在需要填充的字段上添加注解 TableField， 其属性 fill 来设定什么时候进行自动填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime updateTime;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@TableField(fill = FieldFill.INSERT)</span></span><br><span class="line"><span class="keyword">private</span> LocalDateTime createTime;</span><br></pre></td></tr></table></figure></li><li><p>继承自定义填充器MetaObjectHandler，实现两个方法（插入时填充，更新时填充）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyMetaObjectHandler</span> <span class="keyword">implements</span> <span class="title class_">MetaObjectHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;createTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateFill</span><span class="params">(MetaObject metaObject)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.setFieldValByName(<span class="string">&quot;updateTime&quot;</span>, LocalDateTime.now(), metaObject);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="逻辑删除"><a href="#逻辑删除" class="headerlink" title="逻辑删除"></a>逻辑删除</h3><p>逻辑删除：数据没有被删除，只是不会被展示出来；</p><p>使用：</p><ul><li><p>先在数据库 配置好逻辑删除的实体字段名，并规定表示删除和未删除状态的字段值，如规定 delFlag &#x3D; 1为已删除，delFlag &#x3D; 0 为未删除；</p></li><li><p>再配置yaml文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis-plus:</span></span><br><span class="line">  <span class="attr">global-config:</span></span><br><span class="line">    <span class="attr">db-config:</span></span><br><span class="line">      <span class="attr">logic-delete-field:</span> <span class="string">delFlag</span>  <span class="comment"># 全局逻辑删除的实体字段名(since 3.3.0,配置后可以忽略不配置步骤2)</span></span><br><span class="line">      <span class="attr">logic-delete-value:</span> <span class="number">1</span> <span class="comment"># 逻辑已删除值(默认为 1)</span></span><br><span class="line">      <span class="attr">logic-not-delete-value:</span> <span class="number">0</span> <span class="comment"># 逻辑未删除值(默认为 0)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>并发操作时,我们需要保证对数据的操作不发生冲突。乐观锁就是其中一种方式。</p><blockquote><p>乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。.因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。</p></blockquote><p>使用乐观锁时一般在表中增加一个version列。用来记录我们对每次记录操作的版本。每次对某条记录进行过操作是，对应的版本也需要+1。</p><p>在执行更新时： set version &#x3D; 老版本+1 where version &#x3D; 老版本 </p><p>使用：</p><ol><li><p>添加对应MP拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MPConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MybatisPlusInterceptor <span class="title function_">mybatisPlusInterceptor</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//创建MP拦截器栈</span></span><br><span class="line">        <span class="type">MybatisPlusInterceptor</span> <span class="variable">interceptor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MybatisPlusInterceptor</span>();</span><br><span class="line">        <span class="comment">//分页拦截器</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">PaginationInnerInterceptor</span>());</span><br><span class="line">        <span class="comment">//乐观锁拦截器</span></span><br><span class="line">        interceptor.addInnerInterceptor(<span class="keyword">new</span> <span class="title class_">OptimisticLockerInnerInterceptor</span>());</span><br><span class="line">        <span class="keyword">return</span> interceptor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在实体类的字段上加上<code>@Version</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Version</span></span><br><span class="line"><span class="keyword">private</span> Integer version;</span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> SpringBoot&amp;MybatisPlus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络2.0</title>
      <link href="/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/"/>
      <url>/Notes/2022/05/06/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C2-0/</url>
      
        <content type="html"><![CDATA[<h3 id="缩写简称"><a href="#缩写简称" class="headerlink" title="缩写简称"></a>缩写简称</h3><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p></li><li><p>HTTP —— 超文本传输协议， HyperText Transfer Protocol</p></li><li><p>ARP协议 —— 地址解析协议 （Address Resolution Protocol）</p></li><li><p>MSS  —— TCP最大报文段长度</p></li><li><p>QUIC —— 快速UDP互联网连接（Quick UDP Internet Connection）</p></li><li><p>SSL&#x2F;TLS —— </p><blockquote><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p></blockquote></li><li><p>RTT —— 往返时间 （Round-Trip Time）</p></li></ul><h1 id="TCP-x2F-IP网络模型"><a href="#TCP-x2F-IP网络模型" class="headerlink" title="TCP&#x2F;IP网络模型"></a>TCP&#x2F;IP网络模型</h1><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>用户直接接触到的就是应⽤层（Application Layer），当两个不同设备的应⽤需要通信的时候，应用就把应用数据传给下⼀层，也就是传输层。</p><p>所以，应用层只需要专注于为用户提供应用功能，不用去关心数据是如何传输的。</p><blockquote><p>应⽤层是⼯作在操作系统中的⽤户态，传输层及以下则⼯作在内核态。</p></blockquote><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>传输层（Transport Layer）是为应用层提供网络支持的。</p><p>传输层有两个重要协议：TCP和UDP</p><ul><li><p>TCP —— 传输层控制协议（Transmission Control Protocol）</p><p>大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如流量控制、超时重传、拥塞控制等，这些都是为了保证 数据包能可靠地传输给对方。</p></li><li><p>UDP —— 用户数据报协议（User Datagram Protocol）</p><p>UDP 就相对很简单，简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率 也高。</p></li></ul><p>MSS —— TCP最大报文段长度</p><p>当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有⼀个分块丢失或损坏了，只需要重新这⼀个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为⼀个 TCP段（TCP Segment）。</p><p>端口：</p><p>⼀台设备上可能会有很多应用在接收或者传输数 据，因此需要用一个编号将应用区分开来，这个编号就是端口。</p><p>传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用。</p><blockquote><p>公认的默认端口：</p><p>0 ~ 1023 是系统端口号，即已经公认定义或为将要公认定义的软件保留的，1024-49151用户端口号 ，49152-65535 是动态端口号 或称私有端口，不能被正式注册占用。</p><table><thead><tr><th>端口</th><th>服务</th><th>描述</th></tr></thead><tbody><tr><td>20 &#x2F;TCP,UDP</td><td>FTP [Default Data]</td><td>文件传输协议 - 默认数据端口</td></tr><tr><td>21 &#x2F;TCP,UDP</td><td>FTP [Control]</td><td>文件传输协议 - 控制端口</td></tr><tr><td>22 &#x2F;TCP,UDP</td><td>SSH</td><td>SSH（Secure Shell） - 远程登录协议，用于安全登录文件传输（SCP，SFTP）及端口重新定向</td></tr><tr><td>23 &#x2F;TCP,UDP</td><td>Telnet</td><td>Telnet终端仿真协议 - 未加密文本通信</td></tr><tr><td>25 &#x2F;TCP,UDP</td><td>SMTP</td><td>SMTP（简单邮件传输协议） - 用于邮件服务器间的电子邮件传递</td></tr><tr><td>43 &#x2F;TCP</td><td>WHOIS</td><td>WHOIS协议（who is ，查询域名的相关信息）</td></tr><tr><td>53 &#x2F;TCP,UDP</td><td>DNS</td><td>DNS（域名服务系统）</td></tr><tr><td>67 &#x2F;UDP</td><td>BOOTPs</td><td>BOOTP服务；同时用于动态主机设置协议 （BootStrap协议，引导程序协议，是DHCP的前身）</td></tr><tr><td>68 &#x2F;UDP</td><td>BOOTPc</td><td>BOOTP客户端；同时用于动态主机设定协议</td></tr><tr><td>69 &#x2F;UDP</td><td>TFTP</td><td>小型文件传输协议（小型文件传输协议）</td></tr><tr><td>80 &#x2F;TCP</td><td>Http</td><td>超文本传输协议（超文本传输协议）- 用于传输网页</td></tr><tr><td>110 &#x2F;TCP</td><td>POP3</td><td>邮局协议，“邮局协议”，第3版 - 用于接收电子邮件</td></tr><tr><td>113 &#x2F;TCP</td><td>Windows验证服务</td><td>Ident - 旧的服务器身份识别系统，仍然被IRC服务器用来认证它的用户</td></tr><tr><td>123 &#x2F;UDP</td><td>NTP</td><td>NTP（Network Time Protocol） - 用于网络时间同步</td></tr><tr><td>137 &#x2F;TCP,UDP</td><td>NetBIOS Name Service</td><td>NetBIOS（网上基本输入输出系统）， NetBIOS 名称服务</td></tr><tr><td>138 &#x2F;TCP,UDP</td><td>NetBIOS Datagram Service</td><td>NetBIOS NetBIOS 数据报文服务</td></tr><tr><td>139 &#x2F;TCP,UDP</td><td>NetBIOS Session Service</td><td>NetBIOS NetBIOS 会话服务</td></tr><tr><td>143 &#x2F;TCP,UDP</td><td>IMAP</td><td>因特网信息访问协议（Internet Message Access Protocol） - 用于检索 电子邮件</td></tr><tr><td>161 &#x2F;TCP,UDP</td><td>SNMP</td><td>简单网络管理协议</td></tr><tr><td>179 &#x2F;TCP</td><td>Bgp</td><td>边界网关协议 (Border Gateway Protocol)</td></tr><tr><td>194 &#x2F;TCP</td><td>IRC</td><td>互联网中继聊天（Internet Relay Chat）</td></tr><tr><td>220 &#x2F;TCP,UDP</td><td>IMAP3</td><td>因特网信息访问协议，交互邮件访问协议第3版</td></tr><tr><td>389 &#x2F;TCP,UDP</td><td>LDAP</td><td>轻型目录访问协议（Lightweight Directory Access Protocol）</td></tr><tr><td>443 &#x2F;TCP</td><td>Https</td><td>超文本传输安全协议 - 超文本传输协议 over TLS&#x2F;SSL（加密传输）</td></tr><tr><td>546 &#x2F;TCP,UDP</td><td>DHCPv6 client</td><td>DHCPv6客户端（动态主机配置协议，Dynamic Host Configuration Protocol）</td></tr><tr><td>547 &#x2F;TCP,UDP</td><td>DHCPv6 server</td><td>DHCPv6服务器</td></tr><tr><td>631 &#x2F;TCP,UDP</td><td>CUPS</td><td>通用Unix打印系统</td></tr><tr><td>636 &#x2F;TCP,UDP</td><td>LDAPS</td><td>LDAP over SSL（加密传输，也被称为LDAPS）</td></tr><tr><td>991 &#x2F;TCP,UDP</td><td>NAS</td><td>NAS (Netnews Admin System， 网络新闻管理系统 )</td></tr><tr><td>1080 &#x2F;tcp</td><td>SOCKS</td><td>SOCKS代理</td></tr><tr><td>1194 &#x2F;udp</td><td>OpenVPN</td><td>OpenVPN</td></tr><tr><td>1433 &#x2F;tcp,udp</td><td>SQL Server</td><td>Microsoft SQL 数据库系统</td></tr><tr><td>1434 &#x2F;tcp,udp</td><td>SQL Server monitor</td><td>Microsoft SQL 活动监视器</td></tr><tr><td>1521 &#x2F;tcp</td><td>Oracle</td><td>Oracle数据库 default listener, in future releases official port 2483</td></tr><tr><td>3306 &#x2F;tcp,udp</td><td>MySQL</td><td>MySQL数据库系统</td></tr><tr><td>3389 &#x2F;tcp</td><td>RDP</td><td>远程桌面协议（RDP）</td></tr><tr><td>5432 &#x2F;tcp</td><td>PostgreSQL</td><td>PostgreSQL database system</td></tr></tbody></table></blockquote><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>网络层负责 实际的数据传输功能；</p><blockquote><p>⼀个设备的数据要传输给另⼀个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，所以这些功能交由网络层实现。</p></blockquote><p>主要协议： IP</p><p>IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装 成 IP 报文，如果 IP 报文大小超过 MTU（最大传输但与，以太网中⼀般为 1500 字节）就会再次进行分片，得到⼀个即将发送到网络的 IP 报文。</p><p>IP地址分为两种意义 ：</p><ul><li>网络号：负责标识该 IP 地址是属于哪个子网的</li><li>主机号：负责标识同⼀子网下的不同主机</li></ul><p>通过子网掩码算出，先匹配到相同的网络号，再去找对应的主机。</p><p>路由：通过算法决定下一步走哪一条路径。</p><blockquote><p>IP 协议的寻址作用是告诉我们去往下⼀个目的地该朝哪个⽅向走，路由则是根据「下⼀个目的地」选择路径。寻址更像在导航，路由更像在操作⽅向盘。</p></blockquote><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>数据链路层 标识网络中的设备，为网络层提供链路级别传输的服务。</p><blockquote><p>每⼀台设备的网卡都会有⼀个 MAC 地址，它就是用来唯⼀标识设备的。路由器计算出了下⼀个目的地 IP 地址，再通过 ARP 协议找到该目的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。</p></blockquote><h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当数据准备要从设备发送到网络时，需要把数据包转换成电信号，让其可以在物理介质中传输，这⼀层就是物理层 （Physical Layer），它主要是为数据链路层提供⼆进制传输的服务。</p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><h2 id="基础概述"><a href="#基础概述" class="headerlink" title="基础概述"></a>基础概述</h2><p>HTTP，是超文本传输协议，HyperText Transfer Protocol</p><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>HTTP五大类状态码：</p><table><thead><tr><th>状态码</th><th>含义</th></tr></thead><tbody><tr><td>1**</td><td>提示信息，表示目前是协议处理的中间状态，还需要后续操作</td></tr><tr><td>2**</td><td>成功，报文已经收到并正确处理</td></tr><tr><td>3**</td><td>重定向，资源位置发生变动，需要客户端重新发送请求</td></tr><tr><td>4**</td><td>客户端错误，请求报文有误，服务器无法处理</td></tr><tr><td>5**</td><td>服务器错误，服务器在处理请求时内部发生错误</td></tr></tbody></table><p>1xx —— 属于提示信息，是协议处理中的⼀种中间状态，实际⽤到的⽐较少。 </p><p>2xx —— 类状态码表示服务器成功处理了客户端的请求，也是我们最愿意看到的状态。 </p><ul><li>「200 OK」：是最常见的成功状态码，表示⼀切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。 </li><li>「204 No Content」：也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</li><li>「206 Partial Content」：是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的⼀部分，也是服务器处理成功的状态。</li></ul><p>3xx —— 表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是重定向。 </p><ul><li><p>「301 Moved Permanently」表示永久重定向，说明请求的资源已经不存在了，需改⽤新的 URL 再次访问。 </p></li><li><p>「302 Found」表示临时重定向，说明请求的资源还在，但暂时需要⽤另⼀个 URL 来访问。 </p><blockquote><p>301 和 302 都会在响应头里使用字段 Location ，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。 </p></blockquote></li><li><p>「304 Not Modified」不具有跳转的含义，表示资源未修改，᯿定向已存在的缓冲⽂件，也称缓存᯿定向，⽤于缓 存控制。</p></li></ul><p>4xx —— 表示客户端发送的报文有误，服务器无法处理，也就是错误码的含义。 </p><ul><li>「400 Bad Request」表示客户端请求的报文有错误，但只是个笼统的错误。 </li><li>「403 Forbidden」表示服务器禁止访问资源，并不是客户端的请求出错。 </li><li>「404 Not Found」表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</li></ul><p>5xx —— 表示客户端请求报文正确，但是服务器处理时内部发⽣了错误，属于服务器端的错误码。 </p><ul><li>「500 Internal Server Error」与 400 类型一样，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。 </li><li>「501 Not Implemented」表示客户端请求的功能还不⽀持，类似“即将开业，敬请期待”的意思。 </li><li>「502 Bad Gateway」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器 发生了错误。 </li><li>「503 Service Unavailable」表示服务器当前很忙，暂时⽆法响应服务器，类似“网络服务正忙，请稍后再试”的意思。</li></ul><h3 id="常见字段"><a href="#常见字段" class="headerlink" title="常见字段"></a>常见字段</h3><ul><li><p>Host 字段 —— 客户端发送请求时，用来指定服务器的域名。</p><blockquote><p>例： Host: www. baidu.com ，有了Host字段，就可以将请求发往「同⼀台」服务器上的不同网站。</p></blockquote></li><li><p>Content-Length 字段 —— 服务器本次回应返回的数据长度。</p></li><li><p>Connection 字段 —— 用于客户端要求服务器使用TCP 持久连接，以便其他请求复用。</p><blockquote><p>Connection：Keep-Alive</p><p>HTTP&#x2F;1.1 版本的默认连接都是持久连接，但为了兼容⽼版本的 HTTP，需要指定 Connection ⾸部字段的值为 Keep-Alive.</p><p>⼀个可以复用的 TCP 连接会持续到 客户端或服务器主动关闭连接。</p></blockquote></li><li><p>Content-Type —— 用于服务器回应时，告诉客户端，本次数据是什么格式。</p><p>Accept —— 客户端声明自己可以接收哪些数据格式</p><blockquote><p>客户端    Accept:  *&#x2F;*    （表示能接收所有数据格式</p><p>服务器   Content-Type:  text&#x2F;html; charset&#x3D;utf-8</p></blockquote></li><li><p>Content-Encoding  ——  说明数据的压缩方法，即服务器返回的数据用了什么压缩格式</p><p>Accept-Encoding  —— 客户端能接受的压缩方式。</p></li></ul><h2 id="GET与POST"><a href="#GET与POST" class="headerlink" title="GET与POST"></a>GET与POST</h2><p>GET —— 请求从服务器获取资源；</p><p>POST —— 向 url 指定的资源提交数据，数据就放在报文的 body 里；</p><blockquote><p>安全：在 HTTP 协议⾥，所谓的「安全」是指请求⽅法不会「破坏」服务器上的资源。</p><p>幂等：是指多次执⾏相同的操作，结果都是「相同」的。</p><p>对此 —— </p><ul><li>GET方法是安全且幂等的，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全 的，且每次的结果都是相同的；</li><li>POST 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多 个资源，所以不是幂等的。</li></ul></blockquote><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>优点：简单、灵活和易于扩展、应用广泛和跨平台。</p><ul><li><p>简单： HTTP 基本的报文格式就是 header + body ，头部信息也是 key-value 简单文本的形式，易于理解。</p></li><li><p>灵活和易于扩展：：HTTP协议里的各类请求方法、URI&#x2F;URL、状态码、头字段等每个组成要求都没有被固定死，都允许自定义和扩充。</p><p>同时HTTP是工作再应用层的，它的下层可以随意变化，比如：HTTPS就是在HTTP和TCP之间增加了SSL&#x2F;TLS安全传输层，HTTP3还把TCP换成了基于UDP的QUIC。</p></li></ul><p>缺点：无状态，明文传输，不安全</p><ul><li><p>无状态</p><p>好处在于服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的 负担，能够把更多的 CPU 和内存用来对外提供服务。</p><p>坏处是在完成有关联性的操作时会非常麻烦，需要每次都询问身份信息。</p><blockquote><p>最简单的解决方式：使用 Cookie 技术</p></blockquote></li><li><p>明文传输</p><p>好处在于方便阅读，通过浏览器控制台或抓包都可以直接查看，便于调试。</p><p>坏处是 信息裸奔了，很容易被窃取信息。</p></li><li><p>不安全</p><ul><li>窃听风险：通信使用明文；</li><li>冒充风险：不验证通信方的身份，可能遭遇伪装；</li><li>篡改风险：无法证明报文的完整性，可能数据遭到篡改</li></ul><blockquote><p>解决：可以用HTTPS，也就是引入 SSL&#x2F;TLS 层</p></blockquote></li></ul><p>HTTP&#x2F;1.1性能</p><ul><li><p>长连接</p><p>HTTP&#x2F;1.0每次发起请求，都要新建一次TCP连接，而且是串行请求，做了无所谓的TCP建立连接和断开。</p><p>HTTP&#x2F;1.1提出了 长连接，也就是持久连接，只要任意一端没有明确提出断开连接，则会保持TCP连接状态。</p><blockquote><p>长连接使得 管道网络传输 成为可能，即在同⼀个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p><p>但是服务器还是得按顺序处理请求，可能发生 队头阻塞。</p></blockquote></li><li><p>队头阻塞</p><p>「请求 - 应答」的模式会发送队头阻塞，影响性能；</p><p>因为当顺序发送的请求序列中的⼀个请求因为某种原因被阻塞时，在后⾯排队的所有请求也⼀同被阻塞了，会招致客户端⼀直请求不到数据。</p></li></ul><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>HTTPS 在 HTTP 与 TCP 层之间加入了 SSL&#x2F;TLS 协议，可以很好的解决了上述的风险： </p><ul><li><p>信息加密：交互信息无法被窃取；</p><p>使用<strong>混合加密</strong>的方式实现信息的机密性。</p><blockquote><p>混合加密： 对称加密 + 非对称加密 </p><ul><li>在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。 </li><li>在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。</li></ul><p>之所以使用混合加密是因为：</p><ul><li>对称加密 只使用⼀个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换。</li><li>非对称加密 使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。</li></ul></blockquote></li><li><p>校验机制：无法篡改通信内容，篡改了就不能正常显示； </p><p>使用 <strong>摘要算法</strong> 来实现完整性，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决 了篡改的风险。</p><blockquote><p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」⼀同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出 的「指纹」做⽐较，若「指纹」相同，说明数据是完整的。</p></blockquote></li><li><p>身份证书：证明网站合法性；</p><p>将服务器<strong>公钥放入到数字证书</strong>中，解决了冒充的风险。</p><blockquote><p>公钥的可信度：将公钥放在CA（数字证书认证机构）颁发的数字证书中，只要证书可信，公钥就可信；</p><ol><li>服务器把自己的公钥注册到CA;</li><li>CA用自己的私钥将服务器的公钥 数字签名，并颁发数字证书；</li><li>客户端拿到服务器的数字证书后，使用CA的公钥确认服务器的数字证书的真实性；</li><li>从数字证书获取服务器的公钥后，使用公钥对报文加密后发送；</li><li>服务器使用是要对报文解密；</li></ol></blockquote></li></ul><h3 id="HTTPS建立连接"><a href="#HTTPS建立连接" class="headerlink" title="HTTPS建立连接"></a>HTTPS建立连接</h3><p>SSL&#x2F;TLS 协议基本流程： </p><ol><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。 </li><li>双方采用「会话秘钥」进行加密通信。</li></ol><p>前两步是SSL&#x2F;TLS的建立过程，即握手阶段，设计四次通信：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091837504.png" alt="HTTPS 连接建立过程"></p><p>流程：</p><p><em>1. ClientHello</em></p><p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><p>（1）客户端支持的 SSL&#x2F;TLS 协议版本，如 TLS 1.2 版本。</p><p>（2）客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</p><p>（3）客户端支持的密码套件列表，如 RSA 加密算法。</p><p><em>2. SeverHello</em></p><p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p><p>（1）确认 SSL&#x2F; TLS 协议版本，如果浏览器不支持，则关闭加密通信。</p><p>（2）服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</p><p>（3）确认密码套件列表，如 RSA 加密算法。</p><p>（4）服务器的数字证书。</p><p><em>3.客户端回应</em></p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会<strong>从数字证书中取出服务器的公钥</strong>，然后使用它加密报文，向服务器发送如下信息：</p><p>（1）一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p><p>（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p><p><em>4. 服务器的最后回应</em></p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 SSL&#x2F;TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><blockquote><p>关于SSL和TLS：</p><p>SSL 叫 安全套接层，<em>Secure Sockets Layer</em> ，由网景公司设计，因为应用广泛，成为互联网上的事实标准。</p><p>IETF 就把 SSL 标准化。标准化之后的名称改为 TLS（<em>Transport Layer Security</em>），叫 传输层安全协议。</p><p>因此，SSL 和 TLS 可以视作同一东西的不同阶段。</p></blockquote><blockquote><p>SSL1.2 需要4次握手，2个RTT时延；而SSL&#x2F;TLS1.3 只需3次握手，1个RTT时延。</p></blockquote><h2 id="HTTP-x2F-1-1-2-3的演变"><a href="#HTTP-x2F-1-1-2-3的演变" class="headerlink" title="HTTP&#x2F;1.1~2~3的演变"></a>HTTP&#x2F;1.1~2~3的演变</h2><h3 id="HTTP-x2F-1-1"><a href="#HTTP-x2F-1-1" class="headerlink" title="HTTP&#x2F;1.1"></a>HTTP&#x2F;1.1</h3><p>HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0 性能上的改进：</p><ul><li>使用 TCP <strong>长连接</strong>的方式改善了 HTTP&#x2F;1.0 短连接造成的性能开销。</li><li>支持<strong>管道（pipeline）网络传输</strong>，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但 HTTP&#x2F;1.1 还是有性能瓶颈：</p><ul><li>请求 &#x2F; 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 <code>Body</code> 的部分；</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多；</li><li>服务器是按请求的<strong>顺序响应</strong>的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是<strong>队头阻塞</strong>；</li><li>没有请求优先级控制；</li><li>请求只能从客户端开始，服务器只能被动响应。</li></ul><h3 id="HTTP-x2F-2"><a href="#HTTP-x2F-2" class="headerlink" title="HTTP&#x2F;2"></a>HTTP&#x2F;2</h3><p>HTTP&#x2F;2 协议是基于 HTTPS 的，所以 HTTP&#x2F;2 的安全性也是有保障的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091847917.png" alt="HTT/1 ~ HTTP/2"></p><p><em>1. 头部压缩</em></p><p>HTTP&#x2F;2 会<strong>压缩头</strong>（Header）如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你<strong>消除重复的部分</strong>。</p><p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就<strong>提高速度</strong>了。</p><p><em>2. 二进制格式</em></p><p>HTTP&#x2F;2 不再像 HTTP&#x2F;1.1 里的纯文本形式的报文，而是全面采用了<strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：<strong>头信息帧（Headers Frame）和数据帧（Data Frame）</strong>。</p><p>在收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p><em>3. 数据流</em></p><p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p><p>在 HTTP&#x2F;2 中每个请求或相应的所有数据包，称为一个数据流（<code>Stream</code>）。每个数据流都标记着一个独一无二的编号（Stream ID），<strong>不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）</strong>，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p><p><em>4. 多路复用</em></p><p>HTTP&#x2F;2 是可以在<strong>一个连接中并发多个请求或回应，而不用按照顺序一一对应</strong>。</p><p>移除了 HTTP&#x2F;1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，<strong>降低了延迟，大幅度提高了连接的利用率</strong>。</p><blockquote><p>举例来说，在一个 TCP 连接里，服务器收到了客户端 A 和 B 的两个请求，如果发现 A 处理过程非常耗时，于是就回应 A 请求已经处理好的部分，接着回应 B 请求，完成后，再回应 A 请求剩下的部分。</p></blockquote><p><em>5. 服务器推送</em></p><p>HTTP&#x2F;2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p><blockquote><p>比如，客户端通过 HTTP&#x2F;1.1 请求从服务器那获取到了 HTML 文件，而 HTML 可能还需要依赖 CSS 来渲染页面，这时客户端还要再发起获取 CSS 文件的请求，需要两次消息往返，而在 HTTP&#x2F;2 中，客户端在访问 HTML 时，服务器可以直接主动推送 CSS 文件，减少了消息传递的次数。</p></blockquote><p>HTTP&#x2F;2缺陷：</p><p>在TCP层仍存在队头阻塞问题：</p><p>TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP&#x2F;2 应用层才能从内核中拿到数据，这就是 HTTP&#x2F;2 队头阻塞问题。</p><h3 id="HTTP-x2F-3"><a href="#HTTP-x2F-3" class="headerlink" title="HTTP&#x2F;3"></a>HTTP&#x2F;3</h3><blockquote><p>HTTP&#x2F;1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是<strong>没有解决响应的队头阻塞</strong>，</p><p>HTTP&#x2F;2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是<strong>一旦发生丢包，就会阻塞住所有的 HTTP 请求</strong>，这属于 TCP 层队头阻塞。</p></blockquote><p>对此，HTTP&#x2F;3 把 HTTP 下层的 TCP 协议<strong>改成了 UDP</strong>！</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091857744.png" alt="HTTP/1 ~ HTTP/3"></p><p>并且，基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><p>QUIC有以下特点：</p><ul><li><p><em>无队头阻塞</em></p><p>QUIC 协议也有类似 HTTP&#x2F;2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。</p><p>QUIC 有自己的一套机制可以保证传输的可靠性的。<strong>当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题</strong>。（Stream之间没有依赖，都是独立的）</p></li><li><p>更快的连接建立</p><p>对于 HTTP&#x2F;1 和 HTTP&#x2F;2 协议，TCP 和 TLS 是分层的，分别属于内核实现的传输层、openssl 库实现的表示层，因此它们难以合并在一起，需要分批次来握手，先 TCP 握手，再 TLS 握手。</p><p>HTTP&#x2F;3 在传输数据前虽然需要 QUIC 协议握手，这个握手过程只需要 1 RTT，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。</p><p>但是 HTTP&#x2F;3 的 QUIC 协议并不是与 TLS 分层，而是<strong>QUIC 内部包含了 TLS，它在自己的帧会携带 TLS 里的“记录”</strong>，再加上 QUIC 使用的是 TLS&#x2F;1.3，因此仅需 <strong>1 个 RTT 就可以「同时」完成建立连接与密钥协商</strong>，如图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205091901785.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS "></p><blockquote><p>在第二次连接的时候，应用数据包还可以和 QUIC 握手信息（连接信息 + TLS 信息）一起发送，达到 0-RTT 的效果。</p></blockquote></li><li><p>连接迁移</p><p>基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接，那么<strong>当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接</strong>。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong>来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p></li></ul><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP&#x2F;2 的多路复用的协议。</p><p>不过，QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><p>所以，HTTP&#x2F;3 现在普及的进度非常的缓慢。</p><h2 id="HTTP-x2F-1-1如何优化"><a href="#HTTP-x2F-1-1如何优化" class="headerlink" title="HTTP&#x2F;1.1如何优化"></a>HTTP&#x2F;1.1如何优化</h2><p>思路：</p><ul><li><p><strong>尽量避免发送 HTTP 请求</strong>；</p><p>—— <strong>缓存</strong>：将请求的url作为key，响应作为value； 并估算一个过期时间，过期后发请求，会带上上一次请求的摘要，服务器比对后，如果一样，仅返回不含包体的 <code>304 Not Modified</code> 响应，不一样就带上最新的资源。</p></li><li><p><strong>在需要发送 HTTP 请求时，考虑如何减少请求次数</strong>；</p><p>—— <strong>减少重定向请求次数</strong>： 将重定向工作交给代理服务器。</p><p>—— <strong>合并请求</strong>： 比如将多个小图片放在一起发送，将css、js一起打包发送，但缺点是：如果其中一个资源发送变化，客户端必须重新下载整个大资源文件。</p><p>—— <strong>延迟发送请求</strong>：一般页面中有很多url，没必要全部获取，只获取当前用户所看到的页面资源。</p></li><li><p><strong>减少服务器的 HTTP 响应的数据大小</strong>；</p><p>—— <strong>无损压缩</strong>： 如Brotli，gzip等算法</p><p>—— <strong>有损压缩</strong>：WebP格式（图片压缩）</p></li></ul><h2 id="HTTPS-TLS握手解析"><a href="#HTTPS-TLS握手解析" class="headerlink" title="HTTPS TLS握手解析"></a>HTTPS TLS握手解析</h2><p>HTTPS 是应用层协议，需要先完成 TCP 连接建立，然后走 TLS 握手过程后，才能建立通信安全的连接。</p><p>事实上，不同的密钥交换算法，TLS 的握手过程可能会有一些区别。</p><blockquote><p><strong>通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延</strong>，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。</p><ul><li>客户端：ClientHello</li><li>服务端：ServerHello，Certificate，ServerHelloDone</li><li>客户端：ClientKeyExchange，ChangeCipherSpec，Finished</li><li>服务端：ChangeCiipherSpec，Finished</li></ul></blockquote><p>早先的密钥交换算法是RSA算法，但<strong>不支持前向保密</strong>（一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解）。现在大多数网站使用的正是 ECDHE 密钥协商算法，</p><h3 id="RSA算法"><a href="#RSA算法" class="headerlink" title="RSA算法"></a>RSA算法</h3><p>RSA算法中，TLS 证书部署服务端时，证书文件中包含一对公私钥，其中公钥会在 TLS 握手阶段传递给客户端，私钥则一直留在服务端，需要确保私钥不被窃取。</p><h4 id="TLS第一次握手"><a href="#TLS第一次握手" class="headerlink" title="TLS第一次握手"></a>TLS第一次握手</h4><p>客户端发出一个「<strong>Client Hello</strong>」，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的<strong>随机数（<em>Client Random</em>）</strong>，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111346948.png" alt="img"></p><h4 id="TLS第二次握手"><a href="#TLS第二次握手" class="headerlink" title="TLS第二次握手"></a>TLS第二次握手</h4><p>当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成<strong>随机数（<em>Server Random</em>）</strong>。</p><p>接着，返回「<strong>Server Hello</strong>」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111517197.png" alt="img"></p><blockquote><p>上图选择的密码套件： “Cipher Suite: TLS_RSA_WITH_AES_128_GCM_SHA256” ，其基本的形式是「<strong>密钥交换算法 + 签名算法 + 对称加密算法 + 摘要算法</strong>」。</p><ul><li><p>其中 “TLS”后 “WITH” 前 一般有两个单词，为密钥交换算法 和 约定证书的验证算法。图中只有RSA，说明这个算法用的都是RSA；</p></li><li><p>握手后的通信使用 AES 对称算法，密钥长度 128 位，分组模式是 GCM；</p></li><li><p>摘要算法 SHA256 用于消息认证和产生随机数；</p></li></ul><p>此时，两个 HELLO 就确认了TLS 版本和使用的密码套件，并且各自发了一个随机数给对方，这是生成 「会话密钥」的条件。</p></blockquote><p>然后，服务端为了证明自己的身份，会发送「<strong>Server Certificate</strong>」给客户端，这个消息里含有数字证书。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111532597.png" alt="img"></p><p>随后，服务端发送「<strong>Server Hello Done</strong>」消息，目的是告诉客户端，我已经把该给你的东西都给你了，本次打招呼完毕。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111532847.png" alt="img"></p><h4 id="TLS第三次握手"><a href="#TLS第三次握手" class="headerlink" title="TLS第三次握手"></a>TLS第三次握手</h4><p>客户端验证完证书后，认为可信则继续往下走。</p><p>接着，客户端就会生成一个新的<strong>随机数 (<em>pre-master</em>)<strong>，用服务器的 RSA 公钥加密该随机数，通过「</strong>Change Cipher Key Exchange</strong>」消息传给服务端。</p><blockquote><p>服务端会用RSA私钥解密，得到 pre-master。</p><p>此时，双方都有了三个随机数：<strong>Client Random、Server Random、pre-master</strong>，根据这三个随机数，就可以生成 <strong>会话密钥（Master Secret）</strong>，它是对称密钥，用于对后续的 HTTP 请求&#x2F;响应的数据加解密。</p></blockquote><p>客户端生成会话密钥后，发送一个「<strong>Change Cipher Spec</strong>」，告诉服务端开始使用加密方式发送消息。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111553333.png" alt="img"></p><p>然后再发一个「<strong>Encrypted Handshake Message（Finishd）</strong>」消息，把之前所有发送的数据做个摘要，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信是否可用和之前握手信息是否有被中途篡改过。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111554344.png" alt="img"></p><blockquote><p>可以发现，在「Change Cipher Spec」之前传输的 TLS 握手数据都是明文，之后都是对称密钥加密的密文。</p></blockquote><h4 id="TLS第四次握手"><a href="#TLS第四次握手" class="headerlink" title="TLS第四次握手"></a>TLS第四次握手</h4><p>服务器也是同样的操作，发「<strong>Change Cipher Spec</strong>」和「<strong>Encrypted Handshake Message</strong>」消息，如果双方都验证加密和解密没问题，那么握手正式完成。</p><p>之后就可以用 会话密钥加解密 HTTP 请求和响应了。</p><h3 id="ECDHE算法"><a href="#ECDHE算法" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h3><blockquote><p>ECDHE 密钥协商算法是 DH 算法演进过来，DH算法的核心数学思想是 离散对数。</p></blockquote><h4 id="离散对数"><a href="#离散对数" class="headerlink" title="离散对数"></a>离散对数</h4><p>离散对数是在对数运算的基础上加了「模运算」，也就说取余数，即 % 或 mod 。</p><p>式子： a^i^ % p &#x3D; b ， 底数a和模板p是公共参数，是公开的，b是真数，i 是对数。 </p><p>一般 对数 作为密钥，知道了对数，能算出真数，但只知道 真数，且<strong>模板p是很大的质数</strong>时，极难算出 对数。</p><h4 id="DH算法"><a href="#DH算法" class="headerlink" title="DH算法"></a>DH算法</h4><p>DH算法的密钥交换过程：</p><ul><li><p>首先双方会先确定<strong>模板</strong>和<strong>底数</strong>，两个数是公开的，设模板为P，底数为G；</p></li><li><p>然后各自生成一个随机整数为私钥，假设双方的密钥为a和b。</p></li><li><p>于是有：</p><p>公钥A &#x3D; G ^a^ % P</p><p>公钥B &#x3D; G ^b^ % P</p></li><li><p>之后将公钥发给对方， 双方都可以算出一个相同的<strong>对称加密密钥k</strong>， k &#x3D; B ^a^ % P &#x3D; A ^b^ % p。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111612199.png" alt="img"></p><p>DH算法的实现：</p><p>DHE算法，E 是指 ephemeral（临时性的），即双方的私钥在每次密钥交换通信时，都是随机生成的、临时的。</p><blockquote><p>DH算法的另一个实现是 static DH，即有一方的私钥是静态的，一般是服务器方固定私钥，但这样通过大量密钥协商过程的数据 可能可以暴力破解出服务器的私钥。</p><p>所以 static DH 算法不具备前向安全性，并不被采用。</p></blockquote><h4 id="ECDHE算法-1"><a href="#ECDHE算法-1" class="headerlink" title="ECDHE算法"></a>ECDHE算法</h4><p>现在广泛应用的密钥交换算法 —— ECDHE算法。</p><p>ECDHE算法在 DHE算法的基础上，利用了ECC椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。</p><p>小红和小明使用 ECDHE 密钥交换算法的过程：</p><ul><li>双方事先确定好使用哪种<strong>椭圆曲线</strong>，和曲线上的<strong>基点 G</strong>，这两个参数都是公开的；</li><li>双方各自随机生成一个随机数作为<strong>私钥d</strong>，并与基点 G相乘得到<strong>公钥Q</strong>（Q &#x3D; dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；</li><li>双方交换各自的公钥，最后小红计算点（x1，y1） &#x3D; d1Q2，小明计算点（x2，y2） &#x3D; d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 &#x3D; d1d2G &#x3D; d2d1G &#x3D; d2Q1 ，因此<strong>双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥</strong>。</li></ul><p>这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。</p><h3 id="客户端验证证书"><a href="#客户端验证证书" class="headerlink" title="客户端验证证书"></a>客户端验证证书</h3><p>在TLS第二次握手中，客户端拿到服务端的数字证书后，要校验该数字证书的有效性。</p><p>数字证书 通常包含：</p><ul><li>公钥；</li><li>持有者信息；</li><li>证书认证机构（CA）的信息；</li><li>CA 对这份文件的数字签名及使用的算法；</li><li>证书有效期；</li><li>还有一些其他额外信息；</li></ul><p>为了让服务端的公钥被大家信任，服务端的证书都是由 CA （<em>Certificate Authority</em>，证书认证机构）签名的，CA 就是网络世界里的公安局、公证中心，具有极高的可信度，所以由它来给各个公钥签名。</p><p>签名的作用：可以避免中间人在获取证书时对证书内容的篡改。</p><h4 id="数字证书签发和验证"><a href="#数字证书签发和验证" class="headerlink" title="数字证书签发和验证"></a>数字证书签发和验证</h4><p>CA 签发证书的过程：</p><ul><li>首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；</li><li>然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 CA 对证书做了签名；</li><li>最后将 Certificate Signature 添加在文件证书上，形成数字证书；</li></ul><p>客户端校验服务端的数字证书的过程：</p><ul><li>首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；</li><li>通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；</li><li>最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205111541262.png" alt="img"></p><p>证书链：</p><p>一般申请的证书由中间证书签发，而不是由根证书签发。 客户端发现签发者不是根证书时，会逐步向上验证，确保中间证书是可信的。</p><p>之所以要弄证书链，是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序</title>
      <link href="/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
      <url>/Notes/2022/04/17/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>项目结构</p><p>轮播图</p><p>swiper</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 轮播图 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">swiper</span> <span class="attr">class</span>=<span class="string">&quot;banners&quot;</span> <span class="attr">indicator-active-color</span>=<span class="string">&quot;#d43c33&quot;</span> <span class="attr">indicator-color</span>=<span class="string">&quot;ivory&quot;</span> <span class="attr">indicator-dots</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon5.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon2.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">swiper-item</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">image</span> <span class="attr">src</span>=<span class="string">&quot;/static/images/favicon3.png&quot;</span> <span class="attr">class</span>=<span class="string">&quot;img1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">swiper-item</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">swiper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可滚动的视图区</p><p>scroll-view</p><p>接口数据：在代码&#x2F;硅谷音乐_server 目录下cmd进入输入： npm start</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/"/>
      <url>/Notes/2022/04/14/%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="X-amp-X"><a href="#X-amp-X" class="headerlink" title="X &amp; -X"></a>X &amp; -X</h2><p><strong>X &amp; -X 得到 二进制数的LowBit</strong>（其二进制最低位的1，其余位均为0）：</p><p>-X的值，是在X的基础上进行按位取反之后再加1得到的，</p><ul><li>当X为偶数时，~X为奇数，奇数加上1会发生进位，最低位的连续的1都会变为0，所以X和 ~X的低位都为0，高位都相反，只有得到进位的那个位置都为1，即X的最右边的1相等，所以，<strong>当一个偶数与它的负值相与时， 结果是能整除这个偶数的最大的2的幂, 即： m &#x3D; n &amp; -n , 则 n % m &#x3D; 0, 且 m &#x3D; 2^k^</strong></li><li><strong>当X为奇数时</strong>，因为奇数取反后为偶数，偶数加1并不会影响进位，所以<strong>此时 X &amp; -X 结果一定为1</strong>（奇数最低位的1就在二进制数的末尾）</li></ul><h1 id="双指针-Two-Pointers"><a href="#双指针-Two-Pointers" class="headerlink" title="双指针   Two Pointers"></a><strong>双指针   Two Pointer</strong>s</h1><h2 id="141：判断链表中是否有环："><a href="#141：判断链表中是否有环：" class="headerlink" title="141：判断链表中是否有环："></a><strong>141：</strong>判断链表中是否有环<strong>：</strong></h2><p>(快慢指针)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hasCycle</span><span class="params">(<span class="keyword">struct</span> listNode *head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">slow</span> =</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">fast</span> =</span> head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="344：反转字符串"><a href="#344：反转字符串" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> left = <span class="number">0</span>, right = sSize - <span class="number">1</span>; left &lt; right; ++left, --right) &#123;</span><br><span class="line">        swap(s + left, s + right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="881：救生艇"><a href="#881：救生艇" class="headerlink" title="881：救生艇"></a>881：救生艇</h2><p>第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。</p><p>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。</p><p>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：people = [1,2], limit = 3</span><br><span class="line">输出：1</span><br><span class="line">解释：1 艘船载 (1, 2)</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果最重的人可以与最轻的人共用一艘船，那么就这样安排。否则，最重的人无法与任何人配对，那么他们将自己独自乘一艘船。</span></span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a,<span class="type">const</span> <span class="type">void</span> *b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)a - *(<span class="type">int</span>*)b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>* people, <span class="type">int</span> peopleSize, <span class="type">int</span> limit)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(peopleSize == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    qsort(people,peopleSize,<span class="keyword">sizeof</span>(<span class="type">int</span>),cmp);</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = peopleSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; left &lt; right; right--)&#123;</span><br><span class="line">        <span class="keyword">if</span>(people[left] + people[right] &lt;= limit)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        right--;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分查找法-Binary-Search"><a href="#二分查找法-Binary-Search" class="headerlink" title="二分查找法   Binary Search"></a><strong>二分查找法   Binary Search</strong></h1><p>二分査找也称折半査找，其优点是查找速度快，缺点是要求所要査找的数据必须是有序序列。</p><p>该算法的基本思想是将所要査找的序列的中间位置的数据与所要査找的元素进行比较，如果相等，则表示査找成功，否则将以该位置为基准将所要査找的序列分为<strong>左右两部分</strong>。接下来根据所要査找序列的升降序规律及中间元素与所查找元素的大小关系，对其采用同样的方法进行査找，直至能够确定所要查找的元素是否存在。</p><blockquote><p>使用二分法的条件：有序，无重复元素</p></blockquote><h2 id="二分法的边界条件"><a href="#二分法的边界条件" class="headerlink" title="二分法的边界条件"></a>二分法的边界条件</h2><p>二分法的区间一般分为两种，</p><ul><li>左闭右闭，即 [left, right]<ul><li>定义了target 在 [left, right] 区间，所以有：<ul><li>用 while (left &lt;&#x3D; right) ，因为left &#x3D;&#x3D; right是有意义的</li><li>当 if (nums[middle] &gt; target) ，right &#x3D; middle - 1，因为当前这个nums[middle]一定不是target，所以左区间的结束下标就是middle - 1。</li></ul></li></ul></li><li>左闭右开，即 [left, right) <ul><li>用 while (left &lt; right) ，因为left &#x3D;&#x3D; right是无意义的</li><li>当 if (nums[middle] &gt; target) ，right &#x3D; middle，因为当前这个nums[middle]不是target，去左区间寻找，而区间又是左闭右开区间，所以right更新为middle，即：下一个查询区间不会去比较nums[middle]</li></ul></li></ul><h2 id="704：二分查找"><a href="#704：二分查找" class="headerlink" title="704：二分查找"></a>704：二分查找</h2><p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>,right = numsSize - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* 1: mid = (left + right) / 2</span></span><br><span class="line"><span class="comment">         * 2: mid = left + (right - left) / 2</span></span><br><span class="line"><span class="comment">         * 第2种可以防止(left + right)直接相加数值过大越界的问题</span></span><br><span class="line"><span class="comment">         */</span>        </span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35：搜索插入的位置"><a href="#35：搜索插入的位置" class="headerlink" title="35：搜索插入的位置"></a>35：搜索插入的位置</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = numsSize - <span class="number">1</span>, mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid]) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="162：寻找峰值"><a href="#162：寻找峰值" class="headerlink" title="162：寻找峰值"></a>162：寻找峰值</h2><p>峰值元素是指其值大于左右相邻值的元素。</p><p>给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</p><p>你可以假设 nums[-1] &#x3D; nums[n] &#x3D; -∞ 。</p><p>解：（巧用二分法）</p><p>我们可以将 nums 数组中的任何给定序列视为交替的升序和降序序列。</p><p>在简单的二分查找中，我们处理的是一个有序数列，并通过在每一步减少搜索空间来找到所需要的数字。在本例中，我们对二分查找进行一点修改。首先从数组 numsnums 中找到中间的元素 midmid。若该元素恰好位于降序序列或者一个局部下降坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的左边。于是，我们将搜索空间缩小为 midmid 的左边(包括其本身)，并在左侧子数组上重复上述过程。</p><p>若该元素恰好位于升序序列或者一个局部上升坡度中（通过将 nums[i]nums[i] 与右侧比较判断)，则说明峰值会在本元素的右边。于是，我们将搜索空间缩小为 midmid 的右边，并在右侧子数组上重复上述过程。</p><p>就这样，我们不断地缩小搜索空间，直到搜索空间中只有一个元素，该元素即为峰值元素。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> Left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> Right = numsSize - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> Mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(Left &lt; Right)</span><br><span class="line">    &#123;</span><br><span class="line">        iMid = (Left + Right) / <span class="number">2</span>;  </span><br><span class="line">        <span class="keyword">if</span>(nums[Mid] &gt; nums[Mid + <span class="number">1</span>])&#123;</span><br><span class="line">            Right = Mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Left = Mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="74：搜索二维矩阵"><a href="#74：搜索二维矩阵" class="headerlink" title="74：搜索二维矩阵"></a>74：搜索二维矩阵</h2><p>在m * n矩阵中，搜索是否存在一个目标值。</p><p>该矩阵有如下特点：</p><ul><li><p>每行中的整数从左到右按升序排列；</p></li><li><p>每行的第一个整数大于前一行的最后一个整数；</p><p>示例：</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>两次二分查找：</p><p>我们可以对矩阵的第一列的元素二分查找，找到最后一个不大于目标值的元素，然后在该元素所在行中二分查找目标值是否存在。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearchFirstColumn</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">-1</span>, high = matrixSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low + <span class="number">1</span>) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (matrix[mid][<span class="number">0</span>] &lt;= target) &#123;</span><br><span class="line">            low = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">binarySearchRow</span><span class="params">(<span class="type">int</span>* row, <span class="type">int</span> rowSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = rowSize - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">        <span class="keyword">if</span> (row[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (row[mid] &gt; target) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rowIndex = binarySearchFirstColumn(matrix, matrixSize, target);</span><br><span class="line">    <span class="keyword">if</span> (rowIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binarySearchRow(matrix[rowIndex], matrixColSize[rowIndex], target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一次二分查找：</p><p>若将矩阵每一行拼接在上一行的末尾，则会得到一个升序数组，我们可以在该数组上二分找到目标元素。</p><p>代码实现时，可以二分升序数组的下标，将其映射到原矩阵的行和列上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">searchMatrix</span><span class="params">(<span class="type">int</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">    <span class="type">int</span> m = matrixSize, n = matrixColSize[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = m * n - <span class="number">1</span>,mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> a = matrix[mid / n][mid % n];</span><br><span class="line">        <span class="keyword">if</span>(a == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &gt; target)&#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a &lt; target)&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口-Sliding-Window"><a href="#滑动窗口-Sliding-Window" class="headerlink" title="滑动窗口  Sliding Window"></a><strong>滑动窗口  Sliding Window</strong></h1><h2 id="209：长度最小的子数组"><a href="#209：长度最小的子数组" class="headerlink" title="209：长度最小的子数组"></a>209：长度最小的子数组</h2><p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：target = 7, nums = [2,3,1,2,4,3]</span><br><span class="line">输出：2</span><br><span class="line">解释：子数组 [4,3] 是该条件下的长度最小的子数组。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>* nums, <span class="type">int</span> numsSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>,minSize = <span class="number">0</span>, sum = <span class="number">0</span>,ans = INT_MAX;</span><br><span class="line">    <span class="keyword">if</span>(numsSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;right &lt; numsSize; right++)&#123;</span><br><span class="line">        sum += nums[right];</span><br><span class="line">        <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">            minSize = right - left + <span class="number">1</span>;</span><br><span class="line">            ans = minSize &lt; ans ? minSize : ans;</span><br><span class="line">            sum -= nums[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans == INT_MAX ? <span class="number">0</span>:ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1456：定长子串中元音的最大数目"><a href="#1456：定长子串中元音的最大数目" class="headerlink" title="1456：定长子串中元音的最大数目"></a>1456：定长子串中元音的最大数目</h2><p>给你字符串 s 和整数 k 。</p><p>请返回字符串 s 中长度为 k 的单个子字符串中可能包含的最大元音字母数。</p><p>英文中的 元音字母 为（a, e, i, o, u）。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abciiidef&quot;, k = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：子字符串 &quot;iii&quot; 包含 3 个元音字母。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxVowels</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[right] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[right] == <span class="string">&#x27;a&#x27;</span> || s[right] == <span class="string">&#x27;e&#x27;</span> || s[right] == <span class="string">&#x27;i&#x27;</span> || s[right] == <span class="string">&#x27;o&#x27;</span> || s[right] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            ans = sum &gt; ans ? sum : ans;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s[left] == <span class="string">&#x27;a&#x27;</span> || s[left] == <span class="string">&#x27;e&#x27;</span> || s[left] == <span class="string">&#x27;i&#x27;</span> || s[left] == <span class="string">&#x27;o&#x27;</span> || s[left] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">                sum--;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归  Recursion"></a><strong>递归  Recursion</strong></h1><h2 id="344：反转字符串-1"><a href="#344：反转字符串-1" class="headerlink" title="344：反转字符串"></a>344：反转字符串</h2><p>编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。</p><p>不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。</p><p>你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">char</span> t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">recursion</span><span class="params">(<span class="type">char</span> *s,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    recursion(s,left + <span class="number">1</span>,right - <span class="number">1</span>);</span><br><span class="line">    swap(&amp;s[left],&amp;s[right]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> *s, <span class="type">int</span> sSize)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(sSize == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    recursion(s,<span class="number">0</span>,sSize - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="206：反转一个单链表。"><a href="#206：反转一个单链表。" class="headerlink" title="206：反转一个单链表。"></a>206：反转一个单链表。</h2><p><strong>示例:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> ListNode* <span class="title function_">reverseList</span><span class="params">(<span class="keyword">struct</span> ListNode* head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> =</span> reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708769.png" alt="image-20210402193739408"></p><h2 id="687-最长同值路径"><a href="#687-最长同值路径" class="headerlink" title="687:最长同值路径"></a>687:最长同值路径</h2><p>给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。</p><p>注意：两个节点之间的路径长度由它们之间的边数表示。</p><p>示例 1:</p><p>输入:</p><pre><code>          5         / \        4   5       / \   \      1   1   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>输入：</p><pre><code>          1         / \        4   5       / \   \      4   4   5</code></pre><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> dfs(node.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> dfs(node.right);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrowLeft</span> <span class="operator">=</span> <span class="number">0</span>, arrowRight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowLeft += left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="literal">null</span> &amp;&amp; node.left.val == node.val)</span><br><span class="line">            arrowRight += right +  <span class="number">1</span>;</span><br><span class="line">        ans = Math.max(ans, arrowLeft + arrowRight);</span><br><span class="line">        <span class="keyword">return</span> Math.max(arrowLeft, arrowRight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(a, b) ((a) &gt; (b) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Dfs</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> *maxDep, <span class="type">int</span> value)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 进入最底层的节点，从下往上计算 */</span></span><br><span class="line">    <span class="type">int</span> leftDep = Dfs(root-&gt;left, maxDep, root-&gt;val);</span><br><span class="line">    <span class="type">int</span> rightDep = Dfs(root-&gt;right, maxDep, root-&gt;val);</span><br><span class="line"></span><br><span class="line">    *maxDep = MAX(*maxDep, leftDep + rightDep); </span><br><span class="line">    <span class="comment">// 从下往上遍历需要时刻更新最大值</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> MAX(leftDep, rightDep) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(<span class="keyword">struct</span> TreeNode *root)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> maxDep = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Dfs(root, &amp;maxDep, root-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> maxDep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分治法-Divide-amp-Conquer"><a href="#分治法-Divide-amp-Conquer" class="headerlink" title="分治法   Divide &amp; Conquer"></a><strong>分治法   Divide &amp; Conquer</strong></h1><p>分治法所能解决的问题一般具有以下几个特征：</p><ol><li><p>该问题的规模缩小到一定的程度就可以容易地解决</p></li><li><p>该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。(前提)</p></li><li><p>利用该问题分解出的子问题的解可以合并为该问题的解；（分治的关键，如果不具备，可以考虑贪心算法和动态规划）</p></li><li><p>该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。（关系分治的效率，如果要反复求解公共子问题，用动态规划较好）</p></li></ol><p><strong>分治法在每一层递归上都有三个步骤：</strong></p><p><strong>step1 分解</strong>：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p><p><strong>step2 解决</strong>：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p><p><strong>step3 合并</strong>：将各个子问题的解合并为原问题的解。</p><p><strong>分治法的复杂性分析</strong></p><p>一个分治法将<strong>规模为n</strong>的问题分成<strong>k个规模为n／m</strong>的子问题去解。设分解阀值n0&#x3D;1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解**合并为原问题的解需用f(n)**个单位时间。用T(n)表示该分治法解规模为|P|&#x3D;n的问题所需的计算时间，则有：</p><p><strong>T（n）&#x3D; k T(n&#x2F;m)+f(n)</strong></p><h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h2><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n&#x2F;2 ⌋ 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>思路：</strong></p><p>如果数 a 是数组 nums 的众数，如果我们将 nums 分成两部分，那么 a 必定是至少一部分的众数。</p><p>这样以来，我们就可以使用分治法解决这个问题：将数组分成左右两部分，分别求出左半部分的众数 a1 以及右半部分的众数 a2，随后在 a1 和 a2 中选出正确的众数。</p><p><strong>算法：</strong></p><p>我们使用分治算法递归求解，直到所有的子问题都是长度为 1 的数组。长度为 1 的子数组中唯一的数显然是众数，直接返回即可。如果回溯后某区间的长度大于 1，我们必须将左右子区间的值合并。如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。否则，我们需要比较两个众数在整个区间内出现的次数来决定该区间的众数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countInRange</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> num, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) </span><br><span class="line">            <span class="keyword">if</span> (nums[i] == num) </span><br><span class="line">                count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">majorityElementRec</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">//大小为1的数组中唯一的元素是多数</span></span><br><span class="line">        <span class="keyword">if</span> (lo == hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[lo];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//在这个切片的左右两半上递归。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (hi - lo) / <span class="number">2</span> + lo;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> majorityElementRec(nums, lo, mid);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> majorityElementRec(nums, mid + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="comment">//如果两半在多数元素上达成一致，则返回它。</span></span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则，计算每个元素并返回“赢家”。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftCount</span> <span class="operator">=</span> countInRange(nums, left, lo, hi);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightCount</span> <span class="operator">=</span> countInRange(nums, right, lo, hi);</span><br><span class="line">        <span class="keyword">return</span> leftCount &gt; rightCount ? left : right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> majorityElementRec(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53.最大子序和"></a>53.最大子序和</h2><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分治法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态规划</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            pre = Math.max(pre + x, x);</span><br><span class="line">            maxAns = Math.max(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法-Backtracking"><a href="#回溯法-Backtracking" class="headerlink" title="回溯法   Backtracking"></a><strong>回溯法   Backtracking</strong></h1><p>常见问题：</p><ul><li>排列问题，讲究顺序，因此已经选过的元素还有可能再次被选中放置在不同的位置上，构成不同的排列；</li><li>组合问题与子集问题，因为不计算元素顺序，一个元素选还是没有选过很重要，因此需要设置搜索起点，搜索起点之前的元素不再考虑，这样才能做到不重不漏；</li><li>切割问题：如 给一字符串返回符合条件的子串</li><li>棋盘问题：如 N皇后，解数独</li></ul><blockquote><p>编码之前先根据具体的用例画出<code>树形图</code>，图和代码是一 一对应的关系，先画图再编码是不错的方式；</p></blockquote><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22.括号生成"></a>22.括号生成</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">            getParenthesis(<span class="string">&quot;&quot;</span>,n,n);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getParenthesis</span><span class="params">(String str,<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span> )&#123;</span><br><span class="line">                res.add(str);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">                <span class="comment">//剩余左右括号数相等，下一个只能用左括号</span></span><br><span class="line">                getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="comment">//剩余左括号小于右括号，下一个可以用左括号也可以用右括号</span></span><br><span class="line">                <span class="keyword">if</span>(left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    getParenthesis(str+<span class="string">&quot;(&quot;</span>,left-<span class="number">1</span>,right);</span><br><span class="line">                &#125;</span><br><span class="line">                getParenthesis(str+<span class="string">&quot;)&quot;</span>,left,right-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="77-组合"><a href="#77-组合" class="headerlink" title="77.组合"></a>77.组合</h2><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = <span class="number">4</span>, k = <span class="number">2</span></span><br><span class="line">输出：</span><br><span class="line">[[<span class="number">2</span>,<span class="number">4</span>],[<span class="number">3</span>,<span class="number">4</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">4</span>],]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//k1判断a中添加元素的个数，n1用于表示加入的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span> n, <span class="type">int</span> n1, <span class="type">int</span> k, <span class="type">int</span> k1)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k1 == k) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; n1 &lt;= n; n1++) &#123;</span><br><span class="line">            a.add(n1);</span><br><span class="line">            backtrack(a, n, n1 + <span class="number">1</span>, k, k1 + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();<span class="comment">//栈方便后进先出</span></span><br><span class="line">        backtrack(stack, n, <span class="number">1</span>, k, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78.子集"></a>78.子集</h2><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//n为nums长度，m为指示下标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; m &lt;= n; m++) &#123;</span><br><span class="line">            a.add(nums[m]);</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            backtrack(a, nums, n, m + <span class="number">1</span>);</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">        backtrack(a, nums, n, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46.全排列"></a>46.全排列</h2><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <strong>所有可能的全排列</strong> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//a存储每一组答案， ind只放0和1，用来判断nums中的值是否被取过， n为nums长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">backtrack</span><span class="params">(Deque&lt;Integer&gt; a, <span class="type">int</span>[] nums, <span class="type">int</span>[] ind, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (a.size() == n) &#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(a));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ind[i] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">            a.add(nums[i]);</span><br><span class="line">            ind[i] = <span class="number">1</span>;</span><br><span class="line">            backtrack(a, nums, ind, n);</span><br><span class="line">            ind[i] = <span class="number">0</span>;</span><br><span class="line">            a.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; a = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] ind = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        backtrack(a, nums, ind, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a><strong>深度优先搜索</strong>（DFS）</h1><p><strong>深度优先搜索属于图算法的一种，英文缩写为DFS即Depth First Search。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，再返回至最近的分支进行搜索，而且每个节点只能访问一次。</strong></p><p><strong>常用栈 或 递归 实现</strong></p><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> width, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i, j - <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; length - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i, j + <span class="number">1</span>, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>)</span><br><span class="line">            dfs(grid, i - <span class="number">1</span>, j, width, length);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; width - <span class="number">1</span>)</span><br><span class="line">            dfs(grid, i + <span class="number">1</span>, j, width, length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> grid[<span class="number">0</span>].length, width = grid.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; width; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ans += <span class="number">1</span>;</span><br><span class="line">                    dfs(grid, i, j, width, length);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">searchLand_DFS</span><span class="params">(<span class="type">char</span> **grid, <span class="type">int</span> rowSize, <span class="type">int</span> colSize,<span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">    <span class="comment">//将搜索过的位置变为0</span></span><br><span class="line">    grid[row][col] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="comment">//向右搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col + <span class="number">1</span> &lt; colSize) &amp;&amp; (grid[row][col + <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid,rowSize,colSize,row,col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向下搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row + <span class="number">1</span> &lt; rowSize) &amp;&amp; (grid[row + <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row + <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上搜索</span></span><br><span class="line">    <span class="keyword">if</span>((row - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row - <span class="number">1</span>][col] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize, colSize, row - <span class="number">1</span>, col);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向左搜索</span></span><br><span class="line">    <span class="keyword">if</span>((col - <span class="number">1</span> &gt;= <span class="number">0</span>) &amp;&amp; (grid[row][col - <span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">        searchLand_DFS(grid, rowSize,colSize, row, col - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>** grid, <span class="type">int</span> gridSize, <span class="type">int</span>* gridColSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; gridSize; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>;j &lt;gridColSize[<span class="number">0</span>]; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                searchLand_DFS(grid,gridSize, gridColSize[<span class="number">0</span>],i,j);</span><br><span class="line">                result += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="938-二叉搜索树的范围和"><a href="#938-二叉搜索树的范围和" class="headerlink" title="938.二叉搜索树的范围和"></a>938.二叉搜索树的范围和</h2><p>给定二叉搜索树的根结点 <code>root</code>，返回值位于范围 <em><code>[low, high]</code></em> 之间的所有结点的值的和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [10,5,15,3,7,null,18], low = 7, high = 15</span><br><span class="line">输出：32</span><br></pre></td></tr></table></figure><p>代码：(这里利用了递归实现深度优先搜索，下面两种代码一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     struct TreeNode *right;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode *root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &gt; high)&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;left,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(root-&gt;val &lt; low )&#123;</span><br><span class="line">        <span class="keyword">return</span> rangeSumBST(root-&gt;right,low,high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>  root-&gt;val + </span><br><span class="line">       rangeSumBST(root-&gt;left,low,high) +</span><br><span class="line">        rangeSumBST(root-&gt;right,low,high);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">rangeSumBST</span><span class="params">(<span class="keyword">struct</span> TreeNode* root, <span class="type">int</span> L, <span class="type">int</span> R)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> sum = rangeSumBST(root -&gt;left,L,R) + rangeSumBST (root -&gt; right,L,R);</span><br><span class="line">    <span class="keyword">if</span>(root -&gt;val &lt;= R &amp;&amp; root -&gt;val &gt;= L)</span><br><span class="line">        sum += root -&gt;val;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量"><a href="#547-省份数量" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i] [j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i] [j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                dfs(isConnected, visited, n, i);</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] isConnected, <span class="type">boolean</span>[] visited, <span class="type">int</span> n, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])&#123;</span><br><span class="line">                visited[j] = <span class="literal">true</span>;</span><br><span class="line">                dfs(isConnected, visited, n, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方格分割"><a href="#方格分割" class="headerlink" title="方格分割"></a>方格分割</h2><p>有一个6x6的方格，沿着格子的边线剪开成两部分。要求这两部分的形状完全相同。如：</p><img src="https://img-blog.csdn.net/20180203161615277?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTkVVUTUwZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" style="zoom:50%;" /><p>注意：旋转对称的属于同一种分割法。</p><p>题解：<br>如果把样例图案剪开，发现有且只有两个点在边界上，且一定经过 （3,3）点<br>那么以（3,3）为起点进行深搜，深搜到一个点那么他的中心对称点相当于也搜过了，如果发现搜到了边界，那么它的中心对称点也到了边界 ，沿着已经搜过的点剪开，那么，剪开的两个图形为中心对称图形，但要注意最终的结果要除以4<br>例如 我们从（3,3）点出发一直向右到边界 ， 或一直向左，或一直向上，或一直向下，剪出来的图形是同一个。</p><p>我们从中心点开始搜索，每次可以走四个方向。搜索的过程要将中心对称点顺便标记</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[<span class="number">7</span>][<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(x == <span class="number">0</span> || y == <span class="number">0</span> || x == <span class="number">6</span> || y == <span class="number">6</span>)&#123;</span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> xx = x + dx[i];</span><br><span class="line">        <span class="type">int</span> yy = y + dy[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">map</span>[xx][yy] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span>- xx][<span class="number">6</span> - yy] = <span class="number">1</span>;</span><br><span class="line">            DFS(xx,yy);</span><br><span class="line">            <span class="built_in">map</span>[xx][yy] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">map</span>[<span class="number">6</span> - xx][<span class="number">6</span> - yy] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    DFS(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans/<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a><strong>广度优先搜索</strong>（BFS）</h1><h2 id="107-二叉树的层序遍历"><a href="#107-二叉树的层序遍历" class="headerlink" title="107.二叉树的层序遍历"></a>107.二叉树的层序遍历</h2><p>给定一个二叉树，返回其节点值自底向上的层序遍历。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例：给定二叉树 [3,9,20,null,null,15,7],</span><br><span class="line">返回结果：</span><br><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode() &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.left = left;</span><br><span class="line">            <span class="built_in">this</span>.right = right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        Deque&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            List&lt;Integer&gt; tempNums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tempNums.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    queue.add(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ret.add(tempNums);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="200-岛屿数量-1"><a href="#200-岛屿数量-1" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    bfs(grid, i, j);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j &#125;);</span><br><span class="line">        <span class="keyword">while</span>(!list.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = list.remove();</span><br><span class="line">            i = cur[<span class="number">0</span>]; j = cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(<span class="number">0</span> &lt;= i &amp;&amp; i &lt; grid.length &amp;&amp; <span class="number">0</span> &lt;= j &amp;&amp; j &lt; grid[<span class="number">0</span>].length &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i + <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i - <span class="number">1</span>, j &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j + <span class="number">1</span> &#125;);</span><br><span class="line">                list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; i, j - <span class="number">1</span> &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量-1"><a href="#547-省份数量-1" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] visits = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Deque&lt;Integer&gt; q = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visits[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                q.add(i);</span><br><span class="line">                <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                    visits[j] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isConnected[j][k] == <span class="number">1</span> &amp;&amp; visits[k] == <span class="number">0</span>)</span><br><span class="line">                            q.add(k);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="并查集-Union-Find"><a href="#并查集-Union-Find" class="headerlink" title="并查集  Union Find"></a><strong>并查集  Union Find</strong></h1><h2 id="200-岛屿数量-2"><a href="#200-岛屿数量-2" class="headerlink" title="200.岛屿数量"></a>200.岛屿数量</h2><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="keyword">if</span> (rows == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (cols == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] directions = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> rows * cols;</span><br><span class="line">        <span class="comment">// 多开一个结点，把 &#x27;0&#x27; 都与最后这个结点连在一起</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">unionFind</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] direction : directions) &#123;</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> i + direction[<span class="number">0</span>];</span><br><span class="line">                        <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> j + direction[<span class="number">1</span>];</span><br><span class="line">                        <span class="keyword">if</span> (inArea(newX, newY, rows, cols) &amp;&amp; grid[newX][newY] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                            unionFind.union(getIndex(i, j, cols), getIndex(newX, newY, cols));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    unionFind.union(getIndex(i, j, cols), size);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> unionFind.getCount() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span>[] parent;</span><br><span class="line">        <span class="comment">//连通分量个数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">            count = n;</span><br><span class="line">            parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (x != parent[x]) &#123;</span><br><span class="line">                <span class="comment">// 只实现了路径压缩，并且是隔代压缩</span></span><br><span class="line">                parent[x] = parent[parent[x]];</span><br><span class="line">                x = parent[x];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootX</span> <span class="operator">=</span> find(x);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rootY</span> <span class="operator">=</span> find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootX == rootY) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            parent[rootX] = rootY;</span><br><span class="line">            count--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">inArea</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> rows, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getIndex</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> cols)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x * cols + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="547-省份数量-2"><a href="#547-省份数量-2" class="headerlink" title="547.省份数量"></a>547.省份数量</h2><p>有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</p><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] &#x3D; 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] &#x3D; 0 表示二者不直接相连。</p><p>返回矩阵中 省份 的数量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] isConnected)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> isConnected.length;</span><br><span class="line">        <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>)</span><br><span class="line">                    union(parent, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parent[i] == i)</span><br><span class="line">                ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        parent[find(parent, i)] = find(parent, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] parent, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index] != index)</span><br><span class="line">            parent[index] = find(parent, parent[index]);</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="721-账户合并"><a href="#721-账户合并" class="headerlink" title="721.账户合并"></a>721.账户合并</h2><p>给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该账户的邮箱地址。</p><p>现在，我们想合并这些账户。如果两个账户都有一些共同的邮箱地址，则两个账户必定属于同一个人。请注意，即使两个账户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的账户，但其所有账户都具有相同的名称。</p><p>合并账户后，按以下格式返回账户：每个账户的第一个元素是名称，其余元素是 按字符 ASCII 顺序排列 的邮箱地址。账户本身可以以 任意顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：accounts = [</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john00@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>],</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnsmith@mail.com&quot;</span>, <span class="string">&quot;john_newyork@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">输出：[</span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&#x27;john00@mail.com&#x27;</span>, <span class="string">&#x27;john_newyork@mail.com&#x27;</span>, <span class="string">&#x27;johnsmith@mail.com&#x27;</span>], </span><br><span class="line">    [<span class="string">&quot;John&quot;</span>, <span class="string">&quot;johnnybravo@mail.com&quot;</span>], </span><br><span class="line">    [<span class="string">&quot;Mary&quot;</span>, <span class="string">&quot;mary@mail.com&quot;</span>]</span><br><span class="line">]</span><br><span class="line">解释：</span><br><span class="line">第一个和第三个 John 是同一个人，因为他们有共同的邮箱地址 <span class="string">&quot;johnsmith@mail.com&quot;</span>。 </span><br><span class="line">第二个 John 和 Mary 是不同的人，因为他们的邮箱地址没有被其他帐户使用。</span><br><span class="line">（可以以任何顺序返回这些列表）</span><br></pre></td></tr></table></figure><p>根据题意可知：</p><ul><li>存在相同邮箱的账号一定属于同一个人</li><li>名称相同的账户不一定属于同一个人</li></ul><p><strong>思路：</strong><br>由于名称相同无法判断为同1人，所以只能<strong>使用邮箱是否相同来判断是否为同一人。</strong></p><p>这样建立并查集就比较简单了：</p><ul><li>先初始化每个账户为1个连通分量</li><li>遍历每个账户下的邮箱，判断该邮箱是否在其他账户下出现</li><li>如果未出现，继续</li><li>如果账户A、B下出现了相同的邮箱email，那么将账户A和账户B两个连通分量进行合并</li><li>最后遍历并查集中每个连通分量，将所有连通分量内部账户的邮箱全部合并(相同的去重，不同的合并)</li><li>结束</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">accountsMerge</span><span class="params">(List&lt;List&lt;String&gt;&gt; accounts)</span> &#123;</span><br><span class="line">        <span class="comment">// 作用：存储每个邮箱属于哪个账户 ，同时 在遍历邮箱时，判断邮箱是否出现过[去重]</span></span><br><span class="line">        <span class="comment">// 格式：&lt;邮箱，账户id&gt;</span></span><br><span class="line">        Map&lt;String, Integer&gt; emailToId = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> accounts.size();<span class="comment">//id个数</span></span><br><span class="line">        <span class="type">UnionFind</span> <span class="variable">myUnion</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UnionFind</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> accounts.get(i).size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; num; j++)&#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">curEmail</span> <span class="operator">=</span> accounts.get(i).get(j);</span><br><span class="line">                <span class="comment">//当前邮箱没有出现过</span></span><br><span class="line">                <span class="keyword">if</span>(!emailToId.containsKey(curEmail))&#123;</span><br><span class="line">                    emailToId.put(curEmail, i);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;<span class="comment">//当前邮箱已经出现过，那么代表这两个用户是同一个</span></span><br><span class="line">                    myUnion.union(i, emailToId.get(curEmail));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行完上面的步骤，同一个用户的所有邮箱已经属于同一个连通域了，但是就算在同一个连通域，不同的邮箱还是可能会对应不同的id</span></span><br><span class="line">        <span class="comment">// 作用： 存储每个账户下的邮箱</span></span><br><span class="line">        <span class="comment">// 格式： &lt;账户id, 邮箱列表&gt; &gt;</span></span><br><span class="line">        <span class="comment">// 注意：这里的key必须是账户id，不能是账户名称，名称可能相同，会造成覆盖</span></span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; idToEmails = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//将同一个连通域内的邮箱对应到同一个id【也就是第一次出现的id，比如4、5在同一个连通域，那么这个连通域对应的id就是4】</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, Integer&gt; entry : emailToId.entrySet())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> myUnion.find(entry.getValue());</span><br><span class="line">            List&lt;String&gt; emails = idToEmails.getOrDefault(id, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            emails.add(entry.getKey());</span><br><span class="line">            idToEmails.put(id,emails);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//经过上面的步骤，已经做到了id和邮箱集合对应起来，接下来把用户名对应起来就可以了</span></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;Integer, List&lt;String&gt;&gt; entry : idToEmails.entrySet())&#123;</span><br><span class="line">            List&lt;String&gt; emails = entry.getValue();</span><br><span class="line">            Collections.sort(emails);</span><br><span class="line">            List&lt;String&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            tmp.add(accounts.get(entry.getKey()).get(<span class="number">0</span>));<span class="comment">//先添加用户名</span></span><br><span class="line">            tmp.addAll(emails);</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] parent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UnionFind</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            parent[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        parent[find(index2)] = find(index1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">            parent[index] = find(parent[index]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="贪心算法-Greedy"><a href="#贪心算法-Greedy" class="headerlink" title="贪心算法   Greedy"></a><strong>贪心算法</strong>   Greedy</h1><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55.跳跃游戏"></a>55.跳跃游戏</h2><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。</p><p>数组中的每个元素代表你在该位置可以跳跃的<strong>最大长度</strong>。</p><p>判断你是否能够到达最后一个下标。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实时维护 最远可以到达的位置。</span></span><br><span class="line"><span class="comment">// 对于当前遍历到的位置 i，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，</span></span><br><span class="line"><span class="comment">// 因此我们可以用 i + nums[i] 更新最远可以到达的位置。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">far</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//最远可到达距离必须大于当前位置，否则说明无法到达当前位置</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= far) &#123;</span><br><span class="line">                far = Math.max(far, nums[i] + i);</span><br><span class="line">                <span class="keyword">if</span> (far &gt;= n - <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="记忆化搜索-Menory-Search"><a href="#记忆化搜索-Menory-Search" class="headerlink" title="记忆化搜索   Menory Search"></a><strong>记忆化搜索   Menory Search</strong></h1><h1 id="动态规划-Dynamic-Programming"><a href="#动态规划-Dynamic-Programming" class="headerlink" title="动态规划   Dynamic Programming"></a><strong>动态规划   Dynamic Programming</strong></h1><p><strong>动态规划</strong>：先将问题分解为子问题，并且对于这些分解的子问题自身是最优的才能在这个基础上得出我们要解决的问题的最优方案.<br><strong>与贪心算法不同之处</strong>在于，贪心算法是从局部最优来解决问题，而动态规划则是从全局最优来解决问题，当对情况及条件加以限制时，贪心算法会因目光短浅而得到错误答案。<br><strong>记忆化搜索</strong>&#x3D;搜索的形式+动态规划的思想<br>搜索过程中会有很多重复计算，通过记录一些状态的答案减少重复搜索量.<br>搜索过程中一个搜索结果必须可以建立在同类型问题的结果上</p><p><strong>联系</strong><br>记忆化搜索与递归一样，都是自顶向下的思路，而动态规划则是自底向上的思路。<br>在平常练习中，我们一般是只考虑一个问题，一般习惯于自顶向下正向思考，这也比较符合人类的逻辑习惯嘛，这便是记忆化搜索（ms）。如果逆向思考，自底向上递推求解，这便是动态规划（dp）了。</p><hr><p>dp和ms 原理都是相同的，只是实现方法不同<br>可以明显的发现有以下几点不同：</p><p>1、DP是从下向上，而记忆化搜索是从上向下的</p><p>2、DP是从下向上，为了求到最终结果需要把过程中所有的值都保存下来，以便下一步可能会使用，而因为记忆化搜索是从上向下的，所以求解过程求的都是需要的；也就是说不需要的值并没有求</p><p>3、记忆化搜索使用递归实现的；</p><p>如果一个dp[i] [j]的值已经求过，使用DP直接调用即可；而使用记忆化搜索则要进入递归</p><p>如果一个dp[i] [j]的值还未求过，使用DP直接求得，而使用记忆化搜索则要进入递归中去求，而这个递归很有可能是多重的</p><p>这样一来DP在时间上几乎总是优于记忆化搜索的</p><hr><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322.零钱兑换"></a>322.零钱兑换</h2><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p>解答：</p><p>我们采用自下而上的方式进行思考。定义 F(i) 为组成金额 i 所需最少的硬币数量，假设在计算 F(i)之前，我们已经计算出 F(0) - F(i-1) 的答案。 则 F(i) 对应的转移方程应为</p><p>F(i) &#x3D; min [  F( i - cj )  ]  +  1</p><p>{cj 表示第 j 枚硬币的面值，即我们枚举最后一枚硬币时，需要从  i - cj  这个金额状态 F( i - cj ) 转移过来，也就是求出 F( i - cj )  所需的硬币数量，再加1}</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span> *coins, <span class="type">int</span> coinsSize, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="comment">/* 1、确定base case */</span></span><br><span class="line">    <span class="type">int</span> dp[amount + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 2、从面值为1开始，计算其dp值 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/* 2.1、确定状态：当前面值的 dp 值为 amount + 1 */</span></span><br><span class="line">        dp[i] = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">/* 2.2、确定选择：即为硬币的面值</span></span><br><span class="line"><span class="comment">         * 依次计算当前dp值是否可以再分</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; coinsSize; j++) &#123;</span><br><span class="line">            <span class="comment">/* 判断条件是 i &gt; coins[j](1、2、5) */</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coins[j]) &#123;</span><br><span class="line">                <span class="comment">/* dp(amount) = min(dp(amount - coins[1、2、5])) + 1 */</span></span><br><span class="line">                dp[i] = (dp[i - coins[j]] + <span class="number">1</span>) &lt; dp[i] ? (dp[i - coins[j]] + <span class="number">1</span>) : dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 3、若当前硬币不能被再分，则返回-1 */</span></span><br><span class="line">    <span class="keyword">return</span> dp[amount] &lt; amount + <span class="number">1</span> ? dp[amount] : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121.买卖股票的最佳时机"></a>121.买卖股票的最佳时机</h2><p>给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。</p><p>你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p>假如计划在第 i 天卖出股票，那么最大利润的差值一定是在[0, i-1] 之间选最低点买入；所以遍历数组，依次求每个卖出时机的的最大差值，再从中取最大值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>* prices, <span class="type">int</span> pricesSize)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minprice=<span class="number">0xFFFFFF</span>;</span><br><span class="line">    <span class="type">int</span> maxret =<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i&lt;pricesSize;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &lt; minprice)&#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            maxret = (prices[i]-minprice)&gt;maxret ? prices[i]-minprice:maxret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a>70.爬楼梯</h2><p>假设你正在爬楼梯。需要 <em>n</em> 阶你才能到达楼顶。</p><p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>注意：</strong>给定 <em>n</em> 是一个正整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br></pre></td></tr></table></figure><p>解题思路与斐波那契一致；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最少爬一阶</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>,c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a = b;</span><br><span class="line">        b = c;</span><br><span class="line">        c = a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62.不同路径"></a>62.不同路径</h2><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角。</p><p>问总共有多少条不同的路径？</p><p>动态规划转移方程：</p><p><strong>f(i, j) &#x3D; f(i-1, j) + f(i, j-1)</strong></p><p>注：网格的边界，它们的值均为 1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> nums[m][n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                nums[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> nums[i][j] = nums[i - <span class="number">1</span>][j] + nums[i][j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="221-最大正方形"><a href="#221-最大正方形" class="headerlink" title="221.最大正方形"></a>221.最大正方形</h2><p>在一个由 <code>&#39;0&#39;</code> 和 <code>&#39;1&#39;</code> 组成的二维矩阵内，找到只包含 <code>&#39;1&#39;</code> 的最大正方形，并返回其面积。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;],</span><br><span class="line">[&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>用<em>dp</em>( i , j ) 表示以 ( i, j ) 为右下角，且只包含 1 的正方形的边长最大值。</p><ul><li><p>如果该位置的值是 0，则dp( i , j )&#x3D;0，因为当前位置不可能在由 1 组成的正方形中；</p></li><li><p>如果该位置的值是 1，则 dp( i , j ) 的值由其上方、左方和左上方的三个相邻位置的dp( i , j ) 值决定。具体而言，当前位置的元素值等于三个相邻位置的元素中的最小值加 1，状态转移方程如下：</p><p><strong>dp(i, j)&#x3D;min( dp(i−1, j), dp(i−1, j−1), dp(i, j−1) )+1</strong></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MIN(a,b,c) ((a)&lt;(b)?( (a)&lt;(c)?(a):(c) ):( (b)&lt;(c)?(b):(c) ))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">maximalSquare</span><span class="params">(<span class="type">char</span>** matrix, <span class="type">int</span> matrixSize, <span class="type">int</span>* matrixColSize)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(matrixSize == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j,k,ms = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;matrixSize;j++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;matrixColSize[j];k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k]==<span class="string">&#x27;1&#x27;</span> &amp;&amp; j&gt;<span class="number">0</span> &amp;&amp; k&gt;<span class="number">0</span>) matrix[j][k] = MIN(matrix[j<span class="number">-1</span>][k],matrix[j][k<span class="number">-1</span>],matrix[j<span class="number">-1</span>][k<span class="number">-1</span>]) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[j][k] &gt; ms) ms = matrix[j][k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ms-<span class="string">&#x27;0&#x27;</span>)*(ms-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279.完全平方数"></a>279.完全平方数</h2><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><p>给你一个整数 <code>n</code> ，返回和为 <code>n</code> 的完全平方数的 <strong>最少数量</strong> 。</p><p>（完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p>这是完全背包问题的简单变形：</p><ul><li>背包大小即传入的参数<code>n</code></li><li>物品的重量是平方数的值<code>sqr</code></li><li>物品的价值是<code>1</code>，因为我们要求的是数字个数</li></ul><p>题目转换为，能用 [1,n]  里的共<code>m</code>个平方数（物品）刚好装满空间为<code>n</code>的背包的所有方法中，产生价值最少的装法。<br>完全背包问题模板：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">记 dp[<span class="number">0.</span>.capa + <span class="number">1</span>] 是备忘录数组</span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span> to n</span><br><span class="line">    <span class="keyword">for</span> j = weight[i] to capa</span><br><span class="line">        dp[j] = max( dp[j] , dp[j - weight[i]] + val[i] )</span><br><span class="line">输出 dp[capa]</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &lt; b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> *dp = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        dp[i] = INT_MAX - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j*j &lt;= i; ++j)&#123;</span><br><span class="line">            dp[i] = min(dp[i],dp[i - j*j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><p>（十一届蓝桥C++-B组）</p><p>把 1 ∼ 2020 放在 2 × 1010 的矩阵里。</p><p>要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？</p><p>答案很大，你只需要给出方案数除以 2020 的余数即可。</p><p>题解：（动态规划）</p><p>用DP[i] [j]表示第一层有i个数，第二层有j个数有多少种方案</p><p>题目要求同一行中右边比左边大， 同一列中下边比上边的大，所以 j &lt;&#x3D; i</p><p>1.当j &lt; i 时， DP[i] [j]可以用此时少一个数的方案来表示，少一个数可以是DP[i - 1] [j]，也可以是DP[i] [j - 1]，所以：</p><p>DP[i] [j] &#x3D; DP[i - 1] [j] + DP[i] [j - 1]</p><p>2.当j &#x3D; i时， 因为要求，所以</p><p>DP[i] [j] &#x3D; DP[i] [j - 1]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> DP[<span class="number">1011</span>][<span class="number">1011</span>];</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">DP[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) DP[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">1010</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (i == j) DP[i][j] = DP[i][j - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">else</span> DP[i][j] = (DP[i - <span class="number">1</span>][j] + DP[i][j - <span class="number">1</span>]) % <span class="number">2020</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, DP[<span class="number">1010</span>][<span class="number">1010</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;   <span class="comment">// 两行一个数字都不放，也是一种方案</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1010</span>; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i - <span class="number">1</span> &gt;= j)    <span class="comment">// 转移前的状态也要合法，即第一行的数量不小于第二行的数量</span></span><br><span class="line">            f[i][j] += f[i - <span class="number">1</span>][j] % <span class="number">2020</span>;</span><br><span class="line">            <span class="keyword">if</span>(j - <span class="number">1</span> &gt;= <span class="number">0</span>)</span><br><span class="line">            f[i][j] += f[i][j - <span class="number">1</span>] % <span class="number">2020</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a><strong>背包问题</strong></h2><p>背包问题可以描述为：给定一组物品，每种物品都有自己的<strong>重量</strong>和<strong>价值</strong>，在<strong>限定的总重量</strong>内，如何选择才能使得物品的<strong>总价值</strong>最高。<br>背包问题是典型的动态规划问题。</p><p>而背包问题还存在需要<strong>恰好装满</strong>背包和<strong>不需要恰好装满</strong>两种情况</p><ol><li>01背包问题（每种物品只有一件，放或者不放）</li><li>完全背包问题（每件物品有无限件可用）</li><li>多重背包问题（每件物品有n[i]件可用）</li></ol><h3 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。求将哪些物品装入背包可使价值总和最大。</p><p>”01”的意思是：每种物品仅有一件，放为“1”，不放为“0”。<br>我们假定 f [i] [v] 为将前 i 件物品恰好放入一个容量为V的背包中可获得的最大价值。<br>则其状态转移方程是：</p><p><strong>f [i] [V]&#x3D;max{ f [i-1] [V] ,f [i-1] [V-weight[i] ]+value[i] }</strong></p><ul><li>公式中，即将前 i 件物品放入容量为V 的背包中：<ul><li>不放第 i 件：前 i - 1 件物品放入容量为V的背包中，价值为f [i - 1] [V] ;</li><li>放第 i 件：前 i - 1 件物品放入剩余容量为 V - weight[i] 的背包中，价值为f [i-1] [V-weight[i] ]+value[i]</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (weight[i] &lt;= j) &#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j], f[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>还可以将二维数组转化为一维数组，减少空间复杂度：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= weight[i]; --j)</span><br><span class="line">            f[j] = max(f[j], f[j - weight[i]] + value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><p>（在输出的时候，只能输出最后的价值，不能知道选择的物品是哪个。为此，在这里我们定义一个数组x[i]，对于每一个物品，如果被选择置为“1”，否则为“0”。）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V  100  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="type">int</span> N,M; </span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//动态规划分析</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=N; i++)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>; j&lt;=M; j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span> (weight[i]&lt;=j)  </span><br><span class="line">            &#123;  </span><br><span class="line">                f[i][j]=max(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-weight[i]]+value[i]);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">                f[i][j]=f[i<span class="number">-1</span>][j];  </span><br><span class="line">        &#125;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//输出选择的物品</span></span><br><span class="line">    <span class="type">int</span> j = M;</span><br><span class="line">    <span class="type">int</span> x[V];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=N; i&gt;<span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(f[i][j] &gt; f[i<span class="number">-1</span>][j])</span><br><span class="line">        &#123;</span><br><span class="line">            x[i<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">            j = j - weight[i<span class="number">-1</span>];<span class="comment">//装入第i-1个宝石后背包能装入的体积就只剩下j - V[i-1]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;N; ++i)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x[i]);  </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品的费用是weight[i]，价值是value[i]。每件物品可以无限选用，求将哪些物品装入背包可使价值总和最大。</p><p>完全背包问题不设定物品取用上限</p><p>对于算法的优化我们可以这样想：<br>在01背包问题中，我们要保证第i次循环中的f [i] [v]是由f [i-1] [ V-weight[i] ] 递推而来，每一次都是“加选出<strong>一个（即一种）</strong>物品”而这种方式同时也保证了每件物品只选一次。<br>而完全背包问题的特点刚好是每种物品可选无限件，所以在考虑“加选出<strong>一个（即一种）</strong>物品”时就是单纯的考虑“加选出<strong>一个（可能为同一种）</strong>物品”，这样我们就需要考虑选入的物品是已经选入的情况。相比来说，反而简化了代码。</p><p>同样，我们假定f [i] [v]为将前i件物品前恰好放入一个容量为V的背包中可获得的<strong>最大价值</strong><br>则其状态转移方程是：</p><p>*<em>f [i] [V]&#x3D;max{ f [i-1] [V]  ,  f [i-1] [ V-k</em>weight[i] ] + k <em>value[i] }</em>*</p><p>( 0&lt;&#x3D;k*weight[i]&lt;&#x3D;v，其中0&lt;&#x3D;k&lt;&#x3D;V&#x2F;weight[i+1]  )</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">           f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维数组：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j = weight[i]; j &lt;= V; ++j)</span><br><span class="line">        f[j] = max(f[j], f[j - weight[i]] + value[i]); </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M;  </span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    freopen(<span class="string">&quot;1.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;weight[i],&amp;value[i]); </span><br><span class="line">    &#125;  </span><br><span class="line">     <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= M; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k * weight[i] &lt;= j; ++k)</span><br><span class="line">            f[i][j] = max(f[i][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,f[N][M]);<span class="comment">//输出最优解  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h3><p>题目：</p><p>有N件物品和一个容量为V的背包。第i件物品最多有n[i]个，每个的费用是weight[i]，价值是value[i]。每件物品最多可以选用相应的最大个数，求将哪些物品装入背包可使价值总和最大。<br>多重背包问题设定物品选择上限</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br></pre></td></tr></table></figure><p>一维：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = V; j &gt;= <span class="number">0</span>; --j)</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">               f[j] = max(f[j], f[j - k * weight[i]] + k * value[i]);  </span><br></pre></td></tr></table></figure><p>具体代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span>    </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  V 1500  </span></span><br><span class="line"><span class="type">int</span> f[<span class="number">10</span>][V];<span class="comment">//全局变量，自动初始化为0  </span></span><br><span class="line"><span class="type">int</span> weight[<span class="number">10</span>];  </span><br><span class="line"><span class="type">int</span> value[<span class="number">10</span>];   </span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  max(x,y)   (x)&gt;(y)?(x):(y)  </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="comment">//f[i][v]=max&#123;f[i-1][v-k*c[i]]+k*w[i]|0&lt;=k*c[i]&lt;=v&#125;，其中0&lt;=k&lt;=V/weight[i+1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//f[j]=max(f[j],f[j-weight[i]]+value[i])    </span></span><br><span class="line">    <span class="type">int</span> N,M,cur;  </span><br><span class="line">    freopen(<span class="string">&quot;2.txt&quot;</span>,<span class="string">&quot;r&quot;</span>,<span class="built_in">stdin</span>); </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;N,&amp;M);<span class="comment">//N物品个数 M背包容量  </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;weight[i],&amp;value[i],&amp;num[i]); </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; ++i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++j)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= num[i] &amp;&amp; k * weight[i] &lt;= j; ++k)</span><br><span class="line">                f[i][j] = max(f[i<span class="number">-1</span>][j], f[i - <span class="number">1</span>][j - k * weight[i]] + k * value[i]);</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[N][M]);<span class="comment">//输出最优解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><p>LCS ：longest common sequence</p><p>子序列与子串不同，子序列：将给定序列中零个或多个元素去掉之后得到的结果；子串：给定串中任意个连续的字符组成的子序列称为该串的子串</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708770.png"></p><p>此问题有最优子结构性质：</p><p>设序列S<del>1</del>&#x3D;{x<del>1</del>,x<del>2</del>,……x<del>n</del>}和S<del>2</del>&#x3D; {y<del>1</del>,y<del>2</del>,……y<del>m</del>}的最长公共子序列为S&#x3D;{z<del>1</del>,z<del>2</del>,……z<del>k</del>}，则：</p><p>1）若x<del>n</del>&#x3D;y<del>m</del>，那么zk&#x3D;xn&#x3D;ym 且S[k-1]是S1[n-1]和S2[m-1]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del> !&#x3D; x<del>n</del>，则S[k]是S1[n-1]和S2[m]的最长公共子序列</p><p>2）若x<del>n</del> !&#x3D; y<del>m</del>且z<del>k</del>!&#x3D;y<del>m</del>，则S[k]是S1[n]和S2[m-1]的最长公共子序列</p><p>可见：两个序列的最长公共子序列包含了这两个序列的前缀的最长公共子序列。因此，最长公共子序列具有最优子结构性质，可以用动态规划求解。 </p><p><strong>递推公式：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708771.png" alt="image-20210409174359997"></p><p>为了求出LCS中具体的字符，再用一个表格b[i] [j] 表示dp[i] [j]与周边表格的关系（也可以使用dp[i] [j]来推，不必再建一个表格）。</p><p>即 S1[i] 和 S2[j] 值相等时dp[i] [j] 的值与右上的dp[i-1] [j-1]有关 ，用1表示 ，以此类推；</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232206589.png" alt="202203191708772"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232206196.png" alt="202203191708773"></p><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和是一个数组的某项下标之前(包括此项元素)的所有数组元素的和。</p><p>一维数组的前缀和 : sum[i] &#x3D; sum[i-1] + a[i] </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span>) y[i]=x[i];</span><br><span class="line">    <span class="keyword">else</span> y[i]=y[i<span class="number">-1</span>]+x[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组前缀和：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/webp" alt="img"></p><p>二维前缀和实际上就是一个矩阵内值的和，而矩阵又可以由两个行数或列数少一的子矩阵组合后，删去重合部分再加上右下角的值来构成，也就是以下式子：</p><p><img src="https://www.zhihu.com/equation?tex=b_%7Bx,y%7D=b_%7Bx-1,y%7D+b_%7Bx,y-1%7D-b_%7Bx-1,y-1%7D+a_%7Bx,y%7D" alt="[公式]"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/webp" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>;y&lt;n;y++)<span class="comment">//n行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">0</span>;x&lt;m;x++)<span class="comment">//m列</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>) b[y][x]=a[y][x];<span class="comment">//左上角的值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">0</span>) b[y][x]=b[y<span class="number">-1</span>][x]+a[y][x];<span class="comment">//第一列</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(y==<span class="number">0</span>) b[y][x]=b[y][x<span class="number">-1</span>]+a[y][x];<span class="comment">//第一行</span></span><br><span class="line">        <span class="keyword">else</span> b[y][x]=b[y<span class="number">-1</span>][x]+b[y][x<span class="number">-1</span>]-b[y<span class="number">-1</span>][x<span class="number">-1</span>]+a[y][x];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="前缀树-Trie"><a href="#前缀树-Trie" class="headerlink" title="前缀树   Trie"></a><strong>前缀树   Trie</strong></h1><p>Trie 是一颗非典型的多叉树模型，</p><p>多叉：即每个结点的分支数量可能为多个。</p><p>非典型：因为它和一般的多叉树不一样，尤其在结点的数据结构设计上，</p><p>比如一般的多叉树的结点是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    VALUETYPE value;    <span class="comment">//结点值</span></span><br><span class="line">    TreeNode* children[NUM];    <span class="comment">//指向孩子结点</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Trie 的结点是这样的(假设只包含’a’~’z’中的字符)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TrieNode</span> &#123;</span></span><br><span class="line">    <span class="type">bool</span> isEnd; <span class="comment">//该结点是否是一个串的结束</span></span><br><span class="line">    TrieNode* next[<span class="number">26</span>]; <span class="comment">//字母映射表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TrieNode结点中并没有直接保存字符值的数据成员，而是用 字母映射表 next ，TrieNode* next[26]中保存了对当前结点而言下一个可能出现的所有字符的链接，因此我们可以通过一个父结点来预知它所有子结点的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">    <span class="type">char</span> ch = <span class="string">&#x27;a&#x27;</span> + i;</span><br><span class="line">    <span class="keyword">if</span> (parentNode-&gt;next[i] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        说明父结点的后一个字母不可为 ch</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        说明父结点的后一个字母可以是 ch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Trie代码示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Trie[] children;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isEnd;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                node.children[index] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> searchPrefix(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">null</span> &amp;&amp; node.isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> searchPrefix(prefix) != <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Trie <span class="title function_">searchPrefix</span><span class="params">(String prefix)</span>&#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prefix.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> prefix.charAt(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ch - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(node.children[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="720-词典中最长的单词"><a href="#720-词典中最长的单词" class="headerlink" title="720.词典中最长的单词"></a>720.词典中最长的单词</h2><p>给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。</p><p>若无答案，则返回空字符串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;w&quot;,&quot;wo&quot;,&quot;wor&quot;,&quot;worl&quot;, &quot;world&quot;]</span><br><span class="line">输出：&quot;world&quot;</span><br><span class="line">解释： </span><br><span class="line">单词&quot;world&quot;可由&quot;w&quot;, &quot;wo&quot;, &quot;wor&quot;, 和 &quot;worl&quot;添加一个字母组成。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">words = [&quot;a&quot;, &quot;banana&quot;, &quot;app&quot;, &quot;appl&quot;, &quot;ap&quot;, &quot;apply&quot;, &quot;apple&quot;]</span><br><span class="line">输出：&quot;apple&quot;</span><br><span class="line">解释：</span><br><span class="line">&quot;apply&quot;和&quot;apple&quot;都能由词典中的单词组成。但是&quot;apple&quot;的字典序小于&quot;apply&quot;。</span><br></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>将所有单词插入 <code>trie</code>，然后从 <code>trie</code> 进行深度优先搜索，每找到一个单词表示该单词的全部前缀均存在，我们选取长度最长的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line">    String word; <span class="comment">// 用来保存当前遍历的 word</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxLength</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestWord</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        getMaxLengthWord(root, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 调用 insert()insert() 方法时：</span></span><br><span class="line"><span class="comment">若遍历的当前字符串 word 中的某个字符所在字母表中的位置上在对应 children[26] 数组中没有节点，即 **node.children[c - &#x27;a&#x27;] == null**，则在该位置上定义一个新的 Trie 节点并且 node 指向新定义的节点，即 **node = node.children[c - &#x27;a&#x27;]**。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当 word 全部遍历完成时，此时 node 为 word 中的最后一个位置上的节点，此时将 isEnd 设置为 true 表示该 word 已经遍历完并全部插入到 Trie 树中并将该 word 保存到最后一个节点上，即 **node.word = word**。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> word.length();</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> <span class="built_in">this</span>.root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> word.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (node.children[c - <span class="string">&#x27;a&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">                node.children[c - <span class="string">&#x27;a&#x27;</span>] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[c - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        node.isEnd = <span class="literal">true</span>;</span><br><span class="line">        node.word = word;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 当调用 **getMaxLengthWord()** 方法时：</span></span><br><span class="line"><span class="comment">若当前传入的节点不是最后一个位置上节点而是中间某位置的节点，此时直接结束。</span></span><br><span class="line"><span class="comment">若当前传入的节点的深度 deep &gt; maxLength，此时应该更新 maxLength的值并且将该节点对应的 word保存下来。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// 通过递归遍历 node 的 children 数组并且每遍历一次深度 deep 增加 1：DFS</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getMaxLengthWord</span><span class="params">(Trie node, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">0</span> &amp;&amp; !node.isEnd) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (deep &gt; maxLength) &#123;</span><br><span class="line">            res = node.word;</span><br><span class="line">            maxLength = deep;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历当前传入节点的 children[26]children[26] 对每一个不为空的节点都进行深度搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node.children[i] != <span class="literal">null</span>) &#123;</span><br><span class="line">                getMaxLengthWord(node.children[i], deep + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="题目顺序"><a href="#题目顺序" class="headerlink" title="题目顺序"></a>题目顺序</h1><p><strong>leetcode</strong></p><ul><li>数组Arrary：485，283，27</li><li>链表Linked List: 203,206</li><li>队列Queue：933，225（用队列实现<strong>栈</strong>），622，64</li><li>栈Atack：20，496，232（用栈实现队列）</li><li>哈希表Hash Table：217，389，496</li><li>集合Set：217，705（设计哈希集合）</li><li>堆Heap：215，692</li><li>树&#x2F;图：各种算法</li><li>双指针算法Two Pointers：141，344，881</li><li>二分查找法Binary Search(模板）：704，35，162，74</li><li>滑动窗口Sliding Window：209，1456</li><li>递归算法Recursion（开始练习时用笔画）：509，206，344，687</li><li>分治算法Divide &amp; Conquer：169，53</li><li>回溯算法Backtracking：22，78，77，46（全部非常经典）</li><li>深度优先搜索DFS：200，547，721</li><li>宽度优先搜索BFS：102，107，200</li><li>并查集Union Find（模板）：200，547，<strong>721</strong></li><li>贪心算法Greedy：<strong>322</strong>，1217，55</li><li>记忆化搜索Memoization：509，322</li><li><strong>动态规划</strong>Bynamic Bogramming：509，62，121，70，279，221</li><li>拓扑排序Topologic Sort：207，210</li><li>前缀Trie：208（模板），<strong>720</strong>，692</li></ul><h1 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h1><p>判断闰年：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//是闰年，m[2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反转数组：</p><p>Collections.reverse(ret);</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="欠缺"><a href="#欠缺" class="headerlink" title="欠缺"></a>欠缺</h2><p>数组：广义表</p><p>树：<del>层次遍历算法</del>，线索二叉树，<del>二叉搜索(排序)树BST，自平衡二叉树AVL（左旋右旋）</del>，<del>B树（多路平衡查找树）</del>，<del>B+树</del>，——红黑树</p><p>并查集：</p><p>图：</p><h2 id="数组-Arrarry"><a href="#数组-Arrarry" class="headerlink" title="数组  Arrarry"></a><strong>数组  Arrarry</strong></h2><p><a href="#java%E6%95%B0%E7%BB%84">java</a></p><p>C</p><ul><li>使用数组中的第 i + 1 个元素：1.数组名[i]  ;  或者使用指针*p &#x3D; &amp;数组：　*（p +ｉ）</li></ul><p>C 语言不允许返回一个完整的数组作为函数的参数。</p><p>想要从函数返回一个数组，需先声明一个返回指针的函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">myFunction</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C 不支持在函数外返回局部变量的地址，除非定义局部变量为 <strong>static</strong> 变量。</p><p>示例（生成随机数，并用数组返回）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="title function_">getRandom</span><span class="params">( )</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">static</span> <span class="type">int</span>  r[<span class="number">10</span>];</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 设置种子 */</span></span><br><span class="line">  srand( (<span class="type">unsigned</span>)time( <span class="literal">NULL</span> ) );</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)&#123;</span><br><span class="line">     r[i] = rand();</span><br><span class="line">     <span class="built_in">printf</span>( <span class="string">&quot;r[%d] = %d\n&quot;</span>, i, r[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* 要调用上面定义函数的主函数 */</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">()</span>&#123;</span><br><span class="line">   <span class="comment">/* 一个指向整数的指针 */</span></span><br><span class="line">   <span class="type">int</span> *p;</span><br><span class="line">   <span class="type">int</span> i;</span><br><span class="line"> </span><br><span class="line">   p = getRandom();</span><br><span class="line">   <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ ) &#123;</span><br><span class="line">       <span class="built_in">printf</span>( <span class="string">&quot;*(p + %d) : %d\n&quot;</span>, i, *(p + i));</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java数组"><p> <strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.数组创建</span></span><br><span class="line">        <span class="comment">//solution 1</span></span><br><span class="line">        <span class="type">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;a: &quot;</span> + Arrays.toString(a));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 2</span></span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;b: &quot;</span> + Arrays.toString(b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 3</span></span><br><span class="line">        <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            c[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;c: &quot;</span> + Arrays.toString(c));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//solution 4</span></span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr.add(i + <span class="number">1</span>);<span class="comment">//add方法：括号内为(数组索引值,元素），索引值可以不加，则将元素插入到末尾</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;arr: &quot;</span> + arr.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        arr.add(<span class="number">99</span>);        <span class="comment">//O(1)</span></span><br><span class="line">        arr.add(<span class="number">3</span>, <span class="number">88</span>);     <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> c[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">arr1</span> <span class="operator">=</span> arr.get(<span class="number">1</span>);      <span class="comment">//()里为索引值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.更新元素 ：O(1)</span></span><br><span class="line">        c[<span class="number">1</span>] = <span class="number">11</span>;</span><br><span class="line">        arr.set(<span class="number">1</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.删除元素 ： O(N)</span></span><br><span class="line">        arr.remove(<span class="number">1</span>);      <span class="comment">//删除下标为1处的元素</span></span><br><span class="line">        arr.remove(Integer.valueOf(<span class="number">4</span>));     <span class="comment">//删除第一个值为4的元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;      <span class="comment">//删除所有值为3的元素</span></span><br><span class="line">            <span class="keyword">if</span> (arr.get(i) == <span class="number">3</span>) &#123;</span><br><span class="line">                arr.remove(i--);        <span class="comment">//每删除一个元素后当前下标应-1，否则会漏掉下一个元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.数组长度 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cSize</span> <span class="operator">=</span> c.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">arrSize</span> <span class="operator">=</span> arr.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历数组 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> c[i];</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr.get(i);</span><br><span class="line">            System.out.println(<span class="string">&quot;c at index &quot;</span> + i + <span class="string">&quot;: &quot;</span> + current);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//8.查找元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == <span class="number">99</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;we found 99 at int c!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">is99</span> <span class="operator">=</span> arr.contains(<span class="number">99</span>);    <span class="comment">//找到目标值则返回True</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//9. 数组排序 : O(N logN)</span></span><br><span class="line">        Arrays.sort(c);</span><br><span class="line">        Collections.sort(arr);  <span class="comment">//升序排列</span></span><br><span class="line">        Collections.sort(arr, Collections.reverseOrder());  <span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="数组的时间复杂度"><a href="#数组的时间复杂度" class="headerlink" title="数组的时间复杂度"></a>数组的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（N）</p><p>删除（Delete）：O（N）</p><h2 id="链表-Linked-List"><a href="#链表-Linked-List" class="headerlink" title="链表  Linked List"></a><strong>链表  Linked List</strong></h2><p><a href="#java%E9%93%BE%E8%A1%A8">java</a></p><p> <strong>C</strong></p><p>创建链表：</p><p>创建结构变量指针，使用前要先分配内存空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建链表</span></span><br><span class="line">LinkList *<span class="title function_">CreatList</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *head = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    LinkList *temp = head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        LinkList *a = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a-&gt;data);</span><br><span class="line">        a-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        temp-&gt;next = a;</span><br><span class="line">        temp = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//修改链表结点的值</span></span><br><span class="line">LinkList  <span class="title function_">changeList</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; n &amp;&amp; temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;请输入要修改的值：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;结点不存在&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向链表的第n个位置插入数据</span></span><br><span class="line">LinkList *<span class="title function_">insert</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;   <span class="comment">//temp用于表示插入位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;插入位置无效\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        temp =  temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList  *in = (LinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkList));</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;in-&gt;data);</span><br><span class="line">    in-&gt;next = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = in;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除链表中第n个节点</span></span><br><span class="line">LinkList *<span class="title function_">delete</span><span class="params">(LinkList *<span class="built_in">list</span>, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;    <span class="comment">//temp用于表示删除位置的上一个结点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkList *del = temp-&gt;next;</span><br><span class="line">    temp-&gt;next = temp-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(del);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">display</span><span class="params">(LinkList *<span class="built_in">list</span>)</span>&#123;</span><br><span class="line">    LinkList *temp = <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">while</span>(temp-&gt;next)&#123;</span><br><span class="line">        temp = temp-&gt;next;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="头插法和尾插法："><a href="#头插法和尾插法：" class="headerlink" title="头插法和尾插法："></a>头插法和尾插法：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>, *<span class="title">q</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">p=head;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">q=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q-&gt;data);</span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next=q;</span><br><span class="line">p=q;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat_1</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>;</span></span><br><span class="line">head-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">p=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p-&gt;data);</span><br><span class="line">p-&gt;next=head-&gt;next;</span><br><span class="line">head-&gt;next=p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">output</span><span class="params">(<span class="keyword">struct</span> <span class="built_in">list</span> *head)</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">p</span>=</span>head-&gt;next;</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d  &quot;</span>, p-&gt;data);</span><br><span class="line">p=p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;\n\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list</span> *<span class="title">head</span>;</span></span><br><span class="line">head=(<span class="keyword">struct</span> <span class="built_in">list</span>*)<span class="built_in">malloc</span>( <span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="built_in">list</span>) );</span><br><span class="line">creat(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line"></span><br><span class="line">creat_1(head, <span class="number">5</span>);</span><br><span class="line">output(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java链表"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建链表</span></span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素</span></span><br><span class="line">        list.add(<span class="number">1</span>);    <span class="comment">//O(1)</span></span><br><span class="line">        list.add(<span class="number">2</span>, <span class="number">99</span>); <span class="comment">//O(N)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.访问元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">element</span> <span class="operator">=</span> list.get(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.搜索元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> list.indexOf(<span class="number">99</span>);   <span class="comment">//搜索元素值，然后返回索引值(下标)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.更新元素 : O(N)</span></span><br><span class="line">        list.set(<span class="number">2</span>,<span class="number">88</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//6.删除元素 : O(N)</span></span><br><span class="line">        list.remove(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203.移除链表元素"></a>203.移除链表元素</h4><p>给你一个链表的头节点 <code>head</code> 和一个整数 <code>val</code> ，请你删除链表中所有满足 <code>Node.val == val</code> 的节点，并返回 <strong>新的头节点</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,6,3,4,5,6], val = 6</span><br><span class="line">输出：[1,2,3,4,5]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除头节点</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">while</span> (temp.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp.next.val == val)&#123;</span><br><span class="line">                temp.next = temp.next.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> temp = temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//设置哨兵节点，便于删除链表头部节点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeElements</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">sentinel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);<span class="comment">//sentinel：哨兵</span></span><br><span class="line">        sentinel.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> ans, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(curr.val == val)&#123;</span><br><span class="line">                prev.next = curr.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                prev = curr;</span><br><span class="line">            &#125;</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sentinel.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206.反转链表"></a>206.反转链表</h4><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Java</span></span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line"> <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curr</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">prev</span> <span class="operator">=</span> <span class="literal">null</span>, curr = head;</span><br><span class="line">        <span class="keyword">while</span>(curr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表的时间复杂度"><a href="#链表的时间复杂度" class="headerlink" title="链表的时间复杂度"></a>链表的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="队列-Queue"><a href="#队列-Queue" class="headerlink" title="队列  Queue"></a><strong>队列  Queue</strong></h2><p><a href="#java%E9%98%9F%E5%88%97">java</a></p><p><strong>C</strong></p><p>判断队列是否为空：</p><ol><li>设置一个标志变量；</li><li>当队列满时，保留一个元素空间；设队列最大尺寸为QueueSize，则<strong>队列满的条件是：（rear+1）%QueueSize &#x3D;&#x3D; front</strong>。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QuDataType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QListNode</span> *_<span class="title">next</span>;</span></span><br><span class="line">    QuDataType _data;</span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列的结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&#123;</span></span><br><span class="line">    QueueNode *_front;</span><br><span class="line">    QueueNode *_rear;</span><br><span class="line">&#125;Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue *q)</span>;<span class="comment">//初始化队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue *q,QuDataType data)</span>;<span class="comment">//队尾入队列</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue *q)</span>;<span class="comment">//队头出队列</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列头部元素</span></span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列队尾元素</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>;<span class="comment">// 获取队列中有效元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>;<span class="comment">// 检测队列是否为空，如果为空返回非零结果，如果非空返回0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestroy</span><span class="params">(Queue* q)</span>;<span class="comment">// 销毁队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//一个数据入队列必须要先创建节点</span></span><br><span class="line">QueueNode * <span class="title function_">BuyQueueNode</span><span class="params">(QuDataType x)</span>&#123;    <span class="comment">//创建节点并初始化此节点</span></span><br><span class="line">    QueueNode * cur = (QueueNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    cur-&gt;_data = x;</span><br><span class="line">    cur-&gt;_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueInit</span><span class="params">(Queue* q)</span>&#123; <span class="comment">//初始化队列结构</span></span><br><span class="line">    q-&gt;_front = <span class="literal">NULL</span>;</span><br><span class="line">    q-&gt;_rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePush</span><span class="params">(Queue* q, QuDataType x)</span> &#123; <span class="comment">//队列尾部入数据</span></span><br><span class="line">    QueueNode * cur = BuyQueueNode(x);  <span class="comment">//先把创建好的节点传过来</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;             <span class="comment">//若是队列本身为空，队列里就只有这一个节点，又为队列头又为队列尾</span></span><br><span class="line">        q-&gt;_front = q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        q-&gt;_rear-&gt;_next = cur; <span class="comment">//否则，链表尾插操作</span></span><br><span class="line">        q-&gt;_rear = cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueuePop</span><span class="params">(Queue* q)</span> &#123;    <span class="comment">//队列头部出数据</span></span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;    <span class="comment">//本身队列为空，不做操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode* tmp = q-&gt;_front-&gt;_next;   <span class="comment">//先保留下一个节点，防止断链</span></span><br><span class="line">    <span class="built_in">free</span>(q-&gt;_front);</span><br><span class="line">    q-&gt;_front = tmp;   <span class="comment">//更新对列头部</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueFront</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//获取队列首部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QuDataType <span class="title function_">QueueBack</span><span class="params">(Queue* q)</span>&#123;<span class="comment">//获取队列尾部元素</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_rear-&gt;_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueEmpty</span><span class="params">(Queue* q)</span>&#123;   <span class="comment">//判断队列是否为空</span></span><br><span class="line">    <span class="keyword">return</span> q-&gt;_front == <span class="literal">NULL</span>;   <span class="comment">//为空，返回1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">QueueSize</span><span class="params">(Queue* q)</span>&#123;  <span class="comment">//获取队列中的元素个数</span></span><br><span class="line">    QueueNode * cur;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur = q-&gt;_front; cur; cur = cur-&gt;_next)<span class="comment">//循环遍历，计数即可</span></span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">QueueDestory</span><span class="params">(Queue* q)</span>  <span class="comment">//销毁队列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;_front == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q-&gt;_front)&#123;</span><br><span class="line">        QueuePop(q);<span class="comment">//对每一个元素迭代出队即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    Queue q;</span><br><span class="line">    QueueInit(&amp;q);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">1</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">2</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">3</span>);</span><br><span class="line">    QueuePush(&amp;q, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q)); <span class="comment">//1</span></span><br><span class="line">    QueuePop(&amp;q);<span class="comment">//出队列</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueFront(&amp;q));<span class="comment">//2   此时队首为2</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, QueueBack(&amp;q));<span class="comment">//4  队尾为4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a name = "java队列"><p><strong>java</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建队列</span></span><br><span class="line">        <span class="comment">//用LinkedList(链表)作为对象,插入和删除操作时间复杂度只有O(1)</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加元素 :O(1)</span></span><br><span class="line">        queue.add(<span class="number">1</span>);</span><br><span class="line">        queue.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.获取即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp1</span> <span class="operator">=</span> queue.peek();</span><br><span class="line">        System.out.println(temp1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.删除即将出队的元素 ：O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp2</span> <span class="operator">=</span> queue.poll();   <span class="comment">//返回值，并将其删除 </span></span><br><span class="line">        System.out.println(temp2);</span><br><span class="line">        System.out.println(queue.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.判断队列是否为空 ：O(1)</span></span><br><span class="line">        System.out.println(queue.isEmpty());    <span class="comment">//队列空则返回True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.队列长度 ：O(1)</span></span><br><span class="line">        <span class="comment">//创建链表时会有一个变量，当加入一个元素时变量加1，获取长度时会直接返回这个变量值</span></span><br><span class="line">        System.out.println(queue.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//7.遍历队列 :O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="933-最近的请求次数"><a href="#933-最近的请求次数" class="headerlink" title="933.最近的请求次数"></a>933.最近的请求次数</h4><p>写一个 RecentCounter 类来计算特定时间范围内最近的请求。</p><p>请你实现 RecentCounter 类：</p><p>RecentCounter() 初始化计数器，请求数为 0 。<br>int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。<br>保证 每次对 ping 的调用都使用比之前更大的 t 值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]</span><br><span class="line">[[], [1], [100], [3001], [3002]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 2, 3, 3]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RecentCounter</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">RecentCounter</span><span class="params">()</span> &#123;</span><br><span class="line">        q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ping</span><span class="params">(<span class="type">int</span> t)</span> &#123;</span><br><span class="line">        q.add(t);</span><br><span class="line">        <span class="keyword">while</span>(q.peek() &lt; t - <span class="number">3000</span>)&#123;</span><br><span class="line">            q.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="225-用队列实现栈"><a href="#225-用队列实现栈" class="headerlink" title="225.用队列实现栈"></a>225.用队列实现栈</h4><p>利用两个队列 来实现栈的基本操作：进栈，显示栈顶元素，删除栈顶元素，判空f</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span>&#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue1;</span><br><span class="line">    Queue&lt;Integer&gt; queue2;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        queue2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        queue2.add(x);</span><br><span class="line">        <span class="keyword">while</span> (!queue1.isEmpty())&#123;</span><br><span class="line">            queue2.add(queue1.poll());</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Integer&gt; temp = queue1;</span><br><span class="line">        queue1 = queue2;</span><br><span class="line">        queue2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="622-设计循环队列"><a href="#622-设计循环队列" class="headerlink" title="622.设计循环队列"></a>622.设计循环队列</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] queue;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="type">int</span> rear;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        capacity = k;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        rear = <span class="number">0</span>;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == capacity) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        queue[rear] = value;</span><br><span class="line">        rear = (rear + <span class="number">1</span>) % capacity;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            index = (index + <span class="number">1</span>) % capacity;</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> queue[(rear + capacity - <span class="number">1</span>) % capacity];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">count</span> <span class="operator">=</span>= capacity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Deque（双端队列）"><a href="#Deque（双端队列）" class="headerlink" title="Deque（双端队列）"></a>Deque（双端队列）</h4><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p><ul><li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li></ul><p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure><p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p><p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p><p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure><p>创建 ArrayDeque实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure><p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure><p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p><p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()</p><p>方法具体说明：</p><p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p><p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure><p><strong>获取元素：</strong></p><p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p><p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement的值是: “first element”。</p><p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p><p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure><p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p><p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure><p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure><p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure><p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p><p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure><p>执行完代码后size大小是2，因为Deque中包含两个元素。</p><p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p><p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p><p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的时间复杂度"><a href="#队列的时间复杂度" class="headerlink" title="队列的时间复杂度"></a>队列的时间复杂度</h3><p>访问（Access）：O（N）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈   Stack"></a><strong>栈   Stack</strong></h2><p><strong>java：</strong></p><p>（Java堆栈Stack已经过时，推荐使用Deque替代Stack。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建栈</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取栈顶元素 : O(1)</span></span><br><span class="line">        stack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除栈顶元素 : O(1)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> stack.pop(); <span class="comment">//pop方法会删除元素并返回被删除的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的大小 : O(1)</span></span><br><span class="line">        stack.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈是否为空 : O(1)</span></span><br><span class="line">        stack.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//栈的遍历 : O(N)</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            System.out.println(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>单调栈中存放的数据应该是有序的，所以单调栈也分为<strong>单调递增栈</strong>和<strong>单调递减栈</strong></p><ul><li>单调递增栈：单调递增栈就是从栈底到栈顶数据是从大到小</li><li>单调递减栈：单调递减栈就是从栈底到栈顶数据是从小到大</li></ul><p>假设：</p><p>现在有一组数10，3，7，4，12。从左到右依次入栈，则如果栈为空或入栈元素值小于栈顶元素值，则入栈；否则，如果入栈则会破坏栈的单调性，则需要把比入栈元素小的元素全部出栈。单调递减的栈反之。 </p><p>10入栈时，栈为空，直接入栈，栈内元素为10。</p><p>3入栈时，栈顶元素10比3大，则入栈，栈内元素为10，3。</p><p>7入栈时，栈顶元素3比7小，则栈顶元素出栈，此时栈顶元素为10，比7大，则7入栈，栈内元素为10，7。</p><p>4入栈时，栈顶元素7比4大，则入栈，栈内元素为10，7，4。</p><p>12入栈时，栈顶元素4比12小，4出栈，此时栈顶元素为7，仍比12小，栈顶元素7继续出栈，此时栈顶元素为10，仍比12小，10出栈，此时栈为空，12入栈，栈内元素为12。</p><p><strong>伪代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">stack</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">for</span> <span class="params">(遍历这个数组)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (栈空 || 栈顶元素大于等于当前比较元素)</span><br><span class="line">&#123;</span><br><span class="line">入栈;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (栈不为空 &amp;&amp; 栈顶元素小于当前元素)</span><br><span class="line">&#123;</span><br><span class="line">栈顶元素出栈;</span><br><span class="line">更新结果;</span><br><span class="line">&#125;</span><br><span class="line">当前数据入栈;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。</p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character, Character&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Character&gt;();</span><br><span class="line">        hash.put(<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>);</span><br><span class="line">        hash.put(<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        Deque&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (hash.containsKey(c)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != hash.get(c)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="496-下一个更大元素1"><a href="#496-下一个更大元素1" class="headerlink" title="496.下一个更大元素1"></a>496.下一个更大元素1</h3><p>给定两个<strong>没有重复元素</strong>的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。</p><p>请你找出 nums1 中每个元素在 nums2 中的下一个比其大的值。</p><p>nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出 -1 。</p><p>示例 :</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [4,1,2], nums2 = [1,3,4,2].</span><br><span class="line">输出: [-1,3,-1]</span><br><span class="line">解释:</span><br><span class="line">    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。</span><br><span class="line">    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。</span><br><span class="line">    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums1.length, m = nums2.length;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; nums2[i] &gt; stack.peek())&#123;</span><br><span class="line">                map.put(stack.pop(),nums2[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums2[i],-<span class="number">1</span>);</span><br><span class="line">            stack.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            nums1[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="232-用栈实现队列"><a href="#232-用栈实现队列" class="headerlink" title="232.用栈实现队列"></a>232.用栈实现队列</h3><p>只使用两个栈，实现一个先入先出的队列（push,pop,peek,empty)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//stack1中的数据依次出栈并入栈stack2</span></span><br><span class="line">    <span class="comment">//数据进栈stack2</span></span><br><span class="line">    <span class="comment">//stack2中数据依次出栈并入栈stack1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack1.isEmpty())&#123;</span><br><span class="line">            stack2.push(stack1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        stack2.push(x);</span><br><span class="line">        <span class="keyword">while</span> (!stack2.isEmpty())&#123;</span><br><span class="line">            stack1.push(stack2.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack1.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的时间复杂度"><a href="#栈的时间复杂度" class="headerlink" title="栈的时间复杂度"></a>栈的时间复杂度</h3><p>访问（Access）：O（1）</p><p>搜索（Search）：O（N)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="字符串-String"><a href="#字符串-String" class="headerlink" title="字符串   String"></a><strong>字符串   String</strong></h2><p>字符串输入：</p><ol><li><p>数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">6</span>] = <span class="string">&quot;array&quot;</span>;</span><br><span class="line"><span class="type">char</span> arr[] = <span class="string">&quot;array&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;pointer&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s %c %c&quot;</span>,p,*p,*(p + <span class="number">2</span>));   <span class="comment">//第一个输出字符串；第二个输出指针指向，即字符串的第一个字符；第三个输出字符串中 第三个字符</span></span><br></pre></td></tr></table></figure></li><li><p>数组&#x2F;指针 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">6</span>];</span><br><span class="line">scang(<span class="string">&quot;%s\n&quot;</span>,arr1);</span><br><span class="line">gets(arr1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *arr2 = (<span class="type">char</span>*)<span class="built_in">malloc</span>( <span class="number">100</span>*<span class="keyword">sizeof</span>(<span class="type">char</span>) );  <span class="comment">//记得为指针数组分配内存，否则会报错之类的</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s\n&quot;</span>,arr2);</span><br><span class="line">gets(arr2);</span><br></pre></td></tr></table></figure><p>（scanf只能输入一个单词，当遇到空格时会认为字符串结束；gets函数只知道数组的开始，并不知道数组的大小，如果输入过长容易溢出，并可能擦掉程序中的其他数据）</p></li><li><p>使用while完成多组测试，而不是在输入完一组数据后退出控制台</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr1[<span class="number">100</span>],arr2[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> a;   </span><br><span class="line"><span class="keyword">while</span>((a = <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,arr1,arr2)) != EOF)&#123;     <span class="comment">//也可用while((a = getchar(arr1)) != &#x27;\n&#x27;)</span></span><br><span class="line">    pritnf(<span class="string">&quot;scanf返回l %d,s1是%s，s2是%s&quot;</span>，a,arr1,arr2);   <span class="comment">//这行输出后可以继续进行输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="KMP模式匹配"><a href="#KMP模式匹配" class="headerlink" title="KMP模式匹配"></a>KMP模式匹配</h3><p>KMP算法实现过程接近人为模式匹配</p><ul><li>匹配失败后，模式串移动的距离和主串无关，只与模式串本身有关，模式串后移等价于指针j前移。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2-1Q212223I41Z.gif" alt="模式串后移等价于 j 前移"></p><p>因此，我们可以给每个模式串配备一个数组（例如 next[]），用于存储模式串中每个字符对应指针 j 重定向的位置（也就是存储模式串的数组下标），比如 j&#x3D;3，则该字符匹配失败后指针 j 指向模式串中第 3 个字符。</p><p>模式串中各字符对应 <strong>next 值</strong>的计算方式是，取该字符前面的字符串（不包含自己），其<strong>前缀字符串和后缀字符串相同字符的最大个数再 +1</strong> 就是该字符对应的 next 值。</p><p>（模式串中第一个字符对应的值为 0，第二个字符对应 1 ，这是固定不变的。）</p><h4 id="Next函数"><a href="#Next函数" class="headerlink" title="Next函数"></a>Next函数</h4><p>一般的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样可能会有多余的操作，如：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2-1Q212224002945.gif" alt="Next函数的缺陷"></p><p>当匹配失败时，Next 函数会由图 10b) 开始继续进行模式匹配，但是从图中可以看到，这样做是没有必要的。</p><p>如此，问题在当 T[i-1]&#x3D;&#x3D;T[j-1] 成立时，没有继续对 i++ 和 j++ 后的 T[i-1] 和 T[j-1] 的值做判断。</p><p>因此改进后的Next函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123; </span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    next[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (T[i<span class="number">-1</span>]!=T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">               next[i]=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                next[i]=next[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="KMP实现"><a href="#KMP实现" class="headerlink" title="KMP实现"></a>KMP实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Next</span><span class="params">(<span class="type">char</span>*T,<span class="type">int</span> *next)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span>||T[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            next[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">char</span> * S,<span class="type">char</span> * T)</span>&#123;</span><br><span class="line">    <span class="type">int</span> next[<span class="number">10</span>];</span><br><span class="line">    Next(T,next);<span class="comment">//根据模式串T,初始化next数组</span></span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=<span class="built_in">strlen</span>(S)&amp;&amp;j&lt;=<span class="built_in">strlen</span>(T)) &#123;</span><br><span class="line">        <span class="comment">//j==0:代表模式串的第一个字符就和当前测试的字符不相等；S[i-1]==T[j-1],如果对应位置字符相等，两种情况下，指向当前测试的两个指针下标i和j都向后移</span></span><br><span class="line">        <span class="keyword">if</span> (j==<span class="number">0</span> || S[i<span class="number">-1</span>]==T[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            j=next[j];<span class="comment">//如果测试的两个字符不相等，i不动，j变为当前测试字符串的next值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j&gt;<span class="built_in">strlen</span>(T)) &#123;<span class="comment">//如果条件为真，说明匹配成功</span></span><br><span class="line">        <span class="keyword">return</span> i-(<span class="type">int</span>)<span class="built_in">strlen</span>(T);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i=KMP(<span class="string">&quot;ababcabcacbab&quot;</span>,<span class="string">&quot;abcac&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="散列表（Hash）"><a href="#散列表（Hash）" class="headerlink" title="散列表（Hash）"></a><strong>散列表（Hash）</strong></h2><ul><li><p><strong>哈希表</strong>（hashtable），又叫散列表，是根据关键码（key）来进行访问的数据结构，通过哈希函数把key转成哈希值来定位数据存储的位置。通常是键-值对（即key-value）的结构，即用key算出的哈希值来定位存储位置，在该位置上存储内容为value。</p></li><li><p><strong>哈希集合</strong>（hashset），也是一种通过哈希值来定位存储位置的数据结构，只是它不是键-值对结构，而是储存key本身，相当于只有哈希表（hashtable）的key部分，即用key算出的哈希值来定位存储位置，在该位置上存储内容为key本身。<br>简单来说就是，哈希集合是不能存储重复元素的数据结构（集合），而哈希表是存储键-值对（key-value），其中键key不能重复。</p></li><li><p><strong>哈希映射</strong>（hashmap）是和哈希表（hashtable）相似的数据结构，也是键-值对存储，只是哈希映射是线程安全的，而哈希表是非线程安全的。所谓线程安全，就是多线程同时操作数据的时候，能确保在同一时刻只能有一个线程能访问同一个数据（也就是会给数据操作加锁）；如果不能确保这个，就是非线程安全。</p></li></ul><p>哈希表 可能存在特殊情况，就是通过不同的 Key，可能访问到同一个地址，这种现象叫作碰撞（Collision）。而通过某个 Key 一定会得到唯一的 Value 地址。</p><p>目前，这个哈希函数比较常用的实现方法比较多，通常需要考虑几个因素：关键字的长度、哈希表的大小、关键字的分布情况、记录的查找频率，等等。</p><p>下面简单<strong>介绍几种哈希函数</strong>。</p><ul><li>直接寻址法：取关键字或关键字的某个线性函数值为散列地址。</li><li>数字分析法：通过对数据的分析，发现数据中冲突较少的部分，并构造散列地址。例如同学们的学号，通常同一届学生的学号，其中前面的部分差别不太大，所以用后面的部分来构造散列地址。</li><li>平方取中法：当无法确定关键字里哪几位的分布相对比较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为散列地址。这是因为：计算平方之后的中间几位和关键字中的每一位都相关，所以不同的关键字会以较高的概率产生不同的散列地址。</li><li>取随机数法：使用一个随机函数，取关键字的随机值作为散列地址，这种方式通常用于关键字长度不同的场合。</li><li><strong>除留取余法</strong>：取关键字被某个不大于散列表的表长 n 的数 m 除后所得的余数 p 为散列地址。这种方式也可以在用过其他方法后再使用。该函数对 m 的选择很重要，一般取<strong>素数</strong>或者直接用 n。</li></ul><p><strong>对散列表函数产生冲突的解决办法</strong>：</p><p>​有时不同的 Key 通过哈希函数可能会得到相同的地址，这在我们操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 Key 计算之后获得了相同的地址。</p><p>冲突的处理方式也有很多，下面介绍几种。</p><ul><li><strong>开放地址法</strong>（也叫<strong>线性探测</strong>）：实际上就是当需要存储值时，对Key哈希之后，发现这个地址已经有值了，这时该怎么办？不能放在这个地址，不然之前的映射会被覆盖。这时对计算出来的地址进行一个探测再哈希，比如往后移动一个地址，如果没人占用，就用这个地址。如果超过最大长度，则可以对总长度取余。这里移动的地址是产生冲突时的增列序量。(如  f（key) &#x3D; {  f(key + d)  } % m）</li><li><strong>再哈希法</strong>：在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。这种方式的缺点是时间增加了。</li><li><strong>链地址法</strong>：链地址法其实就是对Key通过哈希之后落在同一个地址上的值，做一个链表。其实在很多高级语言的实现当中，也是使用这种方式处理冲突的，我们会在后面着重学习这种方式。</li><li><strong>建立一个公共溢出区</strong>：这种方式是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</li></ul><h3 id="散列表实现"><a href="#散列表实现" class="headerlink" title="散列表实现"></a>散列表实现</h3><p><a href="java%E6%95%A3%E5%88%97%E8%A1%A8">java</a></p><p><strong>C：</strong></p><h5 id="实现简单的哈希表"><a href="#实现简单的哈希表" class="headerlink" title="实现简单的哈希表"></a>实现简单的哈希表</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12   <span class="comment">//定义散列表长为数组的长度</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;    <span class="comment">// 数据元素存储基址，动态分配数组</span></span><br><span class="line">    <span class="type">int</span> count;    <span class="comment">// 当前数据元素个数</span></span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m = <span class="number">0</span>;   <span class="comment">//散列表表长，全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化散列表</span></span><br><span class="line">Status <span class="title function_">InterHashTable</span><span class="params">(HashTable *H)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m = HASHSIZE;</span><br><span class="line">    H-&gt;count = m;</span><br><span class="line">    H-&gt;elem = (<span class="type">int</span> *) <span class="built_in">malloc</span>(m * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        H-&gt;elem[i] = NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;     <span class="comment">//除留余数法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入关键字进散列表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">IntertHash</span><span class="params">(HashTable *H, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);   <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H-&gt;elem[addr] != NULLKEY)    <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        addr = (addr + <span class="number">1</span>) % m;      <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">    H-&gt;elem[addr] = key;        <span class="comment">//直到有空位后插入关键字</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//散列表查找关键字</span></span><br><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H, <span class="type">int</span> key, <span class="type">int</span> *addr)</span> &#123;</span><br><span class="line">    *addr = Hash(key);                 <span class="comment">//求散列地址</span></span><br><span class="line">    <span class="keyword">while</span> (H.elem[*addr] != key) &#123;        <span class="comment">//如果不为空，则冲突</span></span><br><span class="line">        *addr = (*addr + <span class="number">1</span>) % m;            <span class="comment">//开放地址法的线性探测</span></span><br><span class="line">        <span class="keyword">if</span> (H.elem[*addr] == NULLKEY || *addr == Hash(key)) &#123;     <span class="comment">//如果循环回到原点</span></span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;       <span class="comment">//则说明关键字不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">12</span>] = &#123;<span class="number">12</span>, <span class="number">67</span>, <span class="number">56</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">37</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">15</span>, <span class="number">47</span>, <span class="number">48</span>, <span class="number">34</span>&#125;;</span><br><span class="line">    HashTable H;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    InterHashTable(&amp;H);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        IntertHash(&amp;H, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;插入之后的哈希表为：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, H.elem[i]);</span><br><span class="line">    <span class="type">int</span> addr, j;</span><br><span class="line">    j = SearchHash(H, a[<span class="number">5</span>], &amp;addr);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;搜索到a[5]的地址是：%d&quot;</span>, j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希集合"><a href="#实现哈希集合" class="headerlink" title="实现哈希集合"></a>实现哈希集合</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;val = x;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">&#125;&#125;&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">listContains</span><span class="params">(<span class="keyword">struct</span> List *head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List *it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;val == x) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List *head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashSet;</span><br><span class="line"></span><br><span class="line">MyHashSet *<span class="title function_">myHashSetCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashSet *ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashSet));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetAdd</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">if</span> (!listContains(&amp;(obj-&gt;data[h]), key)) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetRemove</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">myHashSetContains</span><span class="params">(MyHashSet *obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="keyword">return</span> listContains(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashSetFree</span><span class="params">(MyHashSet *obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="实现哈希映射"><a href="#实现哈希映射" class="headerlink" title="实现哈希映射"></a>实现哈希映射</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listPush</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));</span><br><span class="line">    tmp-&gt;key = key;</span><br><span class="line">    tmp-&gt;val = val;</span><br><span class="line">    tmp-&gt;next = head-&gt;next;</span><br><span class="line">    head-&gt;next = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listDelete</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> it-&gt;next;</span><br><span class="line">            it-&gt;next = tmp-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(tmp);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> List* <span class="title function_">listFind</span><span class="params">(<span class="keyword">struct</span> List* head, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">struct</span> List* it = head; it-&gt;next; it = it-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it-&gt;next-&gt;key == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> it-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">listFree</span><span class="params">(<span class="keyword">struct</span> List* head)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">tmp</span> =</span> head-&gt;next;</span><br><span class="line">        head-&gt;next = tmp-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> base = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> key % base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">data</span>;</span></span><br><span class="line">&#125; MyHashMap;</span><br><span class="line"></span><br><span class="line">MyHashMap* <span class="title function_">myHashMapCreate</span><span class="params">()</span> &#123;</span><br><span class="line">    MyHashMap* ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MyHashMap));</span><br><span class="line">    ret-&gt;data = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List) * base);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        ret-&gt;data[i].key = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].val = <span class="number">0</span>;</span><br><span class="line">        ret-&gt;data[i].next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapPut</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        listPush(&amp;(obj-&gt;data[h]), key, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rec-&gt;val = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">myHashMapGet</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">List</span>* <span class="title">rec</span> =</span> listFind(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">    <span class="keyword">if</span> (rec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rec-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapRemove</span><span class="params">(MyHashMap* obj, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h = hash(key);</span><br><span class="line">    listDelete(&amp;(obj-&gt;data[h]), key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myHashMapFree</span><span class="params">(MyHashMap* obj)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; base; i++) &#123;</span><br><span class="line">        listFree(&amp;(obj-&gt;data[i]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(obj-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a neme = "java散列表"><p><strong>java：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建哈希表</span></span><br><span class="line">        String[] hashTable = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>]; <span class="comment">//用数组创建</span></span><br><span class="line">        HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//用HashMap方法</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//更新元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">&quot;world&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        hashTable[<span class="number">1</span>] = <span class="string">&quot;&quot;</span>; <span class="comment">//将其改为不会用到的值</span></span><br><span class="line">        map.remove(<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取元素 : O(1)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> hashTable[<span class="number">1</span>];</span><br><span class="line">        map.get(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//检查key是否存在 : O(1)</span></span><br><span class="line">        map.containsKey(<span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//长度，是否为空 : O(1)</span></span><br><span class="line">        map.size();</span><br><span class="line">        </span><br><span class="line">        map.isEmpty();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取指定key对应的value，如果找不到key，则返回设置的默认值。</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h3><p>散列表有两种用法：一种是 Key 的值与 Value 的值一样，一般我们称这种情况的结构为 Set（集合）；而如果 Key 和 Value 所对应的内容不一样时，那么我们称这种情况为 Map，也就是人们俗称的键值对集合。</p><p>根据散列表的存储结构，我们可以得出散列表的以下特点。</p><ol><li><strong>访问速度很快</strong></li></ol><p>由于散列表有散列函数，可以将指定的 Key 都映射到一个地址上，所以在访问一个 Key（键）对应的 Value（值）时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以我们在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</p><ol start="2"><li><strong>需要额外的空间</strong></li></ol><p>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。</p><p>这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</p><p><strong>3) 无序</strong></p><p>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</p><p><strong>4) 可能会产生碰撞</strong></p><p>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</p><h3 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h3><p>根据散列表的特点可以想到，散列表比较适合无序、需要快速访问的情况。</p><p><strong>缓存</strong></p><p>通常我们开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如我们要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 Key，而 Value 用来存储用户的详细信息，这里的 Value 通常是一个对象（高级语言中的术语，前面提到过），包含用户的一些关键字段，比如名字、年龄等。</p><p>在我们每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了（其实在大多数时候，数据库可能与我们的服务不在一台机器上，还会有相应的网络性能损耗），可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p><p>有时我们要查询一些数据，这些数据与其他数据是有关联的，如果我们进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于我们是通过散列表的 Key、Value 的对应关系对应数据的，所以性能也会比较好。</p><p><strong>快速查找</strong></p><p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p><p>这样的场景很多，比如我们要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 Value 这个值。</p><p>还有一个场景，我们一般对网站的操作会有个IP地址黑名单，我们认为某些 IP 有大量的非法操作，于是封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，我们会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p><p>当然，对于上面说的两个例子，用列表也是可以实现的，但是访问速度会受到很大的影响，尤其是列表越来越长时，查找速度会很慢，而散列表则不会。</p><h3 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">HashMap&lt;Integer, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i : nums) &#123;</span><br><span class="line"><span class="keyword">if</span> (hash.containsKey(i)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span></span><br><span class="line">hash.put(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389.找不同"></a>389.找不同</h3><p>给定两个字符串 <strong>s</strong> 和 <em><strong>t</strong></em>，它们只包含小写字母。</p><p>字符串 <strong>t</strong> 由字符串 <strong>s</strong> 随机重排，然后在随机位置添加一个字母。</p><p>请找出在 <em><strong>t</strong></em> 中被添加的字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">findTheDifference</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length(), m = t.length();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cnt[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            cnt[c - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="keyword">if</span> (cnt[c - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表的时间复杂度"><a href="#哈希表的时间复杂度" class="headerlink" title="哈希表的时间复杂度"></a>哈希表的时间复杂度</h3><p>访问（Access）：</p><p>搜索（Search）：O（1)</p><p>插入（Insert）：O（1）</p><p>删除（Delete）：O（1）</p><h2 id="集合-Set"><a href="#集合-Set" class="headerlink" title="集合   Set"></a><strong>集合   Set</strong></h2><ul><li><strong>无序，不重复</strong></li></ul><ol><li>检查元素是否存在</li><li>检查元素是否重复（原数据长度与集合长度是否相同）</li></ol><h3 id="java（哈希集合HashSet）"><a href="#java（哈希集合HashSet）" class="headerlink" title="java（哈希集合HashSet）"></a>java（哈希集合HashSet）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//添加元素 : O(1)</span></span><br><span class="line">        set.add(<span class="number">10</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        set.add(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//[10,2]</span></span><br><span class="line">        System.out.println(set.add(<span class="number">2</span>));<span class="comment">//添加的元素已存在，会返回false，不存在则返回true</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//搜索元素 : O(1)0</span></span><br><span class="line">        set.contains(<span class="number">2</span>);<span class="comment">//存在则返回true</span></span><br><span class="line">        System.out.println(set.contains(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//删除元素 : O(1)</span></span><br><span class="line">        set.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(set.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//长度</span></span><br><span class="line">        set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="217-存在重复元素-1"><a href="#217-存在重复元素-1" class="headerlink" title="217.存在重复元素"></a>217.存在重复元素</h3><p>给定一个整数数组，判断是否存在重复元素。</p><p>如果存在一值在数组中出现至少两次，函数返回 <code>true</code> 。如果数组中每个元素都不相同，则返回 <code>false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.add(x)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树   Tree"></a><strong>树   Tree</strong></h2><ul><li><p>树中有一个根结点，其余节点可以分成若干个互不相交的“子树”。</p></li><li><p>除了根节点，每个结点有且只有一个父节点；</p></li><li><p>一棵N个结点的树有N - 1条边；</p></li></ul><p>结点的度：结点的子树个数；</p><p>树的度：树中所有结点中最大的度；</p><p>叶结点：度为0的结点；</p><p>兄弟结点：具有同一父结点的各个结点；</p><p>路径和路径结点：从结点N到结点Nk的路径，其路径结点为路径中结点个数 - 1，即路径中所包含的边的个数；</p><p>祖先结点：从某一结点，到根结点的所有节点，都是这个结点的祖先节点；</p><p>子孙结点：某一结点的子树中的所有节点，都是这个结点的子孙；</p><p>层次：规定根结点  在0&#x2F;1层，其他结点的层数是其父结点的层数+1；</p><p>深度：从上往下数，等于层；高度：从下往上数</p><h3 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h3><p><strong>普通二叉树</strong>：每个结点最多两个子结点</p><p><strong>满二叉树</strong>：除了叶结点，每个结点都有两个子结点，并且所有叶结点都在同一层上；</p><blockquote><p>满二叉树的深度为k，则该树一共有 2^k^ - 1 个节点。</p></blockquote><p><strong>完全二叉树</strong>：从树的根结点出发，从上到下，从左到右，依次填满结点形成的二叉树</p><p>（满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树）</p><p><strong>二叉树的遍历：</strong></p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td><strong>前</strong>序遍历</td><td><strong>根节点</strong>-&gt;左子树-&gt;右子树</td></tr><tr><td><strong>中</strong>序遍历</td><td>左子树-&gt;<strong>根节点</strong>-&gt;右子树</td></tr><tr><td><strong>后</strong>序遍历</td><td>左子树-&gt;右子树-&gt;<strong>根子树</strong></td></tr><tr><td>层次遍历</td><td>从上到下，从左到右</td></tr></tbody></table><p>（层次遍历需要用到 队列 ）</p><h4 id="二叉树实现"><a href="#二叉树实现" class="headerlink" title="二叉树实现"></a>二叉树实现</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span>    <span class="comment">//创建树的结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//创建树根</span></span><br><span class="line">    Node *root;</span><br><span class="line">&#125; Tree;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(Tree *tree, <span class="type">int</span> value)</span> &#123;     <span class="comment">//创建树</span></span><br><span class="line">    Node *node = (Node *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//创建一个结点</span></span><br><span class="line">    node-&gt;data = value;</span><br><span class="line">    node-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">    node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;root == <span class="literal">NULL</span>) tree-&gt;root = node;  <span class="comment">//判断树是不是空树</span></span><br><span class="line">    <span class="keyword">else</span> &#123;      <span class="comment">//不是空树</span></span><br><span class="line">        Node *temp = tree-&gt;root;    <span class="comment">//从树根开始</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; temp-&gt;data)&#123;    <span class="comment">//小于就进左儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;left = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;    <span class="comment">//否则进右儿子</span></span><br><span class="line">                <span class="keyword">if</span> (temp-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    temp-&gt;right = node;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;    <span class="comment">//继续判断</span></span><br><span class="line">                    temp = temp-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的中序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        inorder(node-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">        inorder(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的前序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//树的后序遍历</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">inorder</span><span class="params">(Node *node)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(node-&gt;left);</span><br><span class="line">    inorder(node-&gt;right);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,node-&gt;data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除结点；</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Deleteer</span><span class="params">(Node *node, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">    Node *L,*LL;    <span class="comment">//在删除左右子树都有的结点时使用；</span></span><br><span class="line">    Node *p=node;</span><br><span class="line">    Node *parent=node;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;  <span class="comment">//0表示左子树，1表示右子树；</span></span><br><span class="line">    <span class="keyword">if</span>(!node)    <span class="comment">//如果排序树为空，则退出；</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">while</span>(p)  <span class="comment">//二叉排序树有效；</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == value)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!p-&gt;left &amp;&amp; !p-&gt;right)  <span class="comment">//叶结点(左右子树都为空)；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == node)  <span class="comment">//被删除的结点只有根结点；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(child==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;left=<span class="literal">NULL</span>;  <span class="comment">//设置父结点左子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);   <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>   <span class="comment">//父结点为右子树；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    parent-&gt;right=<span class="literal">NULL</span>;  <span class="comment">//设置父结点右子树为空；</span></span><br><span class="line">                    <span class="built_in">free</span>(p);  <span class="comment">//释放结点空间；</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;left)  <span class="comment">//左子树为空，右子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)    <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;right;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;right;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!p-&gt;right)  <span class="comment">//右子树为空，左子树不为空；</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(child==<span class="number">0</span>)  <span class="comment">//是父结点的左子树；</span></span><br><span class="line">                    parent-&gt;left=p-&gt;left;</span><br><span class="line">                <span class="keyword">else</span>      <span class="comment">//是父结点的右子树；</span></span><br><span class="line">                    parent-&gt;right=p-&gt;left;</span><br><span class="line">                <span class="built_in">free</span>(p);  <span class="comment">//释放被删除的结点；</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                LL=p;  <span class="comment">//保存左子树的结点；</span></span><br><span class="line">                L=p-&gt;right;  <span class="comment">//从当前结点的右子树进行查找；</span></span><br><span class="line">                <span class="keyword">if</span>(L-&gt;left)  <span class="comment">//左子树不为空；</span></span><br><span class="line">                &#123;</span><br><span class="line">                    LL=L;</span><br><span class="line">                    L=L-&gt;left;   <span class="comment">//查找左子树；</span></span><br><span class="line">                    p-&gt;data=L-&gt;data;  <span class="comment">//将左子树的数据保存到被删除结点；</span></span><br><span class="line">                    LL-&gt;left=L-&gt;left;  <span class="comment">//设置父结点的左子树指针为空；</span></span><br><span class="line">                    <span class="keyword">for</span>(; L-&gt;left; L=L-&gt;left);</span><br><span class="line">                    L-&gt;left=p-&gt;left;</span><br><span class="line">                    p-&gt;left=<span class="literal">NULL</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    p-&gt;data=L-&gt;data;</span><br><span class="line">                    LL-&gt;right=L-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p=<span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; p-&gt;data)  <span class="comment">//需删除记录的关键字小于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的左子树；</span></span><br><span class="line">            child=<span class="number">0</span>;  <span class="comment">//标记在当前结点左子树；</span></span><br><span class="line">            parent=p;<span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;left;  <span class="comment">//查找左子树；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">//需删除记录的关键字大于结点的数据；</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//要删除的结点p是parent的右子树；</span></span><br><span class="line">            child=<span class="number">1</span>;  <span class="comment">//标记在当前结点右子树查找；</span></span><br><span class="line">            parent=p;  <span class="comment">//保存当前结点作为父结点；</span></span><br><span class="line">            p=p-&gt;right;  <span class="comment">//查找右子树；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Tree tree;</span><br><span class="line">    tree.root = <span class="literal">NULL</span>;  <span class="comment">//创建一个空树</span></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;     <span class="comment">//输入n个数并创建这个树</span></span><br><span class="line">        <span class="type">int</span> temp;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;temp);</span><br><span class="line">        insert(&amp;tree, temp);</span><br><span class="line">    &#125;</span><br><span class="line">    inorder(tree.root);</span><br><span class="line">    Deleteer(tree.root,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><h3 id="二叉搜索树BST"><a href="#二叉搜索树BST" class="headerlink" title="二叉搜索树BST"></a>二叉搜索树BST</h3><p>二又排序树、二叉查找树（BST, Binary Search Tree）<br>是一棵二叉树或者是空二叉树，或者是具有如下性质的二叉树：</p><ul><li>左子树上所有结点的关键字均小于根结点的关键字</li><li>右子树上所有结点的关键字均大于根结点的关键字</li><li>左子树和右子树又各是一棵二又排序树。</li></ul><blockquote><p>左子树结点值 &lt; 根结点值 &lt; 右子树结点值；</p><p>进行中序遍历，可以得到一个递增的有序序列。</p></blockquote><p><strong>查找：</strong>时间复杂度 O(h)，若排序树很平衡，则h接近log<del>2</del>n，若非常不平衡，则h会接近n。</p><p><strong>插入：</strong>时间复杂度 O(h)</p><p>若原二叉排序树为空，则直接插入结点；否则，若关键字k小于 根结点值，则插入到左子树，若关键字k大于根结点值，则插入到右子树。</p><p><strong>删除：</strong></p><p>先搜索找到目标结点：</p><ul><li>①若被删除结点z是叶结点，则直接删除，不会破坏二又排序树的性质。</li><li>②若结点z只有一棵左子树或右子树，则让z的子树成为z父结点的子树，替代z的位置。</li><li>③若结点z有左、右两棵子树，则令z的直接后继（或直接前驱）替代z，然后从二叉排序树中删去这个直接后继（或直接前驱），这样就转换成了第一或第二种情况。</li></ul><h3 id="自平衡二叉树AVL"><a href="#自平衡二叉树AVL" class="headerlink" title="自平衡二叉树AVL"></a>自平衡二叉树AVL</h3><p>平衡二叉树( Balanced Binary Tree)，简称平衡树(AVL树)ー一树上任一结点的左子树和右子树的<strong>高度之差不超过1</strong>。</p><p>结点的平衡因子 &#x3D; 左子树高 - 右子树高。</p><ul><li>平衡二叉树结点的平衡因子的值只可能是-1、0或1。否则就不是平衡二叉树了。</li></ul><p>查找：时间复杂度不超过O(h) 、O(log<del>2</del>n)</p><p><strong>插入</strong>：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201805281.png" alt="image-20211228111813606"></p><p><strong>调整</strong>最小不平衡子树A（从插入点找到的第一个不平衡点为根的子树）：</p><ul><li><p><strong>LL</strong>：在A的左孩子的左子树中插入导致不平衡；<br>调整：A的左孩子结点<strong>右上旋</strong>；</p></li><li><p><strong>RR</strong> ：在A的右孩子的右子树中插入导致不平衡；</p><p>调整：A的右孩子结点<strong>左上旋</strong>；</p></li><li><p><strong>LR</strong> ：在A的左孩子的右子树中插入导致不平衡；<br>调整：A的左孩子的右孩子<strong>先左上旋再右上旋</strong>；</p></li><li><p><strong>RL</strong> ：在A的右孩子的左子树中插入导致不平衡；<br>调整：A的右孩子的左孩子<strong>先右上旋后左上旋</strong>；</p></li></ul><h3 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h3><p><strong>结点的带权路径长度：</strong></p><blockquote><p>树的每一个结点，都可以拥有自己的“权重”（Weight），权重在不同的算法当中可以起到不同的作用。结点的带权路径长度，是指树的根结点到该结点的路径长度，和该结点权重的乘积。</p></blockquote><p><strong>树的带权路径长度</strong></p><blockquote><p>在一棵树中，所有叶子结点的带权路径长度之和，被称为树的带权路径长度，也被简称为WPL。</p></blockquote><p><strong>而哈夫曼树（Huffman Tree）是在叶子结点和权重确定的情况下，带权路径长度最小的二叉树，也被称为最优二叉树。</strong></p><p><strong>一颗有n个叶子结点的的哈夫曼树共有2n-1个结点</strong></p><p>原则上，我们应该让权重小的叶子结点远离树根，权重大的叶子结点靠近树根。</p><p>思路：</p><blockquote><p>借助辅助队列，将权值最小的两个叶子节点挑出来，并根据这两个结点生成一个新的父结点，父节点的权值是这两个结点权值之和；从队列中移除已选择的节点，把新的父结点加入队列；</p><p>重复这一步骤，直到所有结点组成一颗完整二叉树</p><p>（如果是构造<strong>k叉哈夫曼树</strong>，且节点数无法严格构成k叉树，则需要补充几个<strong>权值为0的 “假节点”</strong>）</p></blockquote><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207127.png" alt="202204201806626" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207452.png" alt="202204201806756" style="zoom:33%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232207097.png" alt="202204201807079" style="zoom:33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 结点权值?</span></span><br><span class="line">    <span class="type">int</span> parent, lc, rc; <span class="comment">// 双亲结点和左 右子节点</span></span><br><span class="line">&#125; HTNode, *HuffmanTree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> n, <span class="type">int</span> &amp;s1, <span class="type">int</span> &amp;s2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> minum;      <span class="comment">// 定义一个临时变量保存最小值?</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;     <span class="comment">// 以下是找到第一个最小值</span></span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = minum;</span><br><span class="line">    <span class="comment">// 以下是找到第二个最小值，且与第一个不同</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1) &#123;</span><br><span class="line">            minum = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HT[i].parent == <span class="number">0</span> &amp;&amp; i != s1)</span><br><span class="line">            <span class="keyword">if</span> (HT[i].weight &lt; HT[minum].weight)</span><br><span class="line">                minum = i;</span><br><span class="line">    &#125;</span><br><span class="line">    s2 = minum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatHuff</span><span class="params">(HuffmanTree &amp;HT, <span class="type">int</span> *w, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, s1, s2;</span><br><span class="line">    m = n * <span class="number">2</span> - <span class="number">1</span>;  <span class="comment">// 总结点的个数</span></span><br><span class="line">    HT = <span class="keyword">new</span> HTNode[m + <span class="number">1</span>]; <span class="comment">// 分配空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123; <span class="comment">// 1 - n 存放叶子结点，初始化</span></span><br><span class="line">        HT[i].weight = w[i];</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 非叶子结点的初始化</span></span><br><span class="line">        HT[i].weight = <span class="number">0</span>;</span><br><span class="line">        HT[i].parent = <span class="number">0</span>;</span><br><span class="line">        HT[i].lc = <span class="number">0</span>;</span><br><span class="line">        HT[i].rc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nthe HuffmanTree is: \n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n + <span class="number">1</span>; i &lt;= m; i++)     <span class="comment">// 创建非叶子节点，建哈夫曼树</span></span><br><span class="line">    &#123;   <span class="comment">// 在HT[1]~HT[i-1]的范围内选择两个parent为0且weight最小的两个结点，其序号分别赋值给 s1 s2</span></span><br><span class="line">        <span class="built_in">Select</span>(HT, i - <span class="number">1</span>, s1, s2);</span><br><span class="line">        HT[s1].parent = i;  <span class="comment">// 删除这两个结点</span></span><br><span class="line">        HT[s2].parent = i;</span><br><span class="line">        HT[i].lc = s1;      <span class="comment">// 生成新的树，左右子节点是 s1和s2</span></span><br><span class="line">        HT[i].rc = s2;</span><br><span class="line">        HT[i].weight = HT[s1].weight + HT[s2].weight;   <span class="comment">// 新树的权�?</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d (%d, %d)\n&quot;</span>, HT[i].weight, HT[s1].weight, HT[s2].weight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HuffmanTree HT;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *w, n, wei;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input the number of node\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    w = <span class="keyword">new</span> <span class="type">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\ninput the %dth node of value\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;wei);</span><br><span class="line">        w[i] = wei;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CreatHuff</span>(HT, w, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4><p>哈夫曼编码：对一棵具有n个叶子的哈夫曼树，若对树中的每个左分支赋0，右分支赋1，则从根到每个叶子的路径上，各分支的赋值分别构成一个二进制串，该二进制串就称为哈夫曼编码。</p><p>哈夫曼编码的基本思想是：为出现次数较多的字符编以较短的编码，在压缩原理中有重要作用。</p><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><p>B树，又称<strong>多路平衡查找树</strong>。</p><p>B树中所有结点的孩子个数的最大值称为B树的阶，通常用m表示。一棵m阶B树或为空树，或为满足如下特性的<strong>m叉树</strong>：</p><ol><li>树中每个结点<strong>至多有m棵子树</strong>，即<strong>至多含有m-1个关键字</strong></li><li>若<strong>根结点不是终端结点，则至少有两棵子树</strong>。</li><li>除根结点外的所有<strong>非叶结点至少有 m&#x2F;2 棵子树</strong>，即至少含有 (m&#x2F;2) -1 个关键字。</li><li><strong>所有的叶结点都出现在同一层次上，并且不帯信息</strong>（可以视为外部结点或类似于折半查找判定树的查找失败结点，实际上这些结点不存在，指向这些结点的指针为空）。</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807887.png" alt="image-20211227205412747"></p><p><strong>m阶B树的核心特性</strong></p><ol><li>根节点的子树数∈[2,m], 关键字数∈[1, m-1]<br>其他结点的子树数∈ [(m&#x2F;2), m] ;关键字数∈[(m&#x2F;2)-1, m-1]</li><li>对任一结点，其所有子树高度都相同</li><li>关键字的值：子树0 &lt; 关键字1 &lt; 子树1 &lt;关键字2 &lt; 子树2 &lt;. (类比二叉査找树左&lt;中&lt;右)</li></ol><blockquote><p>注：算B树高度时，不用包括叶子节点&#x2F;失败节点；</p><p>n个关键字的B树必有n+1个叶子节点。（相当于在n个关键字中插入木板，两边也插，则插了n+1个木板）</p></blockquote><p><strong>B树的插入</strong></p><p><strong>新元素一定是插入到最底层“终端节点”</strong>，用“查找”来确定插入位置。</p><p>在插入key后，若导致原结点关键字数超过上限，则从中间位置( [m&#x2F;2] )将其中的关键字分为两部分，左部分包含的关键字放在原结点中，右部分包含的关键字放到新结点中，中间位置( [m&#x2F;2] )的结点插入原结点的父结点。 </p><p>若此时导致其父结点的关键字个数也超过了上限，则继续进行这种分裂操作，直至这个过程传到根结点为止，进而导致B树高度增。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807992.png" alt="image-20211227210741287"></p><hr><p><strong>B树的删除</strong></p><ul><li><p>若被删除关键字在<strong>终端节点</strong>，则<strong>直接删除</strong>该关键字（要注意节点关键字个数是否低于下限 [m&#x2F;2] - 1 )</p></li><li><p>若被删除关键字在<strong>非终端节点</strong>，则用<strong>直接前驱或直接后继</strong>来<strong>替代</strong>被删除的关键字（直接前驱：当前关键字左侧指针所指子树中“最右下”的元素）——对非终端结点关键字的删除，必然可以转化为对终端结点的删除操作</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807165.png" alt="image-20211227211302810"></p><ul><li><p>若删除关键字所在节点删除后，<strong>关键字低于下限</strong>：</p><ul><li><p>如果<strong>兄弟节点关键字充足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>借关键字</strong>“的目的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201807275.png" alt="image-20211227211924677"></p></li><li><p>如果<strong>兄弟节点关键字不足</strong>，可以调整该节点、兄弟节点、父节点来达到”<strong>合并</strong>“的目的。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808905.png" alt="image-20211227212543467"></p></li></ul></li></ul><h3 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h3><p>B+树 可以类比分块查找。</p><p>分块查找：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808668.png" alt="image-20211227212836480"></p><p>B+树：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808635.png" alt="image-20211227212949012"></p><p>一棵<strong>m阶的B+树</strong>需满足下列条件：</p><ol><li>每个分支结点最多有m棵子树（孩子结点）。</li><li>非叶根结点至少有两棵子树，其他每个分支结点至少有 m&#x2F;2 棵子树。</li><li><strong>结点的子树个数与关键字个数相等</strong>。（区别于B树，因为B+树的关键字和子树是一一对应的）</li><li>所有<strong>叶结点包含全部关键字及指向相应记录的指针</strong>，叶结点中将关键字按大小顺序排列，并且<strong>相邻叶结点按大小顺序相互链接起来</strong>。（支持顺序查找）</li><li>所有<strong>分支结点</strong>中仅包含它的各个子结点中<strong>关键字的最大值</strong>及指向其子结点的指针。</li></ol><p><strong>B+的查找：</strong></p><p><strong>无论查找成功与否，最终一定要走到最下面一层节点。</strong>因为只有叶子节点存放了所需记录。</p><hr><p><strong>B树和B+树的对比：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201808265.png" alt="image-20211227213649466"></p><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h4 id="概念性质"><a href="#概念性质" class="headerlink" title="概念性质"></a>概念性质</h4><p>红黑树的概念模型是<strong>2-3-4树</strong>，以<strong>二叉树为基础</strong>，在二叉树属性中加入<strong>颜色属性</strong>来表示2-3-4树中不同的节点。</p><p>红黑树的<strong>五大定义</strong>：</p><ol><li><strong>节点颜色只能为红或黑；</strong></li><li><strong>根节点是黑色；</strong></li><li><strong>每个叶子节点是黑色的（这里的叶子节点其实是空节点）</strong></li><li><strong>不能出现连续的红色节点；</strong></li><li><strong>从任意节点到它的每个子节点的所有路径都包含相同的黑色节点；</strong></li></ol><p>这5条定义确保了红黑树的关键特性：</p><ul><li><strong>从根到叶子节点的最长路径，不会超过最短路径的两倍</strong>；</li><li>这棵树<strong>基本是平衡</strong>的；</li><li>虽然不是绝对平衡，但可以保证<strong>最坏情况下，红黑树依然是高效的</strong>；</li></ul><p>为什么能做到最长路径不超过最短路径的两倍？</p><blockquote><p>性质4规定了路径上不能有两个相连的红节点，因此，最长路径一定是红色节点和黑节点交替而成；</p><p>性质2和3规定了根节点和叶子节点都是黑色，所以最短路径的黑节点一定多于红节点（可能全部为黑）；</p><p>性质5规定每条路径黑节点的数目相同；</p><p>因此，没有路径的长能多于其他任何路径两倍。</p></blockquote><p>红黑树的<strong>三种变换：变色，左旋转，右旋转</strong></p><p>红黑树<strong>插入的新节点为红色</strong>的：</p><blockquote><p>因为插入红节点，不会违反红黑树的规则，虽然可能会红红相连，不过可以通过变色和旋转来调整；而插入黑色节点，必然会导致一条路径上多一个黑节点（难以调整）。</p></blockquote><hr><p><strong>左旋转</strong>：以当前节点X为根，逆时针旋转二叉树，使得<strong>父节点原来的位置被右子节点替代，左子节点的位置被父节点替代</strong>。同时，节点Y的<strong>左子树</strong> b 向<strong>左平移</strong>成为了节点X的<strong>右子树</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/2.png" alt="image-20200303132706061"></p><p>旋转之后仍然是二叉搜索树：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/3.png" alt="image-20200303132617108"></p><p><strong>右旋转</strong>：以节点X为根，<strong>顺时针</strong>旋转二叉搜索树，使得父节点原来的位置被自己的左子节点替代，右子节点的位置被父节点替代；</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/4.png" alt="image-20200303132529476"></p><h4 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h4><h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h4 id="2-3树-到-红黑树"><a href="#2-3树-到-红黑树" class="headerlink" title="2-3树 到 红黑树"></a>2-3树 到 红黑树</h4><p>2-3-4树中的2节点对应红黑树中的黑色节点，而非2节点以红节点+黑节点的方式表示，黑色父节点+一个红色子节点表示3节点，黑色父节点+左右两个红色子节点表示4节点；</p><blockquote><p>2-3-4树 ：是一颗阶数为4的B树，它可能会存在2节点，3节点，4节点（2节点就是普通的二叉树节点；3节点：由2个属性X和Y，3个子节点，分别是小于X的，大于X小于Y的，大于Y的；4节点跟3节点类似）</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/9f7961f77546c8f13448372625282335.png" alt="B树到红黑树的转化"></p><p>下面是以较为简单的 2-3树和左倾红黑树 为例，理解两者的转化关系</p><blockquote><p>2-3树不用考虑2-3-4树中复杂的4节点分裂；</p><p>左倾红黑树规定了红色节点只能在左子树，这个限制减少了原本红黑树的调平难度，更容易理解；</p></blockquote><hr><p>2-3树 和 左倾红黑树 ：把左倾红黑树中的红色节点<strong>顺时针方向旋转45°</strong>使其与黑父平行，然后再将它们看作一个整体，可以近似得到一颗2-3树。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/5a84b9872980c9a8761d3b84315d5931.png" alt="B树到红黑树的转化"></p><p>从2-3树来看，红黑树的红节点和黑节点是绑定的，因为在2-3树中它们本来就在同一层，所有只有黑节点在2-3树中体现树的高度</p><hr><p><strong>对于2-3树的插入：</strong></p><p>我们的插入操作需要遵循一个<strong>原则</strong>：先将这个元素尝试性地放在<strong>已经存在的节点中</strong>（即插入一个红色节点），如果要存放的节点是2节点，那么插入后会变成3节点，如果要存放的节点是3节点，那么插入后会变成4节点（<strong>临时</strong>）。然后，我们对可能生成的临时4节点进行分裂处理，使得临时4节点消失。</p><p>如图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/02050b1461f4b891a92052f41139c567.png" alt="2-3树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/706a4ae059ebd3b6cfd8dfef6a3f05e4.png" alt="2-3-4树的插入"></p><p>在2-3树中如果待插入节点是个2节点，而2节点对应着红黑树中的黑色父节点；所以向2节点插入元素，即在黑色父节点下面增加一个红色儿子，</p><p>3节点插入元素，即已经有一个黑色父节点和一个红色子节点，则再给黑色父节点一个红色子节点</p><hr><p><strong>对于2-3树的删除：</strong></p><p>2-3树的删除我们主要要考虑待删除元素在2节点这种情况，因为如果待删除元素在3节点，那么可以直接将这个元素删除，而不会破坏2-3树的任何性质（删除这个元素不会引起高度的变化）。</p><p>当待删除元素在2节点的时候，由于删除这个元素会导致2节点失去自己<strong>唯一的元素</strong>，引发2节点自身的删除，会使得树中某条路径的<strong>高度发生变化</strong>，树变得<strong>不平衡</strong>。</p><p>对此有两种方案：</p><ol><li>先删除这个2节点，再对树进行平衡调整；</li><li>想办法让被删除元素不可能出现在2节点中；</li></ol><p>这里看第二种方案，我们在搜索到这个节点的路径中，不断地判断当前节点是否为2节点，如果是，就从它的兄弟节点或者它的父节点借一个元素，使得当前节点由2节点成为一个3节点或者一个临时4节点。</p><p>这种操作会产生一种结果：除非当前节点是根节点，否则当前节点的父节点一定是一个非2节点（因为搜索的路径是自上而下，父节点已经进行过了这种操作，所以不可能是2节点），那么我们可以保证到达叶子节点的时候，也能顺利的从父节点或者兄弟节点处借到元素，使得自己成为非2节点。从而能够直接删除某个元素<br><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/9f2f0ebec960203ecafac6bf91462be2.png" alt="2-3树的删除"></p><p>插入和删除操作的父子节点上下浮动和删除里借元素的做法，就是红黑树的调整（变色，旋转）；</p><p>看左倾红黑树的 插入和删除（图示）：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/4947b64375651e3b2072ecd09d3fad7b.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/03f56fa81ffaee6bfe4fd68d25b6bc63.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/162498f17b4122405b0ef04cefe55368.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/28d7b36542a54750935418950da5d8eb.png" alt="左倾红黑树的插入"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/cd622250cc9453c634658ae934defc88.png" alt="左倾红黑树的删除"></p><p>删除之后需要一些调整（左倾红黑树不允许出现右倾）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/711d441a7e05c4843237ac5e6f424f26.png" alt="左倾红黑树的删除"></p><h2 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆   Heap"></a><strong>堆   Heap</strong></h2><p>性质：</p><ol><li>结构性：用<strong>数组表示</strong>的<strong>完全二叉树</strong>。</li><li>有序性：任意结点的关键字（权值）是其子树所有结点的最小值&#x2F;最大值<br>1. 父结点大于子结点：最大堆&#x2F;大根堆（MaxHeap）<br>            2. 父结点小于子结点：最小堆&#x2F;小根堆（MinHeap）</li></ol><p>应用：</p><ol><li>优先队列：是一种特殊的“队列”，从队列中取出元素的顺序是依照元素的关键字（权值&#x2F;数值）大小，而不是元素进入队列的先后顺序。</li><li>堆排序</li></ol><h3 id="最小堆操作与实现："><a href="#最小堆操作与实现：" class="headerlink" title="最小堆操作与实现："></a>最小堆操作与实现：</h3><p>对于任意最多有MaxSize个元素的最小堆H ∈ MinHeap 元素，item ∈</p><p> ElementType主要操作有：</p><ul><li>MinHeap Create(int Maxsize): 创建一个空的最小堆。</li><li>void Destroy(MinHeap)：释放堆的空间。</li><li>Boolean IsFull(MinHeap H): 判断最小堆是否已满。</li><li>Boolean IsEmpty(MinHeap H): 判断最小堆是否为空。</li><li>void Insert(MinHeap H,ElementType item): 将元素item插入最小堆H。</li><li>ElementType DeleteMin(MinHeap H): 返回最小堆H中最小元素（高优先级）。</li><li>MinHeap BuildMinHeap(ElementType *Element,int Size,int MaxSize)：创建一个非空的最小堆</li></ul><p><strong>数组下标为0</strong>的位置放一个比所有堆中元素都要小的元素（可以是ElementType的最小值），称为“<strong>哨兵</strong>”。从下标为1的位置开始存放堆中元素。因为是完全二叉树，所以父亲节点与其左右子节点下标满足一些关系。</p><p><strong>由子节点找父节点：父节点下标&#x3D;子节点下标 &#x2F; 2</strong><br><strong>由父节点找左子节点：左子节点下标&#x3D;父节点下标 * 2</strong><br><strong>由父节点找右子节点：右子节点下标&#x3D;父节点下标 * 2 + 1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeapStruct</span> &#123;</span></span><br><span class="line">    ElementType *Elenment;      <span class="comment">//存储堆元素的数组</span></span><br><span class="line">    <span class="type">int</span> Size;       <span class="comment">//堆的当前元素个数（最后一个元素的下标）</span></span><br><span class="line">    <span class="type">int</span> MaxSize;        <span class="comment">//堆存储空间的大小</span></span><br><span class="line">&#125; HeapStruct, *MinHeap;</span><br><span class="line"></span><br><span class="line">MinHeap <span class="title function_">Create</span><span class="params">(<span class="type">int</span> MaxSize)</span> &#123;</span><br><span class="line">    MinHeap H = (MinHeap) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HeapStruct));     <span class="comment">//分配堆结构空间</span></span><br><span class="line">    H-&gt;Elenment = (ElementType *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ElementType) * (MaxSize + <span class="number">1</span>));    <span class="comment">//分配储存堆元素的数组的空间</span></span><br><span class="line">    H-&gt;Size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;MaxSize = MaxSize;</span><br><span class="line">    H-&gt;Elenment[<span class="number">0</span>] = <span class="number">-2020</span>;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放堆申请的空间</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Destroy</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(H-&gt;Elenment);     <span class="comment">//先释放堆节点的数组空间</span></span><br><span class="line">    <span class="built_in">free</span>(H);        <span class="comment">//再释放堆节点的空间</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否已满</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsFull</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == H-&gt;MaxSize); <span class="comment">//判断最小堆中元素个数size是否等于最大容量MaxSize</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断最小堆是否为空</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsEmpty</span><span class="params">(MinHeap H)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (H-&gt;Size == <span class="number">0</span>);  <span class="comment">//判断堆中元素个数是否等于0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将元素item插入最小堆H</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Inset</span><span class="params">(MinHeap H, ElementType item)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//判断堆H是否已满</span></span><br><span class="line">    <span class="keyword">if</span> (IsFull(H)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  如果H未满，将item放入堆最后一个元素，查看它的父节点，如果它的父节点比它大，将它和它的父节点互换位置循环此过程，直至它的父节点小于它。可能它比所有它的父节点都要小，但是一定会比哨兵大（数组中下标为0的位置），所以一定最后它的下标一定大于哨兵的下标0。这就是哨兵的意义。</span></span><br><span class="line">    H-&gt;Size++;</span><br><span class="line">    <span class="keyword">for</span> (i = H-&gt;Size; H-&gt;Elenment[i / <span class="number">2</span>] &gt; item; i = i / <span class="number">2</span>) &#123;</span><br><span class="line">        H-&gt;Elenment[i] = H-&gt;Elenment[i / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回最小堆H中最小元素（高优先级）</span></span><br><span class="line"><span class="comment">//将堆根结点元素取出，并将堆元素重新排序</span></span><br><span class="line">ElementType <span class="title function_">Delete</span><span class="params">(MinHeap H)</span>&#123;</span><br><span class="line">    <span class="type">int</span> parent = <span class="number">0</span>,child = <span class="number">0</span>;</span><br><span class="line">    ElementType item, temp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断堆是否已经空了</span></span><br><span class="line">    <span class="keyword">if</span> (IsEmpty(H))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Heap is Empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> H-&gt;Elenment[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//堆没有空，将根节点返回，最后一个叶子节点放到根节点位置，然后比较它与它的左右子节点中最小节点的大小，如果它比较大，则将它和它的较小的子节点互换位置，重复此过程，直至他比两个子节点都小或者它不在有子节点</span></span><br><span class="line">    item = H-&gt;Elenment[<span class="number">1</span>];</span><br><span class="line">    temp = H-&gt;Elenment[H-&gt;Size];</span><br><span class="line">    H-&gt;Size--;</span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">        child = parent*<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//找出左右子结点最小的那个</span></span><br><span class="line">        <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child +<span class="number">1</span>]))&#123;</span><br><span class="line">            child ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">            H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elenment[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个非空的堆</span></span><br><span class="line"><span class="comment">//可以先建一个空堆，再用Insert函数将元素一个一个插入；另一种方法是：将数组复制到堆结点的Element，再进行排序第二种方法时间复杂度更低</span></span><br><span class="line"><span class="comment">//已知一个数组，创建一个由数组元素组成的最小堆</span></span><br><span class="line">MinHeap <span class="title function_">BuildMinHeap</span><span class="params">(ElementType *Element,<span class="type">int</span> Size,<span class="type">int</span> MaxSize)</span>&#123;</span><br><span class="line">    MinHeap H = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, parent = <span class="number">0</span>, child = <span class="number">0</span>;</span><br><span class="line">    ElementType Temp;</span><br><span class="line"></span><br><span class="line">    H = Create(MaxSize);    <span class="comment">//创建一个空最小堆</span></span><br><span class="line">    <span class="keyword">if</span> (Size &gt; H-&gt;MaxSize)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;堆储存空间不足\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//复制数组元素</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;Size; i++)&#123;</span><br><span class="line">        H-&gt;Elenment[i + <span class="number">1</span>] = Element[i];</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Size = Size;</span><br><span class="line">    <span class="comment">//给最小堆排序</span></span><br><span class="line">    <span class="comment">//最后一个节点的父节点的左右指针都指向一个堆，将最后一个节点的父节点和它的两个子节点排序（方法类似与删除节点的操作），使得最后一个节点、其父节点和其兄弟节点形成一个堆。循环操作，从最后一个节点的父节点往上依次执行这个操作，最后使得整个树都是一个堆。</span></span><br><span class="line">    <span class="keyword">for</span> (parent = H-&gt;Size/<span class="number">2</span>; parent &gt;= <span class="number">1</span>; parent--)&#123;</span><br><span class="line">        Temp = H-&gt;Elenment[parent];</span><br><span class="line">        <span class="keyword">for</span>(; parent * <span class="number">2</span> &lt;= H-&gt;Size; parent = child)&#123;</span><br><span class="line">            child = parent * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果左右子树都存在，将child作为两者较小者的下标</span></span><br><span class="line">            <span class="keyword">if</span>(child != H-&gt;Size &amp;&amp; (H-&gt;Elenment[child] &gt; H-&gt;Elenment[child + <span class="number">1</span>]))&#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较parent和child分别指向的结点的大小，parent较大则互换位置</span></span><br><span class="line">            <span class="keyword">if</span>(Temp &gt; H-&gt;Elenment[child])&#123;</span><br><span class="line">                H-&gt;Elenment[parent] = H-&gt;Elenment[child];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        H-&gt;Elenment[parent] = Temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>Heapsort是利用堆所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质，即子结点的键值总小于（或大于）它的父结点。它有两种方法来排序：</p><ol><li>大顶堆：每个结点的值都大于或等于其他子结点的值，在堆排序中可用于升序排序。（因为其中每一次排序都会先将堆顶的元素交换到后面）</li><li>小顶堆：每个结点的值都小于或等于其他子结点的值，在堆排序中可用于降序排序。</li></ol><p>堆排序的平均时间复杂度是O（nlogn）</p><h4 id="堆排序操作与实现"><a href="#堆排序操作与实现" class="headerlink" title="堆排序操作与实现"></a>堆排序操作与实现</h4><ol><li>创建一个堆；</li><li>把堆首与堆尾互换；</li><li>把堆的尺寸缩小1，并调用heapify（堆化）将堆重新调整好；</li><li>重复步骤2、3，直到堆的尺寸为1。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = *b;</span><br><span class="line">    *b = *a;</span><br><span class="line">    *a = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">max_heapify</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> start, <span class="type">int</span> end)</span>&#123;</span><br><span class="line">    <span class="comment">//建立父结点指标和子结点指标</span></span><br><span class="line">    <span class="type">int</span> parent = start;</span><br><span class="line">    <span class="type">int</span> child = parent * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(child &lt;= end)&#123;    <span class="comment">//子结点指标在范围内才做比较</span></span><br><span class="line">        <span class="keyword">if</span>(child + <span class="number">1</span> &lt;= end &amp;&amp; arr[child] &lt; arr[child + <span class="number">1</span>])     <span class="comment">//选择两个子结点中较大的</span></span><br><span class="line">            child ++;</span><br><span class="line">        <span class="keyword">if</span>(arr[parent] &gt; arr[child])     <span class="comment">//如果父结点较大，则表示调整完毕，直接跳出</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;       <span class="comment">//否则交换父子结点内容，再继续子结点和孙结点比较</span></span><br><span class="line">            swap(&amp;arr[parent],&amp;arr[child]);</span><br><span class="line">            parent = child;</span><br><span class="line">            child = parent *<span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">heap_dort</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//初始化，i从最后一个父结点开始调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len / <span class="number">2</span> <span class="number">-1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        max_heapify(arr, i ,len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//先将第一个元素和已经排好的元素前一位交换，再重新调整</span></span><br><span class="line">    <span class="keyword">for</span>(i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">        swap(&amp;arr[<span class="number">0</span>],&amp;arr[i]);</span><br><span class="line">        max_heapify(arr, <span class="number">0</span>, i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//因为除了交换的两个元素，其他已经堆化好了，所以从上往下只经过一条路径即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> len = (<span class="type">int</span>) <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(*arr);</span><br><span class="line">    heap_sort(arr, len);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第k个最大元素"><a href="#215-数组中的第k个最大元素" class="headerlink" title="215.数组中的第k个最大元素"></a>215.数组中的第k个最大元素</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p><strong>示例 :</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p>（可以自行构造最大堆或最小堆，加深对堆的认识）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; maxheap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            maxheap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            maxheap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxheap.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小堆实现（只需k个元素在堆里）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 对前k个元素建成小根堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            swim(nums, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 剩下的元素与堆顶比较，若大于堆顶则去掉堆顶，再将其插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[<span class="number">0</span>]) &#123;</span><br><span class="line">                swap(nums[<span class="number">0</span>], nums[i]);</span><br><span class="line">                sink(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束后第k个大的数就是小根堆的堆顶</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若v1比v2优先度高，返回true</span></span><br><span class="line">    bool <span class="title function_">priorityThan</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> &#123; <span class="keyword">return</span> v1 &lt; v2; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上浮 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; priorityThan(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>])) &#123;</span><br><span class="line">            swap(heap[i], heap[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下沉 从下到上调整堆</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heap, <span class="type">int</span> i, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * i + <span class="number">1</span> &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= N &amp;&amp; priorityThan(heap[j + <span class="number">1</span>], heap[j])) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (priorityThan(heap[i], heap[j])) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(heap[i], heap[j]);</span><br><span class="line">            i = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="692-前k个高频单词"><a href="#692-前k个高频单词" class="headerlink" title="692.前k个高频单词"></a>692.前k个高频单词</h3><p>给一非空的单词列表，返回前 <em>k</em> 个出现次数最多的单词。</p><p>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。</p><p>示例 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;the&quot;, &quot;day&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;the&quot;, &quot;the&quot;, &quot;the&quot;, &quot;sunny&quot;, &quot;is&quot;, &quot;is&quot;], k = 4</span><br><span class="line">输出: [&quot;the&quot;, &quot;is&quot;, &quot;sunny&quot;, &quot;day&quot;]</span><br><span class="line">解析: &quot;the&quot;, &quot;is&quot;, &quot;sunny&quot; 和 &quot;day&quot; 是出现次数最多的四个单词，</span><br><span class="line">    出现次数依次为 4, 3, 2 和 1 次。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个小根优先队列。</span></span><br><span class="line"><span class="comment">//将每一个字符串插入到优先队列中，如果优先队列的大小超过了 k，那么我们就将优先队列顶端元素弹出。这样最终优先队列中剩下的 kk 个元素就是前 kk 个出现次数最多的单词。</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//用哈希表存储字符串和出现次数</span></span><br><span class="line">        Map&lt;String, Integer&gt; cnt = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            cnt.put(word, cnt.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//一个PriorityQueue对象：将key-value转为entry对象，放入优先队列（堆）中，（自定义）排序（构造最小堆）</span></span><br><span class="line">        PriorityQueue&lt;Map.Entry&lt;String, Integer&gt;&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Map.Entry&lt;String, Integer&gt; entry1, Map.Entry&lt;String, Integer&gt; entry2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> entry1.getValue() == entry2.getValue() ? entry2.getKey().compareTo(entry1.getKey()) : entry1.getValue() - entry2.getValue();<span class="comment">//注意这里 entry2.compareTo(entry1) 中entry1与entry2在数组中的位置，entry2表示后加进来的元素，entry1表示原来的元素.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将哈希表中的key-value依次放入最小堆中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : cnt.entrySet()) &#123;</span><br><span class="line">            pq.offer(entry);</span><br><span class="line">            <span class="keyword">if</span> (pq.size() &gt; k) &#123;    <span class="comment">//大小超过k后，去掉堆顶元素（去掉最小值，因为题目要求最大的k个）</span></span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!pq.isEmpty()) &#123;</span><br><span class="line">            ret.add(pq.poll().getKey());</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表 + 排序</span></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">topKFrequent</span><span class="params">(String[] words, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; hash = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String s : words) &#123;</span><br><span class="line">            hash.put(s, hash.getOrDefault(s, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将每一组value变为一个entry对象存入list数组</span></span><br><span class="line">        List&lt;String&gt; rec = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : hash.entrySet()) &#123;</span><br><span class="line">            rec.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Collections.sort(rec, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;String&gt;() &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> hash.get(word1).equals(hash.get(word2)) ? word1.compareTo(word2) : hash.get(word2) - hash.get(word1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> rec.subList(<span class="number">0</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><p>G（ V , E ）：图由顶点集合V（G）和边集合E（G）构成；</p><p><strong>端点：</strong></p><p>无向图：一条边（i，j） ，它的顶点 i 和 j 叫<strong>端点</strong>，它们互为<strong>邻接点</strong>；</p><p>有向图：一条边&lt; i , j &gt;  ，它的顶点 i 为 起始端点 （起点），j 为终止端点 （终点），它们互为邻接点；</p><p><strong>度</strong>：</p><p>以某点为端点的 边的数量 叫该顶点的<strong>度</strong></p><p>入度：进入该点的边数；</p><p>出度：从该点出发的边数</p><p><strong>完全图：</strong></p><p>完全无向图：n( n - 1 ) &#x2F; 2 条边</p><p>完全有向图：n( n - 1) 条边</p><p>当一个图接近完全图时，称为<strong>稠密图</strong>，反之，则为<strong>稀疏图</strong>；</p><p><strong>路径：</strong></p><p>路径长度：一条路径上经过的边的数目；</p><p>简单路径：除开始点和结束点可以相同，其它顶点均不同；</p><p>环&#x2F;回路：一条路径上开始点和结束点为同一顶点；</p><p><strong>连通：</strong>指从 i 到 j 有路径，则 i 和 j 连通；</p><p>连通图：无向图中任意两点连通；</p><p>强连通图：有向图中任意两点连通；</p><p>连通分量：指无向图G中的极大连通子图；</p><p>强连通分量：指有向图G中的极大连通子图；</p><p>（强连通图的连通分量只有一个，非连通图有多个连通分量）（强连通图也一样）</p><p><strong>权：</strong>边上附加的一个数值，可以表示从一个顶点到另一个顶点的距离或代价；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">问：</span><br><span class="line">设有一个图G=（V，E），取V的子集V&#x27;，E的子集E&#x27;。那么，（V&#x27;，E）一定是G的子图吗？</span><br><span class="line"></span><br><span class="line">答：</span><br><span class="line">如果对顶点的子集和边的子集不加限定的话，(V&#x27;,E&#x27;)不一定构成一个图。</span><br><span class="line">假如边集对应的顶点包含在所取的顶点集中，则(V&#x27;,E&#x27;)构成G的子图</span><br><span class="line">如果所取的顶点集不能包含s取的边集所对应的所有顶点，则(V&#x27;,E&#x27;)不构成G的子图。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 存储类型：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809164.png" alt="image-20211227214212034"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#define MAXV &lt;最大顶点个数&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 顶点 类型    </span></span><br><span class="line">typedef struct&#123;</span><br><span class="line"><span class="type">int</span> no;<span class="comment">//顶点编号</span></span><br><span class="line">InfoType info;<span class="comment">//顶点其他信息</span></span><br><span class="line">&#125;VertexType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接矩阵 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    <span class="type">int</span> edges[MAXV][MAXV];</span><br><span class="line">    <span class="type">int</span> n, e;</span><br><span class="line">    VertexType vexs[MAXV];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>邻接表 存储类型：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809277.png" alt="image-20211227214032490"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明 边节点 类型</span></span><br><span class="line">typedef struct ANode&#123;</span><br><span class="line">    <span class="type">int</span> adjvex;<span class="comment">//该边的终点编号</span></span><br><span class="line">    struct ANode *next;<span class="comment">//指向下一条边</span></span><br><span class="line">    InfoType info;<span class="comment">//该边的权值等信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明 邻接表头节点 类型</span></span><br><span class="line">typedef struct Vnode&#123;</span><br><span class="line">    vertex data;<span class="comment">//顶点信息</span></span><br><span class="line">    ArcNode *firstArc;<span class="comment">//指向第一条边</span></span><br><span class="line">&#125;VNode;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//声明 邻接表 类型</span></span><br><span class="line">typedef struct&#123;</span><br><span class="line">    VNode adjList[MAXV];<span class="comment">//邻接表</span></span><br><span class="line">    <span class="type">int</span> n, e;<span class="comment">//图中顶点数n和边数e</span></span><br><span class="line">&#125;AdjGraph;</span><br></pre></td></tr></table></figure><p><strong>邻接矩阵 和 邻接表 对比：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809762.png" alt="image-20211227214112779"></p><p><strong>十字链表（有向图）</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809325.png" alt="image-20211227214400091"></p><p>找顶点出边： 顺着绿色线找</p><p>找顶点入边：顺着橙色线找</p><hr><p><strong>邻接多重表（无向图）</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809819.png" alt="image-20211227214717843"></p><hr><p><strong>四种存储方式 对比</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201809656.png" alt="image-20211227214851706"></p><h3 id="一些基本操作"><a href="#一些基本操作" class="headerlink" title="一些基本操作"></a>一些基本操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建图的邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createAdj</span><span class="params">(AdjGraph *G, <span class="type">int</span> a[MAXV][MAXV], <span class="type">int</span> n, <span class="type">int</span> e)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;      <span class="comment">//所有头节点的指针域赋初值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i][j] != <span class="number">0</span> &amp;&amp; a[i][j] != INF) &#123;        <span class="comment">//这条边存在</span></span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;                  <span class="comment">//存放邻接点</span></span><br><span class="line">                p-&gt;weight = a[i][j];            <span class="comment">//存放 权</span></span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;   <span class="comment">//头插法插入节点</span></span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = n;</span><br><span class="line">    G-&gt;e = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出邻接表G</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">displayAdj</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;</span><br><span class="line">        printf(<span class="string">&quot;%d:&quot;</span>, i);</span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            printf(<span class="string">&quot;%d[%d]-&gt;&quot;</span>, p-&gt;adjvex, p-&gt;weight);</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(<span class="string">&quot;^\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁邻接表</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">destory</span><span class="params">(AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *pre, *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; ++i) &#123;</span><br><span class="line">        pre = G-&gt;adjList[i].firstArc;</span><br><span class="line">        <span class="keyword">if</span> (pre != NULL) &#123;</span><br><span class="line">            p = pre-&gt;next;</span><br><span class="line">            <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//释放第i个单链表的所有节点</span></span><br><span class="line">                free(pre);</span><br><span class="line">                pre = p;</span><br><span class="line">                p = p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            free(pre);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    free(G);    <span class="comment">//释放头节点数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//邻接矩阵g 转化成 邻接表G （时间复杂度：O(n^2)）</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">MatToList</span><span class="params">(MatGraph g, AdjGraph *G)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    G = (AdjGraph *) malloc(sizeof(AdjGraph));</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;</span><br><span class="line">        G-&gt;adjList[i].firstArc = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &gt;= <span class="number">0</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[i][j] != <span class="number">0</span> &amp;&amp; g.edges[i][j] != INF) &#123;</span><br><span class="line">                p = (ArcNode *) malloc(sizeof(ArcNode));</span><br><span class="line">                p-&gt;adjvex = j;</span><br><span class="line">                p-&gt;weight = g.edges[i][j];</span><br><span class="line">                p-&gt;next = G-&gt;adjList[i].firstArc;</span><br><span class="line">                G-&gt;adjList[i].firstArc = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    G-&gt;n = g.n;</span><br><span class="line">    G-&gt;e = g.e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将邻接表G转换成邻接矩阵g</span></span><br><span class="line"><span class="comment">//时间复杂度：无向图为O(n+2e)，有向图为O(n+e)，e为边数</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">ListToMat</span><span class="params">(AdjGraph *G, MatGraph g)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++)<span class="comment">//扫描所有的单链表</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = G-&gt;adjList[i].firstArc;<span class="comment">//p指向第i个单链表的首结点while(p！=NULL)//扫描第i个单链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">            g.edges[i][p-&gt;adjvex] = p-&gt;weight;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        g.n = G-&gt;n;</span><br><span class="line">        g.e = G-&gt;e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> visited[MAXV] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//深度优先搜索: O(n+e)</span></span><br><span class="line"><span class="comment">//用栈 或 递归</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXV; i++) &#123;</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[v] = <span class="number">1</span>;</span><br><span class="line">    printf(<span class="string">&quot;%d &quot;</span>, v);</span><br><span class="line">    p = G-&gt;adjList[v].firstArc;</span><br><span class="line">    <span class="keyword">while</span> (p != NULL) &#123;</span><br><span class="line">        w = p-&gt;adjvex;</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="number">0</span>)</span><br><span class="line">            DFS(G, w);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//广度优先搜索: O(n+e)</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">BFS</span><span class="params">(AdjGraph *G, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> w, i;</span><br><span class="line">    ArcNode *p;</span><br><span class="line">    SqQueue *qu;    <span class="comment">//定义环形队列指针</span></span><br><span class="line">    IntiQueue(qu);      <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="type">int</span> visit[MAXV];    <span class="comment">//顶点访问标记数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G-&gt;n; i++) &#123;</span><br><span class="line">        visit[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;%2d&quot;</span>, v); <span class="comment">//输出被访问的顶点 编号</span></span><br><span class="line">    visit[v] = <span class="number">1</span>;   <span class="comment">//此点 已访问</span></span><br><span class="line">    EnQueue(qu, v);</span><br><span class="line">    <span class="keyword">while</span> (!QueueEmpty(qu))&#123;</span><br><span class="line">        DeQuenu(qu, w);     <span class="comment">//出队一个顶点w</span></span><br><span class="line">        p = G-&gt;adjList[w].firstArc; <span class="comment">//指向w的第一个邻接点</span></span><br><span class="line">        <span class="keyword">while</span> (p != NULL) &#123; <span class="comment">//查找w的所有邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(visit[p-&gt;adjvex] == <span class="number">0</span>)&#123;</span><br><span class="line">                printf(<span class="string">&quot;%2d&quot;</span>, p-&gt;adjvex);</span><br><span class="line">                visit[p-&gt;adjvex] = <span class="number">1</span>;</span><br><span class="line">                EnQueue(qu, p-&gt;adjvex);<span class="comment">//该点进队</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;<span class="comment">//找下一个点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>一个<strong>连通图的生成树</strong>是一个<strong>极小连通子图</strong>，它含有图中<strong>全部n个顶点</strong>和构成一棵树的（<strong>n - 1</strong> ）条边。</p><p>遍历方法得到生成树：深度优先生成树，广度~~树</p><p>（所以一个连通图的生成树不一定唯一）</p><p><strong>最小生成树</strong></p><p>对 带权连通图G （权 均为大于0的实数），其权值之和最小的生成树 即 图的最小生成树。</p><h4 id="普里姆-prim-算法"><a href="#普里姆-prim-算法" class="headerlink" title="普里姆(prim)算法"></a><strong>普里姆(prim)算法</strong></h4><p>（从顶点 考虑）</p><ol><li>选择初始点 把图中的顶点分成两个不同的顶点集S(生成树的顶点集)，V-S</li><li>在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中</li><li>将该边的另一个顶点加入到顶点集S中，并从V-S中删除</li><li>重复步骤2，3，知道V-S为空集</li></ol><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232209206.png" alt="202204201810815" style="zoom:50%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232209658.png" alt="202204201810813" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">prim</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">    <span class="type">int</span> lowcost[MAXV];<span class="comment">//lowcost存储到未标顶点的最小权值</span></span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line">    <span class="type">int</span> closest[MAXV], i, j, k;<span class="comment">//closest存储最小权值对应的顶点</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g.n; ++i) &#123;         <span class="comment">//赋初值</span></span><br><span class="line">        lowcost[i] = g.edges[v][i];</span><br><span class="line">        closest[i] = v;<span class="comment">//此时生成树只有一个顶点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; g.n; i++) &#123;     <span class="comment">//输出（n - 1）条边</span></span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//在( V - U )中找出离U最近的顶点k</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min) &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;      <span class="comment">//k记录最近的顶点编号</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;边（%d, %d）权为：%d\n&quot;</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;     <span class="comment">//标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; g.n; j++)        <span class="comment">//修改数组lowcost和cloest</span></span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])&#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];<span class="comment">//更新S和V-S之间最小权值</span></span><br><span class="line">                closest[j] = k;<span class="comment">//最小权值对应的 在Sz</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="克鲁斯卡尔（kruskal-算法"><a href="#克鲁斯卡尔（kruskal-算法" class="headerlink" title="克鲁斯卡尔（kruskal)算法"></a><strong>克鲁斯卡尔（kruskal)算法</strong></h4><p>（从边 考虑）</p><ol><li>把图中的顶点看成n个不同的顶点集，每个顶点集都只含1个顶点</li><li>每次都在<strong>横跨不同顶点集的边</strong>中选择一条权值最小的边加入到最小生成树中</li><li>直到图中所有的顶点都在同一个顶点集为止</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232210576.png" alt="202204201810581"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232210733.png" alt="202204201810936"></p><p>思路：连通图的边按照权值从小到大进行排列；依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201811175.png" alt="image-20211227204922551"></p><h4 id="狄克斯特拉-Dijkstra-算法"><a href="#狄克斯特拉-Dijkstra-算法" class="headerlink" title="狄克斯特拉(Dijkstra)算法"></a><strong>狄克斯特拉(Dijkstra)算法</strong></h4><p>只适用 有向无环图，图中存在负权重、环 时，无法使用狄克斯特拉算法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232208359.png" alt="202204201811792"></p><p>过程如下:</p><p>从起点开始，起点到其所有邻居的距离2和6是初始值，其他不相邻的节点的距离为无穷大，</p><p>然后从{2,6,无穷大}中找到最小值2,2对应的节点是B，然后从B开始遍历B的所有邻居{A,终点}，计算起点-&gt;B-&gt;A的距离为2+3&#x3D;5，比之前的距离6要小，所以更新A的记录为5，继续计算起点-&gt;B-&gt;终点的距离为2+5&#x3D;7，比之前的距离无穷大要小，所以更新终点的记录为7，至此B的所有相邻节点遍历完毕，故划去B，</p><p>之后继续从{2,5,7}中寻找最小值，由于2对应的B节点已经被划去，所以只要从{5,7}中找最小值，最小值为5，5对应于节点A，然后从A开始遍历A的所有邻居{终点}，计算起点-&gt;A-&gt;终点的距离6，比之前的距离7要小，故更新终点的记录为6，至此A的所有邻居遍历完毕，故划去A，</p><p>最后只剩下终点这个节点，由于终点没有邻居，故图中的所有邻居遍历完毕。至此得出从起点到终点的最短距离是6。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//狄克斯特拉(Dijkstra)算法：O(n^2)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(MatGraph g, <span class="type">int</span> v)</span> &#123;  <span class="comment">//v为源点</span></span><br><span class="line">    <span class="type">int</span> dist[MAXV], path[MAXV]; <span class="comment">//dist[]存放到某点的最短路径长度，path[]存放最短路径</span></span><br><span class="line">    <span class="type">int</span> s[MAXV];    <span class="comment">//标记顶点是否访问过</span></span><br><span class="line">    <span class="type">int</span> mindis, u;      <span class="comment">//mindis为最短距离，u为新考虑的中间点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123; <span class="comment">//初始化dist和path</span></span><br><span class="line">        dist[i] = g.edges[v][i];    <span class="comment">//距离初始化，即v点到其余点的距离</span></span><br><span class="line">        s[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (g.edges[v][i] &lt; INF)</span><br><span class="line">            path[i] = v;</span><br><span class="line">        <span class="keyword">else</span> path[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    s[v] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g.n; i++) &#123;</span><br><span class="line">        mindis = INF;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)       <span class="comment">//找最小路径长度的顶点u</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span> &amp;&amp; dist[j] &lt; mindis) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                mindis = dist[j];</span><br><span class="line">            &#125;</span><br><span class="line">        s[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; g.n; j++)   <span class="comment">//修改未考虑的顶点的距离</span></span><br><span class="line">            <span class="keyword">if</span> (s[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> (g.edges[u][j] &lt; INF &amp;&amp; dist[u] + g.edges[u][j] &lt; dist[j]) &#123;</span><br><span class="line">                    dist[j] = dist[u] + g.edges[u][j];</span><br><span class="line">                    path[j] = u;</span><br><span class="line">                &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Dispath(dist, path, s, g.n, v); <span class="comment">//输出最短路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弗洛伊德-Floyd）算法"><a href="#弗洛伊德-Floyd）算法" class="headerlink" title="弗洛伊德(Floyd）算法"></a><strong>弗洛伊德(Floyd）算法</strong></h4><p>基本思想：<br>弗洛伊德算法定义了两个二维矩阵：</p><p>矩阵D记录顶点间的最小路径<br>例如D[0q0] [3]&#x3D; 10，说明顶点0 到 3 的最短路径为10；</p><p>矩阵P记录顶点间最小路径中的中转点<br>例如P[0] [3]&#x3D; 1 说明，0 到 3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。</p><p>它通过3重循环，k为中转点，v为起点，w为终点，循环比较D[v] [w] 和 D[v] [k] + D[k] [w] 最小值，如果D[v] [k] + D[k] [w] 为更小值，则把D[v] [k] + D[k] [w] 覆盖保存在D[v] [w]中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pathmatirx[MAXV][MAXV];<span class="comment">//记录对应点的最小路径的前驱点，例如p(1,3) = 2 说明顶点1到顶点3的最小路径要经过2</span></span><br><span class="line"><span class="type">int</span> shortPath[MAXV][MAXV];<span class="comment">//记录顶点间的最小路径值</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">short_path_floyd</span><span class="params">(MatGraph G, <span class="type">int</span> P[MAXV][MAXV], <span class="type">int</span> D[MAXV][MAXV])</span> &#123;</span><br><span class="line">    <span class="type">int</span> v, w, k;</span><br><span class="line">    <span class="comment">//初始化floyd算法的两个矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            D[v][w] = G.edges[v][w];</span><br><span class="line">            P[v][w] = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是弗洛伊德算法的核心部分</span></span><br><span class="line">    <span class="comment">//k为中间点</span></span><br><span class="line">    <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; G.n; k++) &#123;</span><br><span class="line">        <span class="comment">//v为起点</span></span><br><span class="line">        <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">            <span class="comment">//w为终点</span></span><br><span class="line">            <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (D[v][w] &gt; (D[v][k] + D[k][w])) &#123;</span><br><span class="line">                    D[v][w] = D[v][k] + D[k][w];<span class="comment">//更新最小路径</span></span><br><span class="line">                    P[v][w] = P[v][k];<span class="comment">//更新最小路径中间顶点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的D矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, D[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n初始化的P矩阵\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (v = <span class="number">0</span>; v &lt; G.n; v++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (w = <span class="number">0</span>; w &lt; G.n; w++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, P[v][w]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    v = <span class="number">0</span>;</span><br><span class="line">    w = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//求 0 到 3的最小路径</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n%d -&gt; %d 的最小路径为：%d\n&quot;</span>, v, w, D[v][w]);</span><br><span class="line">    k = P[v][w];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;path: %d&quot;</span>, v);<span class="comment">//打印起点</span></span><br><span class="line">    <span class="keyword">while</span> (k != w) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>, k);<span class="comment">//打印中间点</span></span><br><span class="line">        k = P[k][w];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d\n&quot;</span>, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>AOV网（Activity On Vertex NetWork）：用顶点表示活动的网。每个AOV网都有一个或多个拓扑排序序列。</p><blockquote><p>AOV网有且仅有一个入度为0的开始点，出度为0的结束点。</p></blockquote><p>拓扑排序：在有向无环图中，找出做事的先后顺序。</p><p><strong>规则</strong>：</p><ul><li>图中每个顶点只出现<code>一次</code>。</li><li>A在B前面，则不存在B在A前面的路径。(<code>不能成环！！！！</code>)</li><li>顶点的顺序是<strong>保证所有指向它的下个节点在被指节点前面</strong>！(例如A—&gt;B—&gt;C那么A一定在B前面，B一定在C前面)。所以，这个核心规则下只要满足即可，<strong>所以拓扑排序序列不一定唯一</strong>！</li></ul><p>使用拓扑排序时，一般是稀疏图，所以用邻接表，</p><p><strong>代码思想为：</strong></p><p>新建node类，包含节点数值和它的指向；</p><p>一个数组包含node(这里默认编号较集中)。初始化，添加每个节点指向的时候同时被指的节点入度+1！(A—&gt;C)那么C的入度+1；<br>扫描一遍所有node。将所有<strong>入度为0的点</strong>加入一个栈(队列)。</p><p>当<strong>栈(队列)不空的时候，抛出其中任意一个node</strong>(栈就是尾，队就是头，顺序无所谓，上面分析了只要同时入度为零可以随便选择顺序)。将node输出，并且<strong>node指向的所有元素入度减一</strong>。如果某个<strong>点的入度被减为0，那么就将它加入栈</strong>(队列)。</p><p>重复上述操作，直到栈为空。</p><h3 id="210-课程表"><a href="#210-课程表" class="headerlink" title="210.课程表"></a>210.课程表</h3><p>现在你总共有 <strong>numCourses</strong> 门课需要选，记为 0 到 numCourses - 1。给你一个数组 <strong>prerequisites</strong> ，其中 <strong>prerequisites[i] &#x3D; [ai, bi]</strong> ，表示在选修课程 ai 前 必须 先选修 bi 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如，想要学习课程 <span class="number">0</span> ，你需要先完成课程 <span class="number">1</span> ，我们用一个匹配来表示：[<span class="number">0</span>,<span class="number">1</span>]。</span><br></pre></td></tr></table></figure><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组。</p><p><strong>题解：</strong></p><p>本题是一道经典的「拓扑排序」问题。</p><ul><li><p>我们将每一门课看成一个节点；</p></li><li><p>如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B一定出现在 A 的前面。</p></li></ul><p>求出该图的拓扑排序，就可以得到一种符合要求的课程学习顺序。</p><p><strong>方法一，深度优先搜索</strong></p><p>对于一个节点 u，如果它的所有相邻节点都已经搜索完成，那么在搜索回溯到 u 的时候，u本身也会变成一个已经搜索完成的节点。这里的「相邻节点」指的是从 u 出发通过一条有向边可以到达的所有节点。</p><p>对于图中的任意一个节点，它在搜索的过程中有三种状态，即：</p><ul><li><p>「未搜索」：我们还没有搜索到这个节点；</p></li><li><p>「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；</p></li><li><p>「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。</p></li></ul><p>通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。</p><ul><li><p>我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：</p></li><li><p>如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；</p></li><li><p>如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</p></li><li><p>如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v)(u,v) 之前的拓扑关系，所以不用进行任何操作。</p></li><li><p>当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。</p></li></ul><p>在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="type">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">valid</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度: **O(n+m)**，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。</p></li><li><p>空间复杂度: **O(n+m)**。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n+m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，并且还需要若干个 O(n)的空间存储节点状态、最终答案等。</p></li></ul><p><strong>方法二：广度优先搜索</strong></p><p>我们使用一个队列来进行广度优先搜索。开始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。</p><p>在广度优先搜索的每一步中，我们取出队首的节点 u：</p><p>我们将 u 放入答案中；</p><p>我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。</p><p>在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 存储每个节点的入度</span></span><br><span class="line">    <span class="type">int</span>[] indeg;</span><br><span class="line">    <span class="comment">// 存储答案</span></span><br><span class="line">    <span class="type">int</span>[] result;</span><br><span class="line">    <span class="comment">// 答案下标</span></span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> numCourses, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        indeg = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        result = <span class="keyword">new</span> <span class="title class_">int</span>[numCourses];</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">            ++indeg[info[<span class="number">0</span>]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">// 将所有入度为 0 的节点放入队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indeg[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 从队首取出一个节点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">// 放入答案中</span></span><br><span class="line">            result[index++] = u;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> v: edges.get(u)) &#123;</span><br><span class="line">                --indeg[v];</span><br><span class="line">                <span class="comment">// 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了</span></span><br><span class="line">                <span class="keyword">if</span> (indeg[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                    queue.offer(v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != numCourses) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内排序"><a href="#内排序" class="headerlink" title="内排序"></a>内排序</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/sort.png" alt="img"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/0B319B38-B70E-4118-B897-74EFA7E368F9.png" alt="img"></p><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称为缩小增量（递减增量）算法，是<strong>插入排序的改进</strong>。</p><p>希尔排序需要一个增量序列（增量会递减）,一般用len&#x2F;2，如：len为11，则增量分别为5，2，1，进行三次循环。</p><p>每次循环排序只排 间隔 为增量值的数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShellSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len / <span class="number">2</span>; i &gt; <span class="number">0</span>; i /= <span class="number">2</span>) &#123;      <span class="comment">//i为增量,初始化为len/2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; len; j++) &#123;       <span class="comment">//j用于每次更改增量后遍历一次数组</span></span><br><span class="line">                <span class="type">int</span> k;          <span class="comment">//k用于对第j个元素进行插入排序，比较的是前面间隔为i的元素</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[j];</span><br><span class="line">                <span class="keyword">for</span> (k = j; k &gt;= i &amp;&amp; temp &lt; nums[k - i]; k -= i) &#123;</span><br><span class="line">                    nums[k] = nums[k - i];</span><br><span class="line">                &#125;</span><br><span class="line">                nums[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ShellSort</span>().shellSort(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>将数据不断分半，直到只剩下一个元素，然后从以分半的两段数据，逐个选出最小的元素移入临时数组的末尾。（归并排序需要用到临时数组）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Merge-sort-example-300px.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//合并操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr[],<span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//标记左半区第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> l_pos = left;</span><br><span class="line">    <span class="comment">//标记右半曲第一个未排序的元素</span></span><br><span class="line">    <span class="type">int</span> r_pos = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//临时变量元素的下标</span></span><br><span class="line">    <span class="type">int</span> pos = left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l_pos &lt;= mid &amp;&amp;r_pos &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[l_pos] &lt; arr[r_pos])     <span class="comment">//左半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[l_pos++];</span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//右半区剩余第一个元素更小</span></span><br><span class="line">            tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l_pos &lt;= mid)&#123;       <span class="comment">//合并左半区剩余元素（右半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[l_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(r_pos &lt;= right)&#123;      <span class="comment">//合并右半区剩余元素（左半区合并完了）</span></span><br><span class="line">        tempArr[pos++] = arr[r_pos++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将临时数组中合并后的元素复制到原来的数组</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        arr[left] = tempArr[left];</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">msort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> tempArr, <span class="type">int</span> left, <span class="type">int</span> right)</span>&#123;</span><br><span class="line">    <span class="comment">//如果只有一个元素，那么不需要继续划分</span></span><br><span class="line">    <span class="keyword">if</span>(left &lt; right)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//递归划分左右半区</span></span><br><span class="line">        msort(arr,tempArr, left, mid);</span><br><span class="line">        msort(arr, tempArr, mid + <span class="number">1</span>, right);</span><br><span class="line">        merge(arr, tempArr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//归并排序入口</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="comment">//分配一个辅助数组</span></span><br><span class="line">    <span class="type">int</span> *tempArr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(tempArr)&#123;    <span class="comment">//辅助数组分配成功</span></span><br><span class="line">        msort(arr, tempArr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">free</span>(tempArr);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;error: failed to allocate memory&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>在区间中挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行同样操作。直到各个分区只有一个数时为止。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/quickSort.gif" alt="img"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里以第一个元素作为基准</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="type">int</span> i = start, j = end, x = s[start];     <span class="comment">//以第一个元素作为基准，后面用了类似挖坑的写法，临时存储这个元素，遇到第一个需要交换的元素，直接赋值给基准处。</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;     <span class="comment">//一边交换后，换另一边比较</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[j] &gt;= x) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[i++] = s[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; s[i] &lt; x) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">                s[j--] = s[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = x;</span><br><span class="line">        quicksort(s, start, i - <span class="number">1</span>);</span><br><span class="line">        quicksort(s, i + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quick_sort_recursive</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt;= end)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = arr[end];</span><br><span class="line">    <span class="type">int</span> i = start, j = end - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &lt; mid &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">while</span> (arr[j] &gt;= mid &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt;= arr[end])</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[end]);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">        quick_sort_recursive(arr, start, i - <span class="number">1</span>);</span><br><span class="line">    quick_sort_recursive(arr, i + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    quick_sort_recursive(arr, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>（堆积是一个近似完全二叉树的结构，并同时满足堆积的性质）</p><p>堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ul><li><p>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</p></li><li><p>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</p></li></ul><p>算法步骤：</p><ol><li>创建一个堆</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸减少1，并调用上浮&#x2F;下沉操作，把新的最大值调整到堆首；</li><li>重复步骤2，3，直到堆的尺寸为1；</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/heapSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        buildMaxHeap(arr, len);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, i);</span><br><span class="line">            len--;</span><br><span class="line">            heapify(arr, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildMaxHeap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">largest</span> <span class="operator">=</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">            largest = right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">            swap(arr, i, largest);</span><br><span class="line">            heapify(arr, largest, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。</p><p>作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>当输入的元素是 n 个 0 到 k 之间的整数时，它的运行时间是 Θ(n + k)。</p><p>由于<strong>用来计数的数组C的长度取决于待排序数组中数据的范围</strong>（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。例如：计数排序是用来排序0到100之间的数字的最好的算法，但是它不适合按字母顺序排序人名。但是，计数排序可以用在基数排序中的算法来排序数据范围很大的数组。</p><p>算法的步骤如下：</p><ol><li><p>找出待排序的数组中最大和最小的元素</p></li><li><p>统计数组中每个值为i的元素出现的次数，存入数组C的第i项</p></li><li><p>反向填充目标数组：将每个元素 i 放在新数组的第C(i)项，每放一个元素就将C(i)减去1</p></li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/countingSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CountingSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> countingSort(arr, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] countingSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxValue) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketLen</span> <span class="operator">=</span> maxValue + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] bucket = <span class="keyword">new</span> <span class="title class_">int</span>[bucketLen];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            bucket[value]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">sortedIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; bucketLen; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                arr[sortedIndex++] = j;</span><br><span class="line">                bucket[j]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，<strong>尽量增大桶的数量</strong></li><li>使用的映射函数能够将输入的 <strong>N 个数据均匀的分配到 K 个桶中</strong></li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><p>最快的情况：当输入的数据可以均匀的分配到每一个桶中。</p><p>最慢的情况：当输入的数据被分配到了同一个桶中。</p><p>示例：</p><p>元素分布在桶中：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Bucket_sort_1.svg_.png" alt="img"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/Bucket_sort_2.svg_.png" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BucketSort</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="keyword">return</span> bucketSort(arr, <span class="number">5</span>);  <span class="comment">//桶大小是5</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] bucketSort(<span class="type">int</span>[] arr, <span class="type">int</span> bucketSize)&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//选出最大值和最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value &lt; minValue) &#123;</span><br><span class="line">                minValue = value;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bucketCount</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[][] buckets = <span class="keyword">new</span> <span class="title class_">int</span>[bucketCount][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) Math.floor((arr[i] - minValue) / bucketSize);</span><br><span class="line">            buckets[index] = arrAppend(buckets[index], arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">arrIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] bucket : buckets) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bucket.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 对每个桶进行排序，这里的XxxSort根据情况而定</span></span><br><span class="line">            bucket = XxxSort.sort(bucket);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                arr[arrIndex++] = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//（自动扩容）将元素加入到桶中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序是一种非比较型整数排序算法，其原理是<strong>将整数按位数切割成不同的数字，然后按每个位数分别比较</strong>。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><p>下面三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/radixSort.gif" alt="img"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDigit</span> <span class="operator">=</span> getMaxDigit(arr);</span><br><span class="line">        <span class="keyword">return</span> radixSort(arr, maxDigit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最高位数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxDigit</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> getMaxValue(arr);</span><br><span class="line">        <span class="keyword">return</span> getNumLenght(maxValue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getMaxValue</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxValue</span> <span class="operator">=</span> arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> value : arr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxValue &lt; value) &#123;</span><br><span class="line">                maxValue = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取位数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> <span class="title function_">getNumLenght</span><span class="params">(<span class="type">long</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lenght</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> num; temp != <span class="number">0</span>; temp /= <span class="number">10</span>) &#123;</span><br><span class="line">            lenght++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lenght;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] radixSort(<span class="type">int</span>[] arr, <span class="type">int</span> maxDigit) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dev</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxDigit; i++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span></span><br><span class="line">            <span class="type">int</span>[][] counter = <span class="keyword">new</span> <span class="title class_">int</span>[mod * <span class="number">2</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">bucket</span> <span class="operator">=</span> (arr[j] % mod) / dev;</span><br><span class="line">                <span class="keyword">if</span> (arr[j] &gt; <span class="number">0</span>)     <span class="comment">//考虑正负数</span></span><br><span class="line">                    bucket += <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    bucket = -bucket;</span><br><span class="line">                counter[bucket] = arrayAppend(counter[bucket], arr[j]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] bucket : counter) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> value : bucket) &#123;</span><br><span class="line">                    arr[pos++] = value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动扩容，并保存数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arrayAppend(<span class="type">int</span>[] arr, <span class="type">int</span> value) &#123;</span><br><span class="line">        arr = Arrays.copyOf(arr, arr.length + <span class="number">1</span>);</span><br><span class="line">        arr[arr.length - <span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="外排序"><a href="#外排序" class="headerlink" title="外排序"></a>外排序</h2><p>对磁盘中的数据进行排序。</p><h3 id="归并排序-1"><a href="#归并排序-1" class="headerlink" title="归并排序"></a>归并排序</h3><p>最少只需要在内存中开辟2个输入缓冲区和一个输出缓冲区，每次将磁盘的数据块 输入到输入缓冲区，然后按 归并排序的规则，从2个输入缓冲区 每次跳出最小的数 放到输出缓冲区，当有输入缓冲区为空了，应该立刻将和它排好序的下一个数据块放到输入缓冲区中。当输出缓冲区满时，写出外存。</p><p>减少时间开销：进行<strong>K路归并排序</strong>，需要在内存中分配k个输入缓冲区和一个输出缓冲区。</p><blockquote><p>因为读写磁盘时间开销大，所以多几路可以提高效率，但也不能太多，因为需要在内存中开多个缓冲区，且每次比较都要比较这k个缓冲区的最小值</p></blockquote><p>时间开销：读写外存时间+内部排序时间+内部归并时间</p><p>优化：</p><ul><li><strong>增加归并路数k</strong><ul><li>代价1：需要增加相应的输入缓冲区</li><li>代价2：每次从k个归并段总选一个最小值需要（k-1）次比较。——<strong>可用败者树减少关键字比较次数</strong></li></ul></li><li><strong>减少初始归并段数量r</strong><ul><li>若有N个记录，内存工作区可放L个记录，则初始归并段数量 r &#x3D; N &#x2F; L ——<strong>可用 置换-选择排序 减少初始归并段</strong></li></ul></li></ul><h3 id="败者树"><a href="#败者树" class="headerlink" title="败者树"></a>败者树</h3><p>败者树解决的问题：使用多路平衡归并可減少归并趟数，但是用老土方法从k个归并段选出一个最小&#x2F;最大元素需要对比关键字k-1次，构造败者树可以使关键字对比次数减少到 log<del>2</del>k。</p><p>败者树可视为一棵<strong>完全二又树（多了一个在根节点之上的头节点</strong>）。<strong>k个叶结点</strong>分别对应<strong>k个归并段</strong>中当前参加比较的元素，<strong>非叶子结点</strong>用来记忆<strong>左右子树中的“失败者”</strong>，而让胜者往上继续进行比较，一直到根结点。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812994.png" alt="image-20211227202553354"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812382.png" alt="image-20211227202243956"></p><h3 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h3><p>设初始待排文件为FI,初始归并段输出文件为FO,内存工作区为WA，FO和WA的初始状态为空，WA可容纳w个记录。置換-选择算法的步骤如下：</p><ol><li>从FI输入w个记录到工作区WA</li><li>从WA中选出其中关键字取最小值的记录，记为 MIINIMAX记录。(MIINIMAX指不断选出的最小指中的最大值)</li><li>将 MINIMAX记录输出到FO中去。</li><li>若FI不空，则从FI输入下一个记录到WA中。</li><li>从WA中所有关键字比 MIINIMAX记录的关键字大的记录中选出最小关键字记录，作为新的MINIMAX记录。</li><li>重复(3)~(5),直至在WA中选不出新的 MINIMAX记录为止，由此得到一个初始归并段，输出一个归并段的结束标志到FO中去。</li><li>重复(2)~(6),直至WA为空。由此得到全部初始归并段。</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201812678.png" alt="image-20211227203606666"></p><p>r</p><h1 id="试题"><a href="#试题" class="headerlink" title="试题"></a>试题</h1><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol><li><p>设指针变量p指向单链表中结点A，若删除单链表中结点A，则需要修改指针的操作序列为（ ）。<br>(A) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(B) q&#x3D;p-&gt;next；q-&gt;data&#x3D;p-&gt;data；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(C) q&#x3D;p-&gt;next；p-&gt;next&#x3D;q-&gt;next；free(q)；<br>(D) q&#x3D;p-&gt;next；p-&gt;data&#x3D;q-&gt;data；free(q)；</p><blockquote><p>答案：A</p><p>先用指针变量q指向结点A的后继结点B，然后将结点B的值复制到结点A中，最后删除结点B。</p></blockquote></li><li><p>设有n个待排序的记录关键字，则在堆排序中需要（ ）个辅助记录单元。</p><blockquote><p>答案：1个。</p><p>堆排序只需一个辅助空间，用来记录当前操作的二叉树上的根节点的数字，来与其左右孩子节点比较。</p></blockquote></li><li><p>设某二叉树中度数为0的结点数为N0，度数为1的结点数为Nl，度数为2的结点数为N2，则下列等式成立的（ ）。</p><blockquote><p>答案：N<del>0</del> &#x3D; N<del>2</del> + 1</p></blockquote></li><li><p>设有序顺序表中有n个数据元素，则利用二分查找法查找数据元素X的最多比较次数不超过（ ）。</p><blockquote><p>答案：log<del>2</del>n + 1</p></blockquote></li><li><p>1、数据的最小单位是（ A ）。<br>(A) 数据项<br>(B) 数据类型<br>(C) 数据元素<br>(D) 数据变量</p></li><li><p>设一棵m叉树中度数为0的结点数为N0，度数为1的结点数为N1，……，度数为m的结点数为Nm，则N0 &#x3D;（ B ）。<br>(A) Nl+N2+……+Nm<br>(B) <strong>1+N2+2N3+3N4+……+(m-1)Nm</strong><br>(C) N2+2N3+3N4+……+(m-1)Nm<br>(D) 2Nl+3N2+……+(m+1)Nm</p></li><li><p>设在一棵度数为3的树中，度数为3的结点数有2个，度数为2的结点数有1个，度数为1的结点数有2个，那么度数为0的结点数有（ ）个。 </p><blockquote><p>解：6个</p><p>除了根节点外，其他节点均为孩子节点，而孩子节点等于总的分支数，即 孩子节点 &#x3D;  1 * n<del>1</del> + 2 * n<del>2</del>+3 * n<del>3</del> &#x3D; 10；</p><p>所以总节点数 &#x3D; 10 + 1 &#x3D; 11（1是指根节点），度数为0的节点数 &#x3D; 11 - n<del>1</del> - n<del>2</del> - n<del>3</del> &#x3D; 6;</p></blockquote></li><li><p>设顺序表的长度为n，则顺序查找的平均比较次数为（）。</p><blockquote><p>解：（n+1）&#x2F; 2</p><p>若第一个为查找元素，则查找次数为1，。。。。。所以 平均查找次数为 (1+2+3 + ….+ n) &#x2F; n&#x3D; (1+n) &#x2F; 2； </p></blockquote></li><li></li></ol><h2 id="填空题"><a href="#填空题" class="headerlink" title="填空题"></a>填空题</h2><ol><li><p>通常从四个方面评价算法的质量：<u>正确性、易读性、强壮性、高效性</u>。</p></li><li><p>数据结构从逻辑上划分为三种基本类型：线性结构，树型结构，图型结构。</p></li><li><p>用链表存储二叉树，则有n个节点的二叉树共有 2n 个指针域，其中 n-1 个存放了地址，剩下的是空指针（n+1个）。</p></li><li><p>AOV网是一种 <u>有向无回路</u> 的图。</p></li><li><p>对于具有n个顶点和e条边的有向图和无向图，其对应的邻接表中，所含边节点分别有 e 和 2e 个。</p></li><li><p>在一个具有n个顶点的无向完全图中，包含有 n(n-1)&#x2F;2 条边，有n个顶点的有向完全图中，包含有 n(n-1) 条边。</p></li><li><p>设某二叉树中度数为0的节点数为 N，度数为1的节点数为 M，可得该二叉树中度数为2的节点数为 <u>N - 1</u> ，。</p></li><li><p>数据的物理结构主要包括 顺序存储结构 和 链式存储结构。</p></li><li><p>设满二叉树的深度为k， 则该树的节点数为 2^k^ - 1； 若用二叉链表作为二叉树的存储结构，设该树有 n 个节点，则一共有 n + 1个空指针域。</p></li><li><p>一个序列，经过栈的作用可以得到 C^n^<del>2n</del>&#x2F; (n+1) 中不同的输出序列。（卡特兰数）</p></li></ol><blockquote><p>如：序列有3个数，则有5中不同的输出序列。</p></blockquote><ol start="11"><li><p>设哈夫曼树有n个节点，则该树有 0 个度数为1的节点。</p></li><li><p>设有n个结点的完全二叉树，如果按照从自上到下、从左到右从1开始顺序编号，则第 i 个结点的双亲结点编号为 i &#x2F; 2 ;  右孩子结点的编号为 2i + 1。</p></li><li><p>设一组初始记录关键字为(72，73，71，23，94，16，5)，则以记录关键字72为基准的一趟快速排序结果为 </p><blockquote><p>答案：(5，16，71，23，72，94，73)</p><p>两个指针，从左开始，和从右开始，先从右开始选第一个遇到的小于基准的数，和基准数换位；换 从左开始，遇到的第一个大于基准的数，和基准换位；再从右继续……循环，直至小于基准的在左边，大于基准的在右边。</p></blockquote></li><li><p>在二叉排序树中插入一个结点的时间复杂度为 O(n)，如果该排序树即不平衡，需要遍历n个节点，如果该树很平衡，则只需log<del>2</del>n。</p></li><li><p>设初始记录关键字序列为(K1，K2，…，Kn)，则用筛选法思想建堆必须从第 <em><strong>n&#x2F;2</strong></em> 个元素开始进行筛选。</p></li><li><p>设哈夫曼树中共有99个结点，则该树中有<u>50</u> 个叶子结点；若采用二叉链表作为存储结构，则该树中有_<u>100</u>_个空指针。</p></li><li><p>设有一个顺序循环队列中有M个存储单元，则该循环队列中最多能够存储______m-1个队列元素；当前实际存储_____(R - F + M) % M_个队列元素（设头指针F指向当前队头元素的前一个位置，尾指针指向当前队尾元素的位置）。</p></li><li><p>设顺序线性表中有n个数据元素，则第i个位置上插入一个数据元素需要移动表中 <em><strong><u>n-i+1</u></strong></em> 个数据元素；删除第i个位置上的数据元素需要移动表中 <u>n-i</u> 个元素。</p></li><li><p>根据二叉树的<u>先序和中序</u>遍历、或<u>中序和后序</u>遍历，可以唯一确定二叉树的形状。</p></li><li><p>筛选法建初始堆必须从第 n &#x2F; 2 个元素开始进行筛选。</p></li><li><p>快速排序在序列基本有序时为 O(n^2^)，在序列基本无序时为 O(nlog<del>2</del>n)。</p></li><li><p>设一棵m叉树的结点数为n，用多重链表表示其存储结构，则该树中有 <u>n(m-1)+1</u> 个空指针域。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(others)</title>
      <link href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/"/>
      <url>/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9COthers/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>计算机网络已由一种<strong>通信基础设施</strong>发展为一种重要的<strong>信息服务基础设施</strong>。</p><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>网络、互联网 和 因特网：</strong></p><p>网络：网络（Network）由若干<strong>结点（Node）</strong>和连接这些结点的<strong>链路（Link）</strong>组成。</p><p>互连网（互联网）：多个网络通过<strong>路由器</strong>互连起来，这样就构成了一个覆盖范围更大的网络，即互连网（互联网）。因此，互联网又称为“网络的网络（Network of Networks）”。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092055783.png" alt="image-20220609205526560"></p><p>因特网：因特网（Internet）是世界上最大的互连网络（用户数以亿计，互连的网络数以百万计）。</p><blockquote><p><strong>internet与Internet的区别</strong></p><ul><li><strong>internet(互联网或互连网)是一个通用名词，它泛指多个计算机网络互连而成的网络</strong>。在这些网络之间的通信协议可以是任意的。</li><li><strong>Internet（因特网）则是一个专用名词</strong>，它指<strong>当前全球最大的、开放的、由众多网络互连而成的特定计算机网络</strong>，它采用TCP&#x2F;IP协议族作为通信的规则，其前身是美国的ARPANET。</li></ul><p><strong>任意把几个计算机网络互连起来（不管采用什么协议），并能够相互通信，这样构成的是一个互连网(internet) ，而不是因特网(Internet)。</strong></p></blockquote><p><strong>因特网发展的三个阶段：</strong></p><p>一，从单个网络AEPANET向互联网发展</p><blockquote><p>1969年，第一个分组交换网AEPANET；</p><p>70年代中期，研究多种网络之间的互联；</p><p>1983年，TCP&#x2F;IP协议成为ARPANET的标准协议(因特网诞生)</p></blockquote><p>二，逐步建成三级结构的因特网</p><blockquote><p>1985年，NSF围绕六个大型计算机中心建设NSFNET（主干网，地区网，校园网）；</p><p>1990年，ARPANET任务完成，正式关闭；</p><p>1991年，美国政府将因特网主干网交给私人公式经营，并开始对接入因特网的单位收费；</p></blockquote><p>三，逐步形成了多层次的ISP结构的因特网</p><blockquote><p>1993年，NSFNET逐渐被若干个商用因特网主干网替代，政府不再负责因特网运营，让各种<strong>因特网服务提供者ISP</strong>来运营；</p><p>1994年，万维网WWW技术促使因特网迅速发展；</p><p>1995年，NSFNET停止运作，因特网彻底商业化</p></blockquote><p><strong>因特网服务提供者ISP(Internet Service Provider)</strong></p><blockquote><p>普通用户是如何接入到因特网的呢？</p><p>答：<strong>通过ISP接入因特网</strong></p><p>ISP可以从因特网管理机构申请到成块的IP地址，同时拥有通信线路以及路由器等联网设备。任何机构和个人只需缴纳费用，就可从<strong>ISP的得到所需要的IP地址</strong>。</p><p><strong>因为因特网上的主机都必须有IP地址才能进行通信，所以要通过该ISP接入到因特网</strong></p><p>中国的三大<code>ISP</code>：中国电信，中国联通和中国移动</p><p>一旦某个用户能够接入到因特网，那么他也可以成为一个ISP，所需要做的就是购买一些如调制解调器或路由器这样的设备，让其他用户可以和他相连。</p></blockquote><p><strong>因特网的标准化工作：</strong></p><ul><li><p>因特网的标准化工作对因特网的发展起到了非常重要的作用。</p></li><li><p>因特网在指定其标准上的一个很大的特点是</p><p>面向公众。</p><ul><li>因特网所有的<strong>RFC</strong>(Request For Comments)技术文档都可从因特网上免费下载；</li><li>任何人都可以随时用电子邮件发表对某个文档的意见或建议。</li></ul></li><li><p>因特网协会ISOC</p><p>是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><ul><li>因特网体系结构委员会IAB，负责管理因特网有关协议的开发；</li><li>因特网工程部IETF，负责研究中短期工程问题，主要针对协议的开发和标准化；</li><li>因特网研究部IRTF，从事理论方面的研究和开发一些需要长期考虑的问题。</li></ul></li><li><p>制订因特网的正式标准要经过以下<strong>4个阶段</strong>：</p><p>1、因特网草案（在这个阶段还不是RFC文档）</p><p>2、建议标准（从这个阶段开始就成为RFC文档）</p><p>3、草案标准</p><p>4、因特网标准</p></li></ul><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul><li><p>边缘部分</p><p>由所有连接在因特网上的<strong>主机</strong>组成（台式电脑，大型服务器，笔记本电脑，平板，智能手机等）。这部分是<strong>用户直接使用</strong>的，用来进行<strong>通信</strong>（传送数据、音频或视频）和<strong>资源共享</strong>。</p></li><li><p>核心部分</p><p>由<strong>大量网络</strong>和连接这些网络的<strong>路由器</strong>组成。这部分是<strong>为边缘部分提供服务</strong>的（提供连通性和交换）。</p></li></ul><blockquote><p>路由器是一种专用计算机，但我们不称它为主机，路由器是实现分组交换的关键构建，其任务是转发收到的分组，这是网络核心最重要的部分。</p><p>处在互联网边缘的部分就是连接在互联网上的所有的主机。这些主机又称为**端系统 (end system)**。</p><p><strong>端系统在功能上可能有很大的差别：</strong></p><ol><li>小的端系统可以是一台普通个人电脑，具有上网功能的智能手机，甚至是一个很小的网络摄像头。</li><li>大的端系统则可以是一台非常昂贵的大型计算机。</li><li>端系统的拥有者可以是个人，也可以是单位（如学校、企业、政府机关等），当然也可以是某个ISP。</li></ol></blockquote><p><strong>端系统之间通信的含义</strong></p><p>“主机 A 和主机 B 进行通信”实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。<strong>即“主机</strong> <strong>A</strong> <strong>的某个进程和主机</strong> <strong>B</strong> <strong>上的另一个进程进行通信”。简称为“计算机之间通信”。</strong></p><p>端系统之间的通信方式通常可划分为两大类：</p><p><strong>客户-服务器方式（C&#x2F;S方式）：</strong></p><ul><li>客户 (client) 和服务器 (server) 都是指通信中所涉及的两个应用进程。</li><li>客户 - 服务器方式所描述的是进程之间服务和被服务的关系。</li><li>客户是服务的请求方，服务器是服务的提供方。</li></ul><blockquote><p><strong>服务请求方和服务提供方都要使用网络核心部分所提供的服务。</strong></p></blockquote><p><strong>对等连接方式：</strong></p><ul><li><strong>对等连接</strong> (peer-to-peer，简写为 <strong>P2P</strong> ) 是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。</li><li>只要两个主机都运行了对等连接软件 ( P2P 软件) ，它们就可以进行<strong>平等的、对等连接通信</strong>。</li><li>双方都可以下载对方已经存储在硬盘中的共享文档。</li></ul><h2 id="三种交换方式"><a href="#三种交换方式" class="headerlink" title="三种交换方式"></a>三种交换方式</h2><p>网络核心部分是互联网中最复杂的部分。</p><p>网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。</p><p>在网络核心部分起特殊作用的是<strong>路由器</strong>(router)。</p><p><strong>路由器</strong>是实现<strong>分组交换</strong> (packet switching) 的关键构件，其任务是<strong>转发</strong>收到的分组，这是网络核心部分最重要的功能。</p><hr><p>三种交换方式：</p><h4 id="分组交换（Packet-Switching）"><a href="#分组交换（Packet-Switching）" class="headerlink" title="分组交换（Packet Switching）"></a>分组交换（Packet Switching）</h4><blockquote><p>通常我们把表示<strong>该消息的整块数据</strong>成为一个<strong>报文</strong>。</p><p>在发送报文之前，先把较长的报文划分成一个个更小的<strong>等长数据段</strong>，在每一个数据段前面。加上一些由必<strong>要的控制信息组成的首部</strong>后，就构成一个分组，也可简称为“包”，相应地，首部也可称为“包头”。</p><p>首部包含了<strong>分组的目的地址</strong></p><p>分组从源主机到目的主机，可走不同的路径。</p></blockquote><p>发送方</p><ul><li>构造分组</li><li>发送分组</li></ul><p>路由器</p><ul><li><p>缓存分组</p></li><li><p>转发分组</p><p>简称为“分组转发”</p></li></ul><blockquote><p>在路由器中的输入和输出端口之间没有直接连线。</p><p>路由器处理分组的过程是：</p><ol><li>把收到的分组先<strong>放入缓存（暂时存储）；</strong></li><li><strong>查找转发表</strong>，找出到某个目的地址应从哪个端口转发；</li><li>把分组送到适当的端口<strong>转发</strong>出去。</li></ol></blockquote><p>接收方</p><ul><li>接收分组</li><li>还原报文</li></ul><p><strong>报文交换（Message Switching）</strong></p><p>报文交换中的交换结点也采用存储转发方式，但报文交换对报文的大小没有限制，这就要求交换结点需要较大的缓存空间。报文交换主要用于早期的电报通信网，现在较少使用，<strong>通常被较先进的分组交换方式所取代</strong>。</p><p><strong>电路交换（Circuit Switching）</strong></p><blockquote><p>传统两两相连的方式，当电话数量很多时，电话线也很多，就很不方便</p><p>所以要使得每一部电话能够很方便地和另一部电话进行通信，就应该使用一个<strong>中间设备</strong>将这些电话连接起来，这个中间设备就是<strong>电话交换机</strong></p></blockquote><ul><li><p>电话交换机接通电话线的方式称为电路交换；</p></li><li><p>从通信资源的分配角度来看，交换（Switching）就是按照某种方式动态地分配传输线路的资源；</p></li><li><p>电路交换的三个步骤：</p><p>1、建立连接（分配通信资源）</p><p>2、通话（一直占用通信资源）</p><p>3、释放连接（归还通信资源）</p></li></ul><blockquote><p>当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。</p><p>这是因为计算机数据是突发式地出现在传输线路上的。</p><p>所以计算机通常采用的是<strong>分组交换</strong>，而不是线路交换</p></blockquote><h4 id="三种交换方式的对比"><a href="#三种交换方式的对比" class="headerlink" title="三种交换方式的对比"></a>三种交换方式的对比</h4><blockquote><p>假设A，B，C，D是分组传输路径所要经过的4个结点交换机，纵坐标为时间</p></blockquote><p>分析：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092111714.png" alt="image-20220609211127245"></p><p>电路交换：</p><ul><li>通信之前首先要建立连接；连接建立好之后，就可以使用已建立好的连接进行数据传送；数据传送后，需释放连接，以归还之前建立连接所占用的通信线路资源。</li><li>一旦建立连接，中间的各结点交换机就是直通形式的，比特流可以直达终点；</li></ul><p>报文交换：</p><ul><li>可以随时发送报文，而不需要事先建立连接；整个报文先传送到相邻结点交换机，全部存储下来后进行查表转发，转发到下一个结点交换机。</li><li>整个报文需要在各结点交换机上进行存储转发，由于不限制报文大小，因此需要各结点交换机都具有较大的缓存空间。</li></ul><p>分组交换：</p><ul><li>可以随时发送分组，而不需要事先建立连接。构成原始报文的一个个分组，依次在各结点交换机上存储转发。各结点交换机在发送分组的同时，还缓存接收到的分组。</li><li>构成原始报文的一个个分组，在各结点交换机上进行存储转发，相比报文交换，减少了转发时延，还可以避免过长的报文长时间占用链路，同时也有利于进行差错控制。</li></ul><h2 id="定义和分类"><a href="#定义和分类" class="headerlink" title="定义和分类"></a>定义和分类</h2><p><strong>定义</strong></p><ul><li><p>计算机网络的精确定义并未统一</p></li><li><p>计算机网络的最简单的定义是：一些互相连接的、自治的计算机的集合</p><ul><li><strong>互连</strong>：是指计算机之间可以通过有线或无线的方式进行数据通信；</li><li><strong>自治</strong>：是指独立的计算机，他有自己的硬件和软件，可以单独运行使用；</li><li><strong>集合</strong>：是指至少需要两台计算机；</li></ul></li><li><p>计算机网络的较好的定义是：计算机网络主要是由一些<strong>通用的，可编程的硬件</strong>（一定包含有中央处理机CPU）<strong>互连</strong>而成的，而这些硬件并非专门用来实现某一特定目的（例如，传送数据或视频信号）。这些可编程的硬件能够用来<strong>传送多种不同类型的数据</strong>，并能<strong>支持广泛的和日益增长的应用</strong>。</p><ul><li>计算机网络所连接的硬件，并不限于一般的计算机，而是包括了智能手机等智能硬件。</li></ul></li><li><p>计算机网络并非专门用来传送数据，而是能够支持很多种的应用（包括今后可能出现的各种应用）。</p></li></ul><p><strong>分类：</strong></p><p><strong>按交换技术分类：</strong></p><ul><li>电路交换网络</li><li>报文交换网络</li><li>分组交换网络</li></ul><p><strong>按使用者分类：</strong></p><ul><li><p>公用网</p></li><li><p>专用网</p></li></ul><p><strong>按传输介质分类：</strong></p><ul><li>有线网络</li><li>无线网络</li></ul><p><strong>按覆盖范围分类：</strong></p><ul><li>广域网WAN（Wide Area Network）</li></ul><p>作用范围通常为几十到几千公里，因而有时也称为远程网（long haul network）。广域网是互联网的核心部分，其任务是通过长距离（例如，跨越不同的国家）运送主机所发送的数据。</p><ul><li>城域网MAN</li></ul><p>作用范围一般是一个城市，可跨越几个街区甚至整个城市</p><ul><li>局域网LAN</li></ul><p>一般用微型计算机或工作站通过高速通信线路相连（速率通常在 10 Mbit&#x2F;s 以上），但地理上范围较小（1 km 左右）</p><ul><li>个域网PAN</li></ul><p>就是在个人工作的地方把个人使用的电子设备用无线技术连接起来的网络。</p><p><strong>按拓扑结构分类：</strong></p><ul><li><p>总线型网络</p></li><li><p>星型网络</p></li><li><p>环形网络</p></li><li><p>网状型网络</p></li></ul><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092123906.png" alt="image-20220609212320739" style="zoom:33%;" /><hr><h2 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h2><blockquote><p>速率 ，带宽，吞吐量，时延<br>时延带宽积，往返时间RTT，利用率，丢包率</p></blockquote><p><strong>速率</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092129034.png" alt="image-20220609212901840"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092129544.png" alt="image-20220609212954392"></p><p><strong>带宽</strong></p><p>带宽在计算机网络中的意义：</p><p>用来表示网络的<strong>通信线路所能传送数据的能力</strong>，因此网络带宽表示在<strong>单位时间</strong>内从网络中的某一点到另一点所能通过的“<strong>最高数据率</strong>”；<br>单位：b&#x2F;s (kb&#x2F;s,Mb&#x2F;s,Gb&#x2F;s,Tb&#x2F;s)</p><blockquote><p>平时说的出口网速 200兆之类，就是指带宽200Mb&#x2F;s</p></blockquote><blockquote><p>带宽在模拟信号系统中的意义：</p><p>信号所包含的各种不同频率成分所占据的频率范围；<br>单位：Hz （kHz，MHz，GHz）</p></blockquote><p><strong>吞吐量</strong></p><p>吞吐量表示在<strong>单位时间内通过某个网络 (或信道、接口) 的数据量</strong>。吞吐量被经常用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><p>吞吐量受网络的带宽或额定速率的限制。</p><blockquote><p>带宽1 Gb&#x2F;s的以太网，代表其额定速率是1 Gb&#x2F;s，这个数值也是该以太网的<strong>吞吐量的绝对上限值</strong>。因此，对于带宽1 Gb&#x2F;s的以太网，可能实际吞吐量只有 700 Mb&#x2F;s，甚至更低。</p><p>注意：吞吐量还可以用每秒传送的字节数或帧数表示</p></blockquote><p><strong>时延</strong></p><p>时延时指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。</p><p>网络时延由几部分组成：</p><ul><li><strong>发送时延  &#x3D; 分组长度(b) &#x2F; 发送速率 (b&#x2F;s)</strong></li></ul><p>主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 </p><ul><li><strong>传播时延 &#x3D; 信道长度(m) &#x2F; 电磁波传播速率(m&#x2F;s)</strong></li></ul><p>电磁波在信道中传播一定的距离需要花费的时间。</p><blockquote><p>常见的电磁波传播速率：</p><p>自由空间： 3 * 10^8^ m&#x2F;s</p><p>铜线：2.3 * 10^8^ m&#x2F;s</p><p>光纤：2.0 * 10^8^ m&#x2F;s</p></blockquote><ul><li><strong>处理时延</strong></li></ul><p>主机或路由器在收到分组时要花费一定时间进行处理</p><ul><li><strong>排队时延</strong></li></ul><p>分组在进过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。</p><blockquote><p>有时会把排队时延看成<strong>处理时延 一部分</strong></p><p>总时延 &#x3D; 发送时延 + 传播时延 + 处理时延 （处理时延 + 排队时延）</p></blockquote><blockquote><p>当处理时延忽略不计时，发送时延 和 传播时延谁占主导，要具体情况具体分析</p></blockquote><p><strong>时延带宽积</strong></p><p>时延带宽积 &#x3D; 传播时延 * 带宽</p><blockquote><p>可以把时延带宽积看作一个圆柱体管道，传播时延是长度，带宽的圆柱面积，则时延带宽积就是圆柱的体积。</p></blockquote><p><strong>往返时间RTT</strong></p><p>互联网上的信息很多时候是双向交互的。往返时间RTT(route-trip-time)就是<strong>双向交互一次所需的时间</strong>。</p><p><strong>利用率</strong></p><p>利用率有<strong>信道利用率</strong>和<strong>网络利用率</strong>两种。</p><ul><li>信道利用率：用来表示某信道有百分之几的时间是被利用的。（有数据通过）</li><li>网络利用率：全网络的信道利用率的加权平均。</li></ul><p>根据排队论，当某信道的利用率增大时，该信道的时延也会迅速增加。对此，信道利用率不是越多越好。</p><p>令U为利用率，D<del>0</del>表示网络空闲时的时延，D表示网络当前的时延，那么在适当的假定条件下，可以用简单公司来表示： D &#x3D; D<del>0</del> &#x2F; (1-U )  或 U &#x3D; 1 - D<del>0</del>&#x2F;D</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092157958.png" alt="image-20220609215754798" style="zoom:50%;" /><p>一般ISP会控制他们的信道利用率不超过50%，否则就要准备扩容增大线路带宽。</p><p><strong>丢包率</strong></p><p>即分组丢失率，指在一定的时间范围内，传输过程中丢失的分组数量于总分组数量的比率。</p><p>分组丢失主要分为：</p><ul><li>分组在传输过程中出现误码，被节点丢弃；</li><li>分组到达一台队列已满的分组交换机时会被丢弃，在通信量较大时可能造成网络拥塞。</li></ul><hr><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><strong>常见体系结构：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101158602.png" alt="image-20220610115806247"></p><p>如今用的最多的是TCP&#x2F;IP体系结构，现今规模最大的、覆盖全球的、基于TCP&#x2F;IP的互联网并未使用OSI标准。</p><p>TCP&#x2F;IP体系结构相当于将OSI体系结构的<strong>物理层</strong>和<strong>数据链路层</strong>合并为了<strong>网络接口层</strong>，并去掉了<strong>会话层</strong>和<strong>表示层</strong>。</p><p>TCP&#x2F;IP在网络层使用的协议是IP协议，IP协议的意思是网际协议，因此<strong>TCP&#x2F;IP体系结构的网络层称为网际层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206092212994.png" alt="image-20220609221218825"></p><p>在用户主机的操作系统中，通常都带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。</p><p>而用于网络互连的路由器中，也带有符合TCP&#x2F;IP体系结构标准的TCP&#x2F;IP协议族。只不过路由器一般只包含网络接口层和网际层。</p><p><strong>网络接口层</strong>：并没有规定具体内容，这样做的目的是可以互连全世界各种不同的网络接口，例如：有线的以太网接口，无线局域网的WIFI接口等。</p><p><strong>网际层</strong>：它的核心协议是IP协议。</p><p><strong>运输层</strong>：TCP和UDP是这层的两个重要协议。</p><p><strong>应用层</strong>：这层包含了大量的应用层协议，如 HTTP , DNS 等。</p><blockquote><p><strong>IP协议（网际层）</strong>可以将不同的<strong>网络接口（网络接口层）</strong>进行互连，并向其上的<strong>TCP协议和UDP协议（运输层）</strong>提供网络互连服务</p><p>而<strong>TCP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>可靠</strong>的传输服务。</p><p><strong>UDP协议</strong>在享受IP协议提供的网络互连服务的基础上，可向<strong>应用层的相应协议</strong>提供<strong>不可靠</strong>的传输服务。</p></blockquote><blockquote><p>TCP&#x2F;IP体系结构中最重要的是<strong>IP协议</strong>和<strong>TCP协议</strong>，因此用TCP和IP来表示整个协议大家族。</p></blockquote><p><strong>结构分层的必要性：</strong></p><blockquote><p>物理层：解决使用何种信号来传输比特的问题</p><p>数据链路层：解决分组在一个网络或一段链路上传输的问题</p><p>网络层：解决分组在多个网络上传输（路由）的问题</p><p>传输层：解决进程间基于网络的通信问题</p><p>应用层：解决通过应用进程的交互来实现特定网络应用的问题</p></blockquote><p><strong>物理层问题</strong>  </p><ul><li>采用怎样的传输媒体（介质）</li><li>采用在怎样的物理接口</li><li>使用怎样的信号表示比特1和0</li></ul><blockquote><p>严格来说，传输媒体并不属于物理层</p></blockquote><p><strong>数据链路层问题</strong></p><ul><li>如何标识网络中的各主机（主机编制问题，如MAC地址）</li><li>如何从信号所表示的一连串比特流中区分出地址和数据</li><li>如何协调各主机争用总线（总线已被淘汰），以太网交换机如何实现</li></ul><p><strong>网络层问题</strong></p><ul><li>如何标识各网络，以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</li><li>路由器如何转发分组，如何进行路由选择</li></ul><p><strong>运输层问题</strong></p><ul><li>如何解决进程间基于网络的通信问题</li><li>出现传输错误时，如何处理</li></ul><p><strong>应用层问题</strong></p><ul><li>通过应用进程间的交互来完成特定的网络应用</li></ul><blockquote><p>应用层该用什么方法（应用层协议）去解析数据</p></blockquote><h3 id="结构分层思想举例"><a href="#结构分层思想举例" class="headerlink" title="结构分层思想举例"></a>结构分层思想举例</h3><p>例子：主机的浏览器如何与Web服务器进行通信</p><p><strong>解析：</strong></p><p>主机和Web服务器之间基于网络的通信，实际上是主机中的<strong>浏览器应用进程</strong>与Web服务器中的<strong>Web服务器应用进程</strong>之间基于<strong>网络的通信</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101216697.png" alt="image-20220610121600426"></p><p><strong>体系结构的各层在整个过程中起到怎样的作用？</strong></p><p><strong>1、发送方发送</strong></p><p>第一步：</p><ul><li><strong>应用层</strong>按照HTTP协议的规定构建一个<strong>HTTP请求报文</strong></li><li>应用层将HTTP请求报文交付给<strong><strong>运输层</strong></strong>处理</li></ul><p>第二步：</p><ul><li><strong>运输层</strong>给HTTP请求报文添加一个<strong>TCP首部</strong>，使之成为<strong>TCP报文段</strong></li><li>TCP报文段的首部格式作用是区分应用进程以及实现可靠传输</li><li>运输层将TCP报文段交付给网络层处理</li></ul><p>第三步：</p><ul><li><strong>网络层</strong>给TCP报文段添加一个<strong>IP首部</strong>，使之成为<strong>IP数据报</strong></li><li>IP数据报的首部格式作用是使IP数据报可以在互联网传输，也就是被路由器转发</li><li>网络层将IP数据报交付给数据链路层处理</li></ul><p>第四步：</p><ul><li><strong>数据链路层</strong>给IP数据报添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong> </li><li>该<strong>首部的作用</strong>主要是为了让帧能够在一段链路上或一个网络上<strong>传输</strong>，能够被相应的目的主机<strong>接收</strong></li><li>该<strong>尾部的作用</strong>是让目的主机检查所接收到的<strong>帧是否有误码</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>交付给<strong>物理层</strong></li></ul><p>第五步：</p><ul><li><strong>物理层</strong>先将<strong>帧</strong>看做是<strong>比特流</strong>，并在该<strong>比特流</strong>前面添加<strong>前导码</strong></li><li><strong>前导码</strong>的作用是为了让目的主机做好接收帧的准备</li><li>物理层将装有前导码的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体</li></ul><p>第六步：</p><ul><li><strong>信号</strong>通过<strong>传输媒体</strong>到达<strong>路由器</strong></li></ul><p><strong>2、路由器转发</strong></p><p>在路由器中</p><ul><li><p><strong>物理层</strong>将<strong>信号</strong>变为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后，将其交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后，将其交付给<strong>网络层</strong>，这实际交付的是<strong>IP数据报</strong></p></li><li><p><strong>网络层</strong>解析<strong>IP数据报</strong>的<strong>首部</strong>，从中提取<strong>目的网络地址</strong></p></li><li><p>提取<strong>目的网络地址</strong>后查找<strong>自身路由表</strong>。确定<strong>转发端口</strong>， 以便进行转发</p></li><li><p><strong>网络层</strong>将<strong>IP数据报</strong>交付给<strong>数据链路层</strong></p></li><li><p><strong>数据链路层</strong>给<strong>IP数据报</strong>添加一个<strong>首部</strong>和一个<strong>尾部</strong>，使之成为<strong>帧</strong></p></li><li><p><strong>数据链路层</strong>将帧交付给<strong>物理层</strong></p></li><li><p><strong>物理层</strong>先将<strong>帧</strong>看成<strong>比特流</strong>，这里的网络N2假设是以太网，所以<strong>物理层</strong>还会给该<strong>比特流</strong>前面添加<strong>前导码</strong></p></li><li><p>物理层将装有<strong>前导码</strong>的<strong>比特流</strong>变换成相应的<strong>信号</strong>发送给传输媒体，信号通过传输媒体到达<strong>Web服务器</strong></p></li></ul><p><strong>3、接收方接收</strong></p><p>和发送方（主机）发送过程的封装正好是反着来</p><p>在Web 服务器上</p><ul><li><strong>物理层</strong>将<strong>信号</strong>变换为<strong>比特流</strong>，然后去掉<strong>前导码</strong>后成为<strong>帧</strong>，交付给<strong>数据链路层</strong></li><li><strong>数据链路层</strong>将<strong>帧</strong>的<strong>首部</strong>和<strong>尾部</strong>去掉后成为<strong>IP数据报</strong>，将其交付给<strong>网络层</strong></li><li><strong>网络层</strong>将<strong>IP数据报</strong>的<strong>首部</strong>去掉后成为<strong>TCP报文段</strong>，将其交付给<strong>运输层</strong></li><li><strong>运输层</strong>将<strong>TCP报文段</strong>的<strong>首部</strong>去掉后成为<strong>HTTP请求报文</strong>，将其交付给<strong>应用层</strong></li><li><strong>应用层</strong>对<strong>HTTP请求报文</strong>进行<strong>解析</strong>，然后给主机发回<strong>响应报文</strong></li></ul><blockquote><p>发回响应报文的步骤和之前过程类似</p></blockquote><h3 id="结构中的专用术语"><a href="#结构中的专用术语" class="headerlink" title="结构中的专用术语"></a>结构中的专用术语</h3><p>以下介绍的专用术语来源于OSI的七层协议体系结构，但也适用于TCP&#x2F;IP的四层体系结构和五层协议体系结构</p><p><strong>实体</strong></p><p>实体：任何可发送或接受信息的硬件或软件进程；</p><p>对等实体：收发双方相同层次中的实体。</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101225613.png" alt="image-20220610122556298" style="zoom:50%;" /><p><strong>协议</strong></p><p>协议：控制两个对等实体进行逻辑通信的规则的集合</p><p>协议三要素：</p><ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双发的时序关系</li></ul><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101226924.png" alt="image-20220610122641613" style="zoom: 50%;" /><p><strong>服务</strong></p><p>在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务；要实现本层协议，还需要实现下面一层所提供的服务。</p><blockquote><p>协议是水平的，服务的垂直的。</p><p>实体看的见相邻下层所提供的服务，但并不知道实现该服务的具体协议。</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101425791.png" alt="image-20220610142535580"></p><p>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</p><ul><li>数据链路层的服务访问点为 帧的“类型”字段；</li><li>网络层的服务访问点为 IP数据报首部的“协议字段”</li><li>运输层的服务访问点为 “端口号”</li></ul><p>服务原语：上层使用下层所提供的服务必须通过与下层交换的 一些命令。</p><p>协议数据单元PDU：对等层次之间传送的数据包。</p><p>服务数据单元SDU：同一系统内，层与层之间交换的数据报。</p><blockquote><p>多个SDU可以合成为一个PDU，一个SDU也可以划分为几个PDU</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202206101435104.png" alt="image-20220610143542921"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="体系结构题目"><a href="#体系结构题目" class="headerlink" title="体系结构题目"></a>体系结构题目</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816036.png" alt="image-20201007230219248"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816006.png" alt="image-20201007230242426"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816577.png" alt="image-20201007230300194"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816509.png" alt="image-20201007230345580"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816604.png" alt="image-20201007230404271"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816327.png" alt="image-20201007230432453"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816796.png" alt="image-20201007230450993"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201816958.png" alt="image-20201007230511370"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817497.png" alt="image-20201007230548012"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817672.png" alt="image-20201007230616796"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817303.png" alt="image-20201007230635007"></p><h3 id="时延相关题目"><a href="#时延相关题目" class="headerlink" title="时延相关题目"></a>时延相关题目</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817503.png" alt="image-20201007230747143"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817860.png" alt="image-20201007231024960"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817068.png" alt="image-20201007230843470"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817264.png" alt="image-20201007231125552"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817817.png" alt="image-20201007231159268"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817500.png" alt="image-20201007231234486"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817962.png" alt="image-20201007231318549"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201817733.png" alt="image-20201007231338817"></p><hr><hr><h1 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</p><p>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络具体的传输媒体是什么。</p><p>物理层协议的主要任务：</p><ul><li><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li><li><strong>电器特性</strong>：指明在接口电缆的各条线上出现的电压的范围。</li><li><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</li><li><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</li></ul><hr><p><strong>物理层下面的传输媒体</strong></p><p><strong>传输媒体</strong>也称为传输介质或传输媒介，他就是数据传输系统中在发送器和接收器之间的物理通路。可分为两大类，即<strong>导引型传输媒体</strong>和<strong>非导引型传输媒体</strong></p><p>传输媒体不属于计算机网络体系结构的任何一层。如果非要将它添加到体系结构中，那只能将其放置到物理层之下。</p><p><strong>导引型传输媒体——</strong> 同轴电缆，双绞线，光纤，电力线</p><p>在导引型传输媒体中，电磁波被导引沿着固体媒体传播。</p><p><strong>同轴电缆</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820064.png" alt="image-20201008132050917"></p><p><strong>双绞线</strong></p><p>绞合的作用：抵御外部的电磁波干扰，减少相邻导线的电磁干扰</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820943.png" alt="image-20201008132225715"></p><p><strong>光纤</strong></p><p>光纤的优点：</p><ul><li>通信容量大(25000~30000GHz的带宽)</li><li>传输损耗小，远距离传输时更加经济</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820250.png" alt="image-20201008132403903"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820991.png" alt="image-20201011001240573"></p><blockquote><p><strong>多模光纤</strong></p><ul><li>可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为<strong>多模光纤</strong>。</li></ul><p><strong>单模光纤</strong></p><ul><li>若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为<strong>单模光纤</strong>。</li></ul></blockquote><p><strong>电力线</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820364.png" alt="image-20201008132709015"></p><p>**非导引型传输媒体—— ** 无线电波，微波，红外线，可见光</p><p>非导引型传输媒体是指自由空间。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820859.png" alt="image-20201008132857833"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201820579.png" alt="image-20201008132943176"></p><p><strong>无线电波</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821443.png" alt="image-20201008133135659"></p><p><strong>微波</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821980.png" alt="image-20201008133317293"></p><p><strong>红外线</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821480.png" alt="image-20201008133421986"></p><p><strong>可见光</strong></p><p><a href="https://baike.baidu.com/item/%E5%8F%AF%E8%A7%81%E5%85%89%E6%97%A0%E7%BA%BF%E9%80%9A%E4%BF%A1/16268518?fromtitle=LiFi&fromid=5675729&fr=aladdin">LIFI</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201821992.png" alt="image-20201008133718810"></p><hr><h2 id="传输方式"><a href="#传输方式" class="headerlink" title="传输方式"></a>传输方式</h2><h3 id="串行传输和并行传输"><a href="#串行传输和并行传输" class="headerlink" title="串行传输和并行传输"></a>串行传输和并行传输</h3><blockquote><p><strong>串行传输</strong>：</p><ul><li>数据是一个比特一个比特依次发送的，因此在发送端与接收端之间，只需要一条数据传输线路即可</li></ul><p><strong>并行传输</strong>：</p><ul><li><p>一次发送n个比特，因此，在发送端和接收端之间需要有n条传输线路</p></li><li><p>并行传输的优点是比串行传输的速度n倍，但成本高</p></li></ul><p>数据在传输线路上的传输采用是<strong>串行传输</strong>，计算机内部的数据传输常用<strong>并行传输</strong></p></blockquote><h3 id="同步传输和异步传输"><a href="#同步传输和异步传输" class="headerlink" title="同步传输和异步传输"></a>同步传输和异步传输</h3><p><strong>同步传输</strong>：</p><ul><li>数据块以稳定的比特流的形式传输。字节之间没有间隔</li><li>接收端在每个比特信号的中间时刻进行检测，以判别接收到的是比特0还是比特1</li><li>由于不同设备的时钟频率存在一定差异，不可能做到完全相同，在传输大量数据的过程中，所产生的判别时刻的累计误差，会导致接收端对比特信号的判别错位</li></ul><p>所以要使收发双发时钟保持同步</p><ul><li>外同步：在收发双方之间添加一个单独的时钟信号线；</li><li>内同步：发送端将时钟同步信号编码到发送数据中一起传输（如曼切斯特编码）</li></ul><p><strong>异步传输</strong>：</p><ul><li>以字节为独立的传输单位，字节之间的时间间隔不是固定</li><li>接收端仅在每个字节的起始处对字节内的比特实现同步</li><li>通常在每个字节前后分别加上起始位和结束位</li></ul><blockquote><p>字节间异步（字节间的时间间隔不固定）</p><p>但字节中的每个比特仍是同步的（各比特的持续时间相同）</p></blockquote><h3 id="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"><a href="#单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）" class="headerlink" title="单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）"></a>单向通信（单工）、双向交替通信（半双工）和双向同时通信（全双工）</h3><p>在许多情况下，我们要使用“<strong>信道（channel）</strong>”这一名词。信道和电路并不等同。信道一般都是用来表示向某一个方向传送信息的媒体。因此，一条通信电路往往包含一条发送信道和一条接收信道。</p><p>从通信的双方信息交互的方式来看，可以有以下三种基本方式：</p><ul><li><p><strong>单向通信</strong>：</p><p>又称为<strong>单工通信</strong>，即<strong>只能有一个方向的通信而没有反方向的交互</strong>。无线电广播或有线电以及电视广播就属于这种类型</p></li><li><p><strong>双向交替通信</strong>：</p></li></ul><p>  又称为<strong>半双工通信</strong>，即通信的双方可以发送信息，但<strong>不能双方同时发送</strong>（当然也就不能同时接收）。这种通信方式使一方发送另一方接收，过一段时间后可以再反过来。</p><ul><li><strong>双向同时通信</strong>：</li></ul><p>  又称为<strong>全双工通信</strong>，即通信的双发<strong>可以同时发送和接收信息</strong>。</p><blockquote><p><strong>单向通信</strong>只需要一条信道，而<strong>双向交替通信</strong>或<strong>双向同时通信</strong>则需要两条信道（每个方向各一条）</p><p><strong>双向同时通信</strong>的传输效率最高</p></blockquote><h2 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201822780.png" alt="image-20201008144616896"></p><p><strong>常用术语</strong></p><ul><li><p><strong>数据 (data)</strong> —— 运送消息的实体。</p></li><li><p><strong>信号 (signal)</strong> —— 数据的电气的或电磁的表现。 </p></li><li><p><strong>模拟信号 (analogous signal)</strong> —— 代表消息的参数的取值是连续的。 </p></li><li><p><strong>数字信号 (digital signal)</strong> —— 代表消息的参数的取值是离散的。 </p></li><li><p><strong>码元 (code)</strong> —— 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><p>简单的说，码元就是构成信号的一段波形。</p></li><li><p><strong>基带信号</strong>（即基本频带信号）—— 来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>  (modulation)。</p></li></ul><p>在计算机网络中，常见的是将数字基带信号通过编码或调制的方法在相应信道进行传输。</p><ul><li><strong>编码</strong>：不改变信号性质，仅对数字基带信号的波形进行变换。编码后产生的信号仍为数字信号。</li><li><strong>调制</strong>：把数字基带信号的频率范围搬移到较高的频段，并转换为模拟信号。</li></ul><h3 id="传输媒体与信道的关系"><a href="#传输媒体与信道的关系" class="headerlink" title="传输媒体与信道的关系"></a><strong>传输媒体与信道的关系</strong></h3><p><strong>信道的几个基本概念</strong></p><ul><li><strong>信道</strong> —— 一般用来表示向某一个方向传送信息的媒体。</li><li><strong>单向通信（单工通信）</strong>——只能有一个方向的通信而没有反方向的交互。</li><li><strong>双向交替通信（半双工通信）</strong>——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li><strong>双向同时通信（全双工通信）</strong>——通信的双方可以同时发送和接收信息。</li></ul><p>严格来说，传输媒体不能和信道划等号</p><p>对于单工传输，传输媒体只包含一个信道，要么是发送信道，要么是接收信道</p><p>对于半双工和全双工，传输媒体中要包含两个信道，一个发送信道，另一个是接收信道</p><blockquote><p>如果使用信道复用技术，一条传输媒体还可以包含多个信道</p></blockquote><h3 id="常用编码"><a href="#常用编码" class="headerlink" title="常用编码"></a>常用编码</h3><p><strong>不归零编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823868.png" alt="image-20201008150058039"></p><ul><li><p>正电平表示比特1&#x2F;0</p></li><li><p>负电平表示比特0&#x2F;1</p></li></ul><p>中间的虚线是零电平，所谓不归零编码，就是指在整个码元时间内，电平不会出现零电平</p><p>实际比特1和比特0的表示要看现实怎么规定。</p><blockquote><p>接收端如何判断连续的高或低电平是多少个码元？</p><p>这需要发送方的发送与接收方的接收做到严格的同步</p><ul><li>需要<strong>额外一根传输线来传输时钟信号</strong>，使发送方和接收方同步，接收方按时钟信号的节拍来逐个接收码元</li><li>但是对于计算机网络，宁愿利用这根传输线传输数据信号，而不是传输时钟信号</li></ul><p>由于<strong>不归零编码</strong>存在<strong>同步问题</strong>，因此计算机网络中的数据传输不采用这类编码！</p></blockquote><p><strong>归零编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823665.png" alt="image-20201008195033189"></p><p>每个码元传输结束后信号都要“归零”。</p><blockquote><p>归零编码虽然自同步，但<strong>编码效率低</strong></p></blockquote><p><strong>曼彻斯特编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823274.png" alt="image-20201008195148727"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发生跳变</p><ul><li>负跳变表示比特1&#x2F;0</li><li>正跳变表示比特0&#x2F;1</li><li>码元中间时刻的跳变即表示时钟，又表示数据</li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>传统以太网使用的就是曼切斯特编码</p></blockquote><p><strong>差分曼彻斯特编码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201823543.png" alt="image-20201008195235561"></p><blockquote><p>在每个码元时间的中间时刻，信号都会发送跳变，但与<strong>曼彻斯特不同</strong></p><ul><li><strong>跳变仅表示时钟</strong></li><li><strong>码元开始处电平是否变换表示数据</strong><ul><li>变化表示比特1&#x2F;0</li><li>不变化表示比特0&#x2F;1</li></ul></li></ul><p><strong>实际比特1和比特0的表示要看现实怎么规定</strong></p><p>比曼彻斯特编码变化少，更适合较高的传输速率</p></blockquote><h3 id="调制"><a href="#调制" class="headerlink" title="调制"></a>调制</h3><p>数字信号转换为模拟信号，在模拟信道中传输，例如WiFi，采用补码键控CCK&#x2F;直接序列扩频DSSS&#x2F;正交频分复用OFDM等<strong>调制</strong>方式。</p><p>模拟信号转换为另一种模拟信号，在模拟信道中传输，例如，语音数据加载到模拟的载波信号中传输。频分复用FDM技术，充分利用带宽资源。</p><p><strong>基本调制方法</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824797.png" alt="image-20201008155429044"></p><blockquote><ul><li><strong>调幅AM</strong>：所调制的信号由两种不同振幅的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调频FM</strong>：所调制的信号由两种不同频率的基本波形构成。每个基本波形只能表示1比特信息量。</li><li><strong>调相PM</strong>：所调制的信号由两种不同初相位的基本波形构成。每个基本波形只能表示1比特信息量。</li></ul><p>但是使用基本调制方法，1个码元只能包含1个比特信息</p></blockquote><p><strong>混合调制</strong></p><p>对于频率，相位，振幅：</p><p>因为频率和相位是相关的，即频率是随时间的变化率，所以一次只能调制频率和相位两个中的一个。</p><p>而<strong>相位和振幅是可以一起调制</strong>的，称为<strong>正交振幅调制QAM</strong>。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824483.png" alt="image-20201008155955169"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201824648.png" alt="image-20201008160133748"></p><blockquote><p>上图码元所对应的4个比特是错误的，码元不能随便对应4个比特</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828876.png" alt="image-20201008160208060"></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828564.png" alt="image-20201010204336400"></p><p>失真的原因：</p><ul><li>码元传输的速率越高</li><li>信号传输的距离越远</li><li>噪声干扰越大</li><li>传输媒体质量越差</li></ul><p>奈氏准则和香农公式</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828574.png" alt="image-20201010204818976"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201828860.png" alt="image-20201010204928756"></p><p>奈氏准则和香农公式对比：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829903.png" alt="image-20201010205029346"></p><h2 id="信道复用技术"><a href="#信道复用技术" class="headerlink" title="信道复用技术"></a>信道复用技术</h2><p>本节内容视频未讲到，是《计算机网络（第7版）谢希仁》物理层的内容</p><h3 id="频分复用、时分复用和统计时分复用"><a href="#频分复用、时分复用和统计时分复用" class="headerlink" title="频分复用、时分复用和统计时分复用"></a>频分复用、时分复用和统计时分复用</h3><p>复用 (multiplexing) 是通信技术中的基本概念。</p><p>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829130.png" alt="image-20201011001949479"></p><p><strong>频分复用 FDM (Frequency Division Multiplexing)</strong></p><ul><li>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li><li><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829906.png" alt="image-20201011002236208"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong> </p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829227.png" alt="image-20201011002540041"></p><ul><li><strong>时分复用可能会造成线路资源的浪费</strong><ul><li>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829160.png" alt="image-20201011002842704"></p><p><strong>统计时分复用 STDM  (Statistic TDM)</strong> </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201829046.png" alt="image-20201011002953703"></p><h3 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h3><p>波分复用 WDM(Wavelength Division Multiplexing)</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830773.png" alt="image-20201011003214653"></p><h3 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h3><p>码分复用 CDM  (Code Division Multiplexing)</p><ul><li>常用的名词是<strong>码分多址</strong> CDMA (Code Division Multiple Access)。</li><li>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</li><li>这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。</li></ul><h2 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h2><p>物理层的基本概念：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830239.png" alt="image-20201010213213489"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201830843.png" alt="image-20201010213423319"></p><p>信道的极限容量习题：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831374.png" alt="image-20201010205425612"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831817.png" alt="image-20201010205914234"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831990.png" alt="image-20201010210031254"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201831754.png" alt="image-20201010210217898"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832708.png" alt="image-20201010210350902"></p><h1 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>概述：</p><p><strong>链路</strong>是从一个结点到相邻结点的一段物理线路，<strong>数据链路</strong>则是在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）</p><p><strong>网络中的主机、路由器等都必须实现数据链路层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832281.png" alt="image-20201011102531462"></p><p><strong>局域网中的主机、交换机等都必须实现数据链路层</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832208.png" alt="image-20201014004326549"></p><p><strong>从层次上来看数据的流动</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832305.png" alt="image-20201011102618878"></p><p><strong>仅从数据链路层观察帧的流动</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832076.png" alt="image-20201011102653161"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832730.png" alt="image-20201011102733584"></p><blockquote><p>主机H1 到主机H2 所经过的网络可以是多种不同类型的</p><p><strong>注意：不同的链路层可能采用不同的数据链路层协议</strong></p></blockquote><p><strong>数据链路层使用的信道</strong></p><p>数据链路层属于计算机网路的低层。<strong>数据链路层使用的信道主要有以下两种类型：</strong></p><ul><li>点对点信道</li><li>广播信道</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201832446.png" alt="image-20201014004459744"></p><blockquote><p><strong>局域网属于数据链路层</strong></p><p>局域网虽然是个网络。但我们并不把局域网放在网络层中讨论。这是因为在网络层要讨论的是多个网络互连的问题，是讨论分组怎么从一个网络，通过路由器，转发到另一个网络。</p><p>而在同一个局域网中，分组怎么从一台主机传送到另一台主机，但并不经过路由器转发。从整个互联网来看，<strong>局域网仍属于数据链路层</strong>的范围</p></blockquote><p>三个重要问题：封装成帧，差错控制，可靠传输</p><p>数据链路层传送的协议数据单元是<strong>帧</strong></p><p><strong>封装成帧</strong></p><ul><li><strong>封装成帧</strong> (framing) 就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</li><li>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201833689.png" alt="image-20201011103650253"></p><p><strong>差错控制</strong></p><p>在传输过程中可能会产生<strong>比特差错</strong>：1 可能会变成 0， 而 0 也可能变成 1。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834092.png" alt="image-20201011103917512"></p><p><strong>可靠传输</strong></p><p>接收方主机收到有误码的帧后，是不会接受该帧的，会将它丢弃</p><p>如果数据链路层向其上层提供的是不可靠服务，那么丢弃就丢弃了，不会再有更多措施</p><p><strong>如果数据链路层向其上层提供的是可靠服务，那就还需要其他措施，来确保接收方主机还可以重新收到被丢弃的这个帧的正确副本</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834059.png" alt="image-20201011105314053"></p><blockquote><p>以上三个问题都是使用<strong>点对点信道的数据链路层</strong>来举例的</p></blockquote><p><strong>如果使用广播信道的数据链路层除了包含上面三个问题外，还有一些问题要解决</strong></p><p>如图所示，主机A，B，C，D，E通过一根总线进行互连，主机A要给主机C发送数据，代表帧的信号会通过总线传输到总线上的其他各主机，那么主机B，D，E如何知道所收到的帧不是发送给她们的，主机C如何知道发送的帧是发送给自己的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201834929.png" alt="image-20201011105824466"></p><p>可以用编址（地址）的来解决</p><p>将帧的目的地址添加在帧中一起传输</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835050.png" alt="image-20201011110017415"></p><p>还有数据碰撞问题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835279.png" alt="image-20201011110129994"></p><blockquote><p>随着技术的发展，交换技术的成熟，</p><p>在 有线（局域网）领域 使用<strong>点对点链路</strong>和<strong>链路层交换机</strong>的<strong>交换式局域网</strong>取代了<del>共享式局域网</del></p><p>在无线局域网中仍然使用的是共享信道技术</p></blockquote><hr><h2 id="封装成帧"><a href="#封装成帧" class="headerlink" title="封装成帧"></a>封装成帧</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>封装成帧是指数据链路层给上层交付的协议数据单元添加帧头和帧尾使之成为帧</p><ul><li><strong>帧头和帧尾中包含有重要的控制信息</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835745.png" alt="image-20201011110851301"></p><p>发送方的数据链路层将上层交付下来的协议数据单元封装成帧后，还要通过物理层，将构成帧的各比特，转换成电信号交给传输媒体，那么接收方的数据链路层如何从物理层交付的比特流中提取出一个个的帧？</p><p>答：需要帧头和帧尾来做<strong>帧定界</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835483.png" alt="image-20201011111334052"></p><p>但比不是每一种数据链路层协议的帧都包含有帧定界标志，例如下面例子</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835950.png" alt="image-20201011111729324"></p><blockquote><p>前导码</p><ul><li>前同步码：作用是使接收方的时钟同步</li><li>帧开始定界符：表明其后面紧跟着的就是MAC帧</li></ul></blockquote><p>另外以太网还规定了帧间间隔为96比特时间，因此，MAC帧不需要帧结束定界符</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835266.png" alt="image-20201011112450187"></p><h3 id="透明传输"><a href="#透明传输" class="headerlink" title="透明传输"></a>透明传输</h3><blockquote><p><strong>透明</strong></p><p>指某一个实际存在的事物看起来却好像不存在一样。</p></blockquote><p>透明传输是指<strong>数据链路层对上层交付的传输数据没有任何限制</strong>，好像数据链路层不存在一样</p><p>帧界定标志也就是个特定数据值，如果在上层交付的协议数据单元中，  恰好也包含这个特定数值，接收方就不能正确接收</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835838.png" alt="image-20201011113207944"></p><blockquote><p>所以数据链路层应该对上层交付的数据有限制，其内容不能包含帧定界符的值</p></blockquote><p><strong>解决透明传输问题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835258.png" alt="image-20201011113804721"></p><ul><li><strong>解决方法</strong>：面向字节的物理链路使用<strong>字节填充</strong> (byte stuffing) 或<strong>字符填充</strong> (character stuffing)，面向比特的物理链路使用比特填充的方法实现透明传输</li><li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面<strong>插入一个转义字符“ESC”</strong>(其十六进制编码是1B)。</li><li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li><li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一个转义字符 ESC。当接收端收到连续的两个转义字符时，就删除其中前面的一个。</li></ul><p><strong>帧的数据部分长度</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835162.png" alt="image-20201011115008209"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201835744.png" alt="image-20201011115049672"></p><hr><h2 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836377.png" alt="image-20201011133757804"></p><h3 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836792.png" alt="image-20201011234428217"></p><h3 id="循环冗余校验CRC-Cyclic-Redundancy-Check"><a href="#循环冗余校验CRC-Cyclic-Redundancy-Check" class="headerlink" title="循环冗余校验CRC(Cyclic Redundancy Check)"></a>循环冗余校验CRC(Cyclic Redundancy Check)</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836931.png" alt="image-20201011234605045"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836456.png" alt="image-20201011234701845"></p><p><strong>例题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836330.png" alt="image-20201011235128869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836299.png" alt="image-20201011235325022"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201836992.png" alt="image-20201011235726437"></p><blockquote><p>循环冗余校验 CRC 是一种检错方法，而帧校验序列 FCS 是添加在数据后面的冗余码</p></blockquote><hr><h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>下面是比特差错</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837668.png" alt="image-20201012153605893"></p><p><strong>其他传输差错</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837902.png" alt="image-20201012153811724"></p><ul><li>分组丢失</li></ul><p>路由器输入队列快满了，主动丢弃收到的分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837434.png" alt="image-20201012154910921"></p><ul><li>分组失序</li></ul><p>数据并未按照发送顺序依次到达接收端</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837981.png" alt="image-20201012155300937"></p><ul><li>分组重复</li></ul><p>由于某些原因，有些分组在网络中滞留了，没有及时到达接收端，这可能会造成发送端对该分组的重发，重发的分组到达接收端，但一段时间后，滞留在网络的分组也到达了接收端，这就造成<strong>分组重复</strong>的传输差错</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837448.png" alt="image-20201012160026362"></p><h3 id="三种可靠协议"><a href="#三种可靠协议" class="headerlink" title="三种可靠协议"></a>三种可靠协议</h3><ul><li>停止-等待协议SW</li><li>回退N帧协议GBN</li><li>选择重传协议SR</li></ul><blockquote><p>这三种可靠传输实现机制的基本原理并不仅限于数据链路层，可以应用到计算机网络体系结构的各层协议中</p></blockquote><h4 id="停止-等待协议"><a href="#停止-等待协议" class="headerlink" title="停止-等待协议"></a>停止-等待协议</h4><h5 id="停止-等待协议可能遇到的四个问题"><a href="#停止-等待协议可能遇到的四个问题" class="headerlink" title="停止-等待协议可能遇到的四个问题"></a>停止-等待协议可能遇到的四个问题</h5><p><strong>确认与否认</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201837618.png" alt="image-20201012162009780" style="zoom:67%;" /><p><strong>超时重传</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838548.png" alt="image-20201012162112151" style="zoom:67%;" /><p><strong>确认丢失</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838886.png" alt="image-20201012162318298" style="zoom:67%;" /><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838138.png" alt="image-20201012162348428" style="zoom:67%;" /><blockquote><p>既然数据分组需要编号，确认分组是否需要编号？</p><p>要。如下图所示</p></blockquote><p><strong>确认迟到</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838714.png" alt="image-20201012162815885" style="zoom:67%;" /><blockquote><p>注意，图中最下面那个数据分组与之前序号为0的那个数据分组不是同一个数据分组</p></blockquote><p><strong>注意事项</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838787.png" alt="image-20201012164008780"></p><h5 id="停止-等待协议的信道利用率"><a href="#停止-等待协议的信道利用率" class="headerlink" title="停止-等待协议的信道利用率"></a>停止-等待协议的信道利用率</h5><p>假设收发双方之间是一条直通的信道</p><ul><li><strong>TD</strong>：是发送方发送数据分组所耗费的发送时延</li><li><strong>RTT</strong>：是收发双方之间的往返时间</li><li><strong>TA</strong>：是接收方发送确认分组所耗费的发送时延</li></ul><p>TA一般都远小于TD，可以忽略，当RTT远大于TD时，信道利用率会非常低</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838614.png" alt="image-20201012164924635"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201838894.png" alt="image-20201012181005719"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839189.png" alt="image-20201012181047665"></p><blockquote><p>像停止-等待协议这样通过确认和重传机制实现的可靠传输协议，常称为自动请求重传协议ARQ(<strong>A</strong>utomatic <strong>R</strong>epeat re<strong>Q</strong>uest)，意思是重传的请求是自动进行，因为不需要接收方显式地请求，发送方重传某个发送的分组</p></blockquote><h4 id="回退N帧协议GBN"><a href="#回退N帧协议GBN" class="headerlink" title="回退N帧协议GBN"></a>回退N帧协议GBN</h4><h5 id="为什么用回退N帧协议"><a href="#为什么用回退N帧协议" class="headerlink" title="为什么用回退N帧协议"></a>为什么用回退N帧协议</h5><p>在相同的时间内，使用停止-等待协议的发送方只能发送一个数据分组，而采用流水线传输的发送方，可以发送多个数据分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839407.png" alt="image-20201012190027828"></p><p>回退N帧协议在流水线传输的基础上，利用发送窗口来限制发送方可连续发送数据分组的个数</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839877.png" alt="image-20201012190632086"></p><h5 id="无差错情况流程"><a href="#无差错情况流程" class="headerlink" title="无差错情况流程"></a>无差错情况流程</h5><p>发送方将序号落在发送窗口内的0~4号数据分组，依次连续发送出去</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201839295.png" alt="image-20201012191936466"></p><p>他们经过互联网传输正确到达接收方，就是没有乱序和误码，接收方按序接收它们，每接收一个，接收窗口就向前滑动一个位置，并给发送方发送针对所接收分组的确认分组，在通过互联网的传输正确到达了发送方</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840102.png" alt="image-20201012192932035"></p><p>发送方每接收一个、发送窗口就向前滑动一个位置，这样就有新的序号落入发送窗口，发送方可以将收到确认的数据分组从缓存中删除了，而接收方可以择机将已接收的数据分组交付上层处理</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840642.png" alt="image-20201012193212419"></p><h5 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a><strong>累计确认</strong></h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840820.png" alt="image-20201012194304696"></p><blockquote><p>累计确认</p><p>优点:</p><ul><li>即使确认分组丢失，发送方也可能不必重传</li><li>减小接收方的开销</li><li>减小对网络资源的占用</li></ul><p>缺点：</p><ul><li>不能向发送方及时反映出接收方已经正确接收的数据分组信息</li></ul></blockquote><h5 id="有差错情况"><a href="#有差错情况" class="headerlink" title="有差错情况"></a><strong>有差错情况</strong></h5><p>例如</p><p>在传输数据分组时，5号数据分组出现误码，接收方通过数据分组中的检错码发现了错误</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840684.png" alt="image-20201012195440780"></p><p>于是丢弃该分组，而后续到达的这剩下四个分组与接收窗口的序号不匹配</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840224.png" alt="image-20201012195629368"></p><p>接收同样也不能接收它们，讲它们丢弃，并对之前按序接收的最后一个数据分组进行确认，发送ACK4，<strong>每丢弃一个数据分组，就发送一个ACK4</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840568.png" alt="image-20201012195836902"></p><p>当收到重复的ACK4时，就知道之前所发送的数据分组出现了差错，于是可以不等超时计时器超时就立刻开始重传，具体收到几个重复确认就立刻重传，根据具体实现决定</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840802.png" alt="image-20201012200120166"></p><p> 如果收到这4个重复的确认并不会触发发送立刻重传，一段时间后。超时计时器超时，也会将发送窗口内以发送过的这些数据分组全部重传</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840452.png" alt="image-20201012200454557"></p><p>若WT超过取值范围，例如WT&#x3D;8，会出现什么情况？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201840611.png" alt="image-20201012201109774"></p><p>习题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841879.png" alt="image-20201012202419107"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841136.png" alt="image-20201012202222138"></p><ul><li>回退N帧协议在流水线传输的基础上利用发送窗口来限制发送方连续发送数据分组的数量，是一种连续ARQ协议</li><li>在协议的工作过程中发送窗口和接收窗口不断向前滑动，因此这类协议又称为滑动窗口协议</li><li>由于回退N帧协议的特性，当通信线路质量不好时，其信道利用率并不比停止-等待协议高</li></ul><h4 id="选择重传协议SR"><a href="#选择重传协议SR" class="headerlink" title="选择重传协议SR"></a>选择重传协议SR</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841235.png" alt="image-20201012203638722"></p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=27">具体流程请看视频</a></p><p><strong>习题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841142.png" alt="image-20201012205250996"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841680.png" alt="image-20201012204742870"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841365.png" alt="image-20201012205133924"></p><hr><h2 id="点对点协议PPP"><a href="#点对点协议PPP" class="headerlink" title="点对点协议PPP"></a>点对点协议PPP</h2><ul><li>点对点协议PPP（Point-to-Point Protocol）是目前使用最广泛的点对点数据链路层协议</li><li>PPP协议是因特网工程任务组IEIF在1992年制定的。经过1993年和1994年的修订，现在的PPP协议已成为因特网的正式标准[RFC1661，RFC1662]</li><li>数据链路层使用的一种协议，它的特点是：简单；只检测差错，而不是纠正差错；不使用序号，也不进行流量控制；可同时支持多种网络层协议</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841059.png" alt="image-20201012210844629"></p><ul><li>PPPoE 是为宽带上网的主机使用的链路层协议</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201841191.png" alt="image-20201012211423528"></p><h3 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h3><p>必须规定特殊的字符作为帧定界符</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842227.png" alt="image-20201012211826281"></p><h3 id="透明传输-1"><a href="#透明传输-1" class="headerlink" title="透明传输"></a>透明传输</h3><p> 必须保证数据传输的透明性</p><p>实现透明传输的方法</p><ul><li>面向字节的异步链路：字节填充法（插入“转义字符”）</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842132.png" alt="image-20201012212148803"></p><ul><li>面向比特的同步链路：比特填充法（插入“比特0”）</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842896.png" alt="image-20201012212255550"></p><h3 id="差错检测-1"><a href="#差错检测-1" class="headerlink" title="差错检测"></a>差错检测</h3><p>能够对接收端收到的帧进行检测，并立即丢弃有差错的帧。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842191.png" alt="image-20201012212558654"></p><h3 id="工作状态"><a href="#工作状态" class="headerlink" title="工作状态"></a>工作状态</h3><ul><li>当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。</li><li>PC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。</li><li>这些分组及其响应选择一些 PPP 参数，并进行网络层配置，NCP 给新接入的 PC 机</li><li>分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。</li><li>通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842702.png" alt="image-20201012213021860"></p><blockquote><p>可见，PPP 协议已不是纯粹的数据链路层的协议，它还包含了物理层和网络层的内容。</p></blockquote><hr><h2 id="媒体接入控制（介质访问控制）——广播信道"><a href="#媒体接入控制（介质访问控制）——广播信道" class="headerlink" title="媒体接入控制（介质访问控制）——广播信道"></a>媒体接入控制（介质访问控制）——广播信道</h2><p><strong>媒体接入控制（介质访问控制）使用一对多的广播通信方式</strong></p><blockquote><p><strong>Medium Access Control</strong>翻译成媒体接入控制，有些翻译成介质访问控制</p></blockquote><p><strong>局域网的数据链路层</strong></p><ul><li>局域网最主要的<strong>特点</strong>是：<ul><li>网络为一个单位所拥有；</li><li>地理范围和站点数目均有限。</li></ul></li><li>局域网具有如下<strong>主要优点</strong>：<ul><li>具有广播功能，从一个站点可很方便地访问全网。局域网上的主机可共享连接在局域网上的各种硬件和软件资源。 </li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变。</li><li>提高了系统的可靠性、可用性和残存性。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842052.png" alt="image-20201013201521915"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201842967.png" alt="image-20201013201533445"></p><p><strong>数据链路层的两个子层</strong></p><p>为了使数据链路层能更好地适应多种局域网标准，IEEE 802 委员会就将局域网的数据链路层拆成<strong>两个子层</strong>：</p><ol><li><strong>逻辑链路控制</strong> LLC (Logical Link Control)子层；</li><li><strong>媒体接入控制</strong> MAC (Medium Access Control)子层。</li></ol><p>与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关。<br><strong>不管采用何种协议的局域网，对 LLC 子层来说都是透明的。</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843155.png" alt="image-20201013201133903"></p><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>为什么要媒体接入控制（介质访问控制）？</p><p><strong>共享信道带来的问题</strong></p><p>若多个设备在共享信道上同时发送数据，则会造成彼此干扰，导致发送失败。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843066.png" alt="image-20201013152007335"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843815.png" alt="image-20201013152453425"></p><blockquote><p>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术</p></blockquote><h3 id="静态划分信道"><a href="#静态划分信道" class="headerlink" title="静态划分信道"></a>静态划分信道</h3><p><strong>信道复用</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843541.png" alt="image-20201013153642544"></p><p><strong>频分复用FDM (Frequency Division Multiplexing)</strong></p><ul><li><p>将整个带宽分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</p></li><li><p><strong>频分复用</strong>的所有用户在同样的时间<strong>占用不同的带宽资源</strong>（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843603.png" alt="image-20201013153947668"></p><p><strong>时分复用TDM (Time Division Multiplexing)</strong></p><ul><li><strong>时分复用</strong>则是将时间划分为一段段等长的<strong>时分复用帧（TDM帧）</strong>。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。</li><li>每一个用户所占用的时隙是<strong>周期性地出现</strong>（其周期就是TDM帧的长度）的。</li><li>TDM 信号也称为<strong>等时</strong> (isochronous) 信号。</li><li><strong>时分复用的所有用户在不同的时间占用同样的频带宽度。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843265.png" alt="image-20201013154142540"></p><p><strong>波分复用 WDM(Wavelength Division Multiplexing)</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843757.png" alt="image-20201013202218132"></p><blockquote><p>波分复用就是光的频分复用，使用一根光纤来同时传输多个光载波信号</p><p>光信号传输一段距离后悔衰减，所以要用 掺铒光纤放大器 放大光信号</p></blockquote><p><strong>码分复用 CDM  (Code Division Multiplexing)</strong> </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201843093.png" alt="image-20201013203126625"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844662.png" alt="image-20201013203324709"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102991.png" alt="image-20201013203459640"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844943.png" alt="image-20201013203819578"></p><h3 id="动态接入控制"><a href="#动态接入控制" class="headerlink" title="动态接入控制"></a>动态接入控制</h3><p>受控接入</p><p><strong>受控接入在局域网中使用得较少，本书不再讨论</strong></p><p><strong>随机接入</strong></p><p><strong>重点</strong></p><h3 id="随机接入（CSMA-x2F-CD协议）"><a href="#随机接入（CSMA-x2F-CD协议）" class="headerlink" title="随机接入（CSMA&#x2F;CD协议）"></a>随机接入（CSMA&#x2F;CD协议）</h3><p><strong>总线局域网使用协议：CSMA&#x2F;CD</strong></p><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p><strong>最初</strong>的<strong>以太网</strong>是将许多计算机都连接到一根总线上。易于实现广播通信。当初认为这样的连接方法既简单又可靠，因为总线上没有有源器件。</p><blockquote><p><strong>以太网（Ethernet）</strong>是一种计算机<strong>局域网技术</strong>。IEEE组织的IEEE 802.3标准制定了<strong>以太网（Ethernet）</strong>的技术标准</p><p>以太网采用无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢弃，其他什么也不做</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844121.png" alt="image-20201013211620687"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844069.png" alt="image-20201013213102777"></p><h4 id="多址接入MA"><a href="#多址接入MA" class="headerlink" title="多址接入MA"></a>多址接入MA</h4><p>表示许多主机以多点接入的方式连接在一根总线上。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844417.png" alt="image-20201013215400688"></p><h4 id="载波监听CS"><a href="#载波监听CS" class="headerlink" title="载波监听CS"></a>载波监听CS</h4><p>是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201844253.png" alt="image-20201013215530979"></p><p>总线上并没有什么“载波”。因此， <strong>“载波监听”就是用电子技术检测总线上有没有其他计算机发送的数据信号。</strong></p><h4 id="碰撞检测CD"><a href="#碰撞检测CD" class="headerlink" title="碰撞检测CD"></a>碰撞检测CD</h4><ul><li><strong>“碰撞检测”</strong>就是计算机<strong>边发送数据边检测</strong>信道上的信号电压大小。</li><li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。</li><li>当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li><li><strong>所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”。</strong></li><li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li><li><strong>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845220.png" alt="image-20201013221240514"></p><blockquote><p>为什么要进行碰撞检测？ 因为信号传播时延对载波监听产生了影响</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845573.png" alt="image-20201013221834942"></p><p>A 需要单程传播时延的 2 倍的时间，才能检测到与 B 的发送产生了冲突</p></blockquote><h4 id="CSMA-x2F-CD-协议工作流程"><a href="#CSMA-x2F-CD-协议工作流程" class="headerlink" title="CSMA&#x2F;CD 协议工作流程"></a>CSMA&#x2F;CD 协议工作流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845196.png" alt="image-20201013221705893"></p><h4 id="CSMA-x2F-CD-协议工作——争用期（碰撞窗口）"><a href="#CSMA-x2F-CD-协议工作——争用期（碰撞窗口）" class="headerlink" title="CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）"></a>CSMA&#x2F;CD 协议工作——争用期（碰撞窗口）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845009.png" alt="image-20201013223235305"></p><h4 id="CSMA-x2F-CD-协议工作——最小帧长"><a href="#CSMA-x2F-CD-协议工作——最小帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最小帧长"></a>CSMA&#x2F;CD 协议工作——最小帧长</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845970.png" alt="image-20201013224051932"></p><h4 id="CSMA-x2F-CD-协议工作——最大帧长"><a href="#CSMA-x2F-CD-协议工作——最大帧长" class="headerlink" title="CSMA&#x2F;CD 协议工作——最大帧长"></a>CSMA&#x2F;CD 协议工作——最大帧长</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201845234.png" alt="image-20201013225400777"></p><h4 id="CSMA-x2F-CD-协议工作——截断二进制指数退避算法"><a href="#CSMA-x2F-CD-协议工作——截断二进制指数退避算法" class="headerlink" title="CSMA&#x2F;CD 协议工作——截断二进制指数退避算法"></a>CSMA&#x2F;CD 协议工作——截断二进制指数退避算法</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846259.png" alt="image-20201013230717856"></p><h4 id="CSMA-x2F-CD-协议工作——信道利用率"><a href="#CSMA-x2F-CD-协议工作——信道利用率" class="headerlink" title="CSMA&#x2F;CD 协议工作——信道利用率"></a>CSMA&#x2F;CD 协议工作——信道利用率</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846454.png" alt="image-20201013231430295"></p><h4 id="CSMA-x2F-CD-协议工作——帧接收流程"><a href="#CSMA-x2F-CD-协议工作——帧接收流程" class="headerlink" title="CSMA&#x2F;CD 协议工作——帧接收流程"></a>CSMA&#x2F;CD 协议工作——帧接收流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846704.png" alt="image-20201013231703302"></p><h4 id="CSMA-x2F-CD-协议的重要特性"><a href="#CSMA-x2F-CD-协议的重要特性" class="headerlink" title="CSMA&#x2F;CD 协议的重要特性"></a>CSMA&#x2F;CD 协议的重要特性</h4><ul><li>使用 CSMA&#x2F;CD 协议的以太网不能进行全双工通信而<strong>只能进行双向交替通信（半双工通信）。</strong></li><li>每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 </li><li>这种<strong>发送的不确定性</strong>使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><blockquote><p>CSMA&#x2F;CD协议曾经用于各种总线结构以太网和双绞线以太网的早起版本中。</p><p><strong>现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA&#x2F;CS协议</strong></p></blockquote><h3 id="随机接入（CSMA-x2F-CA协议）"><a href="#随机接入（CSMA-x2F-CA协议）" class="headerlink" title="随机接入（CSMA&#x2F;CA协议）"></a>随机接入（CSMA&#x2F;CA协议）</h3><p><strong>无线局域网使用的协议：CSMA&#x2F;CA</strong></p><h4 id="为什么无线局域网要使用CSMA-x2F-CA协议"><a href="#为什么无线局域网要使用CSMA-x2F-CA协议" class="headerlink" title="为什么无线局域网要使用CSMA&#x2F;CA协议"></a>为什么无线局域网要使用CSMA&#x2F;CA协议</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846916.png" alt="image-20201014192811760"></p><h4 id="帧间间隔IFS（InterFrame-Space）"><a href="#帧间间隔IFS（InterFrame-Space）" class="headerlink" title="帧间间隔IFS（InterFrame Space）"></a>帧间间隔IFS（InterFrame Space）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846204.png" alt="image-20201014200149717"></p><h4 id="CSMA-x2F-CA协议的工作原理"><a href="#CSMA-x2F-CA协议的工作原理" class="headerlink" title="CSMA&#x2F;CA协议的工作原理"></a>CSMA&#x2F;CA协议的工作原理</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201846513.png" alt="image-20201014200833233"></p><blockquote><p><strong>源站为什么在检测到信道空闲后还要再等待一段时间DIFS？</strong></p><ul><li>考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送</li></ul><p><strong>目的站为什么正确接收数据帧后还要等待一段时间SIFS才能发送ACK帧？</strong></p><ul><li>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧，在这段时间内，一个站点应当能够从发送方式切换到接收方式</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847394.png" alt="image-20201014201511741"></p><blockquote><p><strong>信道由忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</strong></p><p>防止多个站点同时发送数据而产生碰撞</p></blockquote><p><strong>使用退避算法的时机</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847865.png" alt="image-20201014201927680"></p><h4 id="CSMA-x2F-CA协议的退避算法"><a href="#CSMA-x2F-CA协议的退避算法" class="headerlink" title="CSMA&#x2F;CA协议的退避算法"></a>CSMA&#x2F;CA协议的退避算法</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847251.png" alt="image-20201014202213766"></p><p><strong>退避算法的示例</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847562.png" alt="image-20201014202819851"></p><h4 id="CSMA-x2F-CA协议的信道预约和虚拟载波监听"><a href="#CSMA-x2F-CA协议的信道预约和虚拟载波监听" class="headerlink" title="CSMA&#x2F;CA协议的信道预约和虚拟载波监听"></a>CSMA&#x2F;CA协议的信道预约和虚拟载波监听</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847732.png" alt="image-20201014203119710"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847138.png" alt="image-20201014203506878"></p><p><strong>虚拟载波监听机制能减少隐蔽站带来的碰撞问题的示例</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201847909.png" alt="image-20201014203859033"></p><hr><h2 id="MAC地址、IP地址以及ARP协议"><a href="#MAC地址、IP地址以及ARP协议" class="headerlink" title="MAC地址、IP地址以及ARP协议"></a>MAC地址、IP地址以及ARP协议</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848054.png" alt="image-20201014222831663"></p><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><blockquote><ul><li>使用点对点信道的数据链路层不需要使用地址</li><li>使用广播信道的数据链路层必须使用地址来区分各主机</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848361.png" alt="image-20201014223659993"></p><h4 id="广播信道的数据链路层必须使用地址（MAC）"><a href="#广播信道的数据链路层必须使用地址（MAC）" class="headerlink" title="广播信道的数据链路层必须使用地址（MAC）"></a>广播信道的数据链路层必须使用地址（MAC）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848447.png" alt="image-20201014224732019"></p><blockquote><p><strong>MAC地址又称为硬件地址或物理地址</strong>。请注意：不要被 “物理” 二字误导认为物理地址属于物理层范畴，物理地址属于数据链路层范畴</p></blockquote><h4 id="IEEE-802局域网的MAC地址格式"><a href="#IEEE-802局域网的MAC地址格式" class="headerlink" title="IEEE 802局域网的MAC地址格式"></a>IEEE 802局域网的MAC地址格式</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201848580.png" alt="image-20201014225358570"></p><blockquote><p><strong>组织唯一标识符OUI</strong></p><ul><li>生产网络设备的厂商，需要向IEEE的注册管理机构申请一个或多个OUI</li></ul><p><strong>网络接口标识符</strong></p><ul><li>由获得OUI的厂商自行随意分配</li></ul><p><strong>EUI-48</strong></p><ul><li>48是这个MAC地址的位数</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849458.png" alt="image-20201014230248959"></p><blockquote><p>对于使用EUI-48空间的应用程序，IEEE的目标寿命为100年（直到2080年），但是鼓励采用EUI-64作为替代</p></blockquote><p><strong>关于无效的 MAC 帧</strong></p><ul><li>数据字段的长度与长度字段的值不一致；</li><li>帧的长度不是整数个字节；</li><li>用收到的帧检验序列 FCS 查出有差错；</li><li>数据字段的长度不在 46 ~ 1500 字节之间。</li><li>有效的 MAC 帧长度为 64 ~ 1518 字节之间。</li></ul><blockquote><p><strong>对于检查出的无效</strong> <strong>MAC</strong> <strong>帧就简单地丢弃。以太网不负责重传丢弃的帧。</strong> </p></blockquote><h4 id="IEEE-802局域网的MAC地址发送顺序"><a href="#IEEE-802局域网的MAC地址发送顺序" class="headerlink" title="IEEE 802局域网的MAC地址发送顺序"></a>IEEE 802局域网的MAC地址发送顺序</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849957.png" alt="image-20201014230625182"></p><h4 id="单播MAC地址举例"><a href="#单播MAC地址举例" class="headerlink" title="单播MAC地址举例"></a>单播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849376.png" alt="image-20201014230822305"></p><blockquote><p>主机B给主机C发送<strong>单播帧</strong>，主机B首先要构建该<strong>单播帧</strong>，<strong>在帧首部中的目的地址字段填入主机C的MAC地址</strong>，源地址字段填入自己的MAC地址，再加上帧首部的其他字段、数据载荷以及帧尾部，就构成了该<strong>单播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849241.png" alt="image-20201014231244655"></p><blockquote><p>主机B将该<strong>单播帧</strong>发送出去，主机A和C都会收到该<strong>单播帧</strong></p><p>主机A的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址不匹配，丢弃该帧</p><p>主机C的网卡发现该<strong>单播帧</strong>的目的MAC地址与自己的MAC地址匹配，接受该帧</p><p>并将该帧交给其上层处理</p></blockquote><h4 id="广播MAC地址举例"><a href="#广播MAC地址举例" class="headerlink" title="广播MAC地址举例"></a>广播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849435.png" alt="image-20201014231754669"></p><blockquote><p>假设主机B要发送一个<strong>广播帧</strong>，主机B首先要构建该<strong>广播帧</strong>，<strong>在帧首部中的目的地址字段填入广播地址</strong>，也就是十六进制的全F，源地址字段填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>广播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201849979.png" alt="image-20201014232132424"></p><blockquote><p>主机B讲该<strong>广播帧</strong>发送出去，主机A和C都会收到该<strong>广播帧</strong>，<strong>发现该帧首部中的目的地址字段的内容是广播地址</strong>，就知道该帧是<strong>广播帧</strong>，主机A和主机C都接受该帧，并将该帧交给上层处理</p></blockquote><h4 id="多播MAC地址举例"><a href="#多播MAC地址举例" class="headerlink" title="多播MAC地址举例"></a>多播MAC地址举例</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850865.png" alt="image-20201014232714791"></p><blockquote><p>假设主机A要发送<strong>多播帧</strong>给该<strong>多播地址</strong>。将该<strong>多播地址</strong>的左起第一个字节写成8个比特，第一个字节的最低比特位是1，这就表明该地址是<strong>多播地址</strong>。</p><p>快速判断地址是不是<strong>多播地址</strong>，就是上图所示箭头所指的第十六进制数不能整除2（1,3,5,7,9,B,D,F），则该地址是<strong>多播地址</strong></p><p>假设主机B，C和D支持多播，各用户给自己的主机配置多播组列表<strong>如下所示</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850050.png" alt="image-20201015001243584"></p><blockquote><p>主机B属于两个多播组，主机C也属于两个多播组，而主机D不属于任何多播组</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850804.png" alt="image-20201015001535528"></p><blockquote><p>主机A首先要构建该<strong>多播帧</strong>，<strong>在帧首部中的目的地址字段填入该多播地址</strong>，源地址点填入自己的MAC地址，再加上帧首部中的其他字段、数据载荷以及帧尾部，就构成了该<strong>多播帧</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204201850938.png" alt="image-20201015002054876"></p><blockquote><p>主机A将该<strong>多播帧</strong>发送出去，主机B、C、D都会收到该<strong>多播帧</strong></p><p><strong>主机B和C发现该多播帧的目的MAC地址在自己的多播组列表中</strong>，主机B和C都会接受该帧</p><p>主机D发现该<strong>多播帧</strong>的目的MAC地址不在自己得多播组列表中，则丢弃该<strong>多播帧</strong></p></blockquote><blockquote><p>给主机配置多播组列表进行私有应用时，不得使用公有的标准多播地址</p></blockquote><h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>IP地址属于网 络层的范畴，不属于数据链路层的范畴</p><p>下面内容讲的是IP地址的使用，详细的IP地址内容在网络层中介绍</p><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136208.png" alt="image-20201015104441580"></p><h4 id="从网络体系结构看IP地址与MAC地址"><a href="#从网络体系结构看IP地址与MAC地址" class="headerlink" title="从网络体系结构看IP地址与MAC地址"></a>从网络体系结构看IP地址与MAC地址</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136442.png" alt="image-20201015104913755"></p><h4 id="数据包转发过程中IP地址与MAC地址的变化情况"><a href="#数据包转发过程中IP地址与MAC地址的变化情况" class="headerlink" title="数据包转发过程中IP地址与MAC地址的变化情况"></a>数据包转发过程中IP地址与MAC地址的变化情况</h4><p>图上各主机和路由器各接口的IP地址和MAC地址用简单的标识符来表示</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136019.png" alt="image-20201015105455043"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032136695.png" alt="image-20210103212224961"></p><blockquote><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP协议</p></blockquote><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>如何从IP地址找出其对应的MAC地址？</p><p>ARP（地址解析协议）</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137675.png" alt="image-20201015113826197"></p><p>ARP高速缓存表</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137411.png" alt="image-20201015114052206"></p><blockquote><p>当主机B要给主机C发送数据包时，会首先在自己的ARP高速缓存表中查找主机C的IP地址所对应的MAC地址，但未找到，因此，主机B需要发送ARP请求报文，来获取主机C的MAC地址</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137758.png" alt="image-20201015114444263"></p><blockquote><p>ARP请求报文有具体的格式，上图的只是简单描述</p><p>ARP请求报文被封装在MAC帧中发送，目的地址为广播地址</p><p>主机B发送封装有ARP请求报文的广播帧，总线上的其他主机都能收到该广播帧</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137663.png" alt="image-20201015114811501"></p><blockquote><p>收到ARP请求报文的主机A和主机C会把ARP请求报文交给上层的ARP进程</p><p>主机A发现所询问的IP地址不是自己的IP地址，因此不用理会</p><p>主机C的发现所询问的IP地址是自己的IP地址，需要进行相应</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137915.png" alt="image-20201015115212170"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137213.png" alt="image-20201015115236673"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137862.png" alt="image-20201015115252972"></p><p>动态与静态的区别</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137135.png" alt="image-20201015115831543"></p><p><strong>ARP协议只能在一段链路或一个网络上使用，而不能跨网络使用</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137959.png" alt="image-20201015120108028"></p><blockquote><p>ARP协议的使用是逐段链路进行的</p></blockquote><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032137362.png" alt="image-20201015120707150"></p><blockquote><p>ARP表中的IP地址与MAC地址的对应关系记录，是<strong>会定期自动删除的</strong>，<strong>因为IP地址与MAC地址的对应关系不是永久性的</strong></p></blockquote><hr><h2 id="集线器与交换机的区别"><a href="#集线器与交换机的区别" class="headerlink" title="集线器与交换机的区别"></a>集线器与交换机的区别</h2><h3 id="集线器-在物理层扩展以太网"><a href="#集线器-在物理层扩展以太网" class="headerlink" title="集线器-在物理层扩展以太网"></a>集线器-在物理层扩展以太网</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138058.png" alt="image-20201015144628691"></p><blockquote><ul><li>传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。</li><li>采用双绞线的以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做<strong>集线器</strong> (hub)。</li><li><strong>集线器</strong>是也可以看做多口中继器，每个端口都可以成为一个中继器，中继器是对减弱的信号进行放大和发送的设备</li><li><strong>集线器</strong>的以太网在逻辑上仍是个总线网，需要使用CSMA&#x2F;CD协议来协调各主机争用总线，只能工作在半双工模式，收发帧不能同时进行</li></ul></blockquote><h4 id="集线器HUB在物理层扩展以太网"><a href="#集线器HUB在物理层扩展以太网" class="headerlink" title="集线器HUB在物理层扩展以太网"></a>集线器HUB在物理层扩展以太网</h4><p><strong>使用集线器扩展</strong>：将多个以太网段连成更大的、多级星形结构的以太网</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138728.png" alt="image-20201015145732275"></p><blockquote><ul><li><strong>优点</strong><ol><li>使原来属于不同碰撞域的以太网上的计算机能够进行跨碰撞域的通信。</li><li>扩大了以太网覆盖的地理范围。</li></ol></li><li><strong>缺点</strong><ol><li>碰撞域增大了，但总的吞吐量并未提高。</li><li>如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。</li></ol></li></ul></blockquote><p><strong>碰撞域</strong></p><ul><li><strong>碰撞域（collision domain）</strong>又称为<strong>冲突域</strong>，是指网络中一个站点发出的帧会与其他站点发出的帧产生碰撞或冲突的那部分网络。</li><li>碰撞域越大，发生碰撞的概率越高。</li></ul><h3 id="以太网交换机-在数据链路层扩展以太网"><a href="#以太网交换机-在数据链路层扩展以太网" class="headerlink" title="以太网交换机-在数据链路层扩展以太网"></a>以太网交换机-在数据链路层扩展以太网</h3><h4 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h4><ul><li>扩展以太网更常用的方法是在数据链路层进行。</li><li>早期使用<strong>网桥</strong>，现在使用<strong>以太网交换机</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138344.png" alt="image-20201015150620067"></p><blockquote><p><strong>网桥</strong></p><ul><li>网桥工作在数据链路层。</li><li>它根据 MAC 帧的目的地址对收到的帧进行转发和过滤。</li><li>当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的MAC 地址，然后再确定将该帧转发到哪一个接口，或把它丢弃。</li></ul><p><strong>交换机</strong></p><ul><li>1990 年问世的交换式集线器 (switching hub) 可明显地提高以太网的性能。</li><li>交换式集线器常称为<strong>以太网交换机</strong> (switch) 或<strong>第二层交换机</strong> (L2 switch)，强调这种交换机工作在数据链路层。</li><li>以太网交换机实质上就是一个<strong>多接口的网桥</strong></li></ul></blockquote><h4 id="集线器HUB与交换机SWITCH区别"><a href="#集线器HUB与交换机SWITCH区别" class="headerlink" title="集线器HUB与交换机SWITCH区别"></a><strong>集线器HUB与交换机SWITCH区别</strong></h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138342.png" alt="image-20201015152232158"></p><blockquote><p>使用<strong>集线器</strong>互连而成的共享总线式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧会通过共享总线传输到<strong>总线上的其他各个主机</strong></p><p>使用交换机互连而成的交换式以太网上的某个主机，要给另一个主机发送单播帧，该单播帧进入交换机后，交换机会将该单播帧转发给目的主机，<strong>而不是网络中的其他各个主机</strong></p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138603.png" alt="image-20201015152858146"></p><blockquote><p><strong>以太网交换机的交换方式</strong></p><ul><li>存储转发方式<ul><li>把整个数据帧<strong>先缓存</strong>后再进行处理。</li></ul></li><li>直通 (cut-through) 方式<ul><li>接收数据帧的同时就<strong>立即按数据帧的目的 MAC 地址决定该帧的转发接口</strong>，因而提高了帧的转发速度。</li><li><strong>缺点</strong>是它不检查差错就直接将帧转发出去，因此有可能也将一些无效帧转发给其他的站。</li></ul></li></ul><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>对比集线器和交换机</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138172.png" alt="image-20201015153907268"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138132.png" alt="image-20201015154523036"></p><blockquote><p>多台主机同时给另一台主机发送单播帧</p><p>集线器以太网：会产生碰撞，遭遇碰撞的帧会传播到总线上的各主机</p><p>交换机以太网：会将它们缓存起来，然后逐个转发给目的主机，不会产生碰撞</p><p><strong>这个例子的前提条件是忽略ARP过程，并假设交换机的帧交换表已经学习或配置好了</strong></p></blockquote><p><strong>集线器扩展以太网和交换机扩展以太网区别</strong></p><p><strong>单播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138199.png" alt="image-20201015155408692"></p><p><strong>广播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138404.png" alt="image-20201015155440402"></p><p><strong>多个单播</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138655.png" alt="image-20201015155526386"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138589.png" alt="image-20201015155706698"></p><p>广播域（broadcast domain）：指这样一部分网络，其中任何一台设备发出的广播通信都能被该部分网络中的所有其他设备所接收。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138900.png" alt="image-20201015160146482"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138739.png" alt="image-20201015160526999"></p><blockquote><p>工作在数据链路层的以太网交换机，其性能远远超过工作在物理层的集线器，而且价格并不贵，这就使得集线器逐渐被市场淘汰</p></blockquote><hr><h2 id="以太网交换机自学习和转发帧的流程"><a href="#以太网交换机自学习和转发帧的流程" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h2><h3 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138019.png" alt="image-20201015161015165"></p><h3 id="自学习和转发帧的例子"><a href="#自学习和转发帧的例子" class="headerlink" title="自学习和转发帧的例子"></a>自学习和转发帧的例子</h3><p>以下例子假设各主机知道网络中其他各主机的MAC地址（无需进行ARP）</p><p><strong>A -&gt; B</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139714.png" alt="image-20201015161458528"></p><blockquote><ol><li>A 先向 B 发送一帧。该帧从接口 1 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中左边）交换表中</li><li>交换机向除接口 1 以外的所有的接口广播这个帧</li><li>接口 4到接口 2，先查找（图中右边）交换表。没有查到应从哪个接口转发这个帧给 B</li><li>交换机把这个帧的源地址 A 和接口 1 写入（图中右边）交换表中</li><li>除B主机之外与该帧的目的地址不相符，将丢弃该帧</li><li>主机B发现是给自己的帧，接受该帧</li></ol></blockquote><p><strong>B -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032138052.png" alt="image-20201015162310922"></p><blockquote><ol><li>B 向 A 发送一帧。该帧从接口 3 进入到交换机</li><li>交换机收到帧后，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>主机 A 发现目的地址是它，就接受该帧</li><li>交换机把这个帧的源地址 B 和接口 3 写入（图中左边）交换表中</li></ol></blockquote><p><strong>E -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139151.png" alt="image-20201015162622462"></p><blockquote><ol><li>E 向 A发送一帧</li><li>交换机收到帧后，先查找（图中右边）交换表。发现（图中右边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口2转发出去。于是就把这个帧传送到接口 2 转发给 接口 4。</li><li>交换机把这个帧的源地址 E 和接口 3 写入（图中右边）交换表中</li><li>接口 4 到 左边的交换机，先查找（图中左边）交换表。发现（图中左边）交换表中的 MAC 地址有 A，表明要发送给A的帧应从接口1转发出去。于是就把这个帧传送到接口 1 转发给 A。</li><li>交换机把这个帧的源地址 E 和接口 4 写入（图中左边）交换表中</li><li>主机 A 发现目的地址是它，就接受该帧</li></ol></blockquote><p><strong>G -&gt; A</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139175.png" alt="image-20201015163157140"></p><blockquote><p>主机 A、主机 G、交换机 1的接口 1就共享同一条总线（相当于总线式网络，可以想象成用集线器连接了）</p><ol><li>主机 G 发送给 主机 A 一个帧</li><li>主机 A 和 交换机接口 1都能接收到</li><li>主机 A 的网卡收到后，根据帧的目的MAC地址A，就知道是发送给自己的帧，就接受该帧</li><li>交换机 1收到该帧后，首先进行登记工作</li><li>然后交换机 1对该帧进行转发，该帧的MAC地址是A，在（图中左边）交换表查找MAC 地址有 A</li><li>MAC 地址为 A的接口号是1，但是该帧正是从接口 1 进入交换机的，交换机不会再从该接口 1 将帧转发出去，因为这是没有必要，于是丢弃该帧</li></ol></blockquote><p>随着网络中各主机都发送了帧后，网络中的各交换机就可以学习到各主机的MAC地址，以及它们与自己各接口的对应关系</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139956.png" alt="image-20201015164210543"></p><blockquote><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的<strong>有效时间</strong>。<strong>过期的项目就自动被删除</strong>。</p><p><strong>以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。</strong></p></blockquote><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><strong>交换机自学习和转发帧的步骤归纳</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139732.png" alt="image-20201015170656500"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139056.png" alt="image-20201015170739679"></p><hr><h2 id="以太网交换机的生成树协议STP"><a href="#以太网交换机的生成树协议STP" class="headerlink" title="以太网交换机的生成树协议STP"></a>以太网交换机的生成树协议STP</h2><h3 id="如何提高以太网的可靠性"><a href="#如何提高以太网的可靠性" class="headerlink" title="如何提高以太网的可靠性"></a>如何提高以太网的可靠性</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139171.png" alt="image-20201015171453001"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139047.png" alt="image-20201015171515481"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139916.png" alt="image-20201015171900775"></p><h3 id="生成树协议STP"><a href="#生成树协议STP" class="headerlink" title="生成树协议STP"></a>生成树协议STP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032139764.png" alt="image-20201015172204419"></p><blockquote><ul><li>IEEE 802.1D 标准制定了一个<strong>生成树协议 STP</strong>  (Spanning Tree Protocol)。</li><li>其<strong>要点</strong>是：<strong>不改变</strong>网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是<strong>无环路的树状结构</strong>，从而消除了兜圈子现象。</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140370.png" alt="image-20201015202257756"></p><hr><h2 id="虚拟局域网VLAN"><a href="#虚拟局域网VLAN" class="headerlink" title="虚拟局域网VLAN"></a>虚拟局域网VLAN</h2><h3 id="为什么要虚拟局域网VLAN"><a href="#为什么要虚拟局域网VLAN" class="headerlink" title="为什么要虚拟局域网VLAN"></a>为什么要虚拟局域网VLAN</h3><p><strong>广播风暴</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140175.png" alt="image-20201015202859124"></p><p><strong>分割广播域的方法</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140409.png" alt="image-20201015203113654"></p><blockquote><p>为了分割广播域，所以虚拟局域网VLAN技术应运而生</p></blockquote><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140285.png" alt="image-20201015203559548"></p><blockquote><ul><li>利用以太网交换机可以很方便地实现虚拟局域网 VLAN (Virtual LAN)。</li><li>IEEE 802.1Q 对虚拟局域网 VLAN 的<strong>定义</strong>：<br><strong>虚拟局域网 VLAN</strong> 是由一些局域网网段构成的<strong>与物理位置无关的逻辑组</strong>，而这些网段具有某些共同的需求。每一个 VLAN 的帧都有一个明确的标识符，指明发送这个帧的计算机是属于哪一个 VLAN。</li><li>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</li><li><strong>虚拟局域网其实只是局域网给用户提供的一种服务，而并不是一种新型局域网。</strong></li><li>由于虚拟局域网是用户和网络资源的逻辑组合，因此可按照需要将有关设备和资源非常方便地重新组合，使用户从不同的服务器或数据库中存取所需的资源。</li></ul></blockquote><h3 id="虚拟局域网VLAN的实现机制"><a href="#虚拟局域网VLAN的实现机制" class="headerlink" title="虚拟局域网VLAN的实现机制"></a>虚拟局域网VLAN的实现机制</h3><p>虚拟局域网VLAN技术是在交换机上实现的，需要交换机能够实现以下功能</p><ul><li>能够处理带有VLAN标记的帧——IEEE 802.1 Q帧</li><li>交换机的各端口可以支持不同的端口类型，不同端口类型的端口对帧的处理方式有所不同</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140278.png" alt="image-20201015204639599"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140318.png" alt="image-20201015204749141"></p><p><strong>Access端口</strong></p><p>交换机与用户计算机之间的互连</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140563.png" alt="image-20201015205311757"></p><blockquote><p>同一个VLAN内部可以广播通信，不同VLAN不可以广播通信</p></blockquote><p><strong>Truck端口</strong></p><p>交换机之间或交换机与路由器之间的互连</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140910.png" alt="image-20201015205947636"></p><p><strong>小例题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140498.png" alt="image-20201015210417695"></p><p><strong>华为交换机私有的Hybrid端口类型</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140897.png" alt="image-20201015211031361"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140495.png" alt="image-20201015211349531"></p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032140189.png" alt="image-20201015211512622"></p><blockquote><p><strong>虚拟局域网优点</strong></p><p>虚拟局域网（VLAN）技术具有以下主要优点：</p><ol><li>改善了性能</li><li>简化了管理</li><li>降低了成本</li><li>改善了安全性</li></ol></blockquote><h2 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h2><h3 id="封装成帧习题"><a href="#封装成帧习题" class="headerlink" title="封装成帧习题"></a>封装成帧习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141621.png" alt="image-20201011114856991"></p><h3 id="差错检测习题"><a href="#差错检测习题" class="headerlink" title="差错检测习题"></a>差错检测习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141534.png" alt="image-20201011235128869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141798.png" alt="image-20201011235325022"></p><h3 id="可靠传输习题"><a href="#可靠传输习题" class="headerlink" title="可靠传输习题"></a>可靠传输习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102392.png" alt="image-20201012181005719"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141698.png" alt="image-20201012182002090"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141804.png" alt="image-20201012202419107"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141578.png" alt="image-20201012205250996"></p><h3 id="媒体接入控制习题"><a href="#媒体接入控制习题" class="headerlink" title="媒体接入控制习题"></a>媒体接入控制习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141212.png" alt="image-20201013203459640"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141265.png" alt="image-20201013204352725"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141599.png" alt="image-20201013205054730"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141363.png" alt="image-20201013232656202"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141094.png" alt="image-20201013232840109"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141269.png" alt="image-20201013233632636"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141947.png" alt="image-20201014204557440"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141898.png" alt="image-20201014204839055"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032141187.png" alt="image-20201014204939865"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102983.png" alt="image-20201014224410943"></p><h3 id="MAC地址、IP地址以及ARP协议习题"><a href="#MAC地址、IP地址以及ARP协议习题" class="headerlink" title="MAC地址、IP地址以及ARP协议习题"></a>MAC地址、IP地址以及ARP协议习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142430.png" alt="image-20201015110420372"></p><h3 id="以太网交换机自学习和转发帧的流程-1"><a href="#以太网交换机自学习和转发帧的流程-1" class="headerlink" title="以太网交换机自学习和转发帧的流程"></a>以太网交换机自学习和转发帧的流程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142915.png" alt="image-20201015164846227"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142603.png" alt="image-20201015165218663"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142639.png" alt="image-20201015170131492"></p><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><h2 id="网络层概述"><a href="#网络层概述" class="headerlink" title="网络层概述"></a>网络层概述</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul><li>网络层的主要任务是<strong>实现网络互连</strong>，进而<strong>实现数据包在各网络之间的传输</strong></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142421.png" alt="image-20201017134630948"></p><blockquote><p>这些异构型网络N1~N7如果只是需要各自内部通信，他们只要实现各自的物理层和数据链路层即可</p><p>但是如果要将这些异构型网络互连起来，形成一个更大的互联网，就需要实现网络层设备路由器</p><p>有时为了简单起见，可以不用画出这些网络，图中N1~N7，而将他们看做是一条链路即可</p></blockquote><ul><li><p>要实现网络层任务，需要解决一下主要问题：</p><ul><li>网络层向运输层提供怎样的服务（“可靠传输”还是“不可靠传输”）</li></ul><p>在数据链路层那课讲过的可靠传输，详情可以看那边的笔记：网络层对以下的<strong>分组丢失</strong>、<strong>分组失序</strong>、<strong>分组重复</strong>的传输错误采取措施，使得接收方能正确接受发送方发送的数据，就是<strong>可靠传输</strong>，反之，如果什么措施也不采取，则是<strong>不可靠传输</strong></p><ul><li>网络层寻址问题</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142155.png" alt="image-20201017135644630"></p><ul><li>路由选择问题</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142899.png" alt="image-20201017135710478"></p><blockquote><p>路由器收到数据后，是依据什么来决定将数据包从自己的哪个接口转发出去？</p><p><strong>依据数据包的目的地址和路由器中的路由表</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142162.png" alt="image-20201017135914985"></p><p>但在实际当中，路由器是怎样知道这些路由记录？</p><ul><li>由用户或网络管理员进行人工配置，这种方法只适用于规模较小且网络拓扑不改变的小型互联网</li><li><strong>另一种是实现各种路由选择协议，由路由器执行路由选择协议中所规定的路由选择算法，而自动得出路由表中的路有记录，这种方法更适合规模较大且网络拓扑经常改变的大型互联网</strong></li></ul></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142418.png" alt="image-20201017142545630"></p><blockquote><p>补充 <strong>网络层（网际层）</strong>除了 <strong>IP协议</strong>外，还有之前介绍过的<strong>地址解析协议ARP</strong>，还有<strong>网际控制报文协议ICMP</strong>，<strong>网际组管理协议IGMP</strong></p></blockquote><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142125.png" alt="image-20201017140623851"></p><hr><h2 id="网络层提供的两种服务"><a href="#网络层提供的两种服务" class="headerlink" title="网络层提供的两种服务"></a>网络层提供的两种服务</h2><ul><li>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>”还是“<strong>无连接</strong>”）曾引起了长期的争论。</li><li>争论焦点的实质就是：<strong>在计算机通信中，可靠交付应当由谁来负责</strong>？是<strong>网络</strong>还是<strong>端系统</strong>？</li></ul><h3 id="面向连接的虚电路服务"><a href="#面向连接的虚电路服务" class="headerlink" title="面向连接的虚电路服务"></a>面向连接的虚电路服务</h3><p><strong>一种观点：让网络负责可靠交付</strong></p><ul><li>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。</li><li>通信之前先建立<strong>虚电路</strong> (Virtual Circuit)，以保证双方通信所需的一切网络资源。 </li><li>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142954.png" alt="image-20201017141425892"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的所有分组都沿着同一条虚电路传送</p><blockquote><ul><li>虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。</li><li>请注意，电路交换的电话通信是先建立了一条真正的连接。</li><li>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样</li></ul></blockquote><h3 id="无连接的数据报服务"><a href="#无连接的数据报服务" class="headerlink" title="无连接的数据报服务"></a>无连接的数据报服务</h3><p><strong>另一种观点：网络提供数据报服务</strong></p><ul><li>互联网的先驱者提出了一种崭新的网络设计思路。</li><li>网络层向上只提供简单灵活的、<strong>无连接的</strong>、<strong>尽最大努力交付</strong>的<strong>数据报服务</strong>。</li><li>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。</li><li><strong>网络层不提供服务质量的承诺</strong>。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142664.png" alt="image-20201017141851030"></p><p><strong>发送方</strong> 发送给 <strong>接收方</strong> 的分组可能沿着不同路径传送</p><blockquote><p><strong>尽最大努力交付</strong></p><ul><li>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的<strong>主机中的运输层负责可靠交付（包括差错处理、流量控制等）</strong> 。</li><li><strong>采用这种设计思路的好处是</strong>：网络的造价大大降低，运行方式灵活，能够适应多种应用。</li><li>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。</li></ul></blockquote><h3 id="虚电路服务与数据报服务的对比"><a href="#虚电路服务与数据报服务的对比" class="headerlink" title="虚电路服务与数据报服务的对比"></a>虚电路服务与数据报服务的对比</h3><table><thead><tr><th><strong>对比的方面</strong></th><th><strong>虚电路服务</strong></th><th><strong>数据报服务</strong></th></tr></thead><tbody><tr><td><strong>思路</strong></td><td><strong>可靠通信应当由网络来保证</strong></td><td><strong>可靠通信应当由用户主机来保证</strong></td></tr><tr><td><strong>连接的建立</strong></td><td><strong>必须有</strong></td><td><strong>不需要</strong></td></tr><tr><td><strong>终点地址</strong></td><td><strong>仅在连接建立阶段使用，每个分组使用短的虚电路号</strong></td><td><strong>每个分组都有终点的完整地址</strong></td></tr><tr><td><strong>分组的转发</strong></td><td><strong>属于同一条虚电路的分组均按照同一路由进行转发</strong></td><td><strong>每个分组独立选择路由进行转发</strong></td></tr><tr><td><strong>当结点出故障时</strong></td><td><strong>所有通过出故障的结点的虚电路均不能工作</strong></td><td><strong>出故障的结点可能会丢失分组，一些路由可能会发生变化</strong></td></tr><tr><td><strong>分组的顺序</strong></td><td><strong>总是按发送顺序到达终点</strong></td><td><strong>到达终点时不一定按发送顺序</strong></td></tr><tr><td><strong>端到端的差错处理和流量控制</strong></td><td><strong>可以由网络负责，也可以由用户主机负责</strong></td><td><strong>由用户主机负责</strong></td></tr></tbody></table><hr><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032142076.png" alt="image-20201017143206060"></p><h3 id="分类编制的IPv4地址"><a href="#分类编制的IPv4地址" class="headerlink" title="分类编制的IPv4地址"></a>分类编制的IPv4地址</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143571.png" alt="image-20201017144317166"></p><ul><li>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。</li><li>主机号在它前面的网络号所指明的网络范围内必须是唯一的。</li><li>由此可见，<strong>一个 IP 地址在整个互联网范围内是唯一的</strong>。</li></ul><p><strong>A类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143355.png" alt="image-20201017145210533"></p><p><strong>B类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102164.png" alt="image-20201017145508001"></p><p><strong>C类地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143066.png" alt="image-20201017150204774"></p><p><strong>练习</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143152.png" alt="image-20201017150543386"></p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p><strong>IP 地址的指派范围</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143626.png" alt="image-20201017152911541"></p><p><strong>一般不使用的特殊的 IP 地址</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143431.png" alt="image-20201017152959586"></p><p><strong>IP 地址的一些重要特点</strong></p><p>(1) <strong>IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：</p><ul><li><strong>第一</strong>，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理。</li><li><strong>第二</strong>，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。</li></ul><p>(2) <strong>实际上 IP 地址是标志一个主机（或路由器）和一条链路的接口</strong>。</p><ul><li>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为<strong>多归属主机</strong> (multihomed host)。</li><li>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此<strong>一个路由器至少应当有两个不同的 IP 地址</strong>。</li></ul><p>(3) <strong>用转发器或网桥连接起来的若干个局域网仍为一个网络</strong>，因此这些局域网都具有同样的网络号 net-id。</p><p>(4) <strong>所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</strong></p><h3 id="划分子网的IPv4地址"><a href="#划分子网的IPv4地址" class="headerlink" title="划分子网的IPv4地址"></a>划分子网的IPv4地址</h3><h4 id="为什么要划分子网"><a href="#为什么要划分子网" class="headerlink" title="为什么要划分子网"></a>为什么要划分子网</h4><p>在 ARPANET 的早期，IP 地址的设计确实不够合理：</p><ul><li>IP 地址空间的利用率有时很低。 </li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。 </li><li>两级的 IP 地址不够灵活。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143914.png" alt="image-20201017154645198"></p><p>如果想要将原来的网络划分成三个独立的网路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143642.png" alt="image-20201017154852896"></p><p>所以是否可以从主机号部分借用一部分作为子网号</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143283.png" alt="image-20201017155026814"></p><blockquote><p>但是如果未在图中标记子网号部分，那么我们和计算机又如何知道分类地址中主机号有多少比特被用作子网号了呢？</p><p>所以就有了划分子网的工具：<strong>子网掩码</strong></p><ul><li>从 1985 年起在 IP 地址中又增加了一个“<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。</li><li>这种做法叫做<strong>划分子网</strong> (subnetting) 。</li><li>划分子网已成为互联网的正式标准协议。</li></ul></blockquote><h4 id="如何划分子网"><a href="#如何划分子网" class="headerlink" title="如何划分子网"></a>如何划分子网</h4><p>基本思路</p><ul><li>划分子网纯属一个<strong>单位内部的事情</strong>。单位对外仍然表现为没有划分子网的网络。</li><li>从主机号<strong>借用</strong>若干个位作为<strong>子网号</strong> subnet-id，而主机号 host-id 也就相应减少了若干个位。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143325.png" alt="image-20201017155930011"></p><ul><li>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的<strong>目的网络号</strong> net-id，先找到连接在本单位网络上的路由器。</li><li>然后<strong>此路由器</strong>在收到 IP 数据报后，再按<strong>目的网络号</strong> net-id 和<strong>子网号</strong> subnet-id 找到目的子网。</li><li>最后就将 IP 数据报直接交付目的主机。</li></ul><p>划分为三个子网后对外仍是一个网络</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143933.png" alt="image-20201017160116239"></p><blockquote><ul><li><strong>优点</strong><ol><li>减少了 IP 地址的浪费</li><li>使网络的组织更加灵活</li><li>更便于维护和管理</li></ol></li><li><strong>划分子网纯属一个单位内部的事情，对外部网络透明</strong>，对外仍然表现为没有划分子网的一个网络。</li></ul></blockquote><h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143413.png" alt="image-20201017160252066"></p><blockquote><p><strong>(IP 地址) AND (子网掩码) &#x3D; 网络地址</strong> 重要，下面很多相关知识都会用到</p></blockquote><p>举例</p><p>例子1</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143377.png" alt="image-20201017161651058"></p><p>例子2</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032143929.png" alt="image-20201017161719339"></p><p><strong>默认子网掩码</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144827.png" alt="image-20201017162807076"></p><h4 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144957.png" alt="image-20201017162938612"></p><blockquote><ul><li>子网掩码是一个网络或一个子网的重要属性。</li><li>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。</li><li>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。</li><li>若一个路由器连接在两个子网上，就拥有两个网络地址和两个子网掩码。</li></ul></blockquote><h3 id="无分类编址的IPv4地址"><a href="#无分类编址的IPv4地址" class="headerlink" title="无分类编址的IPv4地址"></a>无分类编址的IPv4地址</h3><h4 id="为什么使用无分类编址"><a href="#为什么使用无分类编址" class="headerlink" title="为什么使用无分类编址"></a>为什么使用无分类编址</h4><p><strong>无分类域间路由选择 CIDR</strong> (Classless Inter-Domain Routing)。 </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144773.png" alt="image-20201017164031532"></p><blockquote><p><strong>CIDR 最主要的特点</strong></p><ul><li>CIDR使用各种长度的“<strong>网络前缀</strong>”(network-prefix)来代替分类地址中的网络号和子网号。</li><li><strong>IP 地址从三级编址（使用子网掩码）又回到了两级编址</strong>。</li></ul></blockquote><h4 id="如何使用无分类编址"><a href="#如何使用无分类编址" class="headerlink" title="如何使用无分类编址"></a>如何使用无分类编址</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144818.png" alt="image-20201017165037268"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144385.png" alt="image-20201017165113442"></p><h4 id="路由聚合（构造超网）"><a href="#路由聚合（构造超网）" class="headerlink" title="路由聚合（构造超网）"></a>路由聚合（构造超网）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144984.png" alt="image-20201017165615915"></p><h4 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144727.png" alt="image-20201017170552495"></p><h3 id="IPv4地址的应用规划"><a href="#IPv4地址的应用规划" class="headerlink" title="IPv4地址的应用规划"></a>IPv4地址的应用规划</h3><p>给定一个IPv4地址快，如何将其划分成几个更小的地址块，并将这些地址块分配给互联网中不同网络，进而可以给各网络中的主机和路由器接口分配IPv4地址</p><h4 id="定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）"><a href="#定长的子网掩码FLSM（Fixed-Length-Subnet-Mask）" class="headerlink" title="定长的子网掩码FLSM（Fixed Length Subnet Mask）"></a>定长的子网掩码FLSM（Fixed Length Subnet Mask）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144640.png" alt="image-20201018143550103"></p><p><strong>划分子网的IPv4就是定长的子网掩码</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144885.png" alt="image-20201018140809079"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144054.png" alt="image-20201018140916631"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144749.png" alt="image-20201018141132446"></p><blockquote><p>通过上面步骤分析，就可以从子网1<del>8中任选5个分配给左图中的N1</del>N5</p><p><strong>采用定长的子网掩码划分，只能划分出2^n个子网，其中n是从主机号部分借用的用来作为子网号的比特数量，每个子网所分配的IP地址数量相同</strong></p><p><strong>但是也因为每个子网所分配的IP地址数量相同，不够灵活，容易造成IP地址的浪费</strong></p></blockquote><h4 id="变长的子网掩码VLSM（Variable-Length-Subnet-Mask）"><a href="#变长的子网掩码VLSM（Variable-Length-Subnet-Mask）" class="headerlink" title="变长的子网掩码VLSM（Variable Length Subnet Mask）"></a>变长的子网掩码VLSM（Variable Length Subnet Mask）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144829.png" alt="image-20201018143632352"></p><p><strong>无分类编址的IPv4就是变长的子网掩码</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144019.png" alt="image-20201018142333145"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144315.png" alt="image-20201018143344440"></p><hr><h2 id="IP数据报的发送和转发过程"><a href="#IP数据报的发送和转发过程" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144538.png" alt="image-20201018144335297"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144393.png" alt="image-20201018151314019"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032144091.png" alt="image-20201018150151171"></p><p>源主机如何知道目的主机是否与自己在同一个网络中，是直接交付，还是间接交付？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145423.png" alt="image-20201018150223497"></p><blockquote><p>可以通过<strong>目的地址IP</strong>和<strong>源地址的子网掩码</strong>进行<strong>逻辑与运算</strong>得到<strong>目的网络地址</strong></p><ul><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>相同</strong>，就是<strong>在同一个网络</strong>中，属于<strong>直接交付</strong></li><li>如果<strong>目的网络地址</strong>和<strong>源网络地址</strong> <strong>不相同</strong>，就<strong>不在同一个网络</strong>中，属于<strong>间接交付</strong>，传输给主机所在网络的<strong>默认网关</strong>（路由器——下图会讲解）,由默认网关帮忙转发</li></ul></blockquote><p>主机C如何知道路由器R的存在？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062102692.png" alt="image-20201018145501063"></p><blockquote><p>用户为了让本网络中的主机能和其他网络中的主机进行通信，就必须给其指定本网络的一个路由器的接口，由该路由器帮忙进行转发，<strong>所指定的路由器</strong>，也被称为<strong>默认网关</strong></p><p>例如。路由器的接口0的IP地址192.168.0.128做为左边网络的默认网关</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145850.png" alt="image-20201018150029179"></p><blockquote><p>主机A会将该IP数据报传输给自己的默认网关，也就是图中所示的路由器接口0</p></blockquote><p>路由器收到IP数据报后如何转发？</p><ul><li>检查IP数据报首部是否出错：<ul><li>若出错，则直接丢弃该IP数据报并通告源主机</li><li>若没有出错，则进行转发</li></ul></li><li>根据IP数据报的目的地址在路由表中查找匹配的条目：<ul><li>若找到匹配的条目，则转发给条目中指示的吓一跳</li><li>若找不到，则丢弃该数据报并通告源主机</li></ul></li></ul><p>假设IP数据报首部没有出错，路由器取出IP数据报首部各地址字段的值</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145151.png" alt="image-20201018151108989"></p><p>接下来路由器对该IP数据报进行查表转发</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145272.png" alt="image-20201018151528027"></p><blockquote><p>逐条检查路由条目，将目的地址与路由条目中的地址掩码进行逻辑与运算得到目的网络地址，然后与路由条目中的目的网络进行比较，如果相同，则这条路由条目就是匹配的路由条目，按照它的下一条指示，图中所示的也就是接口1转发该IP数据报</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145885.png" alt="image-20201018151956275"></p><p>路由器是隔离广播域的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145075.png" alt="image-20201018152040610"></p><hr><h2 id="静态路由配置及其可能产生的路由环路问题"><a href="#静态路由配置及其可能产生的路由环路问题" class="headerlink" title="静态路由配置及其可能产生的路由环路问题"></a>静态路由配置及其可能产生的路由环路问题</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145422.png" alt="image-20201018155702081"></p><h3 id="多种情况举例"><a href="#多种情况举例" class="headerlink" title="多种情况举例"></a>多种情况举例</h3><p> <strong>静态路由配置</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145136.png" alt="image-20201018160349375"></p><p><strong>默认路由</strong></p><p>举例</p><p>默认路由可以被所有网络匹配，但路由匹配有优先级，默认路由是优先级最低的</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145293.png" alt="image-20201018160906284"></p><p><strong>特定主机路由</strong></p><p>举例</p><p>有时候，我们可以给路由器添加针对某个主机的特定主机路由条目</p><p>一般用于网络管理人员对网络的管理和测试</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145925.png" alt="image-20201018161440257"></p><blockquote><p>多条路由可选，匹配路由最具体的</p></blockquote><p><strong>静态路由配置错误导致路由环路</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145060.png" alt="image-20201018161542579"></p><p>假设将R2的路由表中第三条目录配置错了下一跳</p><p>这导致R2和R3之间产生了路由环路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145063.png" alt="image-20201018162041966"></p><p><strong>聚合了不存在的网络而导致路由环路</strong></p><p>举例</p><p>正常情况</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103223.png" alt="image-20201018162333671"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145038.png" alt="image-20201018162759562"></p><p>错误情况</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145591.png" alt="image-20201018163323343"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145392.png" alt="image-20201018163933715"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145058.png" alt="image-20201018164453398"></p><blockquote><p>黑洞路由的下一跳为null0，这是路由器内部的虚拟接口，IP数据报进入它后就被丢弃</p></blockquote><p><strong>网络故障而导致路由环路</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032145273.png" alt="image-20201018164811811"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146199.png" alt="image-20201018164913684"></p><p>解决方法</p><p>添加故障的网络为黑洞路由</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146545.png" alt="image-20201018165122023"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146380.png" alt="image-20201018165153517"></p><p>假设。一段时间后故障网络恢复了</p><p>R1又自动地得出了其接口0的直连网络的路由条目</p><p>针对该网络的黑洞网络会自动失效</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146323.png" alt="image-20201018165328319"></p><p>如果又故障</p><p>则生效该网络的黑洞网络</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146375.png" alt="image-20201018165521938"></p><h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146543.png" alt="image-20201018165709294"></p><hr><h2 id="路由选择协议"><a href="#路由选择协议" class="headerlink" title="路由选择协议"></a>路由选择协议</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146916.png" alt="image-20201019134827343"></p><p><strong>因特网所采用的路由选择协议的主要特点</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146505.png" alt="image-20201019134946971"></p><p><strong>因特网采用分层次的路由选择协议</strong></p><ul><li><strong>自治系统 AS</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146310.png" alt="image-20201019135122326"></p><blockquote><p>自治系统之间的路由选择简称为域间路由选择，自治系统内部的路由选择简称为域内路由选择</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146733.png" alt="image-20201019135328925"></p><blockquote><p>域间路由选择使用外部网关协议EGP这个类别的路由选择协议</p><p>域内路由选择使用内部网关协议IGP这个类别的路由选择协议</p><p><strong>网关协议</strong>的名称可称为<strong>路由协议</strong></p></blockquote><p><strong>常见的路由选择协议</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146209.png" alt="image-20201019140009740"></p><p><strong>路由器的基本结构</strong></p><p>路由器是一种具有多个输入端口，和输出端口的专用计算机，其任务是转发分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146950.png" alt="image-20201019140234652"></p><p>路由器结构可划分为两大部分：</p><p>1、<strong>分组转发部分</strong></p><p> 由三部分构成</p><ul><li><p>交换结构</p></li><li><p>一组输入端口：</p><p>信号从某个输入端口进入路由器</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146852.png" alt="image-20201019141149194" style="zoom:50%;" /><p>物理层将信号转换成比特流，送交数据链路层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146584.png" alt="image-20201019141210774" style="zoom: 50%;" /><p>数据链路层识别从比特流中识别出帧，去掉帧头和帧尾后，送交网络层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146443.png" alt="image-20201019141242246" style="zoom:50%;" /><p>  如果送交网络层的分组是普通待转发的数据分组</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146012.png" alt="image-20201019141305650" style="zoom:50%;" /><p>   则根据分组首部中的目的地址进行查表转发</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146996.png" alt="image-20201019141327380" style="zoom:50%;" /><p>若找不到匹配的转发条目，则丢弃该分组，否则，按照匹配条目中所指示的端口进行转发</p></li><li><p>一组输出端口</p><p>网络层更新数据分组首部中某些字段的值，例如将数据分组的生存时间减1，然后送交数据链路层进行封装</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032146712.png" alt="image-20201019141745375" style="zoom:50%;" /><p>数据链路层将数据分组封装成帧，交给物理层处理</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147738.png" alt="image-20201019141838032" style="zoom:50%;" /><p>物理层将帧看成比特流将其变换成相应的电信号进行发送</p></li></ul><blockquote><p>路由器的各端口还会有输入缓冲区和输出缓冲区</p><ul><li><p>输入缓冲区用来暂存新进入路由器但还来不及处理的分组</p></li><li><p>输出缓冲区用来暂存已经处理完毕但还来不及发送的分组</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147346.png" alt="image-20201019143040253"></p><p><strong>路由器的端口一般都具有输入和输出功能</strong>，这些实例分出了输入端口和输出端口是更好演示路由基本工作过程</p></blockquote><p> 2、<strong>路由选择部分</strong></p><ul><li><p>路由选择部分的核心构件是路由选择处理机，它的任务是根据所使用的路由选择协议。周期性地与其他路由器 进行路由信息的交互，来更新路由表</p><p>如果送交给输入端口的网络层的分组是路由器之间交换路由信息的路由报文，则把这种分组送交给路由选择处理机</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147888.png" alt="image-20201019142228360" style="zoom:50%;" /><p>路由选择处理机根据分组的内容来更新自己的<strong>路由表</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147781.png" alt="image-20201019142415055"></p><p>路由选择处理机还会周期性地给其他路由器发送自己所知道的路由信息</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147895.png" alt="image-20201019142924889"></p></li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032147697.png" alt="image-20201019144915687"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159586.png" alt="image-20201019145247606"></p><p><strong>RIP的基本工作过程</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159219.png" alt="image-20201019145510947"></p><p><strong>RIP的路由条目的更新规则</strong></p><p>举例1</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032159339.png" alt="image-20201019145627339"></p><blockquote><p>路由器C的表到达各目的网络的下一条都记为问号，可以理解为路由器D并不需要关心路由器C的这些内容</p><p>假设路由器C的RIP更新报文发送周期到了，则路由器C将自己路由表中的相关路由信息封装到RIP更新报文中发送给路由器D</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200780.png" alt="image-20201019150120900"></p><blockquote><p>路由器C能到达这些网络，说明路由器C的相邻路由器也能到达，只是比路由器C的距离大1，于是根据距离的对比，路由器D更新自己的路由表</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200091.png" alt="image-20201019150412666"></p><p>举例2</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200777.png" alt="image-20201019150525711"></p><p><strong>RIP存在“坏消息传播得慢”的问题</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200128.png" alt="image-20201019151041492"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200717.png" alt="image-20201019151135255"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200320.png" alt="image-20201019151332767"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200545.png" alt="image-20201019151639181"></p><blockquote><p>但是，这些方法也不能完全解决“坏消息传播得慢”的问题，这是距离向量的本质决定</p></blockquote><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200548.png" alt="image-20201019152526098"></p><blockquote><p>RIP 协议的优缺点</p><p>优点：</p><ol><li>实现简单，开销较小。</li></ol><p>缺点：</p><ol><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>“坏消息传播得慢”，使更新过程的收敛时间过长。</p></li></ol></blockquote><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><p><strong>开放最短路径优先 OSPF (Open Shortest Path First)</strong></p><p><strong>注意</strong>：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。</p><p><strong>概念</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200244.png" alt="image-20201019161841695"></p><p><strong>问候（Hello）分组</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200585.png" alt="image-20201019161653875"></p><blockquote><p>IP数据报首部中协议号字段的取值应为89，来表明IP数据报的数据载荷为OSPF分组</p></blockquote><p><strong>发送链路状态通告LSA</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200277.png" alt="image-20201019162341151"></p><blockquote><p>洪泛法有点类似于广播，就是从一个接口进来，从其他剩余所有接口出去</p></blockquote><p><strong>链路状态数据库同步</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200131.png" alt="image-20201019162933483"></p><p><strong>使用SPF算法计算出各自路由器到达其他路由器的最短路径</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200046.png" alt="image-20201019163148068"></p><p><strong>OSPF五种分组类型</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103702.png" alt="image-20201019163250129"></p><p><strong>OSPF的基本工作过程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200953.png" alt="image-20201019163746254"></p><p><strong>OSPF在多点接入网络中路由器邻居关系建立</strong></p><p>如果不采用其他机制，将会产生大量的多播分组</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200826.png" alt="image-20201019164657606"></p><blockquote><p>若DR出现问题，则由BDR顶替DR</p></blockquote><p><strong>为了使OSPF能够用于规模很大的网络，OSPF把一个自治系统再划分为若干个更小的范围，叫做区域（Area）</strong></p><ul><li><p>在该自治系统内，所有路由器都使用OSPF协议，OSPF将该自治系统再划分成4个更小的区域</p></li><li><p>每个区域都有一个32比特的区域标识符</p></li><li><p>主干区域的区域标识符必须为0，主干区域用于连通其他区域</p></li><li><p>其他区域的区域标识符不能为0且不相同</p></li><li><p>每个区域一般不应包含路由器超过200个</p></li><li><p>划分区域的好处就是，利用洪泛法交换链路状态信息局限于每一个区域而不是自治系统，这样减少整个网络上的通信量</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032200436.png" alt="image-20201019170100568"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201556.png" alt="image-20201019170217622"></p><h3 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h3><p>BGP（Border Gateway Protocol） 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201816.png" alt="image-20201019191438399"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201342.png" alt="image-20201019191718506"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201443.png" alt="image-20201019191836397"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201643.png" alt="image-20201019192031087"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201648.png" alt="image-20201019192059962"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201534.png" alt="image-20201019192840368"></p><h3 id="直接封装RIP、OSPF和BGP报文的协议"><a href="#直接封装RIP、OSPF和BGP报文的协议" class="headerlink" title="直接封装RIP、OSPF和BGP报文的协议"></a>直接封装RIP、OSPF和BGP报文的协议</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201784.png" alt="image-20201019192800829"></p><hr><h2 id="IPv4数据报的首部格式"><a href="#IPv4数据报的首部格式" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h2><h3 id="各字段的作用"><a href="#各字段的作用" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><ul><li>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。</li><li><strong>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。</strong></li><li>在首部的固定部分的后面是一些可选字段，其长度是可变的。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201646.png" alt="image-20201019205931748"></p><p>图中的每一行都由32个比特（也就是4个字节）构成，每个小格子称为字段或者域，每个字段或某些字段的组合用来表达IP协议的相关功能</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201149.png" alt="image-20201019211719880"></p><blockquote><p><strong>IP数据报的首部长度一定是4字节的整数倍</strong></p><p>因为首部中的可选字段的长度从1个字节到40个字节不等，那么，当20字节的固定部分加上1到40个字节长度不等的可变部分，<strong>会造成首部长度不是4字节整数倍时，就用取值为全0的填充字段填充相应个字节</strong>，以确保IP数据报的首部长度是4字节的整数倍</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201065.png" alt="image-20201019212617006"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201308.png" alt="image-20201019220435415"></p><p><strong>对IPv4数据报进行分片</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201665.png" alt="image-20201019221021157"></p><p>​        现在假定分片2的IP数据报经过某个网络时还需要进行分片</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201471.png" alt="image-20201019221246870"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201363.png" alt="image-20201019222512112"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032201290.png" alt="image-20201019222552444"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202265.png" alt="image-20201019222729797"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202402.png" alt="image-20201019223101434"></p><h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202510.png" alt="image-20201019225141559"></p><hr><h2 id="网际控制报文协议ICMP"><a href="#网际控制报文协议ICMP" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><p>架构IP网络时需要特别注意两点：</p><ul><li>确认网络是否正常工作</li><li>遇到异常时进行问题诊断</li></ul><p><strong>而ICMP就是实现这些问题的协议</strong></p><p>ICMP的主要功能包括：</p><ul><li>确认IP包是否成功送达目标地址</li><li>通知在发送过程当中IP包被废弃的具体原因</li><li>改善网络设置等</li></ul><p><strong>有了这些功能以后，就可以获得网络是否正常，设置是否有误以及设备有何异常等信息，从而便于进行网络上的问题诊断</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202306.png" alt="image-20201019232539898"></p><p><strong>ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议</strong></p><p>ICMP 报文的格式</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202517.png" alt="image-20201020001035813"></p><h3 id="ICMP差错报告报文"><a href="#ICMP差错报告报文" class="headerlink" title="ICMP差错报告报文"></a>ICMP差错报告报文</h3><h4 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202270.png" alt="image-20201019230838587"></p><h4 id="源点抑制"><a href="#源点抑制" class="headerlink" title="源点抑制"></a>源点抑制</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202289.png" alt="image-20201019231022291"></p><h4 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202565.png" alt="image-20201019231230798"></p><h4 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202256.png" alt="image-20201019231355471"></p><h4 id="改变路由（重定向）"><a href="#改变路由（重定向）" class="headerlink" title="改变路由（重定向）"></a>改变路由（重定向）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202910.png" alt="image-20201019231553990"></p><h4 id="不应发送ICMP差错报告报文情况"><a href="#不应发送ICMP差错报告报文情况" class="headerlink" title="不应发送ICMP差错报告报文情况"></a>不应发送ICMP差错报告报文情况</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202227.png" alt="image-20201019231733673"></p><h3 id="ICMP应用举例"><a href="#ICMP应用举例" class="headerlink" title="ICMP应用举例"></a>ICMP应用举例</h3><h4 id="分组网间探测PING（Packet-InterNet-Groper）"><a href="#分组网间探测PING（Packet-InterNet-Groper）" class="headerlink" title="分组网间探测PING（Packet InterNet Groper）"></a>分组网间探测PING（Packet InterNet Groper）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202208.png" alt="image-20201019233817921"></p><h4 id="跟踪路由（traceroute）"><a href="#跟踪路由（traceroute）" class="headerlink" title="跟踪路由（traceroute）"></a>跟踪路由（traceroute）</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202658.png" alt="image-20201019234123026"></p><p><strong>tracert命令的实现原理</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032202439.png" alt="image-20201019234718107"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203184.png" alt="image-20201019234741268"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203507.png" alt="image-20201019234758693"></p><h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203373.png" alt="image-20201019234909146"></p><hr><h2 id="虚拟专用网VPN与网络地址转换NAT"><a href="#虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="虚拟专用网VPN与网络地址转换NAT"></a>虚拟专用网VPN与网络地址转换NAT</h2><h3 id="虚拟专用网VPN（Virtual-Private-Network）"><a href="#虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="虚拟专用网VPN（Virtual Private Network）"></a>虚拟专用网VPN（Virtual Private Network）</h3><ul><li>由于 <strong>IP 地址的紧缺</strong>，一个机构能够申请到的IP地址数往往远小于本机构所拥有的主机数。</li><li>考虑到<strong>互联网并不很安全</strong>，一个机构内也并不需要把所有的主机接入到外部的互联网。</li><li>假定在一个机构内部的计算机通信也是采用 TCP&#x2F;IP 协议，那么从原则上讲，对于这些仅在<strong>机构内部使用</strong>的计算机就可以由本机构<strong>自行分配其 IP 地址</strong>。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203221.png" alt="image-20201019235534728"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203199.png" alt="image-20201019235631474"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203051.png" alt="image-20201019235718010"></p><blockquote><p>上图是因特网数字分配机构IANA官网查看IPv4地址空间中特殊地址的分配方案</p><p>用粉红色标出来的地址就是无需申请的、可自由分配的专用地址，或称私有地址</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203532.png" alt="image-20201020000136443"></p><blockquote><p>私有地址只能用于一个机构的内部通信，而不能用于和因特网上的主机通信</p><p>私有地址只能用作本地地址而不能用作全球地址</p><p>因特网中所有路由器对目的地址是私有地址的IP数据报一律不进行转发</p><p><strong>本地地址与全球地址</strong></p><ul><li><strong>本地地址</strong>——仅在机构内部使用的 IP 地址，可以由本机构自行分配，而不需要向互联网的管理机构申请。</li><li><strong>全球地址</strong>——全球唯一的 IP 地址，必须向互联网的管理机构申请。 </li><li><strong>问题</strong>：在内部使用的本地地址就有可能和互联网中某个 IP 地址重合，这样就会出现地址的二义性问题。</li></ul></blockquote><p>所以部门A和部门B至少需要一个 路由器具有合法的全球IP地址，这样各自的专用网才能利用公用的因特网进行通信</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203609.png" alt="image-20201020000618797"></p><p>部门A向部门B发送数据流程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203083.png" alt="image-20201020001107425"></p><blockquote><p>两个专用网内的主机间发送的数据报是通过了公用的因特网，但在效果上就好像是在本机构的专用网上传送一样</p><p>数据报在因特网中可能要经过多个网络和路由器，但从逻辑上看，R1和R2之间好像是一条直通的点对点链路</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203813.png" alt="image-20201020001528569"></p><p>因此也被称为IP隧道技术</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203256.png" alt="image-20201020001935801"></p><h3 id="网络地址转换NAT（Network-Address-Translation）"><a href="#网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="网络地址转换NAT（Network Address Translation）"></a>网络地址转换NAT（Network Address Translation）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203331.png" alt="image-20201020002020607"></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203215.png" alt="image-20201020002439942"></p><blockquote><p>使用私有地址的主机，如何才能与因特网上使用全球IP地址的主机进行通信？</p><p>这需要在专用网络连接到因特网的路由器上安装NAT软件</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203339.png" alt="image-20201020002734192"></p><blockquote><p>专有NAT软件的路由器叫做NAT路由器</p><p>它至少有一个有效的外部全球IP地址</p><p>这样，所有使用私有地址的主机在和外界通信时，都要在NAT路由器上将其私有地址转换为全球IP地址</p></blockquote><p>假设，使用私有地址的主机要给因特网上使用全球IP地址的另一台主机发送IP数据报</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203296.png" alt="image-20201020003238729"></p><p>因特网上的这台主机给源主机发回数据报</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203259.png" alt="image-20201020003411024"></p><p>当专用网中的这两台使用私有地址的主机都要给因特网使用全球地址的另一台主机发送数据报时，在NAT路由器的NAT转换表中就会产生两条记录，分别记录两个私有地址与全球地址的对应关系</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203895.png" alt="image-20201020003658349"></p><p>这种基本转换存在一个问题</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203017.png" alt="image-20201020003733863"></p><p>解决方法</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032203526.png" alt="image-20201020003840584"></p><blockquote><p>我们现在用的很多家用路由器都是这种NART路由器</p></blockquote><p>内网主机与外网主机的通信，是否能由外网主机首先发起？</p><p>否定</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204315.png" alt="image-20201020004159360"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204805.png" alt="image-20201020004312942"></p><h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204532.png" alt="image-20201020004447021"></p><h2 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h2><h3 id="IPv4习题"><a href="#IPv4习题" class="headerlink" title="IPv4习题"></a>IPv4习题</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204392.png" alt="image-20201017151024579"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204149.png" alt="image-20201017151500372"></p><blockquote><p>题目的注意点</p><p><strong>本题按照节约原则</strong></p><p>路由器的接口也要分配一个IP地址</p><p>所以橙色网络的IP地址数量是 65534 + 1 &#x3D; 65535，同理 蓝色网络的是 255 个，绿色网络（交换式以太网）的是 16 + 24 + 1 &#x3D; 41 个，红色网络（两台路由器通过一段链路直连，它们的直连接口也属于一个网络）是 2 个</p><p>分配IP地址不能相同</p><p>不能出现两个一样的网络号</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204613.png" alt="image-20201017161733295"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204915.png" alt="image-20201017162644758"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204956.png" alt="image-20201017165224804"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204998.png" alt="image-20201017170339534"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204982.png" alt="image-20201017170516701"></p><h3 id="IP数据报的发送和转发过程-1"><a href="#IP数据报的发送和转发过程-1" class="headerlink" title="IP数据报的发送和转发过程"></a>IP数据报的发送和转发过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204474.png" alt="image-20201018152326777"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204995.png" alt="image-20201018152504951"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103142.png" alt="image-20201018152811812"></p><h3 id="路由选择协议-1"><a href="#路由选择协议-1" class="headerlink" title="路由选择协议"></a>路由选择协议</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204524.png" alt="image-20201019150738458"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204229.png" alt="image-20201019152221295"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204574.png" alt="image-20201019192349770"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204352.png" alt="image-20201019192546327"></p><h3 id="IPv4数据报的首部格式-1"><a href="#IPv4数据报的首部格式-1" class="headerlink" title="IPv4数据报的首部格式"></a>IPv4数据报的首部格式</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032204163.png" alt="image-20201019223719168"></p><blockquote><p>780&#x2F;8向下取整等于97</p><p>97*8 &#x3D; 776</p></blockquote><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205086.png" alt="image-20201019224949922"></p><h3 id="网际控制报文协议ICMP-1"><a href="#网际控制报文协议ICMP-1" class="headerlink" title="网际控制报文协议ICMP"></a>网际控制报文协议ICMP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205294.png" alt="image-20201019232300815"></p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="运输层概述"><a href="#运输层概述" class="headerlink" title="运输层概述"></a>运输层概述</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><p><strong>进程之间的通信</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205838.png" alt="image-20201020211725185" style="zoom:67%;" /><ul><li>从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，<strong>它属于面向通信部分的最高层，同时也是用户功能中的最低层</strong>。</li><li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到三层（到网络层）的功能。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205927.png" alt="image-20201020211339131"></p><p><strong>进程之间通信流程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205734.png" alt="image-20201020213721054"></p><p>“逻辑通信”是指运输层之间的通信好像是沿水平方向传送数据，但事实上，这两条数据并没有一条水平方向的物理连接，要传送的数据是沿着图中上下多次的虚线方向传送的</p><blockquote><p>进程Ap1与Ap4之间进行基于网络的通信，进程Ap2与Ap3之间进行基于网络的通信</p><p>在运输层使用不同的端口，来对应不同的应用进程</p><p>然后通过网络层及其下层来传输应用层报文</p><p>接收方的运输层通过不同的端口，将收到的应用层报文，交付给应用层中相应的应用进程</p><p>这里端口并不是指看得见、摸得着的物理端口，而是指用来区分不同应用进程的标识符</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205206.png" alt="image-20201020220439303"></p><h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205023.png" alt="image-20201020220545411"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205119.png" alt="image-20201020222828878"></p><hr><h2 id="运输层端口号、复用与分用的概念"><a href="#运输层端口号、复用与分用的概念" class="headerlink" title="运输层端口号、复用与分用的概念"></a>运输层端口号、复用与分用的概念</h2><h3 id="为什么用端口号"><a href="#为什么用端口号" class="headerlink" title="为什么用端口号"></a>为什么用端口号</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205780.png" alt="image-20201020223242364"></p><h3 id="发送方的复用和接收方的分用"><a href="#发送方的复用和接收方的分用" class="headerlink" title="发送方的复用和接收方的分用"></a>发送方的复用和接收方的分用</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205662.png" alt="image-20201020223920225"></p><blockquote><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>发送</strong>数据称为 <strong>复用</strong></p><p><strong>多个进程（这里一个端口表示一个进程）</strong> 利用一个运输层协议（或者称为运输层接口）<strong>接收</strong>时叫做  <strong>分用</strong>。</p></blockquote><h3 id="TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号"><a href="#TCP-x2F-IP体系的应用层常用协议所使用的运输层熟知端口号" class="headerlink" title="TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号"></a>TCP&#x2F;IP体系的应用层常用协议所使用的运输层熟知端口号</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205858.png" alt="image-20201020224521744"></p><h3 id="运输层传输流程"><a href="#运输层传输流程" class="headerlink" title="运输层传输流程"></a>运输层传输流程</h3><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205262.png" alt="image-20201020224658524"></p><blockquote><p>在浏览器输入域名，回车浏览</p><p>然后用户PC中的DNS客户端进程会发送一个DNS查询请求报文</p><p>DNS查询请求报文需要使用运输层的UDP协议</p><p>首部中的源端口字段的值，在短暂端口号49151~65535中挑选一个未被占用的，用来表示DNS客户端进程</p><p>首部中的目的端口字段的值：53，是DNS服务器端进程所使用的熟知端口号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205805.png" alt="image-20201020225830336"></p><blockquote><p>之后，将UDP用户数据报封装在IP数据报中，通过以太网发送给DNS服务器</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205637.png" alt="image-20201020230059196"></p><blockquote><p>DNS服务器收到该IP数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为53，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS查询请求报文，交付给本服务器中的DNS服务器端进程</p><p>DNS服务器端进程解析DNS查询请求报文的内容，然后按其要求查找对应的IP地址</p><p>之后，会给用户PC发送DNS响应报文，DNS响应报文需要使用运输层的UDP协议封装成UDP用户数据报</p><p>其首部中的源端口字段的值设置为熟知端口号53，表明这是DNS服务器端进程所发送的UDP用户数据报，目的端口的值设置为49152，这是之前用户PC中发送DNS查询请求报文的DNS客户端进程所使用的短暂端口号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205063.png" alt="image-20201020231032812"></p><blockquote><p>将UDP用户数据报封装在IP数据报中，通过以太网发送给用户PC</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205474.png" alt="image-20201020231308120"></p><blockquote><p>用户PC收到该数据报后，从中解封出UDP用户数据报</p><p>UDP首部中的目的端口号为49152，这表明应将该UDP用户数据报的数据载荷部分，也就是DNS响应报文，交付给用户PC中的DNS客户端进程</p><p>DNS客户端进程解析DNS响应报文的内容，就可知道自己之前所请求的Web服务器的域名对应的IP地址</p></blockquote><p>现在用户PC中的HTTP客户端进程可以向Web服务器发送HTTP请求报文（和DNS发送和接收流程差不多）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205335.png" alt="image-20201020231935656"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205940.png" alt="image-20201020232517383"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032205718.png" alt="image-20201020232132890"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206490.png" alt="image-20201020232548833"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206268.png" alt="image-20201020232337332"></p><hr><h2 id="UDP和TCP的对比"><a href="#UDP和TCP的对比" class="headerlink" title="UDP和TCP的对比"></a>UDP和TCP的对比</h2><h3 id="概念-8"><a href="#概念-8" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>UDP</strong> 和 <strong>TCP</strong> 是TCP&#x2F;IP体系结构<strong>运输层</strong>中的两个重要协议</li><li>当运输层采用面向连接的 <strong>TCP</strong> 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong>。</li><li>当运输层采用无连接的 <strong>UDP</strong> 协议时，这种逻辑通信信道是一条<strong>不可靠信道</strong>。</li></ul><p>可靠信道与不可靠信道</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206322.png" alt="image-20201021192221061"></p><ul><li><p>两个对等运输实体在通信时传送的数据单位叫作<strong>运输协议数据单元</strong> TPDU (Transport Protocol Data Unit)。</p></li><li><p>TCP 传送的数据单位协议是 <strong>TCP 报文段</strong>(segment)。</p></li><li><p>UDP 传送的数据单位协议是 <strong>UDP 报文</strong>或<strong>用户数据报</strong>。</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206996.png" alt="image-20201021193640130"></p><p>UDP的通信是无连接的，不需要套接字（Socket）</p><p>TCP是面向连接的，TCP之间的通信必须要在两个套接字（Socket）之间建立连接</p><h3 id="用户数据报协议UDP（User-Datagram-Protocol）"><a href="#用户数据报协议UDP（User-Datagram-Protocol）" class="headerlink" title="用户数据报协议UDP（User Datagram Protocol）"></a>用户数据报协议UDP（User Datagram Protocol）</h3><p>可以发送广播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206740.png" alt="image-20201021194104694" style="zoom: 50%;" /><p>可以向某个多播组发送多播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206379.png" alt="image-20201021194225567" style="zoom:50%;" /><p>还可以发送单播</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206513.png" alt="image-20201021194341256" style="zoom:50%;" /><blockquote><p>UDP 支持单播、多播以及广播</p><p>换句话说，UDP支持一对一，一对多，以及一对全的通信</p></blockquote><p>运输过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206431.png" alt="image-20201021195034383"></p><blockquote><p>UDP对应用进程交下来的报文既不合并也不拆分，而是保留这些报文的边界</p><p>换句话说，UDP是面向应用报文的</p></blockquote><p>UDP向上层提供无连接不可靠传输服务</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206471.png" alt="image-20201021204152175"></p><p>UDP结构</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206342.png" alt="image-20201021205214512"></p><h3 id="传输控制协议TCP（Transmission-Control-Protocol）"><a href="#传输控制协议TCP（Transmission-Control-Protocol）" class="headerlink" title="传输控制协议TCP（Transmission Control Protocol）"></a>传输控制协议TCP（Transmission Control Protocol）</h3><p>使用TCP协议的通信双方，在进行数据传输之前，必须使用“三报文握手”建立TCP连接</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206928.png" alt="image-20201021194557102" style="zoom:50%;" /><p>TCP连接建立成功后，通信双方之间就好像有一条可靠的通信信道，通信双方使用这条基于TCP连接的可靠信道进行通信</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206359.png" alt="image-20201021194749562" style="zoom:50%;" /><blockquote><p>很显然，TCP仅支持单播，也就是一对一的通信</p></blockquote><p>运输过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206050.png" alt="image-20201021195435677"></p><blockquote><p>发送方</p><ul><li><p>TCP会把应用进程交付下来的数据块看作是一连串无结构的字节流，TCP并不知道这些待传送的字节流的含义</p></li><li><p>并将他们编号，并存储在自己发送缓存中</p></li><li><p>TCP会根据发送策略，提取一定量的字节构建TCP报文并发送</p></li></ul><p>接收方</p><ul><li>一方面从所接受到的TCP报文段中，取出数据载荷部分并存储在接收缓存中；一方面将接收缓存中的一些字节交付给应用进程</li><li>TCP不保证接收方应用进程所收到的数据块与发送方发送的数据块，具有对应大小的关系（例如，发送方应用进程交给发送方的TCP共10个数据块，但接收方的TCP可能只用了4个数据块，就把收到的字节流交付给了上层的应用进程，但接收方收到的字节流必须和发送方应用进程发出的字节流完全一样）</li><li>接收方的应用进程必须有能力识别收到的字节流，把它还原成有意义的应用层数据</li></ul><p>TCP是面向字节流的，这正是TCP实现可靠传输、流量控制、以及拥塞控制的基础</p><p>本图只画了一个方向的数据流，在实际网络中，基于TCP连接的两端，可以同时进行TCP报文段的发送和接收</p></blockquote><p>TCP向上层提供面向连接的可靠传输服务</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206491.png" alt="image-20201021204508839"></p><p>TCP结构</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032206112.png" alt="image-20201021205307406"></p><h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207577.png" alt="image-20201023004653315"></p><hr><h2 id="TCP的流量控制"><a href="#TCP的流量控制" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><h3 id="概念-9"><a href="#概念-9" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207073.png" alt="image-20201021223432091"></p><p>举例</p><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=60">具体流程的视频</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207882.png" alt="image-20201021231801076"></p><p>上图主机A现在可将发送缓存中序号1~200的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205032207604.png" alt="image-20201021231904707"></p><p>上图主机A现在可将发送缓存中序号201~500的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103829.png" alt="image-20201021231945653"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103375.png" alt="image-20201021232027721"></p><p>上图主机A现在可将发送缓存中序号501~600的字节数据全部删除，因为已经收到了主机B对它们的累计确认</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103814.png" alt="image-20201021232600497"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103574.png" alt="image-20201021232645300"></p><blockquote><p>上图如果零窗口探测报文在发送过程中如果丢失，还是能打破死锁局面</p><p>因为零窗口探测报文段也有重传计时器，重传计时器超时后，零窗口探测报文段会被重传</p></blockquote><h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103652.png" alt="image-20201021234004254"></p><hr><h2 id="TCP的拥塞控制"><a href="#TCP的拥塞控制" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><h3 id="概念-10"><a href="#概念-10" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103929.png" alt="image-20201022141057083"></p><p><strong>网络拥塞往往是由许多因素引起的。例如：</strong></p><ol><li>点缓存的容量太小；</li><li>链路的容量不足；</li><li>处理机处理的速率太慢；</li><li>拥塞本身会进一步加剧拥塞；</li></ol><p><strong>拥塞控制的一般原理</strong></p><ul><li>拥塞控制的前提：网络能够承受现有的网络负荷。</li><li>实践证明，拥塞控制是很难设计的，因为它是一个<strong>动态问题</strong>。</li><li>分组的丢失是网络发生拥塞的<strong>征兆</strong>而不是原因。</li><li>在许多情况下，甚至正是<strong>拥塞控制本身</strong>成为引起网络性能恶化、甚至发生死锁的原因。</li></ul><p><strong>开环控制和闭环控制</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062103604.png" alt="image-20201022142108309"></p><p><strong>监测网络的拥塞</strong></p><p>主要指标有：</p><ol><li>由于缺少缓存空间而被丢弃的分组的百分数；</li><li>平均队列长度；</li><li>超时重传的分组数；</li><li>平均分组时延；</li><li>分组时延的标准差，等等。</li></ol><p>上述这些指标的上升都标志着拥塞的增长。</p><h3 id="拥塞控制的算法"><a href="#拥塞控制的算法" class="headerlink" title="拥塞控制的算法"></a>拥塞控制的算法</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104447.png" alt="image-20201022141423443"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104250.png" alt="image-20201022141556134"></p><blockquote><p>真正的发送窗口值 &#x3D; Min (接收方窗口值，拥塞窗口值)</p></blockquote><p>下图的实例横纵坐标的意思</p><p>传输轮次：</p><ul><li>发送方给接收方发送数据报文段后，接收方给发送方发发回相应的确认报文段</li><li>一个传输轮次所经历的时间其实就是往返时间，往返时间并非是恒定的数值</li><li>使用传输轮次是为了强调把拥塞窗口所允许发送的报文段都连续发送出去，并受到了对已发送的最后一个报文段的确认</li></ul><p>拥塞窗口：</p><ul><li>它会随网络拥塞程度，以及所使用的拥塞控制算法动态变化</li></ul><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><h5 id="慢开始（slow-start）"><a href="#慢开始（slow-start）" class="headerlink" title="慢开始（slow-start）"></a>慢开始（slow-start）</h5><ul><li>目的：用来确定网络的负载能力或拥塞程度。</li><li>算法的思路：由小到大逐渐增大拥塞窗口数值。</li><li>两个变量：<ul><li><strong>拥塞窗口（cwnd）</strong>：初始拥塞窗口值：2 种设置方法。窗口值逐渐增大。<ul><li>1 至 2 个最大报文段 （旧标准）</li><li>2 至 4 个最大报文段 （RFC 5681）</li></ul></li><li><strong>慢开始门限（ssthresh）</strong>：防止拥塞窗口增长过大引起网络拥塞。</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109242.png" alt="image-20201022145631052"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104406.png" alt="image-20201022144725100"></p><blockquote><p>图中swnd是发送窗口</p><p>每经过一个传输轮次，拥塞窗口就加倍</p><p>窗口大小按<strong>指数增加</strong>，2的n-1次方</p></blockquote><h5 id="拥塞避免（congestion-avoidance）"><a href="#拥塞避免（congestion-avoidance）" class="headerlink" title="拥塞避免（congestion avoidance）"></a>拥塞避免（congestion avoidance）</h5><ul><li>思路：让拥塞窗口 cwnd <strong>缓慢地增大</strong>，避免出现拥塞。</li><li>每经过一个传输轮次，拥塞窗口 <strong>cwnd &#x3D; cwnd + 1</strong>。</li><li>使拥塞窗口 cwnd 按线性规律缓慢增长。</li><li>在拥塞避免阶段，具有 “<strong>加法增大</strong>” (Additive Increase) 的特点。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104418.png" alt="image-20201022150143886"></p><p>如果在发送过程中出现部分报文段丢失，这必然会造成发送方对这些丢失报文段的超时重传</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104769.png" alt="image-20201022145749592"></p><p>这个时候又回到了慢开始</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104855.png" alt="image-20201022145544163"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104111.png" alt="image-20201022145824004"></p><h5 id="两个算法完整示意图"><a href="#两个算法完整示意图" class="headerlink" title="两个算法完整示意图"></a>两个算法完整示意图</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104118.png" alt="image-20201022150236926"></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104896.png" alt="image-20201022150902709"></p><h5 id="快重传（fast-retrasmit）"><a href="#快重传（fast-retrasmit）" class="headerlink" title="快重传（fast retrasmit）"></a>快重传（fast retrasmit）</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109112.png" alt="image-20201022151250183"></p><h5 id="快恢复（fast-recovery）"><a href="#快恢复（fast-recovery）" class="headerlink" title="快恢复（fast recovery）"></a>快恢复（fast recovery）</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104801.png" alt="image-20201022151819265"></p><h5 id="改进后的整体算法的示意图"><a href="#改进后的整体算法的示意图" class="headerlink" title="改进后的整体算法的示意图"></a>改进后的整体算法的示意图</h5><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104335.png" alt="image-20201022152041751"></p><hr><h2 id="TCP超时重传时间的选择"><a href="#TCP超时重传时间的选择" class="headerlink" title="TCP超时重传时间的选择"></a>TCP超时重传时间的选择</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104854.png" alt="image-20201022152651184"></p><blockquote><p>如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104075.png" alt="image-20201022152708875"></p><blockquote><p>如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104379.png" alt="image-20201022153244047"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104395.png" alt="image-20201022153518218"></p><p><strong>RFC6298建议使用下式计算超时重传时间RTO</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104356.png" alt="image-20201022153758413"></p><p><strong>往返时间RTT的测量比较复杂</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104634.png" alt="image-20201022154045440"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104875.png" alt="image-20201022154137911"></p><p><strong>TCP超时重传的计算</strong></p><p>举例</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104017.png" alt="image-20201022154350745"></p><p><strong>总结</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062104292.png" alt="image-20201022154418863"></p><hr><h2 id="TCP可靠传输的实现"><a href="#TCP可靠传输的实现" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><a href="https://www.bilibili.com/video/BV1c4411d7jb?p=63">本集具体讲解</a></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105424.png" alt="image-20201022161436801"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105231.png" alt="image-20201022161734997"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105357.png" alt="image-20201022164339902"></p><hr><h2 id="TCP的运输连接管理"><a href="#TCP的运输连接管理" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><h3 id="概念-11"><a href="#概念-11" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105494.png" alt="image-20201022193215183"></p><h3 id="TCP的连接建立"><a href="#TCP的连接建立" class="headerlink" title="TCP的连接建立"></a>TCP的连接建立</h3><ul><li>TCP 建立连接的过程叫做<strong>握手</strong>。</li><li>握手需要在客户和服务器之间交换三个 TCP 报文段。称之为<strong>三报文握手</strong>。</li><li>采用<strong>三报文握手</strong>主要是为了防止已失效的连接请求报文段突然又传送到了，因而产生错误。</li></ul><h4 id="TCP的连接建立要解决以下三个问题"><a href="#TCP的连接建立要解决以下三个问题" class="headerlink" title="TCP的连接建立要解决以下三个问题"></a>TCP的连接建立要解决以下三个问题</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109760.png" alt="image-20201022193418673"></p><h4 id="TCP使用“三报文握手”建立连接"><a href="#TCP使用“三报文握手”建立连接" class="headerlink" title="TCP使用“三报文握手”建立连接"></a>TCP使用“三报文握手”建立连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li></ul><p>“握手”需要在TCP客户端和服务器之间交换三个TCP报文段</p><p>过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105786.png" alt="image-20201022194219693"></p><blockquote><p>最初两端的TCP进程都处于关闭状态</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105116.png" alt="image-20201022194350899"></p><blockquote><p>一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等</p><p>之后，就准备接受TCP客户端进程的连接请求</p><p>此时，TCP服务器进程就进入监听状态，等待TCP客户端进程的连接请求</p></blockquote><p>TCP服务器进程是被动等待来自TCP客户端进程的连接请求，因此成为<strong>被动打开</strong>连接</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105666.png" alt="image-20201022194926877"></p><blockquote><p>TCP客户进程也是首先创建传输控制块</p></blockquote><p>由于TCP连接建立是由TCP客户端主动发起的，因此称为<strong>主动打开</strong>连接</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105383.png" alt="image-20201022195108616"></p><blockquote><p>然后，在打算建立TCP连接时，向TCP服务器进程发送TCP连接请求报文段，并进入同步已发送状态</p><p>TCP连接请求报文段首部中</p><ul><li>同步位SYN被设置为1，表明这是一个TCP连接请求报文段</li><li>序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号</li></ul><p>请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105987.png" alt="image-20201022195847144"></p><blockquote><p>TCP服务器进程收到TCP连接请求报文段后，如果同意建立连接，则向TCP客户进程发送TCP连接请求确认报文段，并进入同步已接收状态</p><p>TCP连接请求确认报文段首部中</p><ul><li>同步位SYN和确认为ACK都设置为1，表明这是一个TCP连接请求确认报文段</li><li>序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，</li><li>确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认</li></ul><p>请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105453.png" alt="image-20201022202010182"></p><blockquote><p>TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个普通的TCP确认报文段，并进入连接已连接状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1</li><li>确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认</li></ul><p>请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105501.png" alt="image-20201022202932905"></p><blockquote><p>TCP服务器进程收到该确认报文段后也进入连接已建立状态</p><p>现在，TCP双方都进入了连接已建立状态，它们可以基于已建立好的TCP连接，进行可靠的数据传输</p></blockquote><p>为什么TCP客户进程最后还要发送一个普通的TCP确认报文段？能否使用“两报文握手”建立连接？</p><p>下图实例是“两报文握手”</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105669.png" alt="image-20201022203744174"></p><blockquote><p>为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有&gt; 丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个&gt; 早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同&gt; 意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因&gt; 此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。</p><p>所以并不<strong>多余</strong>，这是为了防止已失效的连接请求报文段突然又传送到了TCP服务器，因而导致错误</p></blockquote><h4 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105664.png" alt="image-20201022204422775"></p><h3 id="TCP的连接释放"><a href="#TCP的连接释放" class="headerlink" title="TCP的连接释放"></a>TCP的连接释放</h3><ul><li>TCP 连接释放过程比较复杂。</li><li>数据传输结束后，通信的双方都可释放连接。</li><li>TCP 连接释放过程是<strong>四报文握手</strong>。</li></ul><h4 id="TCP通过“四报文挥手”来释放连接"><a href="#TCP通过“四报文挥手”来释放连接" class="headerlink" title="TCP通过“四报文挥手”来释放连接"></a>TCP通过“四报文挥手”来释放连接</h4><ul><li>TCP 连接的建立<strong>采用客户服务器方式</strong>。</li><li>主动发起连接建立的应用进程叫做<strong>TCP客户</strong> (client)。</li><li>被动等待连接建立的应用进程叫做<strong>TCP服务器</strong> (server)。</li><li><strong>任何一方都可以在数据传送结束后发出连接释放的通知</strong></li></ul><p>过程</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105712.png" alt="image-20201022205124204"></p><blockquote><p>现在TCP客户进程和TCP服务器进程都处于连接已建立状态</p><p>TCP客户进程的应用进程通知其主动关闭TCP连接</p><p>TCP客户进程会发送TCP连接释放报文段，并进入终止等待1状态</p><p>TCP连接释放报文段首部中</p><ul><li>终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1</li><li>确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1</li></ul><p>请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105153.png" alt="image-20201022210030419"></p><blockquote><p>TCP服务器进程收到TCP连接释放报文段后，会发送一个普通的TCP确认报文段并进入关闭等待状态</p><p>普通的TCP确认报文段首部中</p><ul><li>确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为v，它等于TCP服务器进程之前已传送过的数据的最后一个字节的序号加1，这也与之前收到的TCP连接释放报文段中的确认号匹配</li><li>确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105425.png" alt="image-20201022232158631"></p><blockquote><p>TCP服务器进程应该通知高层应用进程，TCP客户进程要断开与自己的TCP连接</p><p>此时，从TCP客户进程到TCP服务器进程这个方向的连接就释放了</p><p>这时的TCP连接属于半关闭状态，也就是TCP客户进程已经没有数据要发送了</p><p>但如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105761.png" alt="image-20201022233050922"></p><blockquote><p>TCP客户进程收到TCP确认报文段后就进入终止等待2状态，等待TCP服务器进程发出的TCP连接释放报文段</p><p>若使用TCP服务器进程的应用进程已经没有数据要发送了，应用进程就通知其TCP服务器进程释放连接</p><p>由于TCP连接释放是由TCP客户进程主动发起的，因此TCP服务器进程对TCP连接的释放称为被动关闭连接</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105795.png" alt="image-20201022233941557"></p><blockquote><p>TCP服务器进程发送TCP连接释放报文段并进入最后确认状态</p><p>该报文段首部中</p><ul><li>终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认</li><li>序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送</li><li>确认号ack字段的值为u+1，这是对之前收到的TCP连接释放报文段的重复确认</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105899.png" alt="image-20201022234741310"></p><blockquote><p>TCP客户进程收到TCP连接释放报文段后，必须针对该报文段发送普通的TCP确认报文段，之后进入时间等待状态</p><p>该报文段首部中</p><ul><li>确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段</li><li>序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号</li><li>确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认</li></ul><p>TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态</p></blockquote><p>TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105753.png" alt="image-20201022234942562"></p><blockquote><p>因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态</p><p>另外，TCP客户进程在发送完最后一个TCP确认报文段后，在经过2MSL时长，就可以使本次连接持续时间内所产生的所有报文段都从网络中消失，这样就可以使下一个新的TCP连接中，不会出现旧连接中的报文段</p></blockquote><h4 id="TCP保活计时器的作用"><a href="#TCP保活计时器的作用" class="headerlink" title="TCP保活计时器的作用"></a>TCP保活计时器的作用</h4><p>TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障</p><p>TCP服务器进程以后就不能再收到TCP客户进程发来的数据</p><p>因此，应当有措施使TCP服务器进程不要再白白等待下去</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105118.png" alt="image-20201022235800155"></p><hr><h2 id="TCP报文段的首部格式"><a href="#TCP报文段的首部格式" class="headerlink" title="TCP报文段的首部格式"></a>TCP报文段的首部格式</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105209.png" alt="image-20201023000859363"></p><h3 id="各字段的作用-1"><a href="#各字段的作用-1" class="headerlink" title="各字段的作用"></a>各字段的作用</h3><p>源端口和目的端口</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105005.png" alt="image-20201023005210010"></p><p>序号、确认号和确认标志位</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062105887.png" alt="image-20201023003826059"></p><p>数据偏移、保留、窗口和校验和</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106212.png" alt="image-20201023004227265"></p><p>同步标志位、终止标志位、复位标志位、推送标志位、紧急标志位和紧急指针</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106148.png" alt="image-20201023005001450"></p><p>选项和填充</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106152.png" alt="image-20201023005132426"></p><h2 id="TCP的流量控制-1"><a href="#TCP的流量控制-1" class="headerlink" title="TCP的流量控制"></a>TCP的流量控制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106867.png" alt="image-20201021233918057"></p><h2 id="TCP的拥塞控制-1"><a href="#TCP的拥塞控制-1" class="headerlink" title="TCP的拥塞控制"></a>TCP的拥塞控制</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109288.png" alt="image-20201022152255103"></p><h2 id="TCP可靠传输的实现-1"><a href="#TCP可靠传输的实现-1" class="headerlink" title="TCP可靠传输的实现"></a>TCP可靠传输的实现</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106986.png" alt="image-20201022163045361"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106939.png" alt="image-20201022164057627"></p><h2 id="TCP的运输连接管理-1"><a href="#TCP的运输连接管理-1" class="headerlink" title="TCP的运输连接管理"></a>TCP的运输连接管理</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106225.png" alt="image-20201022204336098"></p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="应用层概述"><a href="#应用层概述" class="headerlink" title="应用层概述"></a>应用层概述</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106569.png" alt="image-20201023195112701"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106908.png" alt="image-20201023200511781"></p><p>我们在浏览器的地址中输入某个网站的域名后，就可以访问该网站的内容，这个就是<strong>万维网WWW应用</strong>，其相关的应用层协议为<strong>超文本传送协议HTTP</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106981.png" alt="image-20201023200819770"></p><p>用户在浏览器地址栏中输入的是“见名知意”的<strong>域名</strong>，而TCP&#x2F;IP的网际层使用<strong>IP地址</strong>来表示目的主机，从域名到IP地址的装转换，由属于<strong>应用层范畴的域名系统DNS</strong>，在后台帮用户完成</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106076.png" alt="image-20201023201028141"></p><p>常见的应用</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106165.png" alt="image-20201023201101024"></p><p>总结</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106303.png" alt="image-20201023201137047"></p><hr><h2 id="客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）和对等方式（P2P方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）和对等方式（P2P方式）</h2><h3 id="概念-12"><a href="#概念-12" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106479.png" alt="image-20201023201308269"></p><h3 id="客户-x2F-服务器方式（C-x2F-S方式）"><a href="#客户-x2F-服务器方式（C-x2F-S方式）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S方式）"></a>客户&#x2F;服务器方式（C&#x2F;S方式）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106472.png" alt="image-20201023201610088"></p><h3 id="对等方式（P2P方式）"><a href="#对等方式（P2P方式）" class="headerlink" title="对等方式（P2P方式）"></a>对等方式（P2P方式）</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106650.png" alt="image-20201023202017683"></p><h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106641.png" alt="image-20201023202049202"></p><hr><h2 id="动态主机配置协议DHCP"><a href="#动态主机配置协议DHCP" class="headerlink" title="动态主机配置协议DHCP"></a>动态主机配置协议DHCP</h2><h3 id="概念-13"><a href="#概念-13" class="headerlink" title="概念"></a>概念</h3><ul><li>互联网广泛使用的<strong>动态主机配置协议 DHCP</strong> (Dynamic Host Configuration Protocol) 提供了<strong>即插即用连网</strong> (plug-and-play networking) 的机制。</li><li>这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。</li></ul><h3 id="DHCP的作用"><a href="#DHCP的作用" class="headerlink" title="DHCP的作用"></a>DHCP的作用</h3><p>在之前，如果要正常访问Web服务器，需要该主机手动配置网络的相关配置信息</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106291.png" alt="image-20201023205719672"></p><blockquote><p>如果主机数很多，就工作量大，容易出错</p></blockquote><p>如果我们给网络中添加一台DHCP服务器</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106375.png" alt="image-20201023210345650"></p><h3 id="DHCP的工作过程"><a href="#DHCP的工作过程" class="headerlink" title="DHCP的工作过程"></a>DHCP的工作过程</h3><p><strong>DHCP 使用客户 - 服务器方式</strong></p><ul><li>需要 IP 地址的主机在启动时就向 DHCP 服务器广播发送发现报文<br>（DHCP DISCOVER），这时该主机就成为 DHCP 客户。</li><li>本地网络上所有主机都能收到此广播报文，但只有 DHCP 服务器才回答此广播报文。</li><li>DHCP 服务器先在其数据库中查找该计算机的配置信息。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做提供报文（DHCP OFFER）。</li></ul><p><strong>DHCP 工作方式</strong></p><ul><li>DHCP 使用客户-服务器方式，采用请求&#x2F;应答方式工作。</li><li>DHCP 基于 UDP 工作（DHCP报文在运输层会被封装成为UDP用户数据报），DHCP 服务器运行在 67 号端口， DHCP客户运行在 68 号端口。</li></ul><p><strong>DHCP交互过程</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110903.png" alt="image-20201023211525686"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP发现报文（DHCP DISCOVER）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li></ul><p><strong>封装该报文的IP数据报的源IP地址为0.0.0.0，这是因为主机目前还未分配到IP地址</strong>，因此使用该地址代替</p><p><strong>目的IP地址为广播地址255.255.255.255，之所以广播发送，是因为主机现在并不知道网络中有哪几个DHCP服务器</strong>。它们的IP地址各是什么</p><p><strong>DHCP服务器收到DHCP发现报文后，根据其中封装的DHCP客户端的MAC地址来查找自己的数据库</strong>，如果查到匹配信息，则使用这些配置信息来构建并发送DHCP提供报文，如果没有则采用默认配置信息来构建报文并发送</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062106009.png" alt="image-20201023213058543"></p><blockquote><p><strong>DHCP服务端将广播发送DHCP提供报文（DHCP OFFER）</strong></p><ul><li>事务ID：DHCP客户端会与之前DHCP发现报文的事务ID做对比，来判断该DHCP提供报文是否是自己的</li><li>配置信息：<ul><li>IP地址：DHCP服务器从自己的IP地址池中挑选待租用给主机的IP地址（使用ARP来确保所选IP地址未被网络中其他主机占用）</li><li>子网掩码</li><li>地址租期</li><li>默认网关</li><li>DNS服务器</li></ul></li></ul><p>源IP地址：发送DHCP提供报文的DHCP服务器的IP</p><p>目的地址：因为目的主机还没分配到IP，所以使用广播地址</p></blockquote><p>在本例中，DHCP客户会收到两个DHCP服务器发来的DHCP提供报文，DHCP客户从中选择一个，一般选择先到的，并向所选择的DHCP服务器发送DHCP请求报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110726.png" alt="image-20201023214542329"></p><blockquote><p><strong>DHCP客户端将广播发送DHCP请求报文（DHCP REQUEST）</strong></p><ul><li>事务ID</li><li>DHCP客户端的MAC地址</li><li>接收的租约中的IP地址</li><li>提供此租约的DHCP服务器端的IP地址</li></ul><p>源地址：0.0.0.0，因为此时DHCP客户才从多个DHCP服务器中挑选一个作为自己的DHCP服务器。它首先要征得该服务器的同意，之后才能正式使用向该DHCP服务器租用的IP地址</p><p>目的地址：广播地址，这样可以一次性向所有DHCP服务器发送DHCP请求报文，来告知它们是否请求它们作为自己的DHCP服务器</p></blockquote><p>在本例中，假设DHCP客户端选择DHCP服务器1作为自己的DHCP服务器，DHCP服务器1接受该请求，于是DHCP服务器1给DHCP客户端发送DHCP确认报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107981.png" alt="image-20201023215341522"></p><blockquote><p>源地址：DHCP服务器1的IP地址</p><p>目的地址：广播地址</p><p><strong>DHCP客户收到该报文后就可以使用租用的IP地址</strong></p><p><strong>在使用前还会进行ARP检测</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107820.png" alt="image-20201023215652859"></p></blockquote><p>剩下流程图示</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107359.png" alt="image-20201023220114952"></p><h3 id="DHCP中继代理"><a href="#DHCP中继代理" class="headerlink" title="DHCP中继代理"></a>DHCP中继代理</h3><p>下图的网络拓扑中的各主机是否可以通过DHCP来自动获取到网络配置？</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107631.png" alt="image-20201023221111923"></p><blockquote><p>使用DHCP中继代理是因为我们不用给每一个网络上都设置一个DHCP服务器，这样会使DHCP服务器的数量太多</p></blockquote><h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107088.png" alt="image-20201023221251022"></p><hr><h2 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>域名相比IP地址更容易记忆</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107866.png" alt="image-20201023234832678"></p><p>因特网是否可以只使用一台DNS服务器？</p><p>不行</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107594.png" alt="image-20201023235123151"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107384.png" alt="image-20201023235231869"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107412.png" alt="image-20201023235457857"></p><blockquote><p>名称相同的域名其等级未必相同</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110026.png" alt="image-20201023235617575"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107303.png" alt="image-20201023235910545"></p><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107162.png" alt="image-20201024000255580"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107018.png" alt="image-20201024000335147"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107997.png" alt="image-20201024000408396"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107763.png" alt="image-20201024002135210"></p><h3 id="总结-19"><a href="#总结-19" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107450.png" alt="image-20201024002224354"></p><hr><h2 id="文件传送协议FTP"><a href="#文件传送协议FTP" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h2><h3 id="概念-14"><a href="#概念-14" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107047.png" alt="image-20201024132745558"></p><h3 id="文件传送协议FTP的应用"><a href="#文件传送协议FTP的应用" class="headerlink" title="文件传送协议FTP的应用"></a>文件传送协议FTP的应用</h3><p>FTP采用C&#x2F;S方式（客户&#x2F;服务器方式）</p><p>FTP客户计算机可将各种类型的文件上传到FTP服务器计算机</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107714.png" alt="image-20201024133155327" style="zoom:50%;" /><p>FTP客户计算机也可以从FTP服务器计算机下载文件</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107071.png" alt="image-20201024133247537" style="zoom:50%;" /><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107982.png" alt="image-20201024133400777"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107875.png" alt="image-20201024133601943"></p><h3 id="FTP基本工作原理"><a href="#FTP基本工作原理" class="headerlink" title="FTP基本工作原理"></a>FTP基本工作原理</h3><p>FTP服务器监听熟知端口（端口号为 21），使客户进程能够连接上。</p><p>FTP客户随机选择一个临时端口号与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送FTP的相关控制命令（这条连接是FTP客户与服务器之间的命令通道）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107109.png" alt="image-20201024134319922"></p><p>下图为建立数据通道的TCP连接</p><p>FTP服务器使用自己的熟知端口号20与其建立TCP连接，这条TCP连接用于FTP客户与服务器之间传送文件</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062110318.png" alt="image-20201024134624114"></p><blockquote><p>上面例子是主动模式：建立数据通道时，FTP服务器主动连接FTP客户</p></blockquote><p>下图实例为被动模式</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107237.png" alt="image-20201024135018620" style="zoom:67%;" /><p>两种模式对比</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062107529.png" alt="image-20201024135050743"></p><blockquote><p>注意两种模式都是</p><p>控制连接在整个会话期间保持打开状态</p><p>数据连接传输完毕后就关闭</p></blockquote><h3 id="总结-20"><a href="#总结-20" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108898.png" alt="image-20201024135848563"></p><hr><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><h3 id="概念-15"><a href="#概念-15" class="headerlink" title="概念"></a>概念</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108116.png" alt="image-20201024151757221"></p><h3 id="邮件发送和接收过程"><a href="#邮件发送和接收过程" class="headerlink" title="邮件发送和接收过程"></a>邮件发送和接收过程</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108781.png" alt="image-20201024152052056"></p><h3 id="简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理"><a href="#简单邮件传送协议SMTP（Simple-Mail-Transfer-Protocol）的基本工作原理" class="headerlink" title="简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理"></a>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）的基本工作原理</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108941.png" alt="image-20201024152628966"></p><h3 id="电子邮件的信息格式"><a href="#电子邮件的信息格式" class="headerlink" title="电子邮件的信息格式"></a>电子邮件的信息格式</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108716.png" alt="image-20201024153425016"></p><h3 id="邮件读取"><a href="#邮件读取" class="headerlink" title="邮件读取"></a>邮件读取</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108381.png" alt="image-20201024153736033"></p><h3 id="基于万维网的电子邮件"><a href="#基于万维网的电子邮件" class="headerlink" title="基于万维网的电子邮件"></a>基于万维网的电子邮件</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108265.png" alt="image-20201024154039565"></p><h3 id="总结-21"><a href="#总结-21" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108299.png" alt="image-20201024154744175"></p><hr><h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><h3 id="概念-16"><a href="#概念-16" class="headerlink" title="概念"></a>概念</h3><p><strong>概述</strong></p><ul><li><strong>万维网</strong> WWW (World Wide Web) 并非某种特殊的计算机网络。</li><li>万维网是一个大规模的、联机式的<strong>信息储藏所</strong>。</li><li>万维网用链接的方法能非常方便地从互联网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。</li><li>这种访问方式称为“<strong>链接</strong>”。</li></ul><p><strong>万维网的工作方式</strong></p><ul><li>万维网以<strong>客户 - 服务器</strong>方式工作。</li><li><strong>浏览器</strong>就是在用户计算机上的万维网<strong>客户程序</strong>。万维网文档所驻留的计算机则运行<strong>服务器程序</strong>，因此这个计算机也称为<strong>万维网服务器</strong>。</li><li>客户程序向服务器程序发出请求，服务器程序向客户程序送回客户所要的<strong>万维网文档</strong>。</li><li>在一个客户程序主窗口上显示出的万维网文档称为<strong>页面</strong> (page)。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108341.png" alt="image-20201024170819303"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108866.png" alt="image-20201024171432743"></p><p><strong>万维网应用举例</strong></p><p>访问网页</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108120.png" alt="image-20201024170923530"></p><p><strong>怎样标志分布在整个互联网上的万维网文档？</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108679.png" alt="image-20201024171058583"></p><p><strong>万维网的文档</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108199.png" alt="image-20201024171724030"></p><h3 id="超文本传输协议HTTP（Hyper-Transfer-Protocol）"><a href="#超文本传输协议HTTP（Hyper-Transfer-Protocol）" class="headerlink" title="超文本传输协议HTTP（Hyper Transfer Protocol）"></a>超文本传输协议HTTP（Hyper Transfer Protocol）</h3><h4 id="概念和传输过程"><a href="#概念和传输过程" class="headerlink" title="概念和传输过程"></a>概念和传输过程</h4><ul><li>在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是<strong>超文本传送协议</strong> HTTP (HyperText Transfer Protocol)。</li><li>HTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108275.png" alt="image-20201024222457800"></p><ul><li>每个万维网网点都有一个服务器进程，它不断地<strong>监听 TCP 的端口 80</strong>，以便发现是否有浏览器向它发出连接建立请求。</li><li>一旦监听到连接建立请求并建立了 TCP 连接之后，浏览器就向万维网服务器发出浏览某个页面的请求，服务器接着就返回所请求的页面作为响应。</li><li>最后，TCP 连接就被释放了。</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108924.png" alt="image-20201024222825888"></p><h4 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h4><p><strong>HTTP请求报文格式</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108707.png" alt="image-20201024224828528"></p><p><strong>HTTP响应报文格式</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108837.png" alt="image-20201024224920638"></p><h4 id="使用Cookie在服务器上记录用户信息"><a href="#使用Cookie在服务器上记录用户信息" class="headerlink" title="使用Cookie在服务器上记录用户信息"></a>使用Cookie在服务器上记录用户信息</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108083.png" alt="image-20201024224945200"></p><h4 id="万维网缓存与代理服务器"><a href="#万维网缓存与代理服务器" class="headerlink" title="万维网缓存与代理服务器"></a>万维网缓存与代理服务器</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108970.png" alt="image-20201024224632514"></p><p>如果该请求有缓存</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108019.png" alt="image-20201024224720124"></p><p>如果该请求没有缓存</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108709.png" alt="image-20201024225013288"></p><blockquote><p>若WEb缓存的命中率比较高</p><p>则会大大减小了该链路上的通信量，因而减少了访问因特网的时延</p></blockquote><p>假设原始服务器的文档被更改，这样代理服务器的文档就不是最新的</p><p>所以原始服务器通常会为每个响应的对象设定一个<strong>修改时间字段</strong>和一个<strong>有效日期字段</strong></p><p>若未过期</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062108683.png" alt="image-20201024225504869"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档一致</strong>，原始服务器则给代理服务器发送不包含实体主体的响应</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109037.png" alt="image-20201024225846863"></p><p>若过期并且代理服务器的文档和原始服务器的<strong>文档不一致</strong>，原始服务器则给代理服务器发送封装有该文档的响应报文</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109122.png" alt="image-20201024230242550"></p><h3 id="总结-22"><a href="#总结-22" class="headerlink" title="总结"></a>总结</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109946.png" alt="image-20201024231143505"></p><h2 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h2><h3 id="域名系统DNS-1"><a href="#域名系统DNS-1" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109103.png" alt="image-20201024000627823"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109876.png" alt="image-20201024002135210"></p><h3 id="文件传送协议FTP-1"><a href="#文件传送协议FTP-1" class="headerlink" title="文件传送协议FTP"></a>文件传送协议FTP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109711.png" alt="image-20201024135242632"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109336.png" alt="image-20201024135740064"></p><h3 id="电子邮件-1"><a href="#电子邮件-1" class="headerlink" title="电子邮件"></a>电子邮件</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109425.png" alt="image-20201024154357384"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109231.png" alt="image-20201024154637025"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109217.png" alt="image-20201024154704101"></p><h3 id="超文本传输协议HTTP"><a href="#超文本传输协议HTTP" class="headerlink" title="超文本传输协议HTTP"></a>超文本传输协议HTTP</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109301.png" alt="image-20201024230522020"></p><hr><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109729.png" alt="image-20201024230846111"></p><h1 id="网络是怎么连接的"><a href="#网络是怎么连接的" class="headerlink" title="网络是怎么连接的"></a>网络是怎么连接的</h1><h2 id="0、大致流程"><a href="#0、大致流程" class="headerlink" title="0、大致流程"></a>0、大致流程</h2><ul><li>首先，用户输入网址</li><li><strong>浏览器</strong>解析网址，生成HTTP消息并转交给Socket库</li><li><strong>Socket库</strong>将收到 的HTTP消息作为数据转交给协议栈</li><li><strong>TCP</strong>按照网络包的长度对数据进行拆分，在每个包前面加上TCP头部并转交给IP——【TCP-HTTP数据块】</li><li><strong>IP</strong>在TCP包前加上IP头部，然后查询MAC地址并加上MAC头部，然后将包转交给网卡驱动——【MAC-IP-TCP-HTTP数据块】</li><li><strong>网卡驱动</strong>收到IP发来的包，将其转交给网卡并发出发送指令</li><li><strong>网卡</strong>检查以太网的可发送状态，将包转换成电信号，通过双绞线发送出去</li><li>信号通过<strong>双绞线</strong>到达集线器</li><li><strong>集线器</strong>将信号广播到所有端口，信号会到达交换机</li><li><strong>交换机</strong>根据收到的包的接收方MAC地址查询自身的地址表，找到输出端口，并将包转发到输出端口——【IP-TCP-HTTP数据块】</li><li><strong>互联网接入路由器</strong>根据收到的包的接收方IP地址查询自身的路由表，找到输出端口，并将包转发到输出端口（互联网接入路由器输出到互联网的包带有PPPoE头部和PPP头部）——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li><strong>ADSL Modem</strong>将收到的包拆分成ATM信元，然后转换成电信号通过电话线发送到电话局的DSLAM</li><li><strong>DSLAM</strong>（局端多路Modem）将收到的电信号还原成ATM信号并发送给BAS</li><li><strong>BAS</strong>将ATM信元还原成网络包，根据接收方IP地址进行转发——【MAC-PPPoE-PPP-IP-TCP-HTTP数据块】</li><li>BAS转发的包加上L2TP头部并通过<strong>隧道</strong>——【L2TP-PPP-IP-TCP-HTTP数据块】</li><li>网络包到达位于隧道出口的隧道路由器，L2TP头部和PPP头部被丢弃，通过互联网流向Web服务器【MAC-IP-TCP-HTTP数据块】</li><li>服务器端的局域网中有防火墙，对进入的包进行检查，判断是否允许通过。Web服务器前面如果有缓存服务器，会拦截通过防火墙的包。如果用户请求的页面已经缓存在服务器上，则代替服务器向用户返回页面数据。如果请求的页面没有被缓存，缓存服务器会将请求转发给Web服务器</li><li>Web服务器收到包后，网卡和网卡驱动会接收这个包并转交给协议栈</li><li>协议栈依次检查IP头部和TCP头部，如果没有问题则取出HTTP消息的数据进行组装</li><li>HTTP消息被恢复成原始状态，然后通过Socket库转交给Web服务器，Web服务器分析HTTP信息的内容，并根据请求内容将读取的数据返回给客户端</li></ul><h2 id="一、浏览器生成消息"><a href="#一、浏览器生成消息" class="headerlink" title="一、浏览器生成消息"></a><strong>一、浏览器生成消息</strong></h2><h3 id="1-生成HTTP-1-请求消息"><a href="#1-生成HTTP-1-请求消息" class="headerlink" title="1.生成HTTP[^1]请求消息"></a>1.生成HTTP[^1]请求消息</h3><p>当使用浏览器输入网址时，浏览器首先会对URL[^2]进行解析，（URL有多种格式<a href="%E4%B8%BB%E8%A6%81%E6%98%AF%E7%94%B1%E4%BA%8E%E5%BC%80%E5%A4%B4%E9%83%A8%E5%88%86%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C%EF%BC%8C%E5%A6%82%EF%BC%9AHTTP%E5%8D%8F%E8%AE%AE%EF%BC%8CFTP%E5%8D%8F%E8%AE%AE%EF%BC%8Cfile%EF%BC%88%E8%AF%BB%E5%8F%96%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%EF%BC%89%EF%BC%8Cmallto%EF%BC%88%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6%EF%BC%89%E7%AD%89%EF%BC%8C%E5%85%B7%E4%BD%93%E7%A4%BA%E4%BE%8B%E5%A6%82%E4%B8%8B%E5%9B%BE%E3%80%82%E5%85%B6%E4%B8%AD%E5%AF%B9%E4%BA%8E%E5%90%8E%E9%9D%A2%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E7%9C%81%E7%95%A5%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E8%AE%BF%E9%97%AE%E4%BA%8B%E5%85%88%E8%AE%BE%E7%BD%AE%E5%A5%BD%E7%9A%84%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B6%EF%BC%8C%E5%8D%B3%E4%B8%BB%E9%A1%B5%E3%80%82">^3</a>）浏览器由此可确定服务器的域名和文件名，接下来便根据这些信息生成HTTP请求消息，</p><p>[^2]: URL:Uniforn Resource Locator,统一资源定位符，即网址。<br>[^1]: HTTP:Hypertext Transfer Protocol,超文本传送协议</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109442.jpg" alt="网络连接大致流程1"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205062109530.jpg" alt="网络连接大致流程2"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java</title>
      <link href="/Notes/2022/04/14/Java/"/>
      <url>/Notes/2022/04/14/Java/</url>
      
        <content type="html"><![CDATA[<h2 id="一些用法"><a href="#一些用法" class="headerlink" title="一些用法"></a>一些用法</h2><h3 id="2-HashMap和Hashtable"><a href="#2-HashMap和Hashtable" class="headerlink" title="2. HashMap和Hashtable"></a>2. HashMap和Hashtable</h3><p><strong>相同点:</strong></p><p>hashmap和Hashtable都实现了map、Cloneable（可克隆）、Serializable（可序列化）这三个接口</p><p><strong>不同点:</strong></p><ol><li><p>底层数据结构不同:jdk1.7底层都是数组+链表,但jdk1.8 HashMap加入了红黑树</p></li><li><p>Hashtable 是不允许键或值为 null 的，HashMap 的键值则都可以为 null。</p></li><li><p>添加key-value的hash值算法不同：HashMap添加元素时，是使用自定义的哈希算法,而HashTable是直接采用key的hashCode()<br>实现方式不同：Hashtable 继承的是 Dictionary类，而 HashMap 继承的是 AbstractMap 类。</p></li><li><p>初始化容量不同：HashMap 的初始容量为：16，Hashtable 初始容量为：11，两者的负载因子默认都是：0.75。</p></li><li><p>扩容机制不同：当已用容量&gt;总容量 * 负载因子时，HashMap 扩容规则为当前容量翻倍，Hashtable 扩容规则为当前容量翻倍 +1。</p></li><li><p>支持的遍历种类不同：HashMap只支持Iterator遍历,而HashTable支持Iterator和Enumeration两种方式遍历</p></li><li><p>迭代器不同：HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。而Hashtable 则不会。</p></li><li><p>部分API不同：HashMap不支持contains(Object value)方法，没有重写toString()方法,而HashTable支持contains(Object value)方法，而且重写了toString()方法</p></li><li><p>同步性不同: Hashtable是同步(synchronized)的，适用于多线程环境,</p><p>而hashmap不是同步的，适用于单线程环境。多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。<br>由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。sdfla</p></li></ol><h3 id="3-Arrays-asList"><a href="#3-Arrays-asList" class="headerlink" title="3.Arrays.asList"></a>3.Arrays.asList</h3><p>List 是一种很有用的数据结构，如果需要将一个数组转换为 List 以便进行更丰富的操作的话，可以这么实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;(Arrays.asList(myArray));</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);</span><br></pre></td></tr></table></figure><p>( new 一个 java.util.ArrayList ，然后再把 asList 方法的返回值作为构造器的参数传入，最后得到的 myList 是动态扩容的了。)</p><p>注意：</p><ul><li>不要将  原生数据类型的数组  作为参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//输出结果为1，而不是3</span></span><br></pre></td></tr></table></figure><p>上述代码，遍历mylist的话，会得到一个带有hashCode 的对象。</p><p>（当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是<strong>数组对象</strong>本身）</p><p>如果需要将一个整型数组转换为 List，那么就将数组的类型声明为 <strong>Integer</strong> 而不是 int。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">myList</span> <span class="operator">=</span> Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());</span><br></pre></td></tr></table></figure><ul><li><p>asList返回一个由指定数组生成的固定大小的List；</p><p>如果不new一个ArrayList，那么得到的list不能修改其大小，且Arrays的内部类ArrayList没有重写add等方法，用add会抛出异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] myArray = &#123; <span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span> &#125;;</span><br><span class="line">List&lt;String&gt; myList = Arrays.asList(myArray);</span><br><span class="line">myList.add(<span class="string">&quot;Guava&quot;</span>);<span class="comment">//异常</span></span><br></pre></td></tr></table></figure><h3 id="4-可变参数"><a href="#4-可变参数" class="headerlink" title="4.可变参数"></a>4.可变参数</h3><p>java允许将同一个类中的<strong>多个同名，同功能但参数个数不同的方法</strong>，封装成一个方法，即通过<strong>可变参数</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int... 表示接受的是可变参数，类型是int， 即可接受多个int；可变参数的实参可以为0到任意多个；</span></span><br><span class="line"><span class="comment">//使用可变参数时，可以当作数组来使用，即nums可以作为数组；</span></span><br><span class="line"><span class="comment">//可变参数可以和普通类型的参数一起放在形参列表，但可变参数必须放在最后；列表里可变参数只能一个</span></span><br><span class="line"><span class="comment">//可变参数的本质就是数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span>... nums)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;接受的参数个数：&quot;</span> + nums.length);</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        res += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-字符"><a href="#5-字符" class="headerlink" title="5.字符"></a>5.字符</h3><h4 id="1-字符分割"><a href="#1-字符分割" class="headerlink" title="1.字符分割"></a>1.字符分割</h4><p>使用了 <strong>split(string)</strong> 方法通过指定分隔符将字符串分割为数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&quot; &quot;</span>;</span><br><span class="line">        String[] temp = str.split(d);</span><br><span class="line">        <span class="keyword">for</span>(String x : temp)&#123;</span><br><span class="line">            System.out.println(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello</span><br><span class="line">World</span><br></pre></td></tr></table></figure><p>使用 <strong>StringTokennizer</strong> 设置不同分隔符来分隔字符串，默认的分隔符是：<strong>空格、制表符（\t）、换行符(\n）、回车符（\r）</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;this is string , split by stringtokenizer&quot;</span>;</span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用空格作为分隔符</span></span><br><span class="line">        <span class="keyword">while</span>(st.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="comment">//用逗号做分隔</span></span><br><span class="line">        <span class="type">StringTokenizer</span> <span class="variable">st2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringTokenizer</span>(str, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(st2.hasMoreElements())&#123;</span><br><span class="line">            System.out.println(st2.nextElement());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">this</span><br><span class="line">is</span><br><span class="line">string</span><br><span class="line">,</span><br><span class="line">split</span><br><span class="line">by</span><br><span class="line">stringtokenizer</span><br><span class="line"></span><br><span class="line">this is string </span><br><span class="line"> split by stringtokenizer</span><br></pre></td></tr></table></figure><h4 id="2-字符大小写"><a href="#2-字符大小写" class="headerlink" title="2.字符大小写"></a><strong>2.字符大小写</strong></h4><p>toUpperCase() 方法将字符串从小写转为大写</p><p>tolowerCase() 方法将字符串从大写转为小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;string runoob&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">strUpper</span> <span class="operator">=</span> str.toUpperCase();</span><br></pre></td></tr></table></figure><h4 id="3-测试两个字符串区域是否相等"><a href="#3-测试两个字符串区域是否相等" class="headerlink" title="3.测试两个字符串区域是否相等"></a><strong>3.测试两个字符串区域是否相等</strong></h4><p> regionMatches() 方法测试两个字符串区域是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Welcome to Microsoft&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;I work with microsoft&quot;</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>);</span><br><span class="line"><span class="comment">//第一个参数 true 表示忽略大小写区别</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> str1.regionMatches(<span class="literal">true</span>, <span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>); </span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str1.regionMatches(<span class="number">11</span>, str2, <span class="number">12</span>, <span class="number">9</span>) 表示将 str1 字符串从第<span class="number">11</span>个字符<span class="string">&quot;M&quot;</span>开始和 str2 字符串的第<span class="number">12</span>个字符<span class="string">&quot;M&quot;</span>开始逐个比较，共比较 <span class="number">9</span> 对字符，由于字符串区分大小写，所以结果为<span class="literal">false</span>。</span><br><span class="line">如果设置第一个参数为 <span class="literal">true</span> ，则表示忽略大小写区别，所以返回 <span class="literal">true</span>。</span><br></pre></td></tr></table></figure><h3 id="6-数组"><a href="#6-数组" class="headerlink" title="6.数组"></a>6.数组</h3><h4 id="获取最大"><a href="#获取最大" class="headerlink" title="获取最大"></a>获取最大</h4><p>通过 Collections 类的 Collections.max() 和 Collections.min() 方法来查找数组中的最大和最小值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer[] numbers = &#123; <span class="number">8</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.min(Arrays.asList(numbers));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> (<span class="type">int</span>) Collections.max(Arrays.asList(numbers));</span><br></pre></td></tr></table></figure><h4 id="数组合并"><a href="#数组合并" class="headerlink" title="数组合并"></a>数组合并</h4><p>使用List类的Arrays.toString方法和list.Addall（list.Addall（array1.aslist(array2））方法将两个数组合并</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String a[] = &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;I&quot;</span> &#125;;</span><br><span class="line">String b[] = &#123; <span class="string">&quot;O&quot;</span>, <span class="string">&quot;U&quot;</span> &#125;;</span><br><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>(Arrays.asList(a));</span><br><span class="line">list.addAll(Arrays.asList(b));</span><br><span class="line">Object[] c = list.toArray();</span><br><span class="line">System.out.println(Arrays.toString(c));</span><br></pre></td></tr></table></figure><h4 id="数组填充"><a href="#数组填充" class="headerlink" title="数组填充"></a>数组填充</h4><p>通过 Java Util 类的 <strong>Arrays.fill(arrayname,value)</strong> 方法和<strong>Arrays.fill(arrayname ,starting index ,ending index ,value)</strong> 方法向数组中填充元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> array[] = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">6</span>];</span><br><span class="line">Arrays.fill(array, <span class="number">100</span>);<span class="comment">//全部填充 </span></span><br><span class="line">Arrays.fill(array, <span class="number">3</span>, <span class="number">6</span>, <span class="number">50</span>);<span class="comment">//填充第3 - 第6 d</span></span><br></pre></td></tr></table></figure><h4 id="数组扩容"><a href="#数组扩容" class="headerlink" title="数组扩容"></a>数组扩容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span> &#125;;</span><br><span class="line">String[] extended = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line">extended[<span class="number">3</span>] = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">extended[<span class="number">4</span>] = <span class="string">&quot;E&quot;</span>;</span><br><span class="line"><span class="comment">//从names索引为0处 复制names.length长度的元素，到extend索引为0处</span></span><br><span class="line">System.arraycopy(names, <span class="number">0</span>, extended, <span class="number">0</span>, names.length);</span><br><span class="line"><span class="keyword">for</span> (String str : extended)&#123;</span><br><span class="line">    System.out.println(str);</span><br></pre></td></tr></table></figure><h4 id="数组差集，交集"><a href="#数组差集，交集" class="headerlink" title="数组差集，交集"></a>数组差集，交集</h4><p> 用<strong>removeAll</strong> () 方法来计算两个数组的差集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.removeAll(objArray2);<span class="comment">//objArray中删去元素一样的，留下不一样的</span></span><br></pre></td></tr></table></figure><p>用 <strong>retainAll</strong> () 方法来计算两个数组的交集：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">objArray2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">objArray.retainAll(objArray2);<span class="comment">//objArray中删去元素不一样的，留下一样的</span></span><br></pre></td></tr></table></figure><h3 id="7-时间处理"><a href="#7-时间处理" class="headerlink" title="7.时间处理"></a>7.时间处理</h3><h4 id="当前时间及格式化"><a href="#当前时间及格式化" class="headerlink" title="当前时间及格式化"></a>当前时间及格式化</h4><p>用simpleDateFormat类的format(date)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个Date对象，获取当前时间</span></span><br><span class="line"><span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;今天是&quot;</span> + <span class="string">&quot;yyyy 年 MM 月 dd日 E HH 点 mm分 ss 秒&quot;</span>)</span><br><span class="line">System.out.pritntln(f.format(now));<span class="comment">//将当前时间格式化为指定的格式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">今天是 <span class="number">2019</span> 年 <span class="number">10</span> 月 <span class="number">15</span> 日 星期一 09 点 <span class="number">26</span> 分 <span class="number">23</span> 秒</span><br></pre></td></tr></table></figure><p>SimpDateFormat自定义格式中常用字母及含义</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTc0Mzc5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h4 id="获取年份月份等"><a href="#获取年份月份等" class="headerlink" title="获取年份月份等"></a>获取年份月份等</h4><p>用Calendar类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Calendar</span> <span class="variable">cal</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line"><span class="comment">//cal.getTime 可获取当前时间</span></span><br><span class="line"><span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> cal.get(Calendar.DATE);<span class="comment">//日</span></span><br><span class="line"><span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> cal.get(Calendar.MONTH) + <span class="number">1</span>;<span class="comment">//月</span></span><br><span class="line"><span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> cal.get(Calendar.YEAR);<span class="comment">//年</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dow</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_WEEK);<span class="comment">//一周中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">dom</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_MONTH);<span class="comment">//一个月中的第几天</span></span><br><span class="line"><span class="type">int</span> <span class="variable">doy</span> <span class="operator">=</span> cal.get(Calendar.DAY_OF_YEAR);<span class="comment">//一年中的第几天</span></span><br></pre></td></tr></table></figure><h3 id="8-方法"><a href="#8-方法" class="headerlink" title="8.方法"></a>8.方法</h3><h4 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h4><p>测试它左边的对象是否是它右边的类的实例，返回 boolean 的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Vector)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.Vector 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (o <span class="keyword">instanceof</span> ArrayList)</span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 java.util.ArrayList 类的实例&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      System.out.println(<span class="string">&quot;对象是 &quot;</span> + o.getClass() + <span class="string">&quot; 类的实例&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象是 java.util.ArrayList 类的实例</span><br></pre></td></tr></table></figure><h4 id="标签（Label）"><a href="#标签（Label）" class="headerlink" title="标签（Label）"></a>标签（Label）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OUTER:  <span class="comment">//定标签义，可以是任意标识符（一般放在迭代语句之前）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Even number: &quot;</span> + i);</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">continue</span> OUTER;<span class="comment">//在continue或break后使用标签，直接跳到标签处</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Varargs可变参数"><a href="#Varargs可变参数" class="headerlink" title="Varargs可变参数"></a>Varargs可变参数</h4><p>在一个形参的”类型”与”参数名”之间加上三个连续的”.”，就可以让它和不确定个实参相匹配。</p><p>本质上和字符串一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumvarargs</span><span class="params">(<span class="type">int</span>... intArrays)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum, i;</span><br><span class="line">    sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; intArrays.length; i++) &#123;</span><br><span class="line">        sum += intArrays[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>(sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>  <span class="title function_">sumstring</span><span class="params">(<span class="type">int</span>[] intArrays)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java练习"><a href="#Java练习" class="headerlink" title="Java练习"></a>Java练习</h2><h3 id="网上练习"><a href="#网上练习" class="headerlink" title="网上练习"></a>网上练习</h3><ol><li><p>JDK：java开发核心组件；JRE：java运行环境；JVM：java虚拟机</p></li><li><p>JDK，JRE，JVM的关系：</p><p>JDK &#x3D; JRE + Java的开发工具（javac.exe，java.exe，javadoc.exe)</p><p>JRE &#x3D; JVM + Java核心类库 </p></li><li><p>javac（java语言编译器）用于编译java源文件。</p></li><li><p>JDK工具中javadoc用于生成java文档，格式为HTML。</p></li><li><p>JVM运行于操作系统之上，依赖于操作系统；能够直接运行<strong>java字节码</strong>文件。</p></li><li><p>Java HotSpot是一种热编译技术，在运行Java代码时会被使用，只对程序的部分字节码进行优化。</p></li><li><p>环境变量PATH中包含多个路径时，路径之间用；（分号）分开。</p></li><li><p>CLASSPATH中的“ .  ” 表示当前目录。</p></li><li><p>JVM执行一个Java类时，大致流程为：</p><p>装载类—&gt;校验类—&gt;执行类中的代码</p></li><li><p>如果类的成员的访问权限设置为默认，则该成员被同一包中的类访问；</p></li><li><p>类具有封装性，但可以通过类的公共接口访问类中的数据；</p></li><li><p>super指的是当前对象的父类对象的内存地址；</p></li><li><p>尝试对null对象进行操作时，会产生NullPointerException类型的异常；</p></li><li><p>覆盖（重写）只能发生在父类与子类之间；</p><p>重载可以发生在同一个类中；</p></li><li><p>this和super不能用在main()方法中；</p></li><li><p>每一个Unicode码占用16个比特位；</p></li><li><p>封装：对外隐藏内部实现细节，增强程序的安全性；</p></li><li><p>自定义异常必须继承Exception，可以继承自Error；</p></li><li><p>使用JDBC（Java Data Base Connectivity）连接数据库的顺序：</p><p>导入驱动包 ——加载驱动——建立数据库的连接——发送并处理SQL语句——关闭连接</p></li></ol><p>19.java分了5片内存：寄存器，本地方法区，方法区，栈，堆。</p><p>​栈：存储的都是局部变量 ( 函数中定义的变量，函数上的参数，语句中的变量 )；栈的存取速度要比堆快，次于CPU寄存器</p><p>   只要数据运算完成所在的区域结束，该数据就会被释放。</p><p>​堆：用于存储数组和对象，也就是实体。</p><p> 1：每一个实体都有内存首地址值。</p><p> 2：堆内存中的变量都有默认初始化值。因为数据类型不同，值也不一样。</p><p> 3：垃圾回收机制。</p><h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><p>一、java入门</p><ol><li><p>java诞生：1995年5月；java特点：简单性，面向对象，安全性，跨平台性，支持多线程，分部性；</p></li><li><p>path环境变量的作用：使用jdk命令 &#x2F; 在任何目录下都可以使用javac和java命令；</p></li><li><p>java程序运行需要经过编译和运行两个步骤：<strong>编译器</strong>执行 <strong>.java文件</strong>，编译生成 .class的字节码文件，而<strong>Java虚拟机</strong>运行 <strong>.class文件</strong>；</p><p>java命令用于运行编译后的 .class文件，不需要文件后缀名；</p></li><li><p>JDK中可执行程序都放在bin目录下：Java编译器javac.exe 和 Java运行工具 java.exe；</p></li><li><p>一个java程序不一定要有main方法，需要独立运行的程序才要有main方法。</p></li></ol><p>二、java编程基础</p><ol><li>在Java中，浮点型数会被默认为double类型，所以给float赋值浮点型数据时，应该加F&#x2F;f，如 float &#x3D; 1F；</li><li>文档注释 格式： &#x2F;**      *&#x2F;</li></ol><p>三、面向对象</p><ol><li>public，static不能修饰局部变量；</li><li>构造方法不能被继承；</li><li>面向对象的三大特征：封装，继承，多态；</li><li>this关键字的作用：（简答题）<ul><li>this调用本类中的属性，即成员变量；</li><li>this调用本类的其他方法；</li><li>this调用本类的其他构造方法，调用时要放在构造方法的首行；</li></ul></li><li>成员变量和局部变量的区别：<ul><li>定义位置的区别：成员变量定义与方法之外，类之内；局部变量定义在方法之内；</li><li>生命周期：成员变量随着对象的创建而产生，随着对象的消失而消失；局部变量随着方法内的创建语句而产生，在代码运行至自己的作用域外即消失；</li><li>存储位置的区别：成员变量存储在堆中，局部变量存储在栈中；</li><li>初始值不同：成员变量有默认的初始值；局部变量没有，需要初始化才能使用；</li></ul></li><li>构造方法和普通成员方法的不同：<ul><li>构造方法与类名相同；</li><li>构造方法前没有返回类型的声明；</li><li>构造方法因为没有返回类型，所以不能返回任何值，但可以使用return来返回；</li></ul></li><li>面向对象的三特征：<ul><li>封装：将对象的属性和行为封装起来，不需要让外界知道具体的实现细节；</li><li>继承：描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类进行功能拓展；</li><li>多态：允许程序中出现重名现象，使同种类的多个对象，在接收到同一个消息时能产生不同反应和效果；（前提是有一个父类，多个子类）</li></ul></li><li>局部内部类只可以被final修饰，且只能访问被final修饰的局部变量；</li><li>super和this不能同时存在与同一个构造方法中；</li></ol><p>五、集合</p><ol><li>如果使用通配符“？”接收对象，则此对象只能接收，不能修改。</li></ol><p>六、IO</p><h2 id="IDEA使用"><a href="#IDEA使用" class="headerlink" title="IDEA使用"></a>IDEA使用</h2><h3 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h3><p>src（source源文件）—package（包）—-class（类）</p><h3 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h3><p>IDEA 中代码模板位置：setting - Editor - Live Templates &#x2F; postfix Completion</p><p>常用模板：</p><ol><li><p>psvm ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>sout</p></li></ol><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><p>删除当前行：ctrl + y</p><p>复制当前行：ctrl + d</p><p>补全代码：at + &#x2F;</p><p>添加取消注释：ctrl + &#x2F;</p><p>生成方法：alt + insert</p><p>生成环绕方式：ctrl + alt + t （即 if … else ，do…while，try…catch 之类的）</p><p>查看类的的层级关系：ctrl + H</p><p>定位方法：ctrl + B</p><p>自动分配变量名：alt + 回车   &#x2F;   ctrl + alt + v  &#x2F; 在后面加 .var</p><p>显示所有快捷键：ctrl + j</p><p>使用单元测试工具 JUnit 来运行调试 单个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在方法上加上@Test，按Alt+Enter，点”将JUnit5加入到类路径中&quot;，之后方法右边会右绿色小箭头可以使用，之后在这个类中要使用JUnit5，只要加上@Test即可</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">m1</span><span class="params">()</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>分类</strong></th><th align="left"><strong>功能点</strong></th><th align="left"><strong>Eclipse快捷键</strong></th><th align="left"><strong>IDEA快捷键</strong></th></tr></thead><tbody><tr><td><strong>搜索</strong></td><td align="left">搜索文本</td><td align="left">Ctrl + F</td><td align="left">Ctrl + FCtrl + R 查找替换                                        Alt + P&#x2F;A 逐个&#x2F;全部替换                                       Alt + F3 查找当前选中词</td></tr><tr><td></td><td align="left">继续搜索</td><td align="left">Ctrl + K 向前        Ctrl + Shift + K 向后</td><td align="left">F3                                                                 Shift + F3</td></tr><tr><td></td><td align="left">搜索方法</td><td align="left">Ctrl + O</td><td align="left">Ctrl + F12</td></tr><tr><td></td><td align="left">搜索类</td><td align="left">Ctrl + Shift + T</td><td align="left">Ctrl + N</td></tr><tr><td></td><td align="left">搜索文件</td><td align="left">Ctrl + Shift + T</td><td align="left">Ctrl + Shift + N                                                         这两个都支持简单的正则表达式，还支持直接按大写字母的缩略，                                   例如：查找JsonTranscoder，只需要输入JT</td></tr><tr><td></td><td align="left">搜索所有引用处</td><td align="left">Ctrl + Alt + H</td><td align="left">Alt + F7</td></tr><tr><td></td><td align="left">搜索所有文本出现的位置</td><td align="left">Ctrl + H</td><td align="left">Ctrl + Shift + F</td></tr><tr><td><strong>编辑</strong></td><td align="left">自动代码补全</td><td align="left">Alt + &#x2F;</td><td align="left">Ctrl + J</td></tr><tr><td></td><td align="left">自动代码生成</td><td align="left"></td><td align="left">Alt + Insert</td></tr><tr><td></td><td align="left">快速修复错误</td><td align="left">Ctrl + 1</td><td align="left">Alt + Enter</td></tr><tr><td></td><td align="left">删除当前行</td><td align="left">Ctrl + D</td><td align="left">Ctrl + X</td></tr><tr><td></td><td align="left">复制到下一行</td><td align="left"></td><td align="left">Ctrl + D</td></tr><tr><td></td><td align="left">注释&#x2F;取消注释</td><td align="left">Ctrl + &#x2F;</td><td align="left">Ctrl + &#x2F;</td></tr><tr><td></td><td align="left">选中当前字</td><td align="left"></td><td align="left">Ctrl + W</td></tr><tr><td></td><td align="left">补全当前行</td><td align="left"></td><td align="left">Ctrl + Shift + Enter神器，补全当前行，最常用的场景时补全当前行后的；号，并将光标定位到下一行</td></tr><tr><td></td><td align="left">调出最近复制的N份内容</td><td align="left"></td><td align="left">Ctrl + Shift + V</td></tr><tr><td></td><td align="left">查看最近编辑的文件</td><td align="left"></td><td align="left">Ctrl + E</td></tr><tr><td></td><td align="left">对比最近修改</td><td align="left"></td><td align="left">Alt + Shift + C</td></tr><tr><td></td><td align="left">格式化代码</td><td align="left">Ctrl + Shift + F</td><td align="left">Ctrl + Alt + L</td></tr><tr><td></td><td align="left">整理import</td><td align="left">Ctrl + Shift + O</td><td align="left">Ctrl + Alt + O</td></tr><tr><td><strong>跳转</strong></td><td align="left">显示方法层次</td><td align="left"></td><td align="left">Ctrl + Shift + H</td></tr><tr><td></td><td align="left">显示类、方法说明</td><td align="left">F2</td><td align="left">Ctrl + Q</td></tr><tr><td></td><td align="left">跳到方法定义处</td><td align="left"></td><td align="left">Ctrl + B</td></tr><tr><td></td><td align="left">跳到方法实现处</td><td align="left"></td><td align="left">Ctrl + Alt + B</td></tr><tr><td></td><td align="left">跳到上&#x2F;下一方法</td><td align="left"></td><td align="left">Alt + Up&#x2F;Down</td></tr><tr><td></td><td align="left">上&#x2F;下一查看处</td><td align="left">Alt + &lt;-Alt + -&gt;</td><td align="left">Ctrl + Alt + Up&#x2F;Down</td></tr><tr><td></td><td align="left">跳到指定行</td><td align="left">Ctrl + L</td><td align="left">Ctrl + G</td></tr><tr><td><strong>重构</strong></td><td align="left">改名</td><td align="left">Alt + Shift + R</td><td align="left">Shift + F6</td></tr><tr><td></td><td align="left">其他常用</td><td align="left"></td><td align="left">Ctrl + F6 修改方法签名                                          Ctrl + Shift + F6 修改参数的类型                       Ctrl + Shift + V引入局部变量                              Ctrl + Shift + P 引入参数                              Ctrl + Shift + F 引入类变量                                     Ctrl + Shift + M 引入方法                         Ctrl + Shift + C 引入常量</td></tr><tr><td><strong>运行</strong></td><td align="left">启动调试</td><td align="left"></td><td align="left">Alt + Shift + F9</td></tr><tr><td></td><td align="left">启动运行</td><td align="left"></td><td align="left">Alt + Shift + F10</td></tr><tr><td></td><td align="left">单步进入</td><td align="left">F5</td><td align="left">F7</td></tr><tr><td></td><td align="left">单步跳过</td><td align="left">F6</td><td align="left">F8</td></tr><tr><td></td><td align="left">跳过</td><td align="left">F8</td><td align="left">F9</td></tr><tr><td></td><td align="left">执行选中语句</td><td align="left"></td><td align="left">Alt + F8</td></tr><tr><td><strong>窗口</strong></td><td align="left">调出界面</td><td align="left"></td><td align="left">Ctrl + Alt + S调出Settings界面                                 Ctrl + Alt + Shift + S调出项目Setting界面</td></tr><tr><td></td><td align="left">关闭界面</td><td align="left"></td><td align="left">Ctrl + F4 或 ESC</td></tr><tr><td></td><td align="left">打开窗口</td><td align="left"></td><td align="left">Alt + 窗口编号(例如项目窗口编号是1)</td></tr><tr><td></td><td align="left">最大化窗口</td><td align="left">Ctrl + M</td><td align="left">Ctrl + Shift + F12</td></tr><tr><td></td><td align="left">隐藏窗口</td><td align="left"></td><td align="left">Shift + ESC</td></tr><tr><td></td><td align="left">关闭当前文件</td><td align="left"></td><td align="left">Ctrl + F4</td></tr><tr><td></td><td align="left">垂直分屏</td><td align="left"></td><td align="left">Ctrl + | (自定义的)</td></tr><tr><td></td><td align="left">调整窗口位置</td><td align="left"></td><td align="left">Ctrl + M 将当前光标处显示到屏幕中央</td></tr><tr><td></td><td align="left">切换窗口</td><td align="left"></td><td align="left">Ctrl + Tab</td></tr></tbody></table><h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/662E827A-FA32-4464-B0BD-40087F429E98.jpg" alt="img"></p><p>编写 Java 程序时，应注意以下几点：</p><ul><li><strong>大小写敏感</strong>：Java 是大小写敏感的，这就意味着标识符 Hello 与 hello 是不同的。</li><li><strong>类名</strong>：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 <strong>MyFirstJavaClass</strong> 。</li><li><strong>方法名</strong>：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li><li><strong>源文件名</strong>：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记 Java 是大小写敏感的），文件名的后缀为 <strong>.java</strong>。（如果文件名和类名不相同则会导致编译错误）。</li><li><strong>主方法入口</strong>：所有的 Java 程序由 <strong>public static void main(String[] args)</strong> 方法开始执行。</li></ul><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>Java 所有的组成部分都需要名字。类名、变量名以及方法名都被称为标识符。</p><p>关于 Java 标识符，有以下几点需要注意：</p><ul><li>所有的标识符都应该以字母（A-Z 或者 a-z）,美元符（$）、或者下划线（_）开始</li><li>首字符之后可以是字母（A-Z 或者 a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li><li>关键字不能用作标识符</li><li>标识符是大小写敏感的</li><li>合法标识符举例：age、$salary、_value、__1_value</li><li>非法标识符举例：123abc、-salary</li></ul><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>Java可以使用修饰符来修饰类中 方法和属性。主要有两类修饰符：</p><ul><li>访问控制修饰符 : default, public , protected, private</li><li>非访问控制修饰符 : final, abstract, static, synchronized</li></ul><h4 id="访问控制修饰符"><a href="#访问控制修饰符" class="headerlink" title="访问控制修饰符"></a>访问控制修饰符</h4><ul><li><p><strong>public</strong> : <strong>对所有类可见（对外公开）</strong>。使用对象：类、接口、变量、方法</p></li><li><p><strong>protected</strong> : 对<strong>所有子类 和 同一包内的类 可见</strong>。使用对象：变量、方法。 注意：不能修饰类（外部类）</p></li><li><p><strong>default</strong> (即默认，什么也不写）: 在<strong>同一包内可见</strong>。使用对象：类、接口、变量、方法。</p></li><li><p><strong>private</strong> : 仅在<strong>类本身内可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p></li></ul><p>可以通过以下表来说明访问权限：</p><table><thead><tr><th align="left">修饰符</th><th align="left">当前类</th><th align="left">同一包内</th><th align="left">子孙类(不同包)</th><th align="left">其他包</th></tr></thead><tbody><tr><td align="left"><code>public</code></td><td align="left">Y</td><td align="left">Y</td><td align="left">Y</td><td align="left"><strong>Y</strong></td></tr><tr><td align="left"><code>protected</code></td><td align="left">Y</td><td align="left">Y</td><td align="left"><strong>Y</strong></td><td align="left">N</td></tr><tr><td align="left"><code>default</code></td><td align="left">Y</td><td align="left"><strong>Y</strong></td><td align="left">N</td><td align="left">N</td></tr><tr><td align="left"><code>private</code></td><td align="left"><strong>Y</strong></td><td align="left">N</td><td align="left">N</td><td align="left">N</td></tr></tbody></table><h4 id="非访问控制修饰符"><a href="#非访问控制修饰符" class="headerlink" title="非访问控制修饰符"></a>非访问控制修饰符</h4><h5 id="static"><a href="#static" class="headerlink" title="static"></a><strong>static</strong></h5><p><strong>类变量，也叫静态变量，是该类的所有对象共享的变量，</strong>任何一个该类的对象去访问&#x2F;修改它，取到&#x2F;修改的都是相同的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据类型 变量名；</span><br></pre></td></tr></table></figure><p>jdk8以前，静态变量放在静态域（方法区），jdk8以后放在<strong>堆中</strong>，当这个类加载的时候会在堆生成这个类的class对象，静态变量就放在class实例的尾部。</p><p><strong>访问方式</strong>：类名.类变量名 或者 对象名.类变量名</p><p>（类变量在类加载时就初始化了，而不管new几次对象，类只会加载一次，类变量的生命周期与类相同）</p><hr><p><strong>类方法</strong>，也叫静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问修饰符 <span class="keyword">static</span> 数据返回类型 方法名()&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>访问方式</strong>：类名.类方法名 或者 对象名.类方法名</p><p>当方法中不涉及任何和对象相关的成员（包括this，super），则可以设计成静态方法，提高开发效率；如：工具类中的方法utils：Math类、Collections集合</p><hr><h5 id="final"><a href="#final" class="headerlink" title="final"></a>final</h5><ol><li><p>这个关键字是一个修饰符，可以修饰类，方法，变量。</p></li><li><p>被final修饰的类是一个<strong>最终类，不可以被继承</strong>。</p></li><li><p>被final修饰的方法是一个<strong>最终方法，不可以被重写</strong>。</p></li><li><p>被final修饰的变量是一个<strong>常量，只能赋值一次</strong>。</p></li></ol><p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 <strong>_</strong> 连接。</p><p>注意点：</p><ul><li>final修饰的属性在定义时，必须赋初值，且不能再修改，可以在如下位置<strong>赋值</strong>：<ul><li><strong>定义时；</strong></li><li><strong>在构造器中</strong></li><li><strong>在代码块中</strong></li></ul></li><li>如果final修饰的<strong>属性是静态</strong>的，则只能在定义时和在静态代码块中赋值，<strong>不能在构造器中赋值</strong>；</li><li>final类不能继承，但可以实例化对象；</li><li>如果类不是final类，但含有final方法，则该方法虽不能重写，但能被继承</li><li>final类中，没有必要再将用final修饰方法；</li><li><strong>final不能修饰构造器；</strong></li><li><strong>final和static搭配使用，不会导致类加载；</strong></li><li>包装类（Integer，Double，Float，Boolean等都是final），String也是final类；</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p>这些保留字不能用于常量、变量、和任何标识符的名称。</p><table><thead><tr><th align="left">类别</th><th align="left">关键字</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">访问控制</td><td align="left">private</td><td align="left">私有的</td></tr><tr><td align="left"></td><td align="left">protected</td><td align="left">受保护的</td></tr><tr><td align="left"></td><td align="left">public</td><td align="left">公共的</td></tr><tr><td align="left"></td><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left">类、方法和变量修饰符</td><td align="left">abstract</td><td align="left">声明抽象</td></tr><tr><td align="left"></td><td align="left">class</td><td align="left">类</td></tr><tr><td align="left"></td><td align="left">extends</td><td align="left">扩充,继承</td></tr><tr><td align="left"></td><td align="left">final</td><td align="left">最终值,不可改变的</td></tr><tr><td align="left"></td><td align="left">implements</td><td align="left">实现（接口）</td></tr><tr><td align="left"></td><td align="left">interface</td><td align="left">接口</td></tr><tr><td align="left"></td><td align="left">native</td><td align="left">本地，原生方法（非 Java 实现）</td></tr><tr><td align="left"></td><td align="left">new</td><td align="left">新,创建</td></tr><tr><td align="left"></td><td align="left">static</td><td align="left">静态</td></tr><tr><td align="left"></td><td align="left">strictfp</td><td align="left">严格,精准</td></tr><tr><td align="left"></td><td align="left">synchronized</td><td align="left">线程,同步</td></tr><tr><td align="left"></td><td align="left">transient</td><td align="left">短暂</td></tr><tr><td align="left"></td><td align="left">volatile</td><td align="left">易失</td></tr><tr><td align="left">程序控制语句</td><td align="left">break</td><td align="left">跳出循环</td></tr><tr><td align="left"></td><td align="left">case</td><td align="left">定义一个值以供 switch 选择</td></tr><tr><td align="left"></td><td align="left">continue</td><td align="left">继续</td></tr><tr><td align="left"></td><td align="left">default</td><td align="left">默认</td></tr><tr><td align="left"></td><td align="left">do</td><td align="left">运行</td></tr><tr><td align="left"></td><td align="left">else</td><td align="left">否则</td></tr><tr><td align="left"></td><td align="left">for</td><td align="left">循环</td></tr><tr><td align="left"></td><td align="left">if</td><td align="left">如果</td></tr><tr><td align="left"></td><td align="left">instanceof</td><td align="left">实例</td></tr><tr><td align="left"></td><td align="left">return</td><td align="left">返回</td></tr><tr><td align="left"></td><td align="left">switch</td><td align="left">根据值选择执行</td></tr><tr><td align="left"></td><td align="left">while</td><td align="left">循环</td></tr><tr><td align="left">错误处理</td><td align="left">assert</td><td align="left">断言表达式是否为真</td></tr><tr><td align="left"></td><td align="left">catch</td><td align="left">捕捉异常</td></tr><tr><td align="left"></td><td align="left">finally</td><td align="left">有没有异常都执行</td></tr><tr><td align="left"></td><td align="left">throw</td><td align="left">抛出一个异常对象</td></tr><tr><td align="left"></td><td align="left">throws</td><td align="left">声明一个异常可能被抛出</td></tr><tr><td align="left"></td><td align="left">try</td><td align="left">捕获异常</td></tr><tr><td align="left">包相关</td><td align="left">import</td><td align="left">引入</td></tr><tr><td align="left"></td><td align="left">package</td><td align="left">包</td></tr><tr><td align="left">基本类型</td><td align="left">boolean</td><td align="left">布尔型</td></tr><tr><td align="left"></td><td align="left">byte</td><td align="left">字节型</td></tr><tr><td align="left"></td><td align="left">char</td><td align="left">字符型</td></tr><tr><td align="left"></td><td align="left">double</td><td align="left">双精度浮点</td></tr><tr><td align="left"></td><td align="left">float</td><td align="left">单精度浮点</td></tr><tr><td align="left"></td><td align="left">int</td><td align="left">整型</td></tr><tr><td align="left"></td><td align="left">long</td><td align="left">长整型</td></tr><tr><td align="left"></td><td align="left">short</td><td align="left">短整型</td></tr><tr><td align="left">变量引用</td><td align="left">super</td><td align="left">父类,超类</td></tr><tr><td align="left"></td><td align="left">this</td><td align="left">本类</td></tr><tr><td align="left"></td><td align="left">void</td><td align="left">无返回值</td></tr><tr><td align="left">保留关键字</td><td align="left">goto</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">const</td><td align="left">是关键字，但不能使用</td></tr><tr><td align="left"></td><td align="left">null</td><td align="left">空</td></tr></tbody></table><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><p><strong>作用：</strong></p><ol><li>区分相同名字的类</li><li>当类很多时，可以很好的管理类（Java API文档）</li><li>控制访问范围</li></ol><p><strong>包的基本语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> 包名</span><br></pre></td></tr></table></figure><p>包本质上，就是创建不同的文件夹&#x2F;目录来保存类文件</p><p><strong>包的命名规则：</strong></p><p>只能包含数字、字母、下划线、小圆点，不能数字开头，不能用关键字或保留字</p><p><strong>命名规范：</strong> 小写字母 + 小圆点 </p><p>一般是    <strong>com.公司名.项目名.业务模块名</strong></p><p><strong>常用的包：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java.lang.*<span class="comment">//lang包是基本包，默认导入</span></span><br><span class="line">java.util.*<span class="comment">//util包是系统提供的工具包，工具类</span></span><br><span class="line">java.net.*<span class="comment">//网络包，网络开发</span></span><br><span class="line">java.awt.*<span class="comment">//java界面开发，GUI</span></span><br></pre></td></tr></table></figure><p><strong>引入包：</strong> <strong>使用 import 关键字</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> javautil.Scanner;</span><br></pre></td></tr></table></figure><p><strong>注意事项：</strong></p><ul><li>package的作用是声明当前类所在的包，需要放在类的最上面，一个类中最多只能声明一句package；</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解@"></a>注解@</h3><p>注解（Annotation），也叫元数据（Metadata），用于修饰包，类，方法，属性，构造器，局部变量等数据信息；</p><p>和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息；</p><p>在JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等；而在JavaEE中，注解有更大的作用，如：配置应用程序的任何切面，代替javaEE旧版中所遗留的繁冗代码和XML配置等；</p><p><strong>使用：</strong></p><p>三个基本的Annotaton：</p><ol><li><p><strong>@Override：限定某个方法，是重写父方法的，该注解只能用于方法；</strong></p><ul><li><p>@Override 表示指定重写父类的方法（从编译层面验证），如果父类没有fly方法，则会报错；</p></li><li><p>@Override 只能用来修饰方法</p></li><li><p>查看@Override注解源码@Target(ElementType. METHOD)，说明只能修饰方法；</p></li><li><p>@Target是修饰注解的注解，称为元注解</p></li></ul></li><li><p><strong>@Deprecated：用于表示某个程序元素（类&#x2F;方法等）已过时；</strong></p><ul><li>@Target(vlaue &#x3D; {CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})</li><li>@Deprecated的作用：新旧版本的兼容和过度</li></ul></li><li><p><strong>@SuppressWarnings：抑制编译器警告；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&#123;&quot;all&quot;&#125;)</span>;</span><br></pre></td></tr></table></figure><blockquote><p>可以指定的警告类型有 (可以查看黄色警告光标，看是什么类型的警告)</p><p>all，抑制所有警告 </p><p>boxing，抑制与封装&#x2F;拆装作业相关的警告 </p><p>cast，抑制与强制转型作业相关的警告 </p><p> dep-ann，抑制与淘汰注释相关的警告</p><p>deprecation，抑制与淘汰的相关警告  </p><p>fallthrough，抑制与 switch 陈述式中遗漏 break 相关的警告  </p><p>finally，抑制与未传回 finally 区块相关的警告 </p><p> hiding，抑制与隐藏变数的区域变数相关的警告 </p><p> incomplete-switch，抑制与 switch 陈述式(enum case)中遗漏项目相关的警告 </p><p> javadoc，抑制与 javadoc 相关的警告 </p><p> nls，抑制与非 nls 字串文字相关的警告 </p><p> null，抑制与空值分析相关的警告 </p><p> rawtypes，抑制与使用 raw 类型相关的警告 </p><p>resource，抑制与使用 Closeable 类型的资源相关的警告 </p><p>restriction，抑制与使用不建议或禁止参照相关的警告</p><p> serial，抑制与可序列化的类别遗漏 serialVersionUID 栏位相关的警告 </p><p>static-access，抑制与静态存取不正确相关的警告 </p><p>static-method，抑制与可能宣告为 static 的方法相关的警告 </p><p> super，抑制与置换方法相关但不含 super 呼叫的警告 </p><p> synthetic-access，抑制与内部类别的存取未最佳化相关的警告 </p><p> sync-override，抑制因为置换同步方法而遗漏同步化的警告 </p><p>unchecked，抑制与未检查的作业相关的警告 </p><p>unqualified-field-access，抑制与栏位存取不合格相关的警告 </p><p>unused，抑制与未用的程式码及停用的程式码相关的警告</p></blockquote></li></ol><p> 补充说明：查看源码时，有个：@interface，表明是一个注解类，跟interface是不一样的          </p><hr><p><strong>四种元注解：</strong></p><ol><li>Retention  ：指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME</li></ol><ol start="2"><li>Target ： 指定注解可以在哪些地方使用 </li><li>Documented ：指定该注解是否会在 javadoc 体现</li><li>Inherited ：子类会继承父类注</li></ol><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="基本类型和引用类型"><a href="#基本类型和引用类型" class="headerlink" title="基本类型和引用类型"></a>基本类型和引用类型</h4><table><thead><tr><th align="left">基本类型</th><th align="left">引用类型(包装类)</th></tr></thead><tbody><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">char</td><td align="left">Character</td></tr></tbody></table><p>此外，BigInteger、BigDecimal 用于高精度的运算，BigInteger 支持任意精度的整数，也是引用类型，但它们没有相对应的基本类型。</p><h4 id="包装类与其他的转换"><a href="#包装类与其他的转换" class="headerlink" title="包装类与其他的转换"></a>包装类与其他的转换</h4><p><strong>包装类与基本类型的相互转换</strong></p><p>jdk5后可以自动装箱和拆箱，自动装箱底层调用的是valueOf 方法，比如：Integer.valueOf()；</p><p>手动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; integer</span></span><br><span class="line"><span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(n);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.valueOf(n);</span><br></pre></td></tr></table></figure><p>手动拆箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer -&gt; int</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> integer.intValue();</span><br></pre></td></tr></table></figure><hr><p><strong>包装类与String类型的相互转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//包装类 —&gt; String</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> i + <span class="string">&quot;&quot;</span>;<span class="comment">//方法一</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> i.toString();<span class="comment">//方法二</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> String.valueOf(i);<span class="comment">//方法三</span></span><br><span class="line"><span class="comment">//String —&gt; 包装类</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;12345&quot;</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> Integer.parseInt(str4);<span class="comment">//使用到自动装箱</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(str4); <span class="comment">//构造器</span></span><br></pre></td></tr></table></figure><h4 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h4><p>Integer和Character常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer.MIN_VALUE <span class="comment">//返回最小值</span></span><br><span class="line">Integer.MAX_VALUE<span class="comment">//返回最大值</span></span><br><span class="line">    </span><br><span class="line">Character.isDigit(<span class="string">&#x27;a&#x27;</span>) <span class="comment">//判断是否是数字</span></span><br><span class="line">Character.isLetter(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//判断是不是字母</span></span><br><span class="line">Character.isUpperCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是大写</span></span><br><span class="line">Character.isLowerCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是小写</span></span><br><span class="line">Character.isWhitespace(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//是不是空格</span></span><br><span class="line">    </span><br><span class="line">Character.toUpperCase(<span class="string">&#x27;a&#x27;</span>)<span class="comment">//转成大写</span></span><br><span class="line">Character.toLowerCase(<span class="string">&#x27;A&#x27;</span>)<span class="comment">//转成小写</span></span><br></pre></td></tr></table></figure><p><strong>关于Integer的数据存放位置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">j</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>);</span><br><span class="line">System.out.println(i == j); <span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">127</span>;<span class="comment">//底层 Integer.valueOf(127);</span></span><br><span class="line">System.out.println(m == n); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//Integer.valueOf(n),如果传入的值在-128 ~ 127，直接返回等于这个数值的对象。如果超过了范围，则new一个Integer对象</span></span><br><span class="line"><span class="comment">//即-128 ~ 127范围内的数字，都已经有一个自己的对象了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;<span class="comment">//valueOf源码</span></span><br><span class="line"><span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line"><span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">//False</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i1 == i2);<span class="comment">//F</span></span><br><span class="line"></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">127</span>; <span class="comment">//Integer.valueOf(127)</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">i10</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">127</span>);</span><br><span class="line">System.out.println(i9 == i10);<span class="comment">//F，对象不同</span></span><br><span class="line"></span><br><span class="line">Integer i11=<span class="number">127</span>;</span><br><span class="line"><span class="type">int</span> i12=<span class="number">127</span>;</span><br><span class="line">System.out.println(i11==i12); <span class="comment">//T</span></span><br><span class="line"><span class="comment">//只要有基本数据类型，判断的是值是否相同</span></span><br></pre></td></tr></table></figure><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table><p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p><p><strong>Java没有无符号形式的int,long,short,byte类型。</strong></p><p>（可以将有符号整数解释为无符号数，但需要非常仔细）</p><hr><p><strong>浮点型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td></tr><tr><td>double</td><td>8字节</td><td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td></tr></tbody></table><p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p><ul><li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p><p>1.正无穷大：Double.POSITIVE_INFINITY</p><p>2.负无穷大：Double.NEGATIVE_INFINITY</p><p>3.NaN(不是一个数字)：Double.NaN</p><ul><li>检测一个特定值是否等于Double.NaN：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Double.isNaN(x))<span class="comment">//检查x是否是一个数</span></span><br></pre></td></tr></table></figure><ul><li>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</li></ul></li><li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，命令System.out.plantln(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p></li></ul><hr><p><strong>char</strong>类型</p><p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p><ul><li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p><p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p><p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p></li><li><p>java中，char类型描述了UTF-16编码中的一个代码单元，但辅助字符编码为一对连续的代码单元（即不止一个代码单元），所以<strong>建议不要在程序中使用char类型，除非确实要处理UTF-16代码单元。最好将字符串作为抽象数据类型处理。</strong></p></li></ul><hr><h4 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a><strong>变量与常量</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明与初始化</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">double</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">12.0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">//对于局部变量，如果可以从初始值推断出它的类型，可以不声明类型，只用关键字var即可：</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">12</span>；  <span class="comment">//i is an int</span></span><br><span class="line"><span class="type">var</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>  <span class="comment">//a is a string</span></span><br></pre></td></tr></table></figure><hr><p><strong>常量</strong></p><p>利用关键字<strong>final</strong>指示常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//final表示这个变量只能被赋值一次，习惯上常量名用全大写</span></span><br></pre></td></tr></table></figure><p><strong>类常量</strong>：使某个常量在一个类的多个方法中使用，用关键字<strong>static final</strong>设置类常量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> calss Constant&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">ABC</span> <span class="operator">=</span> <span class="number">2.54</span>;</span><br><span class="line"><span class="comment">//类常量的定义位于main的外部</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a><strong>枚举类型</strong></h4><p>枚举类型的变量只能存储这个类型声明中给定的某个枚举值，或特殊值null（表示这个变量没有设置任何值）</p><hr><h4 id="关系运算boolean"><a href="#关系运算boolean" class="headerlink" title="关系运算boolean"></a><strong>关系运算boolean</strong></h4><ul><li><p>&amp;&amp;和||运算符按照短路方式求值，如果第一个操作数已能确定表达式的值，第二个操作数就不会进行计算。</p></li><li><p>&amp;和|不采用短路方式求值，即两个操作数都会进行计算。</p></li></ul><p>&amp;：对应位都为1则结果为1，否则为0；</p><p>|：对应位都为0则结果为0，否则为1；</p><p>^：对应位值相同则为0，否则为1；</p><p>~：按位取反每一位；</p><p>位模式左移：&gt;&gt;</p><p>右移：&lt;&lt;</p><p>运算符&gt;&gt;&gt;会用0填充高位，不存在&lt;&lt;&lt;</p><hr><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a><strong>子串</strong></h4><p>String类的substring方法：从字符串中<strong>提取</strong>出一个子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> a.substring(<span class="number">0</span>,<span class="number">3</span>);  </span><br><span class="line"><span class="comment">//substring方法中第二个参数是不想复制的第一个位置，即复制0，1，2位</span></span><br><span class="line"><span class="comment">//substring有个优点，就是子串b的长度容易计算，为3-0 = 3，即第2个参数减第1个参数</span></span><br></pre></td></tr></table></figure><p>java可以用+号<strong>连接</strong>两个字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;def&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br></pre></td></tr></table></figure><p>静态join方法：将多个字符串放在一起，用<strong>界定符分开</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String all = String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);</span><br><span class="line">//结果：all = &quot;S/M/L/XL&quot;</span><br></pre></td></tr></table></figure><p>repeat方法：将字符串<strong>复制n次</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;java&quot;</span>.repeat(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//结果：a = &quot;javajavajava&quot;</span></span><br></pre></td></tr></table></figure><p>java没有提供<strong>修改字符串</strong>的方法，因此要通过其他操作来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">a = a.substring(<span class="number">0</span>,<span class="number">3</span>) +<span class="string">&quot;p!&quot;</span>;</span><br><span class="line"><span class="comment">//结果为a = help!</span></span><br></pre></td></tr></table></figure><p>（尽管通过这种方式修改字符串效率不高，但不可变字符串有其他的优点：编译器可以让字符串共享，即原始字符串与复制字符串共享相同的字符（地址））。</p><p><strong>检测字符串是否相等</strong>：equals方法——s.equals(t）——其中s和t可以是字符串变量，也可以是字符串字面量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.equals(a);</span><br><span class="line"><span class="comment">//如果相等，返回true，否则返回false</span></span><br><span class="line"><span class="comment">//不要使用==运算符来检测两字符串！==只能确定两个字符串是否存放在同一位置，但只有字符串字面量是共享的，而+获substring等操作得到的字符串并不共享。</span></span><br></pre></td></tr></table></figure><hr><p>localDate类的程序：（显示当前月的日历）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.time.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">data</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">//下面获得当前的月份和日期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> data.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">today</span> <span class="operator">=</span> data.getDayOfMonth();</span><br><span class="line">        <span class="comment">//将data设置为这个月的第一天，并得到这一天为星期几</span></span><br><span class="line">        data = data.minusDays(today - <span class="number">1</span>);</span><br><span class="line">        <span class="type">DayOfWeek</span> <span class="variable">weekday</span> <span class="operator">=</span> data.getDayOfWeek();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> weekday.getValue();</span><br><span class="line">        <span class="comment">//打印日历的表头和第一行缩进</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Mon Tue Wed Thu Fri Sat Sun&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; value; i++)&#123;</span><br><span class="line">            System.out.print(<span class="string">&quot;    &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进入循环，使data遍历月的每一天，并打印日期；</span></span><br><span class="line">        <span class="keyword">while</span>(data.getMonthValue() == month)&#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%3d&quot;</span>,data.getDayOfMonth());</span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfMonth() == today)&#123;      <span class="comment">// 如果data是当前日期，则用*标记；</span></span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> System.out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            data = data.plusDays(<span class="number">1</span>);    <span class="comment">// 接下来将data推进到下一天，如果到达新一周，则换行打印</span></span><br><span class="line">            <span class="keyword">if</span>(data.getDayOfWeek().getValue() == <span class="number">1</span>) System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mon Tue Wed Thu Fri Sat Sun</span><br><span class="line">              <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span> </span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span>  <span class="number">10</span>  <span class="number">11</span> </span><br><span class="line"> <span class="number">12</span>  <span class="number">13</span>  <span class="number">14</span>  <span class="number">15</span>  <span class="number">16</span>  <span class="number">17</span>  <span class="number">18</span> </span><br><span class="line"> <span class="number">19</span>  <span class="number">20</span>  <span class="number">21</span>  <span class="number">22</span>  <span class="number">23</span>  <span class="number">24</span>  <span class="number">25</span>*</span><br><span class="line"> <span class="number">26</span>  <span class="number">27</span>  <span class="number">28</span>  <span class="number">29</span>  <span class="number">30</span> </span><br></pre></td></tr></table></figure><h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;&#125;</span><br></pre></td></tr></table></figure><ol><li>main方法时虚拟机调用</li><li>jvm需要调用类的main()方法，所以该方法的访问权限必须是public</li><li>jvm在执行main()方法时不必创建对象，所以main()为static</li><li>main()接受String类型的参数数组，该数组中保存执行java命令时传递给所运行的类的参数</li></ol><p>在main()方法中，可以直接调用main方法所在类的静态方法和静态变量，但不能访问非静态的方法和变量，必须创建该类的一个实例对象后，才能这个对象去访问；</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="类（Class）和对象（object"><a href="#类（Class）和对象（object" class="headerlink" title="类（Class）和对象（object)"></a>类（Class）和对象（object)</h3><p><strong>类</strong>：类是一个模板，它描述一类对象的行为和状态</p><p>(类包含：<strong>属性，方法，构造器，代码块，内部类</strong>)</p><p>一个类可以包含以下类型变量：</p><ul><li><strong>局部变量</strong>：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li><li><strong>成员变量</strong>（非静态变量）：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li><li><strong>类变量</strong>（静态变量）：类变量也声明在类中，方法体之外，但必须声明为 static 类型。</li></ul><blockquote><p>类什么时候会被加载？</p><ol><li>创建对象实例时；</li><li>创建子类对象实例，父类也会被加载；</li><li>使用类的静态成员</li></ol></blockquote><hr><p><strong>代码块：</strong>又称初始化块，类似于方法，将语句封装在方法体中，用{}包起来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[修饰符]&#123;</span><br><span class="line">代码</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//修饰符可选，但只能写static</span></span><br><span class="line"><span class="comment">// ; 号可写可不写</span></span><br></pre></td></tr></table></figure><p><strong>静态代码块</strong>，作用就是对类初始化，随着类的加载而执行，且<strong>只会执行一次</strong>，如果<strong>是普通代码块，每创建一个对象都会执行一次</strong>（如果只是使用类的静态成员，普通代码不会执行）；</p><hr><p><strong>对象</strong>：对象是类的一个示例，有状态和行为。软件对象的状态就是属性，行为通过方法体现</p><p><strong>创建对象</strong></p><p>对象是根据类创建的。在Java中，使用关键字 new 来创建一个新的对象。创建对象需要以下三步：</p><ul><li><strong>声明</strong>：声明一个对象，包括对象名称和对象类型。</li><li><strong>实例化</strong>：使用关键字 new 来创建一个对象。</li><li><strong>初始化</strong>：使用 new 创建对象时，会调用构造方法初始化对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Puppy</span>&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">Puppy</span><span class="params">(String name)</span>&#123;</span><br><span class="line">      <span class="comment">//这个构造器仅有一个参数：name</span></span><br><span class="line">      System.out.println(<span class="string">&quot;小狗的名字是 : &quot;</span> + name ); </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">      <span class="comment">// 下面的语句将创建一个Puppy对象</span></span><br><span class="line">      <span class="type">Puppy</span> <span class="variable">myPuppy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Puppy</span>( <span class="string">&quot;tommy&quot;</span> );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用顺序：</strong></p><ol><li><strong>调用静态代码块和静态属性初始化（有多个则顺序调用）；</strong></li><li><strong>调用普通代码块和普通属性的初始化；</strong></li><li><strong>调用构造方法；</strong></li></ol><hr><p><strong>源文件声明规则</strong></p><p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p><ul><li>一个源文件中只能有一个 public 类</li><li>一个源文件可以有多个非 public 类</li><li>源文件的名称应该和 public 类的类名保持一致。例如：源文件中 public 类的类名是 Employee，那么源文件应该命名为Employee.java。</li><li>如果一个类定义在某个包中，那么 package 语句应该在源文件的首行。</li><li>如果源文件包含 import 语句，那么应该放在 package 语句和类定义之间。如果没有 package 语句，那么 import 语句应该在源文件中最前面。</li><li>import 语句和 package 语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li></ul><h3 id="1-继承"><a href="#1-继承" class="headerlink" title="1.继承"></a>1.继承</h3><p>好处：</p><p>1：提高了代码的复用性。</p><p>2：提高了代码的拓展性和维护性，让类与类之间产生了关系，提供了另一个特征多态的前提。</p><ul><li><p><strong>一般类只能单继承；内部类实现多继承；接口可以多继承；</strong></p></li><li><p>子类继承了所有的属性和方法，<strong>非私有的</strong>属性和方法可以在子类<strong>直接访问</strong>，但是<strong>私有的</strong>属性和方法要通过父类提供的<strong>公共方法去访问</strong>；</p></li><li><p><strong>子类必须调用父类的构造器，完成父类的初始化；</strong></p></li></ul><ol><li><strong>对与成员变量：</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">关键字：</span><br><span class="line"><span class="built_in">this</span>：是本类类型的对象引用</span><br><span class="line"><span class="comment">//this从本类中开始查找，没有才从父类中找</span></span><br><span class="line"><span class="built_in">super</span>：是子类所属的父类中的内存空间引用</span><br><span class="line"><span class="comment">//super直接从父类中查找</span></span><br><span class="line"><span class="comment">//super不能访问父类的private属性或方法</span></span><br></pre></td></tr></table></figure><p>注意：<strong>子父类中通常是不会出现同名成员变量的</strong>，因为父类中只要定义了，子类就不用在定义，直接继承过来用。（当有属性&#x2F;方法<strong>重名时</strong>，<strong>只能用super访问父类的重名属性&#x2F;方法</strong>；super的访问不限于直接父类，如果爷爷类也有与本类重名的属性&#x2F;方法，也能用super去访问；即<strong>多个基类中都有重名的成员，super的访问遵循就近原则</strong>）</p><ol start="2"><li><strong>成员函数：</strong></li></ol><p>当子父类可以出现一样的方法，即可以覆盖（重写）函数（当一个类的功能需要修改时，可以通过覆盖来实现）</p><ol start="3"><li><strong>构造函数</strong></li></ol><p>子类的构造函数运行时，一定会先运行父类的构造函数；</p><p>原因：子类的构造函数中的第一行，都有一条隐身的语句super()，而这个super（）是在调用父类中空参数的构造函数；</p><blockquote><p>因为子类继承父类，会继承父类中的数据，所以必须要看到父类对自己数据进行初始化的过程</p></blockquote><p>子类在进行对象初始化时，先调用父类的构造函数，这就是子类的实例化过程。</p><blockquote><p>注意：子类中所有的构造函数都会默认访问父类中的空参数的构造函数，因为每一个子类构造内第一行都有默认的语句super();</p><p>如果父类中没有空参数的构造函数，那么子类的构造函数内，必须通过super语句指定要访问的父类中的构造函数。</p><p>如果子类构造函数中用this来指定调用子类自己的构造函数，那么被调用的构造函数也一样会访问父类中的构造函数。</p></blockquote><p><strong>在方法覆盖（重写）时，注意：</strong></p><ol><li><p>子类覆盖父类时，必须要保证，<strong>子类方法的权限必须大于等于父类方法权限</strong>可以实现继承。否则，编译失败。</p></li><li><p>覆盖时，要么<strong>都静态</strong>，要么<strong>都不静态</strong>。 (静态只能覆盖静态，或者被静态覆盖)</p></li><li><p>子类中重写父类的方法，必须与父类的那个方法：<strong>名称，返回类型，参数一样</strong>；</p></li></ol><p><strong>而对于重载：只要同一类中，且方法名一致，参数列表不一样即可，对返回类型，修饰符无要求；</strong></p><p>继承的一个弊端：打破了封装性。对于一些类，或者类中功能，是需要被继承，或者复写的。</p><p>此时可以用到final;</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span>特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>：这个关键字是一个修饰符，可以修饰类，方法，变量。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>：被<span class="keyword">final</span>修饰的类是一个最终类，不可以被继承。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>：被<span class="keyword">final</span>修饰的方法是一个最终方法，不可以被覆盖。</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>：被<span class="keyword">final</span>修饰的变量是一个常量，只能赋值一次。</span><br></pre></td></tr></table></figure><p>其实这样的原因的就是给一些固定的数据起个阅读性较强的名称。<br>加了final，程序更为严谨。常量名称定义时，有规范，所有字母都大写，如果由多个单词组成，中间用 _ 连接。</p><p><strong>创建子类对象时的调用顺序：</strong></p><ol><li>父类的静态代码块和静态属性</li><li>子类的静态代码块和静态属性</li><li>父类的普通代码块和普通属性初始化；</li><li>父类的构造方法；</li><li>子类的普通代码块和普通属性初始化；</li><li>子类的构造方法；</li></ol><h3 id="2-封装"><a href="#2-封装" class="headerlink" title="2.封装"></a>2.封装</h3><p>在面向对象程式设计方法中，封装（Encapsulation）是指一种将抽象性函式接口的实现 细节部分 包装、隐藏起来的方法。</p><p>也就是说：<strong>将数据和对数据的操作封装起来，程序的其他部分只有通过被允许的操作才能对数据进行修改。</strong></p><p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p><p>要访问该类的代码和数据，必须通过严格的接口控制。</p><p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p><p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p><p><strong>封装的优点：</strong></p><ol><li><p>良好的封装能够减少耦合。</p></li><li><p>类内部的结构可以自由修改。</p></li><li><p>可以对成员变量进行更精确的控制。</p></li><li><p>隐藏信息，实现细节。</p></li></ol><hr><p><strong>实现Java封装的步骤：</strong></p><ol><li><p>修改属性的可见性来<strong>限制对属性的访问</strong>（一般限制为<strong>private</strong>）,例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">person</span>()&#123;</span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码中，将 <strong>name</strong> 和 <strong>age</strong> 属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p><p><strong>访问权限控制：public &gt; protected &gt; 包 &gt; private</strong> </p></li><li><p>对每个值属性<strong>提供对外的公共方法访问</strong>，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><strong>static关键字</strong>：可对数据进行静态修饰</p><blockquote><ol><li><p><strong>被静态修饰的成员，可以直接被类名所调用。</strong>也就是说，静态的成员多了一种调用方式。<strong>类名.静态方式。</strong></p></li><li><p><strong>静态随着类的加载而加载，而且优先于对象存在。</strong></p></li><li><p><strong>静态方法只能访问静态成员，不可以访问非静态成员。</strong></p></li><li><p><strong>静态方法中不能使用this，super关键字。</strong></p></li></ol><p>   因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</p></blockquote><p>成员变量和静态变量的区别：</p><p>1，成员变量所属于对象，所以也称为<strong>实例变量</strong>。</p><p>   静态变量所属于类，所以也称为<strong>类变量</strong>。</p><p>2，成员变量存在于<strong>堆内存</strong>中。</p><p>   静态变量存在于<strong>方法区</strong>中。</p><p>3，成员变量随着对象创建而存在，随着对象被回收而消失。</p><p>   静态变量随着类的加载而存在，随着类的消失而消失。</p><p>4，成员变量只能被对象所调用。</p><p>   静态变量可以被对象调用，也可以被类名调用。</p><p>所以，成员变量可以称为对象的特有数据，静态变量称为对象的共享数据。</p><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3><p>实现多态的三个必要条件：<strong>继承，重写（重载也是），向上转型</strong>；</p><p><strong>向上转型：子类对象被父类引用；</strong></p><p><strong>向下转型：向下转型是子类对象被父类引用之后，再把父类引用强转成子类；</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fly</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Animal</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();<span class="comment">//向上转型</span></span><br><span class="line">        b.run();</span><br><span class="line">        </span><br><span class="line">        <span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> (Bird)b;<span class="comment">//向下转型</span></span><br><span class="line">        bird.run();</span><br><span class="line">        bird.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>向下转型的意义：当多个子类继承同一个父类或接口时，可以写一个公用的方法，方法传入的形参为父类或接口，这样每个子类实参就可以传入这个父类形参中，进而实现公用性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">publish <span class="keyword">class</span> <span class="title class_">Test2</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Bird</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br><span class="line">        <span class="type">Tom</span> <span class="variable">tom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Tom</span>();</span><br><span class="line">        <span class="comment">//传入子类的实参引用</span></span><br><span class="line">        sleep(b);</span><br><span class="line">        sleep(tom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//方法的参数是父类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">(Animal A)</span>&#123;</span><br><span class="line">        A.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用例子： </p><ol><li><p><strong>多态参数：</strong>可以<strong>在方法实参中使用父类，然后调用方法时传入子类，即向上转型</strong></p></li><li><p><strong>多态数组：</strong>数组的定义类型为父类，里面保存的实际元素类型为子类类型</p><p>如果要调用数组中子类特有的方法，可以使用<strong>类型判断+向下转型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Fu[] f = <span class="keyword">new</span> <span class="title class_">Fu</span>[n];</span><br><span class="line"><span class="keyword">if</span>(f[i] instancef Zi)&#123;</span><br><span class="line">    <span class="type">Zi</span> <span class="variable">z</span> <span class="operator">=</span> (Zi)f[i];</span><br><span class="line">    z.方法();</span><br><span class="line">    <span class="comment">//两句直接写成：((Zi)f[i]).方法();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>多态 体现在：<strong>父类引用变量可以指向子类对象</strong></p><p>多态的定义格式：</p><blockquote><p>父类类型 变量名 &#x3D; new 子类类型（）；</p></blockquote><p>多态成员特点：</p><ol><li>多态成员<strong>变量</strong>：编译类型 运行类型 <strong>都看左边</strong></li><li>多态成员<strong>方法</strong>：<strong>编类型看左边，运行类型看右边</strong></li></ol><p><strong>java的动态绑定机制</strong></p><ul><li><strong>当调用对象方法时，该方法会和对象的内存地址&#x2F;运行类型绑定；</strong></li><li><strong>当调用对象属性时，没有动态绑定机制，哪里声明，那里使用</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Fu</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line"><span class="comment">//f是父类Fu中的值，只能取到父中的值</span></span><br><span class="line"><span class="comment">//f表面是Fu，实际类型是Zi，所以调用到的方法是重写后的方法，</span></span><br><span class="line"><span class="comment">//方法里所用到的值，是当前类的值，即调用的方法在哪个类，就用哪那个类的值；</span></span><br></pre></td></tr></table></figure><hr><p><strong>instanceof关键字：</strong>用于判断对象是否属于某种数据类型（返回值为布尔类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   Fu f1=<span class="keyword">new</span> <span class="title class_">Zi</span>();</span><br><span class="line">        Fu f2=<span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">        <span class="keyword">if</span>(f1 <span class="keyword">instanceof</span> Zi)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Zi的类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;f1是Son的类型&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>多态的转型：</strong></p><p>向上转型：多态本身就是向上转型过的过程</p><ul><li>使用格式：父类类型 变量名&#x3D;new 子类类型();</li></ul><blockquote><p>适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。</p></blockquote><p>向下转型：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型</p><ul><li>使用格式：子类类型 变量名&#x3D;（子类类型） 父类类型的变量；</li></ul><blockquote><p>适用场景：当要使用子类特有功能时。</p></blockquote><hr><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><p>一个类的内部又完整嵌套了另一个结构，被嵌套的类被称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。</p><p>内部类最大的特点是<strong>可以直接访问外部类的所有成员，包括私有属性</strong>。</p><p>按定义的位置：</p><ol><li>定义<strong>在局部位置</strong>（方法&#x2F;代码块）：<ul><li><strong>局部内部类</strong></li><li><strong>匿名内部类</strong></li></ul></li><li>定义<strong>在成员位置</strong>：<ul><li><strong>成员内部类</strong>（不加static）&#x2F; 普通内部类</li><li><strong>静态内部类</strong>（加static）</li></ul></li></ol><hr><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><p>在类里面作为一个字段直接定义即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里 B 类为 A 类的普通内部类，在这种定义方式下，普通内部类对象依赖外部类对象而存在，即在创建一个普通内部类对象时首先需要创建其外部类对，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Outer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">        <span class="comment">//不在外部类内部，要用：外部类对象.new 内部构造器()；的方式创建对象</span></span><br><span class="line">        a.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><p>一个类的静态成员独立于这个类的任何一个对象存在，只要在具有访问权限的地方，我们就可以通过 <strong>类名.静态成员名</strong> 的形式来访问这个静态成员，同样的，静态内部类也是作为一个外部类的静态成员而存在，<strong>创建一个类的静态内部类对象不需要依赖其外部类对象</strong>。</p><p>与静态成员一样，静态内部类 无法访问外部类的非静态成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123; </span><br><span class="line">    <span class="comment">//在外部类内部，可以直接new内部类对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//在同一个外部类中，且同样是静态的，可以直接new</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//其他外部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">//不在外部类内部，用：外部类名.静态成员名 进行访问</span></span><br><span class="line">        Outer.<span class="type">Inner</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><p>匿名内部类没有名字，定义在外部类的局部位置（方法&#x2F;代码块）</p><p>某个类实现接口&#x2F;抽象类，但只使用一次，可以使用匿名内部类（简化开发）  </p><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类或接口(参数列表)&#123;</span><br><span class="line">类体;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><p>基于接口的匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IA</span>&#123;<span class="comment">//接口</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;<span class="comment">//方法</span></span><br><span class="line">        <span class="comment">//anonymity的编译类型是IA，运行类型是匿名内部类</span></span><br><span class="line">        <span class="comment">//匿名内部类其实在底层会分配一个名字，不会显示出来</span></span><br><span class="line">        <span class="comment">//jdk底层在创建匿名内部类anomymity$1,立刻就创建了其实例，并把地址返回给anomymity;</span></span><br><span class="line">        <span class="type">IA</span> <span class="variable">anonymity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IA</span>()&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;         </span><br><span class="line">        <span class="comment">//查看一下运行类型，即在原名字后加$1: anomymity$1</span></span><br><span class="line">        system.out.println(anomymity.getclass());</span><br><span class="line">        <span class="comment">//匿名内部类anomymity$1使用一次就回收掉，但anonymity是一个对象，仍可以反复调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于类的匿名内部类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>()&#123;<span class="comment">//A可以为普通类或抽象类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>匿名内部类可以直接当作实参直接传递，简洁高效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//当做实参直接传递，简洁高效</span></span><br><span class="line">f1(<span class="keyword">new</span> <span class="title class_">IL</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是一副名画~~...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//传统方法</span></span><br><span class="line">f1(<span class="keyword">new</span> <span class="title class_">Picture</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><p>定义在外部类的局部位置，有名字。</p><p>不能添加访问修饰符，但可以使用final修饰（跟局部变量一样）</p><p>作用域：仅在定义它的方法或代码块中</p><ul><li><p>访问方式：</p><ul><li>局部内部类访问外部类的成员：直接访问</li><li>外部类访问局部内部类的成员：<strong>在它的作用域中创建对象</strong>，再访问；</li></ul></li><li><p>外部其他类不能访问局部内部类（地位相当于是一个局部变量）</p></li><li><p>如果外部类和局部内部类的成员<strong>同名</strong>，默认遵循就近原则，如果想访问外部类成员，可以用：<strong>外部类名. this. 成员名</strong> ，去访问</p></li></ul><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>在面向对象的概念中，所有的对象都是通过类来描绘的，但是反过来，并不是所有的类都是用来描绘对象的，</p><p>如果一个类中<strong>没有包含足够的信息来描绘一个具体的对象</strong>，这样的类就是<strong>抽象类</strong>。</p><p>抽象类除了<strong>不能实例化对象</strong>之外，类的<strong>其它功能依然存在</strong>，成员变量、成员方法和构造方法的访问方式和普通类一样。</p><p>由于抽象类不能实例化对象，所以<strong>抽象类必须被继承，才能被使用</strong>。</p><p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p><p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p><p><strong>使用abstract class来定义抽象类。</strong></p><p>抽象方法：如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p><p>Abstract 关键字同样可以用来声明抽象方法，<strong>抽象方法只包含一个方法名，而没有方法体。</strong></p><p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String address;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> number;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">double</span> <span class="title function_">computePay</span><span class="params">()</span>;<span class="comment">//抽象方法</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">//其余代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明抽象方法会造成以下两个结果：</p><ul><li>如果一个类<strong>包含抽象方法</strong>，那么该类<strong>必须是抽象类</strong>。</li><li>任何<strong>子类必须重写父类的抽象方法</strong>，<strong>或者声明自身为抽象类</strong>。</li></ul><p>继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p><p> <strong>抽象类总结规定</strong></p><ol><li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</li><li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</li><li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。</li><li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</li><li>抽象关键字abstract 和 final, private, static不共存</li></ol><p>设计模式：</p><p>解决的问题：当功能内部一部分实现时确定，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">getTime</span><span class="params">()</span>&#123; <span class="comment">//此功能如果不需要复写，可加final限定</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        code(); <span class="comment">//不确定的功能部分，提取出来，通过抽象方法实现</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;毫秒是：&quot;</span>+(end-start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>; <span class="comment">//抽象不确定的功能，让子类复写实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubDemo</span> <span class="keyword">extends</span> <span class="title class_">GetTime</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>&#123; &lt;font color=red &gt;<span class="comment">//子类复写功能方法&lt;/font&gt;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">0</span>; y&lt;<span class="number">1000</span>; y++)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;y&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口（Interface），在JAVA中是一个抽象类型，是抽象方法的集合，</p><p>接口通常以interface来声明。一个类通过继承接口，从而继承接口中的抽象方法。</p><p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p><p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p><p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p><p><strong>接口声明：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[可见度] interface 接口名称 [extends 其他的接口名] &#123;</span><br><span class="line">        <span class="comment">// 声明变量</span></span><br><span class="line">        <span class="comment">// 抽象方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一个接口 允许继承 多个其他接口</span></span><br></pre></td></tr></table></figure><p><strong>接口实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...implements 接口名称[, 其他接口名称, 其他接口名称..., ...]&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接口与类相似点：</strong></p><ul><li>一个接口可以有多个方法。</li><li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li><li>接口的字节码文件保存在 .class 结尾的文件中。</li><li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li></ul><p><strong>接口与类的区别：</strong></p><ul><li>接口不能用于实例化对象。</li><li>接口没有构造方法。</li><li>接口中所有的方法必须是抽象方法。</li><li>接口不能包含成员变量，除了 static 和 final 变量。</li><li>接口不是被类继承了，而是要被类实现。</li><li>接口支持多继承。</li></ul><p><strong>接口特性：</strong></p><ul><li><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 <strong>public abstract</strong>（只能是 public abstract，其他修饰符都会报错）。</p></li><li><p>接口中可以含有变量，但是接口中的变量会被隐式的指定为 <strong>public static final</strong> 变量（并且只能是 public，用 private 修饰会报编译错误）。</p><ul><li><p>使用static可以 在继承多接口时，如果存在多个同名变量，可以使用接口名.变量名来区分；</p></li><li><p>使用final，让接口中的变量不可更改，否则，每个实现接口的类都可以改变这个变量的值，就违背了OCP原则；</p></li></ul></li><li><p>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</p></li><li><p>接口的修饰符只能是public和默认。</p></li></ul><p><strong>抽象类和接口的区别：</strong></p><ol><li><p>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</p></li><li><p>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 <strong>public static final</strong> 类型的。</p></li><li><p>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</p></li><li><p>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p></li></ol><p>注：</p><ol><li><p>JDK 1.8 以后，接口里可以有静态方法和方法体了。</p></li><li><p>JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为”默认方法”，默认方法使用 default 关键字修饰。</p></li><li><p>JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。</p></li></ol><hr><p><strong>实现接口和继承类的区别</strong></p><p>当子类继承了父类，就自动拥有父类的功能，是 is-a的关系</p><p>如果子类<strong>需要扩展功能</strong>，可以通过实现接口的方式扩展，是like - a 的关系，可以理解 ” 实现接口“ 是对java单继承机制的补充；</p><p>继承的价值只要是：解决代码的复用性和可维护性。</p><p>接口的价值主要是：<strong>设计好各种规范</strong>（方法），让其它子类去实现，更加灵活。且接口在一定程度上实现代码解耦（即：接口规范性+动态绑定机制）。</p><hr><p><strong>接口与多态</strong></p><p>接口也能利用动态参数 和 多态数组</p><p>接口存在多态传递现象</p><hr><p>在重写接口中声明的方法时，需要注意以下规则：</p><ul><li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li><li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li><li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li></ul><p>在实现接口的时候，也要注意一些规则：</p><ul><li>一个类可以同时实现多个接口。</li><li>一个类只能继承一个类，但是能实现多个接口。</li><li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li></ul><p><strong>标记接口：</strong></p><p>最常用的继承接口是没有包含任何方法的接口。</p><p>标记接口是没有任何方法和属性的接口。它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p><p>没有任何方法的接口被称为标记接口。标记接口主要用于以下两种目的：</p><ul><li><p>建立一个公共的父接口：</p><p>正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p></li><li><p>向一个类添加数据类型：</p><p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p></li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚举的两种实现：</p><ol><li>自定义枚举类；</li><li>使用enum关键字实现枚举；</li></ol><hr><p> 枚举是一个特殊的类，一般表示一组常量，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ...&#123;</span><br><span class="line">... , ... , ... ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用enum，要求将定义常量<strong>对象写在最前面</strong>;</li><li>直接使用： <strong>常量名（实参列表）</strong>; 如果使用无参构造器，则实参列表和小括号都可以省略；</li><li>如果有多个常量&#x2F;对象,使用<strong>逗号间隔</strong>即可；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="comment">//使用enum，要求将定义常量对象写在最前面</span></span><br><span class="line">    <span class="comment">//直接使用： 常量名（实参列表）</span></span><br><span class="line">    <span class="comment">//如果有多个常量/对象,使用逗号间隔即可；</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>),SUMMER(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>values(), ordinal() 和 valueOf() 方法:</strong></p><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p><p>（所以使用enum关键字后，就<strong>不能再继承其他类</strong>了，因为enum隐式继承了Enum类）</p><p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p><ul><li><strong>values() 返回枚举类中所有的值。</strong></li><li><strong>ordinal()方法可以找到每个枚举常量的索引，就像数组索引一样。</strong></li><li><strong>valueOf()方法返回指定字符串值的枚举常量。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span></span><br><span class="line">&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 调用 values()</span></span><br><span class="line">        Color[] arr = Color.values();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 迭代枚举</span></span><br><span class="line">        <span class="keyword">for</span> (Color col : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 查看索引</span></span><br><span class="line">            System.out.println(col + <span class="string">&quot; at index &quot;</span> + col.ordinal());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException</span></span><br><span class="line">        System.out.println(Color.valueOf(<span class="string">&quot;RED&quot;</span>));</span><br><span class="line">        <span class="comment">// System.out.println(Color.valueOf(&quot;WHITE&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举类成员:</strong></p><p>枚举跟普通类一样可以用<strong>自己的变量、方法和构造函数</strong>，构造函数只能使用 <strong>private</strong> 访问修饰符，让外部无法调用。</p><p>枚举既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它。</p><hr><p><strong>自定义枚举类</strong></p><ol><li>将构造器私有化，防止外部直接new；</li><li>去掉set方法，防止属性被修改；</li><li>在枚举类内部，直接创建固定的对象；</li><li>对外暴露对象：对枚举对象&#x2F;属性使用public + final + static共同修饰，实现底层优化； </li><li>枚举对象名通常全部大写（这是常量的命名规范）；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = neme;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="包-1"><a href="#包-1" class="headerlink" title="包"></a>包</h3><p>包是Java语言提供的一种区别类名字命名空间的机制，它是类的一种文件组织和管理方式、是一组功能相似或相关的类或接口的集合。</p><p>Java package提供了访问权限和命名的管理机制。</p><p>一、<strong>包的作用</strong> </p><ol><li>把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。 </li><li>如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</li><li>包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</li></ol><p>二、<strong>包的定义</strong><br>在一个.java文件中可以一个public类和多个非public类，如果要将这些类组织在一个包当中，则在.java文件中除注释以外的第一行使用关键字package即可实现。</p><p>当需要调用此包中的类时，就可以使用关键字import进行导入。在定义包的时候，应该注意几点: </p><ol><li>为了尽量使包名保持唯一性，包名通常采用小写、按倒写互联网址的形式进行定义。</li><li>在进行命名包时，应该避免使用与系统发生冲突的名字。</li></ol><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常：程序执行中发生的不正常情况</p><p>异常分为两大类：</p><ol><li><strong>Error</strong>（错误）：JVM无法解决的严重问题，如：JVM系统内部错误，资源耗尽等严重情况</li><li><strong>Exception</strong>：其他因编程错误或外在因素导致的一般性问题，可以使用针对性代码进行处理；Exception分为两大类：<strong>运行时异常</strong>（程序运行时发生的异常），<strong>编程时异常</strong>（编程时，编译器检查出的异常，编译器要求必须处理）</li></ol><p><strong>常见的运行时异常：</strong></p><ol><li><p>**NullPointerException  空指针异常 **</p><p>如：当应用程序试图在需要对象的地方使用 null 时，会抛出该异常；</p></li><li><p>**ArithmeticException  数学运算异常 **</p><p>如：当出现异常的运算条件时，抛出此异常，比如整数除以零时；</p></li><li><p><strong>ArrayIndexOutOfBoundsException</strong> <strong>数组下标越界异常</strong></p><p>用非法索引访问数组时抛出的异常，比如索引为负或大于等于数组大小，则该索引为非法索引；</p></li><li><p><strong>ClassCastException</strong> <strong>类型转换异常</strong></p><p>当试图将对象强制转换为不是实例的子类时，抛出该异常；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassCastException_</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">A</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>(); <span class="comment">//向上转型</span></span><br><span class="line"><span class="type">B</span> <span class="variable">b2</span> <span class="operator">=</span> (B)b;<span class="comment">//向下转型，这里是 OK</span></span><br><span class="line"><span class="type">C</span> <span class="variable">c2</span> <span class="operator">=</span> (C)b;<span class="comment">//这里抛出 ClassCastException</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>NumberFormatException</strong> <strong>数字格式不正确异常</strong></p><p>当程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常（使用此异常可以确保输入满足条件的数字）</p></li></ol><p><strong>常见的编译异常：</strong></p><ol><li>SQLException ：操作数据库时，查询表可能发生异常</li><li>IOException ：操作文件时，发生的异常</li><li>FileNotFoundException ：当操作一个不存在的文件时，发生异常</li><li>ClassNotFoundException：加载类，而该类不存在时，异常</li><li>EOFException：操作文件时，到文件末尾，发生异常</li><li>IllegalArguementException：参数异常</li></ol><hr><p><strong>异常处理机制</strong></p><ol><li><p><strong>try - catch - finally</strong></p><p>程序员在代码中捕获发生的异常，自行处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    可能有异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//当异常发生时，系统将异常封装成Exception对象e，传递给catch</span></span><br><span class="line">    <span class="comment">//得到异常对象后，程序员自己处理</span></span><br><span class="line">    <span class="comment">//如果没有发生异常，catch代码块不执行</span></span><br><span class="line">    <span class="comment">//可以有多个catch语句，捕获不同的异常，要求子类异常写在前，父类异常在后（只会匹配一个catch）</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//不管try代码块有没有异常发生，始终要执行finally</span></span><br><span class="line">    <span class="comment">//通常将释放资源的代码放在finally</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>就算在catch中ruturn了，但因为finally必须执行，所以catch的return中的语句会执行，但不会立即返回（return）；</li><li>如果catch中 ruturn  i  ；但finally中又用到了 变量 i  ，底层会保存临时变量temp &#x3D; i ，执行完finally后，catch返回temp（finally有return的话则在finally中return）；</li></ul></li><li><p><strong>throws</strong></p><p>将发生的异常抛出，交给调用者（方法）处理，最高级的处理者是JVM（JVM会直接打印异常信息，退出）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> <span class="keyword">throws</span> XXException&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类重写父类的方法时，对抛出异常的规定：子类重写的方法，所抛出的异常类型要和父类的一致或其异常类型的子类型；</li></ul></li><li><p><strong>自定义异常</strong></p><p>自定义异常 需要继承 Excption或RuntimeException；如果继承Exception属于编译异常， 继承RuntimeException属于运行异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="comment">/*throws AgeException*/</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">180</span>;</span><br><span class="line"><span class="comment">//要求范围在 18 – 120 之间，否则抛出一个自定义异常</span></span><br><span class="line"><span class="keyword">if</span>(!(age &gt;= <span class="number">18</span> &amp;&amp; age &lt;= <span class="number">120</span>)) &#123;</span><br><span class="line"><span class="comment">//这里我们可以通过构造器，设置信息</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AgeException</span>(<span class="string">&quot;年龄需要在 18~120 之间&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;你的年龄范围正确.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AgeException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">AgeException</span><span class="params">(String message)</span> &#123;  <span class="comment">//构造器</span></span><br><span class="line"><span class="built_in">super</span>(message);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>throw和throws的区别</p><table><thead><tr><th></th><th>意义</th><th>位置</th><th>后面跟的是</th></tr></thead><tbody><tr><td>throws</td><td>异常处理的一种方式</td><td>方法声明处</td><td>异常类型</td></tr><tr><td>throw</td><td>手动生成异常对象的关键字</td><td>方法体中</td><td>异常对象</td></tr></tbody></table><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合主要有 单列集合 和 双列集合：</p><ul><li><p>Collection接口有两个重要的子接口List，Set，它们实行的都是单列集合；</p></li><li><p>Map接口的实现子类，是双列集合，从存放K - V；</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707036.png" alt="image-20211003183537824"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707037.png" alt="image-20211003183548688"></p><hr><p><strong>如何选择</strong>集合实现类：判断存储的类型：单列&#x2F;双列</p><ul><li><p>一组对象（单列）：Collection接口</p><ul><li><p>允许重复：List</p><ul><li>增删多：LinkedList（底层是双向链表）</li><li>查改多：ArrayList（底层是可变数组）</li></ul></li><li><p>不允许重复：Set</p><ul><li><p>无序：HashSet（底层HashMap）</p></li><li><p>排序：TreeSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure></li><li><p>插入和取出顺序一致：LinkedHashSet（维护数组和双向链表）</p></li></ul></li></ul></li><li><p>一组键值对（双列）：Map</p><ul><li><p>键无序：HashMap（底层：维护了一个哈希表：数组+链表+红黑树）</p></li><li><p>键排序：TreeMap</p></li><li><p>键插入和取出顺序一致：LinkedHashMap</p></li><li><p>读取文件：Properties</p></li></ul></li></ul><hr><h3 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a><strong>Collection接口</strong></h3><p>Collection接口的常用方法：add，remove，contains，size，isEmpty，clear，addAll，containsAll，removeAll（All都是指多个元素）</p><p>遍历方式：</p><ol><li>使用 <strong>Iterator</strong> 迭代器（快捷模板：while-&gt;itit）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">col</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">//先得到col对应的迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> col.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">System.out.println(<span class="string">&quot;obj = &quot;</span> + obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在调用iterator.next()之前必须先用iterator.hasNext()进行检测，不然，如果下一条记录无效，且直接调用next方法会抛出NoSuchElementException异常</p></li><li><p>当退出while循环后，iterator迭代器指向最后的元素，如果要再次遍历，需重置迭代器：ite &#x3D; col.iterator();</p></li><li><p>iterator迭代器的remove方法是迭代过程中唯一能 线性安全地 删除集合元素的方法，因为iterator在遍历过程中，会锁定集合中的元素。</p></li><li><p>不能直接使用集合的remove方法：因为集合中会有变量modCount记录修改次数，当调用remove方法时，modCount ++，而迭代开始时，会先把modCount 记录下来，在调用iterator.next时会检查修改次数是否一致，如果不一致，则会报错ConcurrentModificationException；</p><blockquote><p>注：由于hasnext是检查当前已经迭代的数量是否等于集合大小，如果删除倒数第二个数据，集合size–，就会使size &#x3D;&#x3D; 已经迭代的个数，所以会漏掉最后一项数据，即最后一遍循环不执行，iterator.next不执行，也就不会报错。</p></blockquote></li></ul><ol start="2"><li><p>使用for循环增强</p><p>增强for就是简化版的iterator，本质一样，只能用于遍历集合或数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素类型 元素名 ： 集合名/数组名)&#123;</span><br><span class="line">访问元素</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(Object object : col)&#123;</span><br><span class="line">    System.out.println(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h3><ul><li>元素有序（添加和取出的顺序一致），有索引</li><li>元素可重复</li></ul><p>List接口常用方法：add，add（index，Object），get，indexOf，lastIndexOf，remove，set，subList（fromIndex，toIndex）(注意fromIndex &lt;&#x3D; subList &lt; toIndex)</p><p>ArrayList和Vector基本等同，区别在线程是否安全</p><p>ArrayList类：效率较高，但线程不安全</p><p>创建 ArrayList 对象时，如果使用的是无参构造器，则初始 elementData 容量为0，第一次添加，则扩容elementData 为10，后面再次扩容，则扩容为原来的1.5倍 + 1；如果使用指定大小的构造器，则初始elementData 为指定大小，再次扩容，则为原来的1.5倍 + 1。</p><hr><p>Vector类：线程安全，效率比ArrayList低</p><p>Vector类的操作方法带有synchronized。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &gt;= elementCount)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ArrayIndexOutOfBoundsException</span>(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vector扩容：无参构造，默认10；扩容为原来的2倍</p><hr><p>LinkList类：底层实现了双向链表和双端队列的特点，线程不安全，没有实现同步；</p><ul><li>LinkList维护了两个属性：first指向首节点，last指向尾节点，</li><li>每个节点（Node对象）又维护了三个属性：prev指向前一个，next指向下一个，item存放数值；</li></ul><hr><h3 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h3><ul><li>无序（添加和取出的顺序不一致，但存放位置是固定的），没有索引</li><li>不允许重复元素，所以最多包含一个null</li></ul><p>Set常用方法，因为也是Collection的子接口，所以常用方法和Collection接口一样</p><p>遍历方式：迭代器，增强for（但不能使用索引方式来获取）</p><p><strong>HashSet类</strong></p><p>HashSet实现了Set接口，实际上是HashMap</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashSet的构造器</span></span><br><span class="line">pUblic <span class="title function_">HashSet</span><span class="params">()</span>&#123;</span><br><span class="line">map = <span class="keyword">new</span> <span class="title class_">HashMap</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>LinkedHashSet类</strong></p><p>LinkedHashSet是HashSet的子类，底层是LinkedHashMap，底层中维护了一个hash表和双向链表；</p><p><strong>LinkedHashMap类</strong></p><p>LinkedHashMap中有<strong>头节点head和尾节点tail</strong>（指向第一个添加的节点和最后添加的节点），还创建了<strong>Entry类</strong>来存放节点，它继承自HashMap.Node类，<strong>每个节点有before和after属性</strong>。</p><ul><li>LinkedHashMap根据元素的hashCode值来决定元素的存储位置，同时使用链表维护元素的次序，使得元素看起来是以插入顺序保存的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tail.next = newElenment</span><br><span class="line">newElement.pre = tail;</span><br><span class="line">tail = newElement;</span><br><span class="line"><span class="comment">//新加入节点和末尾节点相连；</span></span><br><span class="line"><span class="comment">//这样，遍历LinkedHashMap时也能确保插入顺序和遍历顺序一致</span></span><br></pre></td></tr></table></figure><h3 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map中用于保存具有映射关系的数据：Key - Value</p><p>key不允许重复，只能有一个key为null；value允许重复，可以有多个null；</p><p><strong>遍历方式：</strong></p><p><strong>containsKey：查找键是否存在</strong></p><p><strong>keySet：获取所有的键</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">ks</span> <span class="operator">=</span> map.keySet();</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span>(Object key : ks)&#123;</span><br><span class="line">System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> ks.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">key</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet：获取所有的关系k - v</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span> <span class="variable">entrySet</span> <span class="operator">=</span> map.entrySet();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span> (Object entry : entrySet) &#123;</span><br><span class="line"><span class="comment">//将 entry 转成 Map.Entry</span></span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValue());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> entrySet.iterator();</span><br><span class="line"><span class="keyword">while</span> (ite.hasNext()) &#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">entry</span> <span class="operator">=</span> ite.next();</span><br><span class="line"><span class="comment">//向下转型 Map.Entry</span></span><br><span class="line">Map.<span class="type">Entry</span> <span class="variable">m</span> <span class="operator">=</span> (Map.Entry) entry;</span><br><span class="line">System.out.println(m.getKey() + <span class="string">&quot;-&quot;</span> + m.getValues());</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p><strong>values：获取所有的值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Collection</span> <span class="variable">val</span> <span class="operator">=</span> map.values();</span><br><span class="line"><span class="comment">//增强for</span></span><br><span class="line"><span class="keyword">for</span>(Object value : val)&#123;</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line"><span class="type">Iterator</span> <span class="variable">ite</span> <span class="operator">=</span> val.iterator();</span><br><span class="line"><span class="keyword">while</span>(ite.hasNext())&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> ite.next();</span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>HashMap类</strong></p><p>如果添加相同的key，则会<strong>覆盖原来的key - value，相当于修改了value</strong>；</p><p>底层没有实现同步，<strong>线程不安全</strong>；</p><p>HashMap底层：<strong>数组+链表+红黑树</strong>（不保证映射顺序）</p><ol><li>先获取元素的哈希值（hashcode方法）；</li><li>对哈希值进行运算，得出一个索引值即为要存放在哈希表中的位置；（用（length-1）&amp;hash得到数组下标）</li><li>如果该位置上没有其他元素，则直接存放，如果有，则需要进行equals判断，如果相等，则不添加，如果不等，则以链表的方式添加；</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算hash值的算法，“扰动函数”</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line"><span class="type">int</span> h;</span><br><span class="line"><span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容机制：</p><ol><li>第一次添加时，table数组扩容到<strong>16</strong>，临界值（threshold）是16 * <strong>加载因子（loadFactor &#x3D; 0.75）</strong>&#x3D; 12；</li><li>如果table数组使用到临界值12，就会扩容到16*2 &#x3D; 32，新的临界值为32 * 0.75 &#x3D; 24；</li><li>在Java8中，如果一条链表的<strong>元素个数到达TREEIFY_THRESHOLD（默认是8），且table大小&gt;&#x3D;MIN_TREEIFY_CAPACITY（默认是64），就会进行树化（红黑树）</strong>；（table是HashMap的一个数组，类型是Node[]）</li><li>如果链表的元素个数达到8以上，但table不足64，会将元素加入链表后，对table进行一次扩容。</li></ol><hr><p><strong>Hashtable类</strong></p><p>存放的元素的键值对：K - V ，键和值都<strong>不能为null</strong>，否则会抛出NullPointerException；</p><p>是<strong>线程安全</strong>的（效率比HashMap低）</p><p>（使用方法和HashMap基本一样）</p><hr><p><strong>Properties类</strong></p><p>Properties类<strong>继承自Hashtable类并实行了Map接口</strong>；键和值同样<strong>不能为null</strong>，否则会抛出NullPointerException；</p><p>特点：可以用于<strong>从xxx.properties文件中，加载数据到Properties类对象，并进行读取和修改</strong>（工作中，xxx.properties文件<strong>通常为配置文件</strong>）</p><hr><p>一道<strong>练习</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">&quot;BB&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(p1);<span class="comment">//OK</span></span><br><span class="line">set.add(p2);<span class="comment">//OK</span></span><br><span class="line">p1.name = <span class="string">&quot;CC&quot;</span>;</span><br><span class="line">set.remove(p1);<span class="comment">//name被修改过，找不到，删除失败</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;CC&quot;</span>);<span class="comment">//OK</span></span><br><span class="line">set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>,<span class="string">&quot;AA&quot;</span>);<span class="comment">//OK</span></span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>泛型又称参数化类型。</p><p>java中的泛型<strong>只在编译阶段有效</strong>，在编译之后程序会采取去泛型化的措施。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//泛型声明</span></span><br><span class="line">interface 接口&lt;T&gt; &#123;&#125;<span class="comment">//泛型接口</span></span><br><span class="line">class 类&lt;K,V&gt;&#123;&#125;<span class="comment">//泛型类</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>&#123;&#125;<span class="comment">//泛型方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化,在类名后面指定类型参数的值</span></span><br><span class="line">List&lt;String&gt; strList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br></pre></td></tr></table></figure><ul><li><p>T，E …只能是引用类型，不能是基本数据类型</p></li><li><p>在给泛型指定具体类型后，可以传入该类型的子类类型</p></li><li><p>要注意，在静态方法中使用泛型，必须将静态方法定义成泛型方法。因为静态方法访问在类上定义的泛型，不能引用不确定的数据类型。</p></li><li><p>如果在创建对象时，没有指定类型，默认为Object</p></li><li><p>泛型接口的类型，在<strong>继承接口</strong>或<strong>实现接口</strong>时确定</p></li><li><p>java中不能创建一个确切的泛型类型的数组；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;[<span class="number">10</span>]; <span class="comment">//这样是不允许的</span></span><br><span class="line"></span><br><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;[<span class="number">10</span>];<span class="comment">//这样可以</span></span><br><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[<span class="number">10</span>];<span class="comment">//这样也可以</span></span><br></pre></td></tr></table></figure><p>解释：由于JVM泛型的擦除机制，在运行时JVM不知道泛型信息，可以将一个确切数据类型的数据加入，但在取出数据时却还要做一次类型转换，所以有可能出现ClassCastException。如果可以进行泛型数组的声明，则这种情况不会在编译期进行警告和错误，只有到运行时才出错，所有对泛型数据的声明进行限制可以防止运行时的错误发生；</p><p>而使用通配符，最后取出数据要做显式的类型转换，所以没问题；</p></li></ul><hr><p><strong>泛型上下边界</strong></p><p>在使用泛型的时候，我们还可以为传入的泛型类型实参进行<strong>上下边界的限制</strong>，如：类型实参只准传入某种类型的父类或某种类型的子类。</p><p><strong>泛型通配符 &lt;?&gt;</strong> ：支持任意泛型类型</p><p><strong>&lt; ? extends A &gt;</strong> ：支持<strong>A类以及A类的子类</strong>，规定了泛型的上限</p><p><strong>&lt; ? super A&gt;</strong> ：支持<strong>A类以及A类的父类</strong>，不限于直接父类，规定了泛型的下限</p><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><p><strong>创建文件</strong>的三种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：new File(String pathname) </span></span><br><span class="line">   <span class="comment">//根据路径构建一个File对象</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\news1.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(filePath);</span><br><span class="line">   <span class="comment">//上面的file1对象，在java程序中，只是一个对象，只有执行了CreatNewFile方法，才会在磁盘创建该文件</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">       System.out.println(<span class="string">&quot;creat successful&quot;</span>);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法二：new File(File parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录文件+之路径构建</span></span><br><span class="line">   <span class="type">File</span> <span class="variable">parentFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;e:\\&quot;</span>);</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName</span> <span class="operator">=</span> <span class="string">&quot;news2.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName);   </span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file1.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//方法三：new File(String parent, String child)</span></span><br><span class="line">   <span class="comment">//根据父目录+子目录构建</span></span><br><span class="line">   <span class="type">String</span> <span class="variable">parentPath</span> <span class="operator">=</span> <span class="string">&quot;e:\\&quot;</span>;</span><br><span class="line">   <span class="type">String</span> <span class="variable">fileName1</span> <span class="operator">=</span> <span class="string">&quot;news3.txt&quot;</span>;</span><br><span class="line">   <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(parentFile, fileName1);</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       file.createNewFile();</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">       e.printStackTrace();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><p><strong>获取文件的相关信息：</strong></p><p>getName()，length()，</p><p>getAbsolutePath()：获取绝对路径</p><p>getParent()：获取父目录</p><p>exist()：文件是否存在</p><p>isFile()：是不是文件</p><p>isDirectory()：是不是目录</p><hr><p><strong>目录的操作和文件删除：</strong></p><p>mkdir：创建一级目录</p><p>mkdirs：创建多级目录</p><p>delete：删除空目录或空文件</p><h3 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h3><p>I&#x2F;O 是Input &#x2F; Output 的缩写，用于处理数据传输，如：读写文件、网络通讯等；</p><p><strong>输入input</strong>：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</p><p><strong>输出output</strong>：将程序（内存)中的数据输出到磁盘等存储设备中；</p><p><strong>分类：</strong></p><ul><li>按操作的数据单位不同：字节流文件（二进制文件），字符流文件（文本文件）；</li><li>按数据流的流向不同：输入流，输出流；</li><li>按流的角色的不同：节点流，处理流（包装流）；</li></ul><table><thead><tr><th></th><th>字节流</th><th>字符流</th></tr></thead><tbody><tr><td>输入流</td><td>InputStream</td><td>Reader</td></tr><tr><td>输出流</td><td>OutputStream</td><td>Writer</td></tr></tbody></table><p>由上面四个类派生出来的子类名称 都是以其父类名作为子类名后缀</p><p>体系图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/20200307125658523.png" alt="img"></p><h4 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一次接受一个字节的数据</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">readData</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//接受单个直接的数据</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//read()无参时会返回单个字节的数据</span></span><br><span class="line">        <span class="comment">//读取完毕，会返回-1</span></span><br><span class="line">        <span class="keyword">while</span>((readData = fis.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print((<span class="type">char</span>)readData);<span class="comment">//转为char显示</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();<span class="comment">//记得要关闭文件流，释放资源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字节数据一次接受多个数据，效率更高</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">readFile2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];<span class="comment">//一次读取8个字节</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath);</span><br><span class="line">        <span class="comment">//一次最多读取8字节，返回读取读取字节的数量</span></span><br><span class="line">        <span class="keyword">while</span>((readLen = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.print(<span class="keyword">new</span> <span class="title class_">String</span>(buf, <span class="number">0</span>, readLen));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace;</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeFile</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filePath, <span class="literal">true</span>);<span class="comment">//再加一个true，表示写入内容追加到文件末尾，不加true，则表示覆盖原来的内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        fos.write(str.getBytes(),<span class="number">0</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="FileReader-和-FileWriter"><a href="#FileReader-和-FileWriter" class="headerlink" title="FileReader 和 FileWriter"></a>FileReader 和 FileWriter</h4><p>FileReader —&gt; InputStreamReader —&gt;Reader</p><p>FileReader  —&gt;  InputStreamReader —&gt;Reader</p><p>使用方法跟上面的差不多</p><p>注意：<strong>对于字符流，记得操作完后要关闭文件流，或使用flush()，否则更新内容不会保存</strong></p><hr><h4 id="节点流和处理流"><a href="#节点流和处理流" class="headerlink" title="节点流和处理流"></a>节点流和处理流</h4><p>节点流 ：从一个特定的数据源读写数据，如FileReader，FileWriter；</p><p>处理流（包装流）：是连接在已存在的流（节点流&#x2F;处理流）之上，提供了更方便，更强大的读写功能，如BufferedReader，BufferedWriter。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707038.png" alt="image-20211007204910829"></p><p>节点流是底层流，直接跟数据源相接。</p><p>处理流包装节点流，既可以<strong>消除不同节点流的实现差异，也可以提供更方便的方法</strong>；处理流使用了修饰器设计模式，<strong>不会直接与数据源相连</strong>。</p><p>处理流对性能的提高：主要<strong>以增加缓冲的方式来提高输入输出的效率</strong>；</p><hr><p>（BufferedReader，BufferedWriter是字符流，不要去操作二进制文件（声音、视频、pdf等），可能造成文件损坏）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedReader</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(filePath));<span class="comment">//将</span></span><br><span class="line">    String line;<span class="comment">//按行读取</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>((line = br.readLine()) != <span class="literal">null</span>)&#123;<span class="comment">//读取完毕，返回null</span></span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();<span class="comment">//关闭外层流即可，以为底层会去关闭内层的流</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BufferedWriter</span></span><br><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\hello.txt&quot;</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(filePath));</span><br><span class="line">    bw.write(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    bw.newLine();<span class="comment">//插入一个和系统相关的换行</span></span><br><span class="line">    bw.write(<span class="string">&quot;hello,hello,world&quot;</span>);</span><br><span class="line">    bw.close();</span><br></pre></td></tr></table></figure><hr><p><strong>BufferedInputStream 和 BufferedOutputStream</strong></p><p>（是字节流，创建时，内部会创建一个缓冲区数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用BufferedInputStream 和 BufferedOutputStream将一个二进制文件的内容拷贝到另一个文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">File01</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">srcFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.java&quot;</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">destFilePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a3.java&quot;</span>;</span><br><span class="line">        <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//因为 FileInputStream 是 InputStream 子类</span></span><br><span class="line">            bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFilePath));</span><br><span class="line">            bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFilePath));</span><br><span class="line">            <span class="comment">//循环的读取文件，并写入到 destFilePath</span></span><br><span class="line">            <span class="type">byte</span>[] buff = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">readLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//当返回 -1 时，就表示文件读取完毕</span></span><br><span class="line">            <span class="keyword">while</span> ((readLen = bis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bos.write(buff, <span class="number">0</span>, readLen);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;文件拷贝完毕~~~&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (bis != <span class="literal">null</span>) &#123;  <span class="comment">//因为对象为空会被自动回收，但此时对象还在，需要手动关闭</span></span><br><span class="line">                    bis.close();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (bos != <span class="literal">null</span>) &#123;</span><br><span class="line">                    bos.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h4><p><strong>ObjectOutputStream ：提供 序列化功能 ObjectInputStream ：提供 反序列化</strong></p><hr><p>序列化：在保存数据时，保存数据的值和数据类型</p><p>反序列化：恢复数据时，恢复数据的值和数据类型</p><p>想要让对象支持序列化机制，其类应该是可序列化的，必须实现两个接口之一：<strong>Serializable</strong>（是一个标记接口，没有方法）或  Externalizable（有方法需要实现，所以一般实现Serializable接口）</p><hr><p>注意：</p><ul><li>读写顺序要一致；</li><li>要求对象实现Serializable</li><li>为了提高版本的兼容性，序列化的类中建议添加SerialVersionUID</li><li>序列化对象时，默认将里面所有属性都进行序列化，除了static或transient修饰的成员</li><li>序列化对象时，要求其属性的类型也实现序列化接口</li><li>序列化具备可继承性，即实现了序列化的类，它的子类默认也实现了序列化</li></ul><hr><h4 id="标准输入输出流"><a href="#标准输入输出流" class="headerlink" title="标准输入输出流"></a>标准输入输出流</h4><table><thead><tr><th></th><th>类型</th><th>默认设备</th></tr></thead><tbody><tr><td>System.in标准输入</td><td>InputStream</td><td>键盘</td></tr><tr><td>System.out标准输出</td><td>PrintStream</td><td>显示器</td></tr></tbody></table><h4 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h4><p><strong>InputStreamReader</strong>和<strong>OutputStreamWriter</strong></p><p>可以将字节流转换成字符流，同时可以指定编码格式（如：utf-8，gbk等）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">filePath</span> <span class="operator">=</span> <span class="string">&quot;e:\\a.txt&quot;</span>;</span><br><span class="line"><span class="comment">//把 FileInputStream 转成 InputStreamReader，并指定编码</span></span><br><span class="line"><span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filePath), <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"><span class="comment">//3. 把 InputStreamReader 传入 BufferedReader</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(isr);</span><br><span class="line">br.close();</span><br></pre></td></tr></table></figure><hr><h4 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h4><p>打印流只有输出流，没有输入流</p><p><strong>PrintStream</strong> 和  <strong>PrintWriter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">out</span> <span class="operator">=</span> System.out;</span><br><span class="line"><span class="comment">//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器</span></span><br><span class="line">out.print(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">out.write(<span class="string">&quot;你好&quot;</span>);<span class="comment">//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印输出(当s为空时，print方法会打印&quot;null&quot;);</span></span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以修改打印流输出的位置/设备</span></span><br><span class="line"><span class="comment">//这里修改，打印到 e:\\f1.txt</span></span><br><span class="line">System.setOut(<span class="keyword">new</span> <span class="title class_">PrintStream</span>(<span class="string">&quot;e:\\f1.txt&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="properties类"><a href="#properties类" class="headerlink" title="properties类"></a>properties类</h4><p>专门用于<strong>读写配置文件</strong>的集合类</p><p>配置文件的格式：<strong>键&#x3D;值</strong></p><p>（不用空格，值不需要引号，默认类型时String）</p><hr><p>常用方法：</p><p><strong>load</strong>：加载配置文件的键值对到Properties对象；</p><p><strong>list</strong>：将数据显示到指定设备；</p><p><strong>getProperty（key）</strong>：根据键 取 值</p><p><strong>setProperty（key，value）</strong>：设置键值对</p><p><strong>store</strong>：键Properties对象中的键值对存储到配置文件（在idea中，保存信息到配置文件，如果含有中文，会存储为unicode码）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Properties</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">   p.load(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>));</span><br><span class="line">   p.list(System.out); <span class="comment">//将K-V显示到控制台</span></span><br><span class="line">   p.setProperty(<span class="string">&quot;pwd&quot;</span>, <span class="string">&quot;888888&quot;</span>);</span><br><span class="line">   p.store(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;src\\mysql.properties&quot;</span>), <span class="literal">null</span>);</span><br></pre></td></tr></table></figure><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><ul><li><p>进程：一个独立的正在执行的程序；</p><p>多进程：在操作系统中，同时运行多个程序；</p><ul><li>多进程好处：可以充分利用CPU，提高CPU使用率；</li></ul></li><li><p>线程：一个进程的最基本的执行单位，执行路径；</p><p>多线程：在同一个进程（应用程序）中同时执行多个线程</p><ul><li>多线程好处：提高进程的执行使用率，提高CPU的使用率</li></ul></li><li><p>并发：同一时刻，多个任务交替执行；</p><p>并行：同一时刻，多个任务同时执行，多核cpu可以实现并行；</p></li></ul><p>注意：</p><ol><li>在同一个时间点，一个CPU中只能有一个线程在执行；</li><li>多线程会降低效率，但可以提高CPU使用率；</li><li>一个进程如果有多条执行路径，则称为多线程程序；</li><li>Java虚拟机的启动至少开启两条进程：主线程和垃圾回收线程；</li><li>一个线程可以理解为进程的子任务；</li></ol><h3 id="线程实现方式"><a href="#线程实现方式" class="headerlink" title="线程实现方式"></a>线程实现方式</h3><ol><li>继承Thread类，重写run方法；</li><li>实现Runnable接口，重写run方法；</li></ol><p>（Thread类实现了Runnable接口，Runnable接口里面只有一个方法run() ）</p><ul><li>调用start方法，才是真正开启了一个子线程，调用run方法不会开启新的线程（所处的线程还是执行调用的那个线程）</li><li>start() 方法调用了start0()方法， start0()方法是本地方法，由JVM调用，底层是C&#x2F;C++实现， start0()真正实现多线程的效果。</li><li>start() 方法调用start() 方法后，该线程不一定会立即执行，只是将线程变成了可运行的状态。具体什么时候执行，取决于CPU，由CPU统一调度。</li></ul><p><strong>方法一：继承Thread类</strong></p><p>当一个类继承了Thread类，该类就可以当作线程使用，并在run方法里写上自己的业务代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Thread01</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread01</span> <span class="variable">thread01</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread01</span>();<span class="comment">//创建线程对象</span></span><br><span class="line">        thread01.start();<span class="comment">//开启线程</span></span><br><span class="line">        </span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);<span class="comment">//让主线程休眠1秒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>方法二：实现Runnable接口</strong></p><p>可能一个类已经继承了某个父类，再继承Thread类来创建线程显然不可能。此时可以通过实现Runnable接口来创建进程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;<span class="comment">//重写run方法</span></span><br><span class="line">        <span class="keyword">while</span>(flag)&#123;</span><br><span class="line">            times++;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(times &gt; <span class="number">15</span>) </span><br><span class="line">                flag = flase;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">AA</span> <span class="variable">aa</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AA</span>();</span><br><span class="line">        <span class="comment">//不能用aa.start()来调用start，</span></span><br><span class="line">        <span class="comment">//应该创建Thread对象，把对象aa（需要实现了Runnable）放进Thread；</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(aa);</span><br><span class="line">        thead.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>继承Thread 和 实现Runnable 的区别</strong></p><p>从本质上来讲是没有区别的；</p><p>不过实现Runnable接口的方式更加适合多个线程共享一个资源的情况，并且避免了单继承的限制（建议使用Runnable）</p><hr><p><strong>线程终止</strong></p><ol><li>当线程完成任务后，会自动退出；</li><li>可以通过<strong>使用变量</strong>来控制run方法退出的方式来停止线程，即<strong>通知方式</strong></li></ol><hr><h3 id="线程常用方法"><a href="#线程常用方法" class="headerlink" title="线程常用方法"></a>线程常用方法</h3><p><strong>setName</strong>  ： 设置线程名称，赋值给name；</p><p><strong>getName</strong> ： 返回该线程的名称；</p><p><strong>start</strong>：使该线程开始执行（JVM底层调用该线程的start0方法）；</p><p><strong>run</strong>：调用该线程对象的run方法；</p><p><strong>setPriority</strong>：更改线程的优先级；</p><p><strong>getPriority</strong>：获取线程的优先级；</p><p><strong>sleep</strong>：让当前正在执行的线程在指定的毫秒数内休眠（线程的静态方法，使当前线程暂停休眠）</p><p><strong>interrupt</strong>：中断线程（不是终止线程，一般用于中断线程的休眠状态）；</p><p><strong>yield</strong>：线程的礼让。让出CPU，让其他线程先执行，但礼让的时间不确定，也不一定能礼让成功；</p><p><strong>join</strong>：线程的插队。插队的线程一旦插队成功，则肯定先执行完插入的线程所有的任务；（t1.join() ）</p><hr><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p><strong>用户线程和守护线程：</strong></p><ul><li>用户线程：也叫工作线程</li><li>守护线程：一般是为工作线程服务的，当所有的用户线程结束，守护线程自动结束。（常见的守护线程：垃圾回收机制）</li></ul><p>使用<strong>setDaemon</strong>方法将普通线程设为守护线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Runnable</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r1, <span class="string">&quot;A&quot;</span>);</span><br><span class="line">t1.setDaemon(<span class="literal">true</span>);</span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure><p>守护线程的优先级非常低；</p><p><strong>TimerTask</strong></p><p>守护线程经常要做一些周期性的操作，如：每5分钟执行某操作，每天12点执行某操作等；此时可以用到Java的计时器的工具类：Timer和TimerTask</p><h3 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h3><p>JDK中用<strong>Thread.State</strong>枚举了线程的六种状态：</p><ol><li><strong>NEW</strong>：（new）尚未启动的线程 处于此状态</li><li><strong>RUNNABLE</strong>：（runnable）在java虚拟机中执行的线程 处于此状态</li><li><strong>BLOCKED</strong>：（blocked）被阻塞等待监视器锁定的线程 处于此状态</li><li><strong>WAITING</strong>：正在等待另一个线程执行特定动作的线程 处于此状态</li><li><strong>TIMED_WAITING</strong>：正在等待另一个线程执行动作达到指定等待时间的线程 处于此状态</li><li><strong>TERMINATED</strong>：已退出的线程 处于此状态</li></ol><p>线程状态转换图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707039.png" alt="image-20211006205038275"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707040.png" alt="image-20211007085636266"></p><h3 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h3><p>在多线程编程中，为了防止部分数据被多个线程同时访问，所有就使用同步访问计数，保证数据在任何 同一时刻，最多被一个线程访问，以保证数据的完整性</p><p>实现同步的方法：<strong>Synchronized &#x2F; Lock</strong></p><p><strong>Synchronized</strong></p><ul><li><p>同步代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象)&#123;<span class="comment">//需要对象的锁，才能操作同步代码</span></span><br><span class="line">    被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line">     被同步的代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态同步方法的锁是加在当前类本身</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> vodi <span class="title function_">method</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>同步方法如果没有使用static修饰，默认锁对象是this，如果方法由static修饰，默认锁对象：当前类.class</p><p><strong>Lock</strong></p><p>Lock 是一种比 Synchroized更加灵活的一种加锁方式，使用的时候必须显示的加锁 ：lock.lock ，然后 在释放锁的时候我们也需要显示的 lock.unlock 调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(flag)&#123;</span><br><span class="line">        lock.lock;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Thread.sleep();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p><strong>互斥锁：</strong></p><p>保证共享数据操作的完整性；每个对象都对应于一个可称为“互斥锁”的标记，这个标记用于保证在任一时刻，都只能有一个线程访问该对象；</p><p>关键字synchronized来与对象的互斥锁联系。当某个对象用synchronized修饰时，表明该对象在任一时刻只能由一个线程访问；</p><p><strong>死锁：</strong></p><p>多个线程都占用了对方的锁资源，但不肯让出资源，导致了死锁（必须要避免死锁发生）</p><p><strong>释放锁：</strong></p><ol><li>当前线程的同步方法，同步代码块执行结束；</li><li>当前线程在同步方法，同步代码块中遇到break，return；</li><li>当前线程在同步方法，同步代码块中出现了未处理的Error或Exception，导致异常结束；</li><li>当前线程在同步方法，同步代码块中执行了线程对象的wait()方法，当前线程暂停，并释放锁；</li></ol><p>注意：下面操作不会释放锁</p><ol><li>线程执行同步方法，同步代码块时，程序调用了Thread.sleep()，Thread.yied()方法暂停当前线程的执行，不会释放锁；</li><li>线程执行同步代码块时，其他线程调用了该线程的suspend() 方法将该线程挂起，该线程不会释放锁；（尽量避免使用suspend() 和resume() 来控制程序，方法不再推荐使用）</li></ol><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><p>java.net包中包含的类和接口，提供了低层次的通信细节，因此我们专注于网络程序开发，而不用考虑通信的细节。</p><p><strong>java.net</strong>包中提供了两种常见的网络协议的支持：<strong>TCP和UDP</strong>；</p><p>而对于IP地址，java中的<strong>InetAddress类</strong>表示<strong>互联网协议（IP）地址</strong>；</p><hr><h3 id="InetAddress类"><a href="#InetAddress类" class="headerlink" title="InetAddress类"></a>InetAddress类</h3><p>无构造方法</p><p>常用方法：</p><p>**type[] getAddress( )**：返回此InetAddress对象的原始IP地址</p><p>**static Inetaddress getByName(String host)**：在给定主机名的情况下确定主机的IP地址</p><p>**String getHostAddress( )**：返回IP地址字符串（以文本表现形式）</p><p>**String getHostName( )**：获取此IP地址的主机名</p><p>**static InetAddress getLocalHost( )**：返回本地主机</p><blockquote><p>127.0.0.1：本地主机，主要用于测试。</p><p>别名：Localhost</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">InetAddress</span> <span class="variable">inetAddress</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);</span><br><span class="line"><span class="comment">// 获取此 IP 地址的主机名。</span></span><br><span class="line">System.out.println(inetAddress.getHostName());</span><br><span class="line"><span class="comment">//返回 IP 地址字符串（以文本表现形式）。</span></span><br><span class="line">System.out.println(inetAddress.getHostAddress());</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//www.baidu.com</span></span><br><span class="line"><span class="comment">//14.215.177.39</span></span><br></pre></td></tr></table></figure><hr><h3 id="InetSocketAddress类"><a href="#InetSocketAddress类" class="headerlink" title="InetSocketAddress类"></a>InetSocketAddress类</h3><p>InetSocketAddress类实现了<strong>IP套接字地址（IP地址+端口号）</strong></p><p>注意：</p><ul><li>编写的程序要占用端口号的话 只占用1024以上的端口号，<strong>1024以下的端口号不要去占用，因为系统有可能会随时征用。端口号本身又分为TCP端口和UDP端口，TCP的8888端口和UDP的8888端口是完全不同的两个端口。TCP端口和UDP端口都有65536个</strong>。（端口的表示是一个16位的二进制整数，2个字节，对应十进制的<strong>0~65535</strong>）(ssh 22, ftp 21, smtp, 25, http 80, tomcat 2020, mysql 3306, oracle 1521, sqlserver 1433)</li></ul><blockquote><p><strong>DOS命令查看端口：</strong></p><ul><li>查看所有端口：netstat  -ano</li><li>查看指定端口：netstat  -ano|findstr “端口号”</li><li>查看指定端口的进程：tasklist|findstr “端口号”</li></ul></blockquote><p>InetSocketAddress类：</p><p><strong>构造方法</strong>：</p><p><strong>InetSocketAddress ( InetAddress addr, int port)</strong> ：根据IP地址和端口号创建套接字地址。</p><p>**InetSocketAddress ( int port)**：创建套接字地址，其中IP地址为通配符地址，端口号为指定值。</p><p>**InetSocketAddress ( String hostname, int port)**：根据主机名和端口号创建套接字地址。</p><p>常用方法：</p><p>**InetAddress getAddress( )**：获取InetAddress（IP对象)</p><p><strong>String</strong> getHostName( )：获取主机名</p><p>**int getPort( )**：获取端口号</p><hr><h3 id="TCP网络编程："><a href="#TCP网络编程：" class="headerlink" title="TCP网络编程："></a>TCP网络编程：</h3><p>TCP通信能实现两台计算机之间的数据交互，通信的两端，要<strong>严格区分为客户端（Client）与服务端（Server）。</strong></p><p><strong>两端通信时步骤</strong>：</p><ol><li>服务端程序，需要<strong>事先启动</strong>，等待客户端的连接。</li><li>客户端主动连接服务器端，连接成功才能实现通信。服务端不可以主动连接客户端。</li></ol><p>java提供了两个类用于实现TCP通信程序：</p><ol><li>客户端：用 java.net.Socket类实现。创建Socket对象，向服务端发出连接请求，服务端响应请求，两者建立连接开始通信。</li><li>服务端：用 java.netServerSocket类实现。创建ServerSocket对象，相当于开启一个服务，等待客户端的连接。</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707041.png" alt="image-20211011200948784"></p><h4 id="Socket类"><a href="#Socket类" class="headerlink" title="Socket类"></a>Socket类</h4><p>Socket类实现客户端套接字，套接字指的是两台设备间通讯的端点。</p><p><strong>构造方法：</strong></p><p>**public Socket ( String host, int port)**：创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。</p><blockquote><p>回送地址（127.0.0.1）是本机回送地址（Loopback   Address），主要用于网络让江测试以及本地机进程间通讯，无论什么程序，一旦使用回送地址发送数据，会立即返回，不进行任何网络传输。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//示例：</span></span><br><span class="line"><span class="type">Socket</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>**public InputStream getInputStream( )**：返回此套接字的输入流</p><ul><li>如果此Scoket具有相关联的通道，则生成的InputStream 的所有操作也关联该通道。</li><li>关闭生成的InputStream也将关闭相关的Socket。</li></ul><p>**public OutputStream getOutputStream( )**：返回此套接字的输出流</p><ul><li>如果此Socket具有相关联的通道，则生成的OutputStream 的所有操作也关联该通道。</li><li>关闭生成的OutputStream也将关闭相关的Socket。</li></ul><p>**public void closs( )**：关闭此套接字</p><ul><li>一旦一个socket被关闭，它不可再使用。</li><li>关闭此socket也将关闭相关的InputStream和OutputStream 。</li></ul><p><strong>public void shutdownOutput( )</strong> ： 禁用此套接字的输出流。</p><ul><li>任何先前写出的数据将被发送，随后终止输出流。</li></ul><hr><h4 id="ServerSocket类"><a href="#ServerSocket类" class="headerlink" title="ServerSocket类"></a>ServerSocket类</h4><p><code>ServerSocket</code>类实现了服务器套接字，该对象等待通过网络的请求。</p><p><strong>构造方法：</strong></p><p>**public ServerSocket( int port)**：创建ServerSocket对象，并将其绑定到一个指定的端口号上，参数port就是端口号。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ServerSocket</span> <span class="variable">server</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">6666</span>);</span><br></pre></td></tr></table></figure><p><strong>常用方法：</strong></p><p>**public Socket accept( )**：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。该方法会一直柱塞直到建立连接。</p><p>注意：</p><ul><li>服务器是没有IO流的，服务器可以获取到请求的客户端对象socket；</li><li>使用每个客户端socket中提供的IO流和客户端进行交互；</li><li>服务器使用客户端的字节输入流读取客户端发送的数据；</li><li>服务器使用客户端的字节输出流给客户端回写数据；</li></ul><hr><p>示例：客户端向客户端发送消息，服务端向客户端回写消息</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建Socket对象，它的第一个参数需要的是服务端的IP，第二个参数是服务端的端口</span></span><br><span class="line">            <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet, <span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、获取一个输出流，用于写出要发送的数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是客户端！&quot;</span>.getBytes());</span><br><span class="line">            <span class="comment">//==========================解析回复==================================</span></span><br><span class="line">            <span class="comment">//4、首先必须通知服务器，我已经输出完毕了，不然服务端不知道什么时候输出完毕</span></span><br><span class="line">            <span class="comment">//服务端的while循环会一直执行，会阻塞</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            <span class="comment">///5、获取输入流，用于读取服务端回复的数据</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自服务端的消息：&quot;</span> + baos.toString());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//6、释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TCPServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">serverSocket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、创建服务端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">            <span class="comment">//2、调用accept接收到来自于客户端的socket</span></span><br><span class="line">            socket = serverSocket.accept();<span class="comment">//阻塞式监听，会一直等待客户端接入</span></span><br><span class="line">            <span class="comment">//3、获取socket的输入流</span></span><br><span class="line">            is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line"><span class="comment">//        不建议这样写：因为如果我们发送的数据有汉字，用String的方式输出可能会截取汉字，产生乱码</span></span><br><span class="line"><span class="comment">//        int len=0;</span></span><br><span class="line"><span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line"><span class="comment">//        while ((len=is.read(buffer))!=-1)&#123;</span></span><br><span class="line"><span class="comment">//            String str = new String(buffer, 0, len);</span></span><br><span class="line"><span class="comment">//            System.out.println(str);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、读取输入流中的数据</span></span><br><span class="line">            <span class="comment">//ByteArrayOutputStream的好处是它可以根据数据的大小自动扩充</span></span><br><span class="line">            baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                baos.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;收到了来自于客户端&quot;</span> + socket.getInetAddress().getHostName()</span><br><span class="line">                    + <span class="string">&quot;的消息：&quot;</span> + baos.toString());</span><br><span class="line">            <span class="comment">//===========================回复==========================================</span></span><br><span class="line">            <span class="comment">//5、获取一个输出流，写出回复给客户端</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//6、写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好，我是服务端&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;<span class="comment">//7、关闭资源</span></span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (is != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    is.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (baos != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    baos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (os != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><p><code>java.net</code>包提供了两个类DatagramSocket类和DatagramPacket类</p><ul><li><code>DatagramSocket</code>类：表示用于发送和接收数据报的套接字</li><li><code>DatagramPacket</code>类：表示数据报的数据包。</li></ul><hr><h4 id="DatagramSocket类"><a href="#DatagramSocket类" class="headerlink" title="DatagramSocket类"></a>DatagramSocket类</h4><p><strong>构造方法：</strong></p><p>**protected DatagramSocket()**：构造数据报套接字并将其绑定到本地主机上的任何可用端口。</p><p>**protected DatagramSocket(int port)**：构造数据报套接字并将其绑定到本地主机上的指定端口。</p><p>**protected DatagramSocket(int port, InetAddress laddr)**：创建一个数据报套接字，绑定到指定的本地地址。</p><hr><h4 id="DatagramPacket类"><a href="#DatagramPacket类" class="headerlink" title="DatagramPacket类"></a>DatagramPacket类</h4><p><strong>构造方法：</strong></p><p><strong>DatagramPacket( byte[] buf, int offset, int length)</strong> ：构造一个DatagramPacket对象用于接受指定长度的数据报 包到缓冲区。</p><p>**DatagramPacket（ byte[] buf, int offset, int length, InetAddress address, int port)**：构造用于发送指定长度的数据报包 到指定主机的指定端口号上。</p><p><strong>常用方法：</strong></p><p><strong>byte[] getData()</strong> ：返回数据报包中的数据。</p><p>**InetAddress getAddress()**：返回该数据报发送或接收数据报的计算机的IP地址。</p><p>**int getLength()**：返回要发送的数据的长度或接收到的数据的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">        String msg=<span class="string">&quot;你好，很高兴认识你！&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">        <span class="comment">//2、创建一个包（要发送给谁）</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length,inet,<span class="number">9090</span>);</span><br><span class="line">        <span class="comment">//3、发送包</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//1、创建一个socket，开放端口</span></span><br><span class="line">        <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//2、创建一个包接收数据</span></span><br><span class="line">        <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">        <span class="comment">//3、接收数据</span></span><br><span class="line">        socket.receive(packet);<span class="comment">//阻塞式接收</span></span><br><span class="line">        <span class="comment">//将数据包转换为字符串输出</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(msg);</span><br><span class="line">        <span class="comment">//4、释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><p><strong>如果是TCP中先启动客户端会报错；而UDP中先启动发送方不会报错，但会正常退出；</strong></p><p>案例：在线咨询功能，学生和老师一对一交流（多线程）</p><p>发送方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPSender</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//创建一个流 用于录入键盘的数据</span></span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">bfr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//发送数据目的地的IP</span></span><br><span class="line">    <span class="keyword">private</span> String toIP;</span><br><span class="line">    <span class="comment">//发送数据目的地的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> toPort;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPSender</span><span class="params">(String toIP, <span class="type">int</span> toPort)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.toIP = toIP;</span><br><span class="line">        <span class="built_in">this</span>.toPort = toPort;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        bfr = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));<span class="comment">//从键盘录入数据到流中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环发送数据</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> bfr.readLine();<span class="comment">//从流中读取数据</span></span><br><span class="line">                <span class="type">byte</span>[] buffer = msg.getBytes();</span><br><span class="line">                <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(toIP);</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length, inet, toPort);</span><br><span class="line">                socket.send(packet);</span><br><span class="line">                <span class="comment">//如果发送了拜拜，则退出发送</span></span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="literal">null</span>) &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bfr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bfr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UDPReceiver</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">//创建一个socket</span></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//接收方自己所在的端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> fromPort;</span><br><span class="line">    <span class="comment">//数据发送者的姓名</span></span><br><span class="line">    <span class="keyword">private</span> String msgFrom;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UDPReceiver</span><span class="params">(<span class="type">int</span> fromPort, String msgFrom)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.fromPort = fromPort;</span><br><span class="line">        <span class="built_in">this</span>.msgFrom = msgFrom;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(fromPort);<span class="comment">//创建一个socket</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SocketException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;<span class="comment">//循环接收</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">                <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer, <span class="number">0</span>, buffer.length);</span><br><span class="line">                socket.receive(packet);</span><br><span class="line">                <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(), <span class="number">0</span>, packet.getLength());</span><br><span class="line">                System.out.println(msgFrom + <span class="string">&quot;:&quot;</span> + msg);</span><br><span class="line">                <span class="keyword">if</span> (msg.equals(<span class="string">&quot;拜拜&quot;</span>)) &#123;<span class="comment">//如果接收到的数据为拜拜，则退出接收</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学生线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8888</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">7777</span>,<span class="string">&quot;老师&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>老师线程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPSender</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">7777</span>)).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">UDPReceiver</span>(<span class="number">8888</span>,<span class="string">&quot;学生&quot;</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="URL类"><a href="#URL类" class="headerlink" title="URL类"></a>URL类</h3><p>位于java.net包下</p><p><strong>构造方法：</strong><br>**URL(String spec)**：根据 String 表示形式创建 URL 对象。<br><strong>URL(String protocol, String host, int port, String file)</strong> ：根据指定协议名、主机名、端口号和文件名创建 URL 对象。<br>**URL(String protocol, String host, String file)**： 根据指定的协议名、主机名和文件名创建 URL。</p><p><strong>常用方法：</strong></p><p>**String getProtocol()**：获取此 URL的协议名称。</p><p><strong>String getHost()</strong> ：获取此 URL 的主机名。</p><p><strong>int getPort()</strong> ：获取此 URL 的端口号。</p><p><strong>String getPath()</strong> ：获取此 URL 的文件路径。</p><p>**String getFile()**：获取此 URL 的文件名。</p><p>**String getQuery()**：获取此 URL的查询部分。</p><p><strong>URLConnection openConnection()</strong> ：返回一个URLConnection实例，表示与URL引用的远程对象的URL </p><ul><li>URLConnection类中又有一个方法：<br><strong>InputStream getInputStream()</strong> ：返回从此打开的连接读取的输入流。</li></ul><p>演示案例：URL下载网络资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//下载地址</span></span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;https://img.t.sinajs.cn/t6/style/images/global_nav/WB_logo.png?id=1404211047727&quot;</span>);</span><br><span class="line">        <span class="comment">//连接到这个资源 HTTP</span></span><br><span class="line">        <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> (HttpURLConnection) url.openConnection();</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> urlConnection.getInputStream();</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;weibo.jpg&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((len=is.read(buffer))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        urlConnection.disconnect();<span class="comment">//断开连接</span></span><br><span class="line">        is.close();</span><br><span class="line">        fos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到一张图片：微博t</span></span><br></pre></td></tr></table></figure><p>a</p><table><thead><tr><th>x</th><th>f1(x)</th><th>f2(x)</th><th>f3(x)</th><th>f4(x)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>11</td><td>0</td><td>2</td><td>20</td></tr><tr><td>2</td><td>12</td><td>5</td><td>10</td><td>21</td></tr><tr><td>3</td><td>13</td><td>10</td><td>30</td><td>22</td></tr><tr><td>4</td><td>14</td><td>30</td><td>32</td><td>23</td></tr><tr><td>5</td><td>15</td><td>20</td><td>40</td><td>24</td></tr></tbody></table><table><thead><tr><th>x</th><th>F1(x)</th><th>F2(x)</th><th>F3(x)</th><th>F4(x)</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>1</td><td>11</td><td>11</td><td>11</td><td>20</td></tr><tr><td>2</td><td>12</td><td>12</td><td>13</td><td>31</td></tr><tr><td>3</td><td>13</td><td>16</td><td>30</td><td>33</td></tr><tr><td>4</td><td>14</td><td>21</td><td>41</td><td>50</td></tr><tr><td>5</td><td>15</td><td>26</td><td>43</td><td>61</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//n为项目</span></span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; maxMomey; j++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> maxMomey - j;</span><br><span class="line">        temp = F[j][i - <span class="number">1</span>] + f[k][i] </span><br><span class="line">        F[j][i] = max&#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><blockquote><p><strong>java程序有三个阶段：</strong></p><ul><li>代码阶段&#x2F;编译阶段</li><li><strong>Class类阶段（加载阶段）：当new一个对象时（类实例化），会在堆里加载一个Class类，里面存放类的成员变量，构造器，成员方法</strong>(通过类加载器ClassLoader从.class字节码文件中加载数据，体现了反射)；会<strong>在方法区生成该类的字节码二进制数据&#x2F;元数据</strong>；</li><li>运行阶段</li></ul></blockquote><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul><li>反射机制允许程序在<strong>运行期</strong>借助Reflection API 取得<strong>任何类的内部信息</strong>（比如成员变量，构造器，成员方法等），并能<strong>操作对象的属性及方法</strong>，反射在设计模式和框架底层都会用到；</li><li>加载完类之后，在堆中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象包含了类的完整结构信息，反射可以通过这个对象得到类的结构。</li><li>功能：<ul><li>在运行时<strong>判断</strong>任意一个<strong>对象所属的类</strong>；</li><li>在运行时<strong>构造</strong>任意一个<strong>类的对象</strong>；</li><li>在运行时<strong>得到</strong>任意一个<strong>类所具有的成员变量和方法</strong>；</li><li>在运行时<strong>调用</strong>任意一个<strong>对象的成员变量和方法</strong>；</li><li>生成<strong>动态代理</strong>；</li></ul></li></ul><hr><h4 id="反射的主要类"><a href="#反射的主要类" class="headerlink" title="反射的主要类"></a>反射的主要类</h4><p>java.lang.<strong>Class</strong>：代表一个<strong>类</strong>，Class对象表示某个类加载在堆中的对象；</p><p>java.lang.<strong>reflect.Method</strong>：代表类的<strong>方法</strong>，Method对象表示某个类的方法；</p><p>java.lang.<strong>reflect.field</strong>：代表类的成员<strong>变量</strong>，Field对象表示某个类的成员变量；</p><p>java.lang.<strong>reflect.Constructor</strong>：代表类的<strong>构造方法</strong>，Constructor对象表示构造器；</p><hr><p>反射优点：可以动态的创建和使用对象（也是框架底层核心），使用灵活。</p><p>反射缺点：使用反射基本是解释执行，对执行速度有影响；</p><p>反射调用优化：Method和Field，Constructor对象都有setAccessible方法； 使用setAccessible（true）可以访问安全检查的开关；</p><hr><p>使用反射：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1. 使用 Properties 类, 可以读写配置文件</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.load(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;src\\re.properties&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">classfullpath</span> <span class="operator">=</span> properties.get(<span class="string">&quot;classfullpath&quot;</span>).toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">methodName</span> <span class="operator">=</span> properties.get(<span class="string">&quot;method&quot;</span>).toString();</span><br><span class="line">        <span class="comment">//2. 使用反射机制解决</span></span><br><span class="line">        <span class="comment">//(1) 加载类, 返回 Class 类型的对象 cls</span></span><br><span class="line">        Class&lt;?&gt; cls = Class.forName(classfullpath);</span><br><span class="line">        <span class="comment">//(2) 通过 cls 得到你加载的类 com.hspedu.Cat 的对象实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> cls.newInstance();</span><br><span class="line">        System.out.println(<span class="string">&quot;o 的运行类型=&quot;</span> + o.getClass()); <span class="comment">//运行类型</span></span><br><span class="line">        <span class="comment">//(3) 通过 cls 得到你加载的类的&quot;methodName&quot;的方法对象</span></span><br><span class="line">        <span class="comment">// 即：在反射中，可以把方法视为对象（万物皆对象）</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">method1</span> <span class="operator">=</span> cls.getMethod(methodName);</span><br><span class="line">        <span class="comment">//(4) 通过 method1 调用方法: 即通过方法对象来实现调用方法</span></span><br><span class="line">        method1.invoke(o); <span class="comment">//传统方法: 对象.方法() ; 反射机制: 方法.invoke(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Field: 代表类的成员变量, Field 对象表示某个类的成员变量</span></span><br><span class="line">        <span class="comment">//getField 不能得到私有的属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">nameField</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;age&quot;</span>); <span class="comment">//</span></span><br><span class="line">        System.out.println(nameField.get(o)); <span class="comment">// 传统写法: 对象.成员变量 , 反射: 成员变量对象.get(对象)</span></span><br><span class="line">        <span class="comment">//java.lang.reflect.Constructor: 代表类的构造方法, Constructor对象 表示构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = cls.getConstructor(); <span class="comment">//()中可以指定构造器参数类型, 返回无参构造器</span></span><br><span class="line">        System.out.println(constructor);   <span class="comment">//打印方法名，无参</span></span><br><span class="line">        Constructor&lt;?&gt; constructor2 = cls.getConstructor(String.class); <span class="comment">//这里传入的String.class就是String类的Class对象</span></span><br><span class="line">        System.out.println(constructor2);<span class="comment">// 打印方法名，有参 (String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ol><li>Class类也继承Object类；</li><li>Class类对象不是new出来的，而是<strong>系统创建</strong>的；</li><li>对于每个类的Class类对象，在<strong>内存中只有一份</strong>，因为<strong>类只加载一次</strong>；</li><li>每个类的实例 都知道自己是由哪个Class实例生成的；</li><li>通过Class对象可以<strong>完整地得到一个类的完整结构;</strong></li><li>Class对象<strong>存放在堆中</strong>；</li><li>类的 字节码二进制数据&#x2F;元数据 是放在<strong>方法区</strong>的（包括类的方法代码，变量名，方法名，访问权限，返回值等）；</li></ol><h4 id="Class类的常用方法："><a href="#Class类的常用方法：" class="headerlink" title="Class类的常用方法："></a>Class类的常用方法：</h4><p>**static Class forName (String name)**：返回指定类名name的Class对象；</p><p><strong>Object newInstance( )</strong> ：调用缺省构造函数，返回该Class对象的一个实例；</p><p><strong>getName( )</strong> ：返回此Class对象所表示的实体（类，接口，数组类，基本类型等）名称；</p><p>**Class[] getInterfaces( )**：获取当前Class对象的接口；</p><p>**ClassLoader getClassLoader( )**：返回该类的类加载器；</p><p><strong>Class getSuperclass( )</strong> ：返回此Class所表示的试题的超类的Class；</p><p><strong>Constructor[] getConstructors( )</strong> ：返回一个包含某些Constructor对象的数组；</p><p>**Field[] getDeclaredFields( )**：返回Field对象的一个数组；</p><p><strong>Method getMethod( )</strong> ：返回一个Method对象，此对象的形参类型为paramType；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">classAllPath</span> <span class="operator">=</span> <span class="string">&quot;com.leaning.Car&quot;</span>;</span><br><span class="line">       <span class="comment">//1 . 获取到 Car 类 对应的 Class 对象</span></span><br><span class="line">       Class&lt;?&gt; cls = Class.forName(classAllPath);</span><br><span class="line">       <span class="comment">//2. 输出 cls</span></span><br><span class="line">       System.out.println(cls); <span class="comment">//显示 cls 对象, 是哪个类的 Class 对象 com.leaning.Car</span></span><br><span class="line">       System.out.println(cls.getClass());<span class="comment">//输出 cls 运行类型 java.lang.Class</span></span><br><span class="line">       <span class="comment">//3. 得到包名</span></span><br><span class="line">       System.out.println(cls.getPackage().getName());<span class="comment">//包名</span></span><br><span class="line">       <span class="comment">//4. 得到全类名</span></span><br><span class="line">       System.out.println(cls.getName());</span><br><span class="line">       <span class="comment">//5. 通过 cls 创建对象实例</span></span><br><span class="line">       <span class="type">Car</span> <span class="variable">car</span> <span class="operator">=</span> (Car) cls.newInstance();</span><br><span class="line">       System.out.println(car);<span class="comment">//car.toString()</span></span><br><span class="line">       <span class="comment">//6. 通过反射获取属性 brand</span></span><br><span class="line">       <span class="type">Field</span> <span class="variable">brand</span> <span class="operator">=</span> cls.getField(<span class="string">&quot;brand&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//得到属性的赋值：宝马</span></span><br><span class="line">       <span class="comment">//7. 通过反射给属性赋值</span></span><br><span class="line">       brand.set(car, <span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">       System.out.println(brand.get(car)); <span class="comment">//奔驰</span></span><br><span class="line">       Field[] fields = cls.getFields();   <span class="comment">//得到所有的属性(字段)</span></span><br><span class="line">       <span class="keyword">for</span> (Field f : fields) &#123;</span><br><span class="line">           System.out.println(f.getName());<span class="comment">//名称</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><hr><h4 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h4><ol><li><p>前提：已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法 forName( ) 获取，如：**Class cls &#x3D; Class.forName(“java.lang.Cat”)**；</p><p>应用场景：<strong>多用于配置文件，读取类全路径，加载类</strong>；</p></li><li><p>前提：若已知具体的类，通过类的class获取，该方式最为安全可靠，程序性能最高；如：<strong>Class cls &#x3D; Cat.class</strong>；</p><p>应用场景：多用于<strong>参数传递</strong>，比如通过反射得到对应构造器对象；</p></li><li><p>前提：已知某个类的实例，调用该实例的getClass() 方法获取Class对象，如：<strong>Class cls &#x3D; 对象.getClass()</strong>; &#x2F;&#x2F;运行类型</p><p>应用场景：通过创建好的对象，获取Class对象；</p></li><li><p>先得到类加载器，再<strong>通过类加载器得到Class对象</strong>：</p><p>ClassLoader cl&#x3D;对象.getClass().getClassLoader()；</p><p>Class cls &#x3D; cl.loadClass(“类的全类名”)；</p></li><li><p>基本数据（int, char, boolean, float, double, byte, long, short）得到Class类对象：</p><p>Class cls &#x3D; <strong>基本数据类型.class</strong></p></li><li><p>基本数据类型对应的包装类，可以通过 .TYPE得到Class对象：Class cls &#x3D; <strong>包装类.type</strong></p></li></ol><hr><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p><strong>静态加载</strong>：<strong>编译时加载相关的类</strong>，如果没有则报错，依赖性强；</p><p><strong>动态加载</strong>：<strong>运行时加载需要的类</strong>，如果运行时不用该类，即使不存在该类，也不报错，降低了依赖性；</p><hr><p><strong>类加载时机</strong>：</p><ul><li>当创建对象时（new）&#x2F;&#x2F;静态加载</li><li>当子类被加载时，父类也加载 &#x2F;&#x2F;静态加载</li><li>调用类中的静态成员时 &#x2F;&#x2F;静态加载</li><li>通过反射 &#x2F;&#x2F;动态加载</li></ul><hr><p><strong>类加载的三个阶段：</strong></p><p>Java源码 —(javac编译)—&gt; 字节码文件 —(java运行)—&gt; <strong>加载 –&gt; 连接（验证，准备，解析）–&gt; 初始化</strong></p><ul><li><p><strong>加载阶段</strong>：将类的字节码从不同的数据源（可能是Class文件，jar包，网络）转化为二进制字节流加载到内存，并为之创建一个java.lang.Class对象，此过程由类加载器完成；</p></li><li><p><strong>连接阶段</strong>：将类的二进制数据合并到JRE中；</p><ul><li><p><strong>验证</strong>：</p><p>目的：是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，且不会危害虚拟机自身的安全。</p><p>包括：文件格式验证（是否以魔数oxcafebabe开头），元数据验证，字节码验证，符号引用验证；</p><p>可以考虑使用 -Xverify : none参数来关闭大部分的类验证措施，缩短虚拟机 类加载的时间；</p></li><li><p><strong>准备</strong>：</p><p>JVM会在该阶段对静态变量分配内存并默认初始化，这些变量所使用的内存都将在方法区中进行分配；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">//n1 是实例属性, 不是静态变量，因此在准备阶段，是不会分配内存</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">20</span>;<span class="comment">//n2 是静态变量，分配内存 n2 是默认初始化 0 ,而不是 20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">n3</span> <span class="operator">=</span> <span class="number">30</span>;<span class="comment">//n3 是 static final 是常量, 他和静态变量不一样, 因为一旦赋值就不变 n3 = 30</span></span><br></pre></td></tr></table></figure></li><li><p><strong>解析</strong>：</p><p>到这里，才真正开始执行类中定义的Java程序代码，此阶段是执行 &lt; clinit &gt; ( ) 方法的过程；</p><p>&lt; clinit &gt; ( ) 方法 是由编译器按语句在源文件中出现的顺序，依次自动收集类中的所有<strong>静态变量的赋值动作</strong>和<strong>静态代码块</strong>中的语句，并进行合并；</p><p>虚拟机会保证一个类的&lt; clinit &gt; ( ) 方法在多线程环境中被正确地<strong>加锁、同步</strong>；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line"><span class="comment">//因为有同步机制，能保证某个类在内存中, 只有一份 Class 对象</span></span><br><span class="line"><span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">//.... </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>初始化阶段</strong>：JVM负责对类进行初始化，这里主要是指静态成员；</p></li></ul><h3 id="反射获取类结构信息"><a href="#反射获取类结构信息" class="headerlink" title="反射获取类结构信息"></a>反射获取类结构信息</h3><ul><li><p>java.lang.<strong>Class</strong>类</p><ol><li>getName：获取全类名</li><li>getSimpleName：获取简单类名</li><li>getFields：获取所有public修饰的属性，包括本类以及父类的</li><li>getDeclaredFields：获取本类中所有属性</li><li>getMethods：获取所有public修饰的方法，包括本类以及父类的</li><li>getDeclaredMethods：获取本类中所有方法</li><li>getConstructors：获取本类中所有public修饰的构造器</li><li>getDeclaredConstructors：获取本类中所有构造器</li><li>getPackage：以Package形式返回 包信息</li><li>getSuperClass：以Class形式返回父类信息</li><li>getInterfaces：以Class[] 形式返回接口信息</li><li>getAnnotations：以Annotation[] 形式返回注解信息</li></ol></li><li><p>java.lang.reflect.<strong>Field</strong>类</p><ol><li><p>getModifiers：以int形式返回修饰符</p><p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p></li><li><p>getType：以Class形式返回 类型</p></li><li><p>getName：返回属性名</p></li></ol></li><li><p>java.lang.reflect.<strong>Method</strong>类</p><ol><li><p>getModifiers：以int形式返回修饰符</p><p>（默认修饰符为0；public为1；private为2；protected为4；static为8；final为16）</p></li><li><p>getReturnType：以Class形式获取 返回类型</p></li><li><p>getParameterTypes：以Class[] 返回参数类型数组</p></li></ol></li><li><p>java.lang.reflect.<strong>Constructor</strong>类</p><ol><li>getModifiers：以int形式返回修饰符</li><li>getName：返回构造器名（全名）</li><li>getParameterTypes：以Class[] 形式返回参数类型数组</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect</span> &#123;</span><br><span class="line">    <span class="comment">//第一组方法 API</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_01</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getName:获取全类名</span></span><br><span class="line">        System.out.println(personCls.getName());<span class="comment">//homework.OrangeJuice</span></span><br><span class="line">        <span class="comment">//getSimpleName:获取简单类名</span></span><br><span class="line">        System.out.println(personCls.getSimpleName());<span class="comment">//OrangeJuice</span></span><br><span class="line">        <span class="comment">//getFields:获取所有 public 修饰的属性，包含本类以及父类的</span></span><br><span class="line">        Field[] fields = personCls.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : fields) &#123;<span class="comment">//增强 for</span></span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的属性=&quot;</span> + field.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getMethods:获取所有 public 修饰的方法，包含本类以及父类的</span></span><br><span class="line">        Method[] methods = personCls.getMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类以及父类的方法=&quot;</span> + method.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getConstructors: 获取所有 public 修饰的构造器，包含本类</span></span><br><span class="line">        Constructor&lt;?&gt;[] constructors = personCls.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : constructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类的构造器=&quot;</span> + constructor.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里老师只是输出名</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getPackage:以 Package 形式返回 包信息</span></span><br><span class="line">        System.out.println(personCls.getPackage());<span class="comment">//package homework</span></span><br><span class="line">        <span class="comment">//getSuperClass:以 Class 形式返回父类信息</span></span><br><span class="line">        Class&lt;?&gt; superclass = personCls.getSuperclass();</span><br><span class="line">        System.out.println(<span class="string">&quot;父类的 class 对象=&quot;</span> + superclass);<span class="comment">//class homework.Drink</span></span><br><span class="line">        <span class="comment">//getInterfaces:以 Class[]形式返回接口信息</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = personCls.getInterfaces();</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;接口信息=&quot;</span> + anInterface);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getAnnotations:以 Annotation[] 形式返回注解信息</span></span><br><span class="line">        Annotation[] annotations = personCls.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span> (Annotation annotation : annotations) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;注解信息=&quot;</span> + annotation);<span class="comment">//注解</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第2，3，4组api</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">api_02</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="comment">//得到 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; personCls = Class.forName(<span class="string">&quot;homework.OrangeJuice&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields:获取本类中所有属性</span></span><br><span class="line">        <span class="comment">//规定 说明: 默认修饰符 是 0 ， public 是 1 ，private 是 2 ，protected 是 4 , static 是 8 ，final 是 16</span></span><br><span class="line">        Field[] declaredFields = personCls.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field declaredField : declaredFields) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有属性=&quot;</span> + declaredField.getName()</span><br><span class="line">                    + <span class="string">&quot; 该属性的修饰符值=&quot;</span> + declaredField.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该属性的类型=&quot;</span> + declaredField.getType());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredMethods:获取本类中所有方法</span></span><br><span class="line">        Method[] declaredMethods = personCls.getDeclaredMethods();</span><br><span class="line">        <span class="keyword">for</span> (Method declaredMethod : declaredMethods) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有方法=&quot;</span> + declaredMethod.getName()</span><br><span class="line">                    + <span class="string">&quot; 该方法的访问修饰符值=&quot;</span> + declaredMethod.getModifiers()</span><br><span class="line">                    + <span class="string">&quot; 该方法返回类型&quot;</span> + declaredMethod.getReturnType());</span><br><span class="line">            <span class="comment">//输出当前这个方法的形参数组情况</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredMethod.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该方法的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//getDeclaredConstructors:获取本类中所有构造器</span></span><br><span class="line">        Constructor&lt;?&gt;[] declaredConstructors = personCls.getDeclaredConstructors();</span><br><span class="line">        <span class="keyword">for</span> (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;本类中所有构造器=&quot;</span> + declaredConstructor.getName());<span class="comment">//这里只输出名</span></span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = declaredConstructor.getParameterTypes();</span><br><span class="line">            <span class="keyword">for</span> (Class&lt;?&gt; parameterType : parameterTypes) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;该构造器的形参类型=&quot;</span> + parameterType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException &#123;</span><br><span class="line">        <span class="type">reflect</span> <span class="variable">reflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">reflect</span>();</span><br><span class="line">        reflect.api_01();</span><br><span class="line">        reflect.api_02();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射创建对象"><a href="#反射创建对象" class="headerlink" title="反射创建对象"></a>反射创建对象</h3><p>方式一：调用类中的public修饰的无参构造器</p><p>方式二：调用类中的指定构造器</p><p>方式三：Class类相关方法：newInstance，getConstructor，getDecalaredConstructor</p><p>方式四：Constructor类相关方式：setAccessible，newInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 先获取到 User 类的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; userClass = Class.forName(<span class="string">&quot;leaning.User&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 通过 public 的无参构造器创建实例</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> userClass.newInstance();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">        <span class="comment">//3. 通过 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//3.1 先得到对应构造器</span></span><br><span class="line">        Constructor&lt;?&gt; constructor = userClass.getConstructor(String.class);</span><br><span class="line">        <span class="comment">//3.2 创建实例，并传入实参</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">hsp</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;屏平&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;屏平 = &quot;</span> + hsp);</span><br><span class="line">        <span class="comment">//4. 通过非 public 的有参构造器创建实例</span></span><br><span class="line">        <span class="comment">//4.1 得到 private 的构造器对象</span></span><br><span class="line">        Constructor&lt;?&gt; constructor1 = userClass.getDeclaredConstructor(<span class="type">int</span>.class, String.class);</span><br><span class="line">        <span class="comment">//4.2 创建实例</span></span><br><span class="line">        <span class="comment">//暴破【暴力破解】 , 使用反射可以访问 private 构造器/方法/属性, 反射面前，都是纸老虎</span></span><br><span class="line">        constructor1.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">user2</span> <span class="operator">=</span> constructor1.newInstance(<span class="number">100</span>, <span class="string">&quot;张三丰&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user2 = &quot;</span> + user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> &#123; <span class="comment">//User 类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;灿灿灿&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;<span class="comment">//无参 public</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name)</span> &#123;<span class="comment">//public 的有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">User</span><span class="params">(<span class="type">int</span> age, String name)</span> &#123;<span class="comment">//private 有参构造器</span></span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反射访问类中成员"><a href="#反射访问类中成员" class="headerlink" title="反射访问类中成员"></a>反射访问类中成员</h3><p><strong>访问属性：</strong></p><ol><li><p>根据属性名获取Field对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> class对象.getDeclaredField(属性名);</span><br></pre></td></tr></table></figure></li><li><p>爆破：f.setAccessible (true);   &#x2F;&#x2F;f是Field</p></li><li><p>访问：</p><p>f.set(o值)； &#x2F;&#x2F;o表示对象</p><p>syso(f.get(o))；&#x2F;&#x2F;o表示对象</p><p>（如果是静态属性，则set和get中的参数o可以写成null）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchFieldException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Student 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; stuClass = Class.forName(<span class="string">&quot;leaning.Student2&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> stuClass.newInstance();<span class="comment">//o 的运行类型就是 Student</span></span><br><span class="line">        System.out.println(o.getClass());<span class="comment">//Student</span></span><br><span class="line">        <span class="comment">//3. 使用反射得到 age 属性对象</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">age</span> <span class="operator">=</span> stuClass.getField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">        age.set(o, <span class="number">88</span>);<span class="comment">//通过反射来操作属性</span></span><br><span class="line">        System.out.println(o);<span class="comment">//</span></span><br><span class="line">        System.out.println(age.get(o));<span class="comment">//返回 age 属性的值</span></span><br><span class="line">        <span class="comment">//4. 使用反射操作 name 属性</span></span><br><span class="line">        <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> stuClass.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//对 name 进行暴破, 可以操作 private 属性</span></span><br><span class="line">        name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//name.set(o, &quot;小郑&quot;);</span></span><br><span class="line">        name.set(<span class="literal">null</span>, <span class="string">&quot;小郑~&quot;</span>);<span class="comment">//因为 name 是 static 属性，因此 o 也可以写出 null</span></span><br><span class="line">        System.out.println(o);</span><br><span class="line">        System.out.println(name.get(o)); <span class="comment">//获取属性值</span></span><br><span class="line">        System.out.println(name.get(<span class="literal">null</span>));<span class="comment">//获取属性值, 要求 name 是 static</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student2</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student2</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student [age=&quot;</span> + age + <span class="string">&quot;, name=&quot;</span> + name + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>访问方法：</strong></p><ol><li><p>根据方法名和参数列表获取Method方法对象：Method m &#x3D; class.getDeclaredMethod(方法名，XX.class)；&#x2F;&#x2F;得到本类的所有方法</p></li><li><p>获取对象：Object o &#x3D; class.newInstance()；</p></li><li><p>爆破：m.setAccessible(true)；</p></li><li><p>访问：Object.returnValue &#x3D; m.invoke(o，实参列表)； &#x2F;&#x2F;o就是对象</p><p>（如果是静态方法，则invoke的参数o，可以写成null）</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">reflect4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;</span><br><span class="line">        <span class="comment">//1. 得到 Boss 类对应的 Class 对象</span></span><br><span class="line">        Class&lt;?&gt; bossCls = Class.forName(<span class="string">&quot;leaning.Boss&quot;</span>);</span><br><span class="line">        <span class="comment">//2. 创建对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> bossCls.newInstance();</span><br><span class="line">        <span class="comment">//3. 调用 public 的 hi 方法</span></span><br><span class="line">        <span class="comment">//Method hi = bossCls.getMethod(&quot;hi&quot;, String.class);//OK</span></span><br><span class="line">        <span class="comment">//3.1 得到 hi 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">hi</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;hi&quot;</span>, String.class);<span class="comment">//OK</span></span><br><span class="line">        <span class="comment">//3.2 调用</span></span><br><span class="line">        hi.invoke(o, <span class="string">&quot;调用了hi方法&quot;</span>);</span><br><span class="line">        <span class="comment">//4. 调用 private static 方法</span></span><br><span class="line">        <span class="comment">//4.1 得到 say 方法对象</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">say</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;say&quot;</span>, <span class="type">int</span>.class, String.class, <span class="type">char</span>.class);</span><br><span class="line">        <span class="comment">//4.2 因为 say 方法是 private, 所以需要暴破，原理和前面讲的构造器和属性一样</span></span><br><span class="line">        say.setAccessible(<span class="literal">true</span>);</span><br><span class="line">        System.out.println(say.invoke(o, <span class="number">100</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&#x27;男&#x27;</span>));</span><br><span class="line">        <span class="comment">//4.3 因为 say 方法是 static 的，还可以这样调用 ，可以传入 null</span></span><br><span class="line">        System.out.println(say.invoke(<span class="literal">null</span>, <span class="number">200</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&#x27;女&#x27;</span>));</span><br><span class="line">        <span class="comment">//5. 在反射中，如果方法有返回值，统一返回 Object , 但是他运行类型和方法定义的返回类型一致</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal</span> <span class="operator">=</span> say.invoke(<span class="literal">null</span>, <span class="number">300</span>, <span class="string">&quot;王五&quot;</span>, <span class="string">&#x27;男&#x27;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal 的运行类型=&quot;</span> + reVal.getClass());<span class="comment">//String</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//演示一个返回的案例</span></span><br><span class="line">        <span class="type">Method</span> <span class="variable">m1</span> <span class="operator">=</span> bossCls.getDeclaredMethod(<span class="string">&quot;m1&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">reVal2</span> <span class="operator">=</span> m1.invoke(o);</span><br><span class="line">        System.out.println(<span class="string">&quot;reVal2 的运行类型=&quot;</span> + reVal2.getClass());<span class="comment">//Monster</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Monster</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Boss</span> &#123;<span class="comment">//类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Boss</span><span class="params">()</span> &#123;<span class="comment">//构造器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Monster <span class="title function_">m1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Monster</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">(<span class="type">int</span> n, String s, <span class="type">char</span> c)</span> &#123;<span class="comment">//静态方法</span></span><br><span class="line">        <span class="keyword">return</span> n + <span class="string">&quot; &quot;</span> + s + <span class="string">&quot; &quot;</span> + c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">(String s)</span> &#123;<span class="comment">//普通 public 方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hi &quot;</span> + s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>（String能使用正则表达式，如</p><p>string.replaceAll(“aaa”, “AAA”);  </p><p>string.matches(“1(38|39)\d{8}”)；（返回true或false） </p><p>String[] split &#x3D; string.split(“#|-|~|\\d+”); </p><p>（stirng都是指一个字符串）</p><p>)</p><h3 id="正则表达式-1"><a href="#正则表达式-1" class="headerlink" title="正则表达式"></a>正则表达式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String content;<span class="comment">//目标串</span></span><br><span class="line">String regStr;<span class="comment">//模式串</span></span><br><span class="line"><span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regStr);<span class="comment">//创建模式对象，参数如果加上Pattern.CASE_INSENSITIVE,表示不区分大小写</span></span><br><span class="line"><span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);<span class="comment">//创建匹配器matcher，按照 正则表达式的规则 去匹配content字符串;</span></span><br></pre></td></tr></table></figure><p>正则表达式中的（）表示分组，第一个（）表示第一组..</p><p>底层：</p><ul><li><p>根据指定的表达式规则，定位到满足规则的子字符串；</p></li><li><p>找到后，将子字符串的开始索引值和结束索引值+1记录到 int[] groups;</p></li><li><p>同时记录oldLast的值为子字符串的结束索引值+1，即下一次执行find时，就从oldLast开始；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">group</span><span class="params">(<span class="type">int</span> group)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (first &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;No match found&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (group &lt; <span class="number">0</span> || group &gt; groupCount())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;No group &quot;</span> + group);</span><br><span class="line">        <span class="keyword">if</span> ((groups[group * <span class="number">2</span>] == -<span class="number">1</span>) || (groups[group * <span class="number">2</span> + <span class="number">1</span>] == -<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> getSubSequence(groups[group * <span class="number">2</span>], groups[group * <span class="number">2</span> + <span class="number">1</span>]).toString();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//group(0)表示匹配到的子字符串</span></span><br><span class="line"><span class="comment">//group(1)表示匹配到的子字符串的第一组子串</span></span><br><span class="line"><span class="comment">//group(2)表示匹配的子字符串的第二组子串</span></span><br><span class="line"><span class="comment">//...但是分组的数不能越界，否则报错</span></span><br><span class="line">System.out.println(<span class="string">&quot;第 1 组()匹配到的值=&quot;</span> + matcher.group(<span class="number">1</span>));</span><br></pre></td></tr></table></figure></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="限定符"><a href="#限定符" class="headerlink" title="限定符"></a>限定符</h4><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>*</td><td>指定字符字符重复0到多次</td><td>(abc)*</td><td>仅包含任意个abc字符串</td></tr><tr><td>+</td><td>指定字符重复1到多次</td><td>(abc)+</td><td>仅包含至少一个abc字符串</td></tr><tr><td>？</td><td>指定字符重复0或1次</td><td>abc？</td><td>ab或abc</td></tr><tr><td>{n}</td><td>只能输入n个字符</td><td>[abcd]{3}</td><td>由abcd中字母组成的任意长度为3的字符串</td></tr><tr><td>{n,}</td><td>指定至少n个匹配</td><td>[abcd]{3,}</td><td>由abcd中字母组成的任意长度不小于3的字符串</td></tr><tr><td>{n,m}</td><td>指定至少n个到m个之间的匹配</td><td>[abcd]{3,5}</td><td>由abcd中字母组成的任意长度不小于3，不大于5的字符串</td></tr></tbody></table><hr><h4 id="选择匹配符"><a href="#选择匹配符" class="headerlink" title="选择匹配符"></a>选择匹配符</h4><p>有选择性的匹配字符：|</p><p>|：匹配之前或之后的表达式</p><p>如：ab|cd ：匹配ab或cd</p><hr><h4 id="分组组合和方向应用符"><a href="#分组组合和方向应用符" class="headerlink" title="分组组合和方向应用符"></a>分组组合和方向应用符</h4><p>在表达式分组中:</p><p><strong>（表达式）</strong>：非命名捕获，编号为0的第一个捕获是整个表达式模式匹配的文本，其他捕获则根据括号顺序从1开始编号；</p><p>**(?&lt; name&gt;表达式)**：命名捕获，将匹配到的子字符串捕获到一个组名或编号name中。name不能包含任何标点符号，不能以数字开头，可以使用单引号代替&lt;&gt;</p><hr><p><strong>（?:表达式）</strong>：</p><p>非捕获匹配（即匹配但不存储）,例：“industr(?:y|ies)”效果与”industry|intdustries“相同，但更经济；</p><p><strong>（?&#x3D;表达式）</strong>：</p><p>是非捕获匹配 ，例：“Windows(?&#x3D;95|98|NT)”匹配“Windows 95”中的“Windows”，但不匹配“Windows 3.1”中的“Windows”；</p><p><strong>（?!表达式）</strong>：</p><p>非捕获匹配，例：“Windows(?!95|98|NT)”匹配“Windows 3.1”中的“Windows”，但不匹配“Windows 98”中的“Windows”；</p><hr><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>对于已经有特殊的含义的字符，想要匹配这些字符，就需要加上转义符号：**\\**（java中使用两个\，其他语言使用一个\）；</p><p>需要用到转义符号的字符有： <strong>.  *  +  ( )  $  &#x2F; \  ?  [ ]  ^  { }</strong></p><hr><p><strong>字符匹配符</strong></p><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>[ ]</td><td>可接收的字符列表</td><td>[efgh]</td><td>efgh中任意一个字符</td></tr><tr><td>[^ ]</td><td>不可接收的字符列表</td><td>[^abc]</td><td>除了a，b，c之外的任意一个字符，包括特殊符号</td></tr><tr><td>-</td><td>连字符</td><td>A-Z</td><td>任意单个大写字符</td></tr><tr><td>.</td><td>匹配除\n外的任何字符</td><td>a..b</td><td>以a开头，b结尾，中间任意2个字符</td></tr><tr><td>\\d</td><td>匹配单个数字字符，相当于[0-9]</td><td>\\d{3}(\\d)?</td><td>包含3个或4个数字的字符串</td></tr><tr><td>\\D</td><td>匹配单个非数字字符，相当于[ ^ 0-9 ]</td><td>\\D(\\d)*</td><td>以单个非数字字符开头，后接任意个数字</td></tr><tr><td>\\w</td><td>匹配单个数字，大小写字母，相当于[0-9a-zA-Z]</td><td>\\w{4}</td><td>长度为4的数字字母字符串</td></tr><tr><td>\\W</td><td>匹配单个非数字，大小写字母，相当于[ ^ 0-9a-zA-Z]</td><td>\\W+\\d{2}</td><td>以至少一个非数字字母字符开头，2个数字结尾</td></tr><tr><td>\\s</td><td>匹配任何空白字符（空格，制表符）</td><td></td><td></td></tr></tbody></table><hr><h4 id="定位符"><a href="#定位符" class="headerlink" title="定位符"></a>定位符</h4><table><thead><tr><th>符号</th><th>含义</th><th>示例</th><th>解释</th></tr></thead><tbody><tr><td>^</td><td>指定起始字符</td><td>^[0-9]+[a-z]*</td><td>至少一个数字开头，后接任意小写字母</td></tr><tr><td>$</td><td>指定结束字符</td><td>^[0-9] [a-z]+$</td><td>以一个数字开头，后接至少一个小写字母结尾</td></tr><tr><td>\\b</td><td>匹配目标字符串的边界</td><td>can\\b</td><td>边界指空格或结束位置，如：can<strong>can</strong>  c<strong>can</strong></td></tr><tr><td>\\B</td><td>匹配目标字符串的非边界</td><td>can\\B</td><td>如：<strong>can</strong>can can</td></tr></tbody></table><hr><h3 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h3><p>Pattern类，Matcher类，PatternSyntaxException</p><p>Pattern对象是一个正则表达式对象，Pattern类没有公共构造方法，要创建对象，应调用其公共静态方法，它接收一个正则表达式作为参数，返回一个Pattern对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pattern</span> <span class="variable">compile</span> <span class="operator">=</span> Pattern.compile(regStr,Pattern.CASE_INSENSITIVE);</span><br></pre></td></tr></table></figure><p>Matcher对象是对输入字符串进行解释和匹配的引擎。与Pattern类一样，Matcher也没有公共构造方法，需要调用Pattern对象的matcher方法或获得一个Matcher对象；</p><p>PatternSyntaxException是一个非强制性异常类，它表示一个正则表达式模式中的语法错误；</p><hr><h3 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h3><p>分组：</p><p>正则表达式中的 一个括号的部分可以看成是一个分组&#x2F;子表达式；</p><p>捕获：</p><p>分组匹配到的内容，会保存到以数字编号或显示命名的组里，方便后面引用；</p><p><strong>反向引用：</strong></p><p>圆括号（分组）的内容被捕获后，可以在这个括号后被使用；这种引用可以在内部使用，也可以在外部使用；</p><p>内部：<strong>\\分组号</strong></p><p>外部：**$分组号**</p><p>如：要匹配两个连续的相同数字： (\\d)\\1</p><p>​要匹配五个连续的相同数字：(\\d)\\1{4}</p><p>​要匹配个位与千位相同，十位与百位相同的数(5225,1551)：(\\d)(\\d)\\2\\1</p><p>程序案例：<strong>结巴去重</strong></p><p>把 类似 : “我….我要….学学学学….编程 java!”</p><p>通过正则表达式 修改成 “我要学编程 java” ；（即没有连续重复的字符）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;我....我要....学学学学....编程 java!&quot;</span>;</span><br><span class="line">      <span class="comment">//1. 去掉所有的. </span></span><br><span class="line">      <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">      <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(content);</span><br><span class="line">      content = matcher.replaceAll(<span class="string">&quot;&quot;</span>);</span><br><span class="line">      <span class="comment">//2. 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">      <span class="comment">// 思路</span></span><br><span class="line">      <span class="comment">//(1) 使用 (.)\\1+</span></span><br><span class="line">      <span class="comment">//(2) 使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">      <span class="comment">// 注意：因为正则表达式变化，所以需要重置 matcher</span></span><br><span class="line">       pattern = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>);<span class="comment">//分组的捕获内容记录到$1</span></span><br><span class="line">       matcher = pattern.matcher(content);</span><br><span class="line">       <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">      <span class="comment">//使用 反向引用$1 来替换匹配到的内容</span></span><br><span class="line">       content = matcher.replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">       System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure><p>简化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. 使用一条语句 去掉重复的字 我我要学学学学编程 java!</span></span><br><span class="line">        content = Pattern.compile(<span class="string">&quot;(.)\\1+&quot;</span>).matcher(content).replaceAll(<span class="string">&quot;$1&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;content=&quot;</span> + content);</span><br></pre></td></tr></table></figure><h3 id="元字符-详细说明"><a href="#元字符-详细说明" class="headerlink" title="元字符-详细说明"></a>元字符-详细说明</h3><table><thead><tr><th><strong>字符</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>\</td><td><strong>将下一字符标记为特殊字符、文本、反向引用或八进制转义符。例如，”n”匹配字符”n”。”\n”匹配换行符。序列”\\“匹配”\“，”\(“匹配”(“。</strong></td></tr><tr><td><strong>^</strong></td><td><strong>匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与”\n”或”\r”之后的位置匹配。</strong></td></tr><tr><td><strong>$</strong></td><td><strong>匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与”\n”或”\r”之前的位置匹配。</strong></td></tr><tr><td>*****</td><td><strong>零次或多次匹配前面的字符或子表达式。例如，zo* 匹配”z”和”zoo”。* 等效于 {0,}。</strong></td></tr><tr><td><strong>+</strong></td><td><strong>一次或多次匹配前面的字符或子表达式。例如，”zo+”与”zo”和”zoo”匹配，但与”z”不匹配。+ 等效于 {1,}。</strong></td></tr><tr><td><strong>?</strong></td><td><strong>零次或一次匹配前面的字符或子表达式。例如，”do(es)?”匹配”do”或”does”中的”do”。? 等效于 {0,1}。</strong></td></tr><tr><td><strong>{*n*}</strong></td><td>*<strong>n*</strong> <strong>是非负整数。正好匹配 *n* 次。例如，”o{2}”与”Bob”中的”o”不匹配，但与”food”中的两个”o”匹配。</strong></td></tr><tr><td><strong>{*n*,}</strong></td><td>*<strong>n*</strong> <strong>是非负整数。至少匹配 *n* 次。例如，”o{2,}”不匹配”Bob”中的”o”，而匹配”foooood”中的所有 o。”o{1,}”等效于”o+”。”o{0,}”等效于”o*“。</strong></td></tr><tr><td><strong>{*n*,*m*}</strong></td><td>*<strong>m*</strong> <strong>和 *n* 是非负整数，其中 *n* &lt;&#x3D; *m*。匹配至少 *n* 次，至多 *m* 次。例如，”o{1,3}”匹配”fooooood”中的头三个 o。’o{0,1}’ 等效于  ‘o?’。注意：您不能将空格插入逗号和数字之间。</strong></td></tr><tr><td><strong>?</strong></td><td><strong>当此字符紧随任何其他限定符（*、+、?、{*n*}、{*n*,}、{*n*,*m*}）之后时，匹配模式是”非贪心的”。”非贪心的”模式匹配搜索到的、尽可能短的字符串，而默认的”贪心的”模式匹配搜索到的、尽可能长的字符串。例如，在字符串”oooo”中，”o+?”只匹配单个”o”，而”o+”匹配所有”o”。</strong></td></tr><tr><td><strong>.</strong></td><td><strong>匹配除”\r\n”之外的任何单个字符。若要匹配包括”\r\n”在内的任意字符，请使用诸如”[\s\S]”之类的模式。</strong></td></tr><tr><td><strong>(*pattern*)</strong></td><td><strong>匹配 *pattern* 并捕获该匹配的子表达式。可以使用 $0…$9 属性从结果”匹配”集合中检索捕获的匹配。若要匹配括号字符 ( )，请使用”(“或者”)“。</strong></td></tr><tr><td><strong>(?:*pattern*)</strong></td><td><strong>匹配 *pattern* 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。这对于用”or”字符 (|) 组合模式部件的情况很有用。例如，’industr(?:y|ies) 是比 ‘industry|industries’  更经济的表达式。</strong></td></tr><tr><td><strong>(?&#x3D;*pattern*)</strong></td><td><strong>执行正向预测先行搜索的子表达式，该表达式匹配处于匹配 *pattern* 的字符串的起始点的字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?&#x3D;95|98|NT|2000)’ 匹配”Windows  2000”中的”Windows”，但不匹配”Windows 3.1”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td></tr><tr><td><strong>(?!*pattern*)</strong></td><td><strong>执行反向预测先行搜索的子表达式，该表达式匹配不处于匹配 *pattern* 的字符串的起始点的搜索字符串。它是一个非捕获匹配，即不能捕获供以后使用的匹配。例如，’Windows (?!95|98|NT|2000)’ 匹配”Windows  3.1”中的 “Windows”，但不匹配”Windows 2000”中的”Windows”。预测先行不占用字符，即发生匹配后，下一匹配的搜索紧随上一匹配之后，而不是在组成预测先行的字符后。</strong></td></tr><tr><td><em><strong>x*</strong></em><em>|*y*</em>*</td><td><strong>匹配 *x* 或 *y*。例如，’z|food’ 匹配”z”或”food”。’(z|f)ood’ 匹配”zood”或”food”。</strong></td></tr><tr><td><strong>[*xyz*]</strong></td><td><strong>字符集。匹配包含的任一字符。例如，”[abc]”匹配”plain”中的”a”。</strong></td></tr><tr><td><strong>[^*xyz*]</strong></td><td><strong>反向字符集。匹配未包含的任何字符。例如，”[^abc]”匹配”plain”中”p”，”l”，”i”，”n”。</strong></td></tr><tr><td><strong>[*a-z*]</strong></td><td><strong>字符范围。匹配指定范围内的任何字符。例如，”[a-z]”匹配”a”到”z”范围内的任何小写字母。</strong></td></tr><tr><td><strong>[^*a-z*]</strong></td><td><strong>反向范围字符。匹配不在指定的范围内的任何字符。例如，”[^a-z]”匹配任何不在”a”到”z”范围内的任何字符。</strong></td></tr><tr><td><strong>\b</strong></td><td><strong>匹配一个字边界，即字与空格间的位置。例如，”er\b”匹配”never”中的”er”，但不匹配”verb”中的”er”。</strong></td></tr><tr><td><strong>\B</strong></td><td><strong>非字边界匹配。”er\B”匹配”verb”中的”er”，但不匹配”never”中的”er”。</strong></td></tr><tr><td><strong>\c*x*</strong></td><td><strong>匹配 *x* 指示的控制字符。例如，\cM 匹配 Control-M 或回车符。*x* 的值必须在 A-Z 或  a-z 之间。如果不是这样，则假定 c 就是”c”字符本身。</strong></td></tr><tr><td><strong>\d</strong></td><td><strong>数字字符匹配。等效于  [0-9]。</strong></td></tr><tr><td><strong>\D</strong></td><td><strong>非数字字符匹配。等效于  [^0-9]。</strong></td></tr><tr><td><strong>\f</strong></td><td><strong>换页符匹配。等效于  \x0c 和 \cL。</strong></td></tr><tr><td><strong>\n</strong></td><td><strong>换行符匹配。等效于  \x0a 和 \cJ。</strong></td></tr><tr><td><strong>\r</strong></td><td><strong>匹配一个回车符。等效于  \x0d 和 \cM。</strong></td></tr><tr><td><strong>\s</strong></td><td><strong>匹配任何空白字符，包括空格、制表符、换页符等。与 [ \f\n\r\t\v] 等效。</strong></td></tr><tr><td><strong>\S</strong></td><td><strong>匹配任何非空白字符。与  [^ \f\n\r\t\v] 等效。</strong></td></tr><tr><td><strong>\t</strong></td><td><strong>制表符匹配。与  \x09 和 \cI 等效。</strong></td></tr><tr><td><strong>\v</strong></td><td><strong>垂直制表符匹配。与  \x0b 和 \cK 等效。</strong></td></tr><tr><td><strong>\w</strong></td><td><strong>匹配任何字类字符，包括下划线。与”[A-Za-z0-9_]”等效。</strong></td></tr><tr><td><strong>\W</strong></td><td><strong>与任何非单词字符匹配。与”[^A-Za-z0-9_]”等效。</strong></td></tr><tr><td><strong>\x*n*</strong></td><td><strong>匹配 *n*，此处的 *n* 是一个十六进制转义码。十六进制转义码必须正好是两位数长。例如，”\x41”匹配”A”。”\x041”与”\x04”&amp;”1”等效。允许在正则表达式中使用 ASCII 代码。</strong></td></tr><tr><td><strong>*num*</strong></td><td><strong>匹配 *num*，此处的 *num* 是一个正整数。到捕获匹配的反向引用。例如，”(.)\1”匹配两个连续的相同字符。</strong></td></tr><tr><td><strong>*n*</strong></td><td><strong>标识一个八进制转义码或反向引用。如果 *n* 前面至少有 *n* 个捕获子表达式，那么 *n* 是反向引用。否则，如果 *n* 是八进制数 (0-7)，那么 *n* 是八进制转义码。</strong></td></tr><tr><td><strong>*nm*</strong></td><td><strong>标识一个八进制转义码或反向引用。如果 *nm* 前面至少有 *nm* 个捕获子表达式，那么 *nm* 是反向引用。如果 *nm* 前面至少有 *n* 个捕获，则 *n* 是反向引用，后面跟有字符 *m*。如果两种前面的情况都不存在，则 *nm* 匹配八进制值 *nm*，其中 *n* 和 *m* 是八进制数字 (0-7)。</strong></td></tr><tr><td><strong>\nml</strong></td><td><strong>当 *n* 是八进制数  (0-3)，*m* 和 *l* 是八进制数 (0-7) 时，匹配八进制转义码 *nml*。</strong></td></tr><tr><td><strong>\u*n*</strong></td><td><strong>匹配 *n*，其中 *n* 是以四位十六进制数表示的 Unicode 字符。例如，\u00A9 匹配版权符号 (©)。</strong></td></tr></tbody></table><h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h3><p>采用一定的方法保证在整个软件系统中，<strong>对某个类，只能存在一个对象实例，且该类只提供一个取得其对象实例的方法</strong>。</p><p><strong>步骤：</strong></p><ul><li><strong>构造器私有化，防止直接new；</strong></li><li><strong>在类的内部创建对象；</strong></li><li><strong>向外暴露一个静态的公共方法</strong></li></ul><p>饿汉式和懒汉式<strong>区别</strong>：</p><ol><li>创建时机不同，<strong>饿汉式是在类加载就创建了对象实例</strong>，而<strong>懒汉式是使用时才创建</strong>；</li><li><strong>饿汉式不存在线程安全问题，懒汉式存在线程安全问题</strong>；</li><li><strong>饿汉式存在资源浪费问题</strong>，如果使用时一个对象实例都没使用，饿汉式创建的对象就浪费了；</li></ol><p>饿汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了能在静态方法中返回这个对象，使用static</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Instance</span> <span class="variable">ins</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;饿汉&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Instance</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//只是一个引用，还没有创建对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Instance ins;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Instance</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公共的静态方法，可以直接通过类来调用</span></span><br><span class="line">    <span class="comment">//若对象还未创建，才去创建，即第一次调用了这个方法，对象才会被创建</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Instance <span class="title function_">getIns</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ins == <span class="literal">null</span>)&#123;</span><br><span class="line">            ins = <span class="keyword">new</span> <span class="title class_">Instance</span>(<span class="string">&quot;懒汉&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ins;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板设计模式"><a href="#模板设计模式" class="headerlink" title="模板设计模式"></a>模板设计模式</h3><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>**equals（object o)**：指示其他对象是否与此对象相等</p><p><strong>finalize()</strong></p><p>当垃圾收集确定不再有对该对象的引用时，垃圾收集器在对象上调用该对象。</p><p>**getclass()**：返回此 <code>Object</code>的运行时类。 </p><p>**hashcode()**：返回对象的哈希码值</p><p>**toString()**：返回对象的字符串表示形式</p><p>**clone()**：创建并返回此对象的一个副本</p><p><strong>notify()</strong></p><p><strong>notifyAll()</strong></p><p><strong>wait()</strong></p><hr><p><strong>&#x3D;&#x3D;与equals的对比</strong>：</p><p>&#x3D;&#x3D;是一个比较运算符</p><ul><li><strong>&#x3D;&#x3D; 判断基本类型时，判断值是否相等</strong></li><li><strong>&#x3D;&#x3D; 判断引用类型时，判断地址是否相等</strong>，即是不是同一个对象</li></ul><p><strong>equals</strong>是Objects类中的方法，<strong>只能判断引用类型，默认判断地址是否相等</strong>，不过其<strong>子类往往重写该方法，用于判断内容是否相等</strong>，如Integer, String</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Integer中的equals方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Integer)&#123;</span><br><span class="line">        <span class="type">return</span> <span class="variable">value</span> <span class="operator">=</span>= ((integer)obj).intValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>hashcode方法</strong></p><ol><li>提高具有哈希结构的容器的效率；</li><li>两个引用，如果指向同一个对象，则哈希值肯定是一样的；</li><li>两个引用，如果指向不同的对象，则哈希值不一样；</li><li>哈希值主要根据地址号 计算得来的，不能完全将哈希值等价与地址</li></ol><p>重写hahscode：</p><hr><p><strong>toString方法</strong></p><p>Object的toString方法默认返回：全类名 + @ + 哈希值的十六进制；子类往往重写toString方法，用于返回对象的属性信息；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Object的toString方法</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><strong>finalize方法</strong></p><ul><li><p>当对象被回收时，系统自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作</p></li><li><p>什么时候被回收：当某个对象没有任何引用时，则jvm就认为该对象是一个垃圾对象，就会使用垃圾回收机制来销毁对象，在销毁该对象前，会先调用finalize方法；</p></li><li><p>垃圾回收机制的调用，是由系统来决定 ( 即有自己的 GC 算法 ) ，也可以通过 System.gc() 主动触发垃圾回收机制</p><p>（实际开发中，几乎不会用到finalize）</p></li></ul><hr><h3 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h3><p><strong>reverse（List）</strong>：反转List中元素的顺序；</p><p><strong>shuffle（List</strong>）：对List中元素进行随机排序；</p><p><strong>swap（List， int ，int）</strong>：交换List中两个元素的位置</p><p>Object max（Collection）：返回给定集合中最大元素</p><p><strong>Object max（Collection，Comparator）</strong>：根据Comparator指定的顺序，返回最大元素；</p><p>min跟max一样</p><p><strong>int frequency（Collection， Object）</strong>：返回指定集合中指定元素的出现次数</p><p><strong>void copy（List dest，List src）</strong>：将src复制到dest中</p><p><strong>boolean replaceAll（List list，Object oldVal，Object newVal）</strong>：使用新值，替换掉List中所有旧值</p><hr><p><strong>sort（）：</strong></p><p>Map, Set, List等集合中，都提供了一个排序方法：**sort()**，不过要保证集合中的对象是可比较的；</p><p>让对象是 可比较的， 可以让对象实现 <strong>Comparable&lt; T&gt;接口</strong>，然后重写里面的**compareTo()**方法，</p><p><strong>compareTo（Object o）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Student o)</span> &#123;</span><br><span class="line"><span class="comment">//降序</span></span><br><span class="line"><span class="comment">//return o.age - this.age;</span></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">this</span>.age - o.age;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>返回值</th><th>含义</th></tr></thead><tbody><tr><td>负整数</td><td>当前对象的值 <strong>&lt;</strong> 比较对象的值 ， 位置排在前</td></tr><tr><td>零</td><td>当前对象的值 <strong>&#x3D;</strong> 比较对象的值 ， 位置不变</td></tr><tr><td>正整数</td><td>当前对象的值 <strong>&gt;</strong> 比较对象的值 ， 位置排在后</td></tr></tbody></table><p><strong>比较器的使用：</strong></p><p>(例题可看 笔记（数据结构 ) —堆 692.前k个高频词)</p><p>想要排序集合中的其他元素，可以使用Comparator :</p><ul><li>Collertions.sort ( list , Comparator&lt; T&gt; ) ;</li><li>list.sort ( Comparator&lt; T&gt;) ;</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序1</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义排序2</span></span><br><span class="line">list.sort(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Student o1, Student o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> o1.getId() - o2.getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Scanner类"><a href="#Scanner类" class="headerlink" title="Scanner类"></a>Scanner类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Scanner</span> <span class="variable">hh</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> hh.nextInt();</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//.next  -&gt;  输入字符串</span></span><br><span class="line"><span class="comment">//.nextDouble  -&gt;  输入双精度浮点数</span></span><br><span class="line"><span class="comment">//其他类型 输入样式 相似</span></span><br></pre></td></tr></table></figure><p>当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。</p><p>如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">string</span> <span class="variable">line</span> <span class="operator">=</span>  s.nextLine;</span><br></pre></td></tr></table></figure><p>Scanner类主要提供了两个方法来扫描输入：</p><p>1）**hasNextXx()**：是否还有下一个输入项，其中Xxx可以是Int、Long等代表基本数据类型的字符串。如果只是判断是否包含下一个字符串，则直接使用hasNext()。</p><p>2）**nextXxx()**：获取下一个输入项。Xxx的含义同上。</p><p>默认情况下，Scanner使用空白（包括空格、Tab空白和回车）作为多个输入项的分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="comment">//System.in代表键盘输入</span></span><br><span class="line"><span class="type">Scanner</span> <span class="variable">sc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="comment">//使用回车作为分隔符</span></span><br><span class="line">    sc.useDelimiter(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(sc.hasNext())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;键盘输入的内容是：&quot;</span> + sc.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br></pre></td></tr></table></figure><p>String 类是<strong>被 final 修饰的，即 String 类不能被继承</strong>。</p><p>其中有一个很重要的数组，char 数组，用来保存字符串的，既然是用 final 关键字来修饰的，那就代表 <strong>String 是不可变的</strong>（不能指向新地址，但char[]里面的单个字符可改）</p><p>在源代码中，substring，replace 最后都是通过 new String(xxx) 来产生了一个新的 String 对象，最原始的字符串并没有改变。</p><p>（String实现了serializable接口，说明可以串行化（可以在网络上传输），实现了comparable接口，说明String对象可以比较；）</p><p>而<strong>StringBuilder</strong>中的字符可变</p><p>比如使用append方法，返回的依然是 StringBuffer 对象本身，说明他确实是值改变了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> StringBuilder <span class="title function_">append</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法实际调用的是 StringBuilder 的父方法。该父方法，会先检测容量够不够，不够的话会进行扩容，然后调用 String 的 getChars 方法。注意，最后返回的依旧是 StringBuffer 对象</p><p><strong>关于字符串相加：</strong><br>使用“+”对两个字符串相加的过程：</p><p>String 对象的操作符“+”其实被赋予了特殊的含义，该操作符是 Java 中仅有的两个重载过的操作符。</p><p>String 对象在进行“+”操作的时候，其实是调用了StringBuilder 对象的 append() 方法来加以构造</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a1</span> <span class="operator">=</span> <span class="string">&quot;helloworld&quot;</span>;<span class="comment">//a1指向常量区</span></span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;<span class="comment">//也指向常量区</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&quot;world&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">d</span> <span class="operator">=</span> b + c;<span class="comment">//指向堆中的String对象</span></span><br><span class="line"><span class="comment">//a1 == a</span></span><br><span class="line"><span class="comment">//a != d</span></span><br><span class="line"><span class="comment">//a1 != d</span></span><br></pre></td></tr></table></figure><p>看 String a，“hello” + “world” 在 String 编译期间进行优化，优化结果为 “helloworld”，而该值在常量池中已经存有一份，因此 a 也指向了该常量池中的字符串，因此 a1 和 a 相等;</p><p>在对 b 和 c 进行相加的过程中：1. xia你创建StringBuilder sb &#x3D; StringBuilder()；2. 执行sb.append(“hello”);  再执行一次sb.append(“world”)； 3. String d &#x3D; sb.toString();</p><p>很明显 d 对象指向的是堆中的 String 对象，而 a1 则指向的是常量池中的字符串，两者引用明显不同，</p><p><strong>小结：String s &#x3D; “ab” + “cd”：常量相加，看的是池；String s &#x3D; a + b :  变量相加，是在堆中</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707042.png" alt="image-20211002201859440"></p><hr><p><strong>创建</strong>的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;ssss&quot;</span>;</span><br><span class="line"><span class="comment">//一，先从常量池查看是否有“ssss”数据空间，如果有，直接指向；没有则重新创建，然后指向。s最终指向的是常量池的空间地址</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ssss&quot;</span>);</span><br><span class="line"><span class="comment">//二，先在堆中创建空间，里面维护了value属性，指向常量池的“ssss”空间。如果常量池没有，重新创建，有的话则直接通过value指向。s最终指向的是堆中的空间地址。</span></span><br></pre></td></tr></table></figure><p>构造器 参数列表有多种：(String s)， (char[] a ), (char[] a, int startIndex, int count), (byte[] b) ….</p><p>int **indexOf(int ch) : ** <strong>lastIndexOf(int ch) :</strong></p><p>返回指定字符第一次(最后一次)出现处的索引</p><p>int **indexOf(String str) ** <strong>&#x2F; lastIndexOf(String str)</strong></p><p>返回指定 子字符串 第一次出现处的索引</p><p>char <strong>cahrAt(int index) :</strong></p><p>返回index’位置上的字符</p><p><strong>concat( String s) :</strong>  拼接字符串</p><p>boolean <strong>endsWith(String suffix) :</strong></p><p>判断此字符串是否以指定的字符串结尾</p><p>boolean <strong>startsWith(String prefix) :</strong></p><p>判断此字符串是否以指定的字符串开始</p><p>int <strong>length() :</strong>  返回此字符串的长度</p><p>boolean <strong>equals (Object anObject) :</strong></p><p>将此字符串与指定的字符串比较</p><p><strong>equaIsIgnoreCase</strong> :忽略大小写的判断内容相等</p><p>boolean <strong>isEmpty() :</strong></p><p>此字符串长度为0时返回true</p><p>boolean <strong>contains(CharSequence cs) :</strong></p><p>判断是否包含指定的字符序列</p><p>String <strong>toLowerCase() :</strong></p><p>将String中的所有字符都转换为小写（使用默认语言环境的规则）</p><p>String <strong>toUpperCase() :</strong></p><p>将String中的所有字符都转换为大写</p><p>static <strong>String valueOf(int i) :</strong></p><p>返回int参数的字符串表示形式</p><p>char[] <strong>toCharArray() :</strong></p><p>将此字符串转换为一个字符数组</p><p>String <strong>replace(CharSequence oldstr, CharSequence newstr) :</strong></p><p>返回新的字符串，用newstr替换所有的oldstr</p><p>String[] <strong>split(String regex) :</strong></p><p>根据参数regex（regex是一个正则表达式，用于限定分隔规则）将此字符串分割为若干个字符串</p><p>String <strong>substring(itn beginIndex) :</strong> </p><p>返回一个新字符串，从指定的beginIndex开始，直至末尾</p><p>String <strong>substring(itn beginIndex， int endIndex) :</strong> </p><p>返回一个新字符串，从指定的beginIndex到endIndex - 1</p><p>String <strong>trim() :</strong></p><p>返回一个新字符串，它去除了原字符串 首尾的空格</p><p><strong>format（String s, …）</strong>：格式化字符串，%s 字符串，%c 字符 … </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> String.format(s, ....);</span><br><span class="line"><span class="comment">//format的第一个参数是要格式化的字符串，后面是要替换s中占位符%的变量；</span></span><br><span class="line">system.out.println(<span class="string">&quot;s = &quot;</span> + info);</span><br></pre></td></tr></table></figure><p>Strng方法练习：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getType</span><span class="params">(Object o)</span> &#123;<span class="comment">//定义一个静态方法，获取变量的类型，通过类Main来调用它</span></span><br><span class="line"><span class="keyword">return</span> o.getClass().getName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">String s1=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice!&quot;</span>);<span class="comment">//这里全部使用String类的构造方法来初始化字符串对象</span></span><br><span class="line">String s2=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我喜欢学Java,Java很nice&quot;</span>);</span><br><span class="line">String s3=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abcd&quot;</span>);</span><br><span class="line">String s4=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;ABCD&quot;</span>);</span><br><span class="line">String s5=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">String s6=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot; abcd &quot;</span>);</span><br><span class="line">String s7=<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a123a123b456&quot;</span>);</span><br><span class="line"><span class="type">char</span>[] str=s1.toCharArray();</span><br><span class="line"><span class="type">int</span> a=<span class="number">5</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;↓↓↓String类的一些常用方法如下↓↓↓&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1的长度为：&quot;</span> + s1.length());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符&#x27;J&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&#x27;J&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;第一次出现在字符串s1中的索引为：&quot;</span> + s1.indexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;从指定的索引2开始搜索，返回字符串&#x27;a1&#x27;在字符串s7中第一次出现的索引：&quot;</span> + s7.indexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">2</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符&#x27;a&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;子字符串&#x27;Java&#x27;最后一次出现在字符串s1中的索引为：&quot;</span> + s1.lastIndexOf(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;从指定的索引8开始反向搜索，返回字符串&#x27;a1&#x27;在字符串s7中最后一次出现的索引：&quot;</span>+s7.lastIndexOf(<span class="string">&quot;a1&quot;</span>,<span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;获取字符串s1中第3个位置上的字符：&quot;</span> + s1.charAt(<span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串开始：&quot;</span> + s1.startsWith(<span class="string">&quot;我喜欢&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1是否以指定的字符串结尾：&quot;</span> + s1.endsWith(<span class="string">&quot;nice&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.equals(s2));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.equalsIgnoreCase(s4));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1和s2进行比较：&quot;</span> + s1.compareTo(s2));</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s3和s4进行不区分大小写的比较：&quot;</span> + s3.compareToIgnoreCase(s4));</span><br><span class="line"><span class="comment">/*compareTo(String anotherString)方法将当前字符串与参数字符串进行比较，</span></span><br><span class="line"><span class="comment">如果相同，则返回0。</span></span><br><span class="line"><span class="comment">不相同时，从两个字符串第1个字符开始比较，返回第一个不相等的字符差，按照字典顺序</span></span><br><span class="line"><span class="comment">另一种情况，某个字符串和其子串进行比较，返回它们的长度差。</span></span><br><span class="line"><span class="comment">compareToIgnoreCase(str)与compareTo的区别是忽略了大小写*/</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s5的长度是否为0：&quot;</span> + s5.isEmpty());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;字符串s1中是否包含指定的序列：&quot;</span> + s1.contains(<span class="string">&quot;Java&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s4连接到s3的结尾：&quot;</span> + s3.concat(s4));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s4的所有字符转为小写：&quot;</span> + s4.toLowerCase());</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s3的所有字符转为大写：&quot;</span> + s3.toUpperCase());</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将int类型转为字符串，并获取a的变量类型：&quot;</span> + Main.getType(String.valueOf(a)));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;将字符串s1转为字符数组str：&quot;</span>);<span class="comment">//见代码第13行</span></span><br><span class="line">System.out.println(str);</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;将字符串s2中的&#x27;Java&#x27;全部替换为&#x27;Python&#x27;：&quot;</span> + s2.replace(<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;Python&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;截取字符串s1从第3个位置开始到结尾：&quot;</span> + s1.substring(<span class="number">3</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;截取字符串s1从0个位置开始到第7个位置结尾：&quot;</span> + s1.substring(<span class="number">0</span>,<span class="number">8</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------------------------------------------&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;去掉字符串s6首尾的空格：&quot;</span> + s6.trim());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StringBuffer类"><a href="#StringBuffer类" class="headerlink" title="StringBuffer类"></a>StringBuffer类</h3><p>StringBuffer代表可变的字符序列，可以对字符串内容进行增删；是一个final类，不能被继承；</p><p>很多方法与String相同，StringBuffer是一个容器；</p><p>StringBuffer中的char[] value<strong>没有加final</strong>，所以可以增删字符，且<strong>放在堆中</strong></p><hr><p><strong>String与StringBuffer的转换</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String -&gt; StringBuffer</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">//一，使用构造器，返回的是StringBuffer对象，对s没有影响</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//二，使用append方法</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb2 =sb2.append(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringBuffer -&gt; String</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="comment">//使用StringBuffer的toString方法</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> sb3.toString();</span><br><span class="line"><span class="comment">//使用构造器</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(sb3);</span><br></pre></td></tr></table></figure><hr><p><strong>StringBuffer方法</strong></p><p><strong>append( String s)</strong> ：末尾增添字符串</p><p><strong>delete( int start, int end)</strong> ：删，将start到end的内容删掉，不包括end</p><p><strong>replace( int start, int end, String s)</strong> ：改，将start到end的内容换掉，不包括end</p><p><strong>insert（int index， String s)</strong> ：插，在索引n处插入字符串，索引n后的内容自动后移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">sb.append(s);<span class="comment">//传入一个空的字符串，但这里没问题</span></span><br><span class="line"><span class="comment">//底层调用了父类的AbstractStingBuffer的appendNull方法，加入一个字符串“null”。</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(s);</span><br><span class="line"><span class="comment">//构造器传入空的字符串，会出现异常；因为底层调用的父类构造器传入的参数是字符串的长度+16，而字符串为空，显然会出现异常</span></span><br></pre></td></tr></table></figure><hr><p><strong>StringBulider类</strong></p><p>StringBulider提供一个与 StringBuffer兼容的API，但不保证同步（不是线程安全）。该类被设计作为StringBuffer的一个简易替换，用在字符串缓冲区被单个线程使用的时候。</p><p>StringBuilder类的方法和StringBuffer类的一样</p><hr><p><strong>String，StringBuffer，StringBuilder的比较</strong></p><ul><li>String：不可变字符序列，效率低，但复用率高</li><li>StringBuffer：可变序列，效率较高，线程安全</li><li>StringBuilder：可变序列，效率最高，线程不安全</li></ul><p>所以，如果字符串存在大量修改操作：在<strong>单线程时用StringBuilder</strong>，在<strong>多线程时用StringBuffer</strong>；如果字符串<strong>很少修改，且被多个对象引用，使用String</strong>。</p><h3 id="Arrays类"><a href="#Arrays类" class="headerlink" title="Arrays类"></a>Arrays类</h3><p><strong>数组转List</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(arr).contains(<span class="number">3</span>)); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">out.println(Arrays.asList(array).contains(<span class="number">3</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的转换，拆开：</span></span><br><span class="line">Integer arr[] = <span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;Integer&gt; integers = Arrays.asList(arr);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">array</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; ints = Arrays.asList(array);</span><br><span class="line"><span class="comment">//区别:原始数据类型int的数组调用asList之后得到的List只有一个元素，这个元素就是元素类型的数组。而封装类Integer数组调用asList是把数组中每个元素加到了List中。</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.fill() ;填充数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Arrays.fill(arr,<span class="number">4</span>);<span class="comment">//给所有值赋值4</span></span><br><span class="line">Arrays.fill(arr, <span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);<span class="comment">//给第2位（0开始）到第4位（不包括）赋值6</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.sort(); &#x2F;&#x2F;数组排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Arrays.sort(intArray);</span><br><span class="line"><span class="comment">//数字排序：从小到大；</span></span><br><span class="line"><span class="comment">//字符串排序：先大写后小写（ASCII码）</span></span><br><span class="line"></span><br><span class="line"> Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER);</span><br><span class="line"><span class="comment">//严格按字母表顺序排序，也就是忽略大小写排序 Case-insensitive sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, Collections.reverseOrder());</span><br><span class="line"><span class="comment">//反向排序， Reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(strArray, String.CASE_INSENSITIVE_ORDER); Collections.reverse(Arrays.asList(strArray));</span><br><span class="line"><span class="comment">//忽略大小写反向排序 Case-insensitive reverse-order sort</span></span><br><span class="line"></span><br><span class="line">Arrays.sort(arr,<span class="number">0</span>,<span class="number">3</span>);<span class="comment">//选择数组指定位置进行排序：给第0位（0开始）到第3位（不包括）排序</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.sort(T[] a, Comparator&lt;? super T&gt; c)  &#x2F;&#x2F;自定义数组排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> Arrays.sort(a, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> o1 - o2; <span class="comment">//返回&gt;0或&lt;0会影响排序结果</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Arrays.toString(); &#x2F;&#x2F;将数组中的内容全部打印出来</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(arr);<span class="comment">//直接将数组打印输出</span></span><br><span class="line"><span class="comment">//输出：[I@7852e922 (数组的地址)</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> Arrays.toString(arr); <span class="comment">// Arrays类的toString()方法能将数组中的内容全部转为字符串输出</span></span><br><span class="line"><span class="comment">//System.out.print(str);</span></span><br><span class="line"><span class="comment">//输出：[3, 2, 1, 5, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.toString(deepArray)); <span class="comment">//[[I@1540e19d, [I@677327b6]</span></span><br><span class="line">out.println(Arrays.deepToString(deepArray)); <span class="comment">//[[1, 3], [2, 4]]</span></span><br><span class="line"><span class="comment">//对于多维数组，需要使用deepToString</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.equals(); &#x2F;&#x2F;比较数组元素是否相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">System.out.println(Arrays.equals(arr1,arr2));</span><br><span class="line"><span class="comment">//输出：true</span></span><br><span class="line"><span class="comment">//如果是arr1.equals(arr2),则返回false，因为equals比较的是两个对象的地址，不是里面的数，而Arrays.equals重写了equals，所以，这里能比较元素是否相等。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[][] deepArray1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span>[][] deepArray2 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;,&#123;<span class="number">2</span>, <span class="number">4</span>&#125;&#125;;</span><br><span class="line">out.println(Arrays.equals(deepArray1, deepArray2)); <span class="comment">//false</span></span><br><span class="line">out.println(Arrays.deepEquals(deepArray1, deepArray2)); <span class="comment">//true</span></span><br><span class="line"><span class="comment">//对多维数组，同样要用deepEquals</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.binarySearch(); &#x2F;&#x2F;二分查找法找指定元素的索引值（下标）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Arrays.binarySearch(arr, <span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （下标索引值从0开始）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">36</span>)</span><br><span class="line"><span class="comment">//输出：-4 （找不到元素，返回-x，从-1开始数，如题，返回-4）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">30</span>)</span><br><span class="line"><span class="comment">//输出：2 （从0到3位（不包括）找30，找到了，在第2位，返回2）</span></span><br><span class="line"></span><br><span class="line">Arrays.binarySearch(arr, <span class="number">0</span>,<span class="number">3</span>,<span class="number">40</span>)</span><br><span class="line"><span class="comment">//输出：-4 （从0到3位（不包括）找40，找不到，从-1开始数，返回-4）</span></span><br></pre></td></tr></table></figure><p><strong>Arrays.copeOf() 和Arrays.copeOfRange(); &#x2F;&#x2F;截取数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1 = Arrays.copyOf(arr, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[10, 20, 30] （截取arr数组的3个元素赋值给新数组arr1）</span></span><br><span class="line"><span class="type">int</span> []arr1 = Arrays.copyOfRange(arr,<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line"><span class="comment">//arr1：[20, 30] （从第1位（0开始）截取到第3位（不包括）</span></span><br></pre></td></tr></table></figure><p> <strong>对数组元素采用指定的方法计算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelPrefix(array, (x,y)-&gt;(x+y)); <span class="comment">//[3, 13, 17, 17, 19]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">array = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>&#125;;</span><br><span class="line">Arrays.parallelSetAll(array, (x)-&gt;(x*x)); <span class="comment">//[0, 1, 4, 9, 16]</span></span><br><span class="line">out.println(Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">Arrays.setAll(array, (x)-&gt;(x%<span class="number">3</span>));</span><br><span class="line">out.println(Arrays.toString(array)); <span class="comment">//[0, 1, 2, 0, 1], 与parallelSetAll相比只是不并行</span></span><br></pre></td></tr></table></figure><p><strong>自定义排序规则</strong></p><p><code>Arrays.sort</code>方法和<code>Collections.sort</code>方法都提供了一个可以接收<code>Comparator</code>实例作为第二个参数的版本。</p><p>像Comparator、Runable等这&#x3D;一些接口有一个特点就是只有一个抽象方法（其他的都是static或者default的方法），比如继承Comparator接口只需要重写compare方法，继承Runnable接口只需要重写run方法，这种类型的接口被称为函数式接口，可以被lambda表达式所代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Comparator&lt;String&gt; comp = (first, second) -&gt; first.length() - second.length();</span><br><span class="line">Arrays.sort(names, comp);</span><br></pre></td></tr></table></figure><p>或者更简单些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;tom&quot;</span>, <span class="string">&quot;alice&quot;</span>, <span class="string">&quot;fred&quot;</span>&#125;;</span><br><span class="line">Arrays.sort(names, (first, second) -&gt; first.length() - second.length());</span><br></pre></td></tr></table></figure><h3 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a>ArrayList类</h3><p><strong>add()</strong></p><p>将元素插入指定位置的动态数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.add（<span class="type">int</span> index，E element）</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure><p><strong>insert(itn index, object value)</strong></p><p>将元素插入到索引处(不过其有一定的限制性,必须在数组长度以内插入数组)</p><p><strong>addAll()</strong></p><p>将给定集合中的所有元素添加到 arraylist 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.addAll(<span class="type">int</span> index, Collection c)</span><br><span class="line"><span class="comment">//如果 index 没有传入实际参数，元素将插入数组末尾。</span></span><br></pre></td></tr></table></figure><p><strong>clear()</strong></p><p>用于删除动态数组中的所有元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clear()</span><br></pre></td></tr></table></figure><p><strong>clone()</strong></p><p>用于拷贝一份动态数组，属于浅拷贝。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.clone()</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例：sites为已设置好的数组，使用clone将其拷贝给clonesites;</span></span><br><span class="line">ArrayList&lt;String&gt; cloneSites = (ArrayList&lt;String&gt;)sites.clone();</span><br></pre></td></tr></table></figure><p><strong>拓展：</strong></p><p>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存， 所以<strong>如果其中一个对象改变了这个地址，就会影响到另一个对象</strong>。</p><p>浅拷贝对应的就是深拷贝，深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且<strong>修改新对象不会影响原对象</strong>。</p><p><strong>contains()</strong></p><p>判断元素是否在动态数组中。</p><p>存在于动态数组中，则返回 true。</p><p>不存在于动态数组中，则返回 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.contains(Object obj)</span><br></pre></td></tr></table></figure><p><strong>set()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arraylist.set(<span class="type">int</span> index,E element) ;</span><br><span class="line">修改指定索引处的元素，返回被修改的元素。</span><br></pre></td></tr></table></figure><p><strong>get()</strong></p><p>通过索引值获取动态数组中的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraylist.get(<span class="type">int</span> index)</span><br></pre></td></tr></table></figure><p><strong>indexOf()</strong></p><p><strong>remove()</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arraylist.remove(<span class="type">int</span> index) ;</span><br><span class="line">移除此集合中指定位置上的元素。返回被删除的元素。</span><br><span class="line">arraylist.remove(Object o) ;</span><br><span class="line">删除指定的元素，返回删除是否成功    </span><br></pre></td></tr></table></figure><p><strong>size()</strong></p><p>返回此集合中的元素数。遍历集合时，可以控制索引范围，防止越界。</p><p><strong>isEmpty()</strong></p><p><strong>subList()</strong></p><p><strong>sort()</strong></p><p><strong>toArray()</strong></p><p><strong>toString()</strong></p><p><strong>ensureCapacity()</strong></p><p><strong>lastIndexOf()</strong></p><p><strong>retainAll()</strong></p><p><strong>containAll()</strong></p><p><strong>trimToSize()</strong></p><p><strong>removeRange()</strong></p><p> <strong>replaceAll()</strong></p><p><strong>removeIf()</strong></p><p><strong>forEach()</strong></p><h3 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a>LinkedList类</h3><p><strong>add(E e)</strong> 将指定元素添加到此列表的结尾。</p><p><strong>add(int index, E element)</strong> 在此列表中指定的位置插入指定的元素。</p><p><strong>get(int index)</strong> 返回此列表中指定位置处的元素。</p><p><strong>getFirst()</strong> 返回此列表的第一个元素。</p><p><strong>getLast</strong>() 返回此列表的最后一个元素。</p><p><strong>remove(int index)</strong> 移除此列表中指定位置处的元素。</p><p><strong>remove()</strong> 获取并移除此列表的头（第一个元素）。</p><p><strong>remove(Object o)</strong> 从此列表中移除首次出现的指定元素（如果存在）。</p><p><strong>size()</strong>   返回此列表的元素数。</p><p><strong>push(E e)：</strong>与addFirst一样，实际上它就是addFirst；</p><p><strong>pop()  :</strong> removeFirst一样，实际上它就是removeFirst；</p><p><strong>E poll()：</strong>查询并移除第一个元素；</p><p><strong>peek()  :</strong> 获取第一个元素，但是不移除；</p><p> <strong>offer(E e)：</strong>在链表尾部插入一个元素；</p><p><strong>isEmpty :</strong> 判空</p><p><strong>contains(Object o) ：</strong>是否包含</p><h3 id="Hashset类"><a href="#Hashset类" class="headerlink" title="Hashset类"></a>Hashset类</h3><h3 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a>HashMap类</h3><p>HashMap的每次增删查改都是O(1)，但这个常数操作比较大，是没数组的查询快的。</p><p><strong>put(key, value) ：</strong>将键&#x2F;值 映射 存放到Map集合中（如果key重复，则会覆盖原先的value值）</p><p><strong>get(key) ：</strong>返回指定键 所映射的值，没有该key对应的值则返回null</p><p><strong>getOrDefault ( key, defaultvalue) :</strong> 当集合中有这个key时，就返回key对应的value，没有这个key的话，返回默认值；</p><p><strong>size( ) ：</strong>返回Map集合中的 key-value的组数</p><p><strong>clear( )：</strong>清空Map集合</p><p><strong>isEmpty( )：</strong>判空，集合中为空则返回true</p><p><strong>remove（key）：</strong>删除集合中键为key的数据，并返回对应的value值</p><p>getOrDefault( key, defaultValue) :  返回key对应的value值，如果没有该key值，就返回默认值defaultValue</p><p><strong>values（）：</strong>返回Map集合中所有value组成的以Collection数据类型格式数据（一般用于遍历HashMap集合中value值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;();</span><br><span class="line">Collection&lt;Integer&gt; con = map.values();</span><br><span class="line"><span class="keyword">for</span> (Integer score : con) &#123;</span><br><span class="line">System.out.println(score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>keyset（）：</strong>返回Map集合中所有key组成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将key作为元素转存入一个set集合。</span></span><br><span class="line">Set&lt;String&gt; set = map.keySet();</span><br><span class="line"><span class="comment">//遍历HashMap集合中的key和value</span></span><br><span class="line"><span class="keyword">for</span> (String key : set) &#123;</span><br><span class="line">System.out.println(key + <span class="string">&quot; &quot;</span> + map.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet（）：</strong> 将Map集合每个key-value转换为一个Entry对象，并返回由所有的Entry对象组成的Set集合</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将每一组key-value变为一个entry对象存入set集合</span></span><br><span class="line">Set&lt;Entry&lt;String, Integer&gt;&gt; set = map.entrySet();</span><br><span class="line"><span class="keyword">for</span> (Entry&lt;String, Integer&gt; entry : set)&#123;</span><br><span class="line">System.out.println(entry.getKey() + <span class="string">&quot;:&quot;</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable类"><a href="#Hashtable类" class="headerlink" title="Hashtable类"></a>Hashtable类</h3><p>Hashtable定义了四个构造方法。第一个是默认构造方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable()</span><br></pre></td></tr></table></figure><p>第二个构造函数创建指定大小的哈希表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size)</span><br></pre></td></tr></table></figure><p>第三个构造方法创建了一个指定大小的哈希表，并且通过fillRatio指定填充比例。</p><p>填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(int size,float fillRatio)</span><br></pre></td></tr></table></figure><p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表。</p><p>哈希表的容量被设置为M的两倍。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hashtable(Map m)</span><br></pre></td></tr></table></figure><p>Hashtable中除了从Map接口中定义的方法外，还定义了以下方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>void clear( )</strong>  将此哈希表清空，使其不包含任何键。</td></tr><tr><td align="left">2</td><td align="left"><strong>Object clone( )</strong> 创建此哈希表的浅表副本。</td></tr><tr><td align="left">3</td><td align="left"><strong>boolean contains(Object value)</strong>  测试此映射表中是否存在与指定值关联的键。</td></tr><tr><td align="left">4</td><td align="left"><strong>boolean containsKey(Object key)</strong> 测试指定对象是否为此哈希表中的键。</td></tr><tr><td align="left">5</td><td align="left"><strong>boolean containsValue(Object value)</strong> 如果此 Hashtable 将一个或多个键映射到此值，则返回 true。</td></tr><tr><td align="left">6</td><td align="left"><strong>Enumeration elements( )</strong> 返回此哈希表中的值的枚举。</td></tr><tr><td align="left">7</td><td align="left"><strong>Object get(Object key)</strong>  返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null. 更确切地讲，如果此映射包含满足 (key.equals(k)) 的从键 k 到值 v 的映射，则此方法返回 v；否则，返回 null。</td></tr><tr><td align="left">8</td><td align="left"><strong>boolean isEmpty( )</strong> 测试此哈希表是否没有键映射到值。</td></tr><tr><td align="left">9</td><td align="left"><strong>Enumeration keys( )</strong>  返回此哈希表中的键的枚举。</td></tr><tr><td align="left">10</td><td align="left"><strong>Object put(Object key, Object value)</strong> 将指定 key 映射到此哈希表中的指定 value。</td></tr><tr><td align="left">11</td><td align="left"><strong>void rehash( )</strong> 增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素。</td></tr><tr><td align="left">12</td><td align="left"><strong>Object remove(Object key)</strong> 从哈希表中移除该键及其相应的值。</td></tr><tr><td align="left">13</td><td align="left"><strong>int size( )</strong>  返回此哈希表中的键的数量。</td></tr><tr><td align="left">14</td><td align="left"><strong>String toString( )</strong> 返回此 Hashtable 对象的字符串表示形式，其形式为 ASCII 字符 “, “ （逗号加空格）分隔开的、括在括号中的一组条目。</td></tr></tbody></table><h3 id="TreeMap类"><a href="#TreeMap类" class="headerlink" title="TreeMap类"></a>TreeMap类</h3><p>TreeMap中的值有序排列，每次增删改查的时间复杂度都是O(logN)；<br>创建时传入Comparator可自定义排序规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用默认构造器是自然顺序的，重写Compatator能实现q排序）</span></span><br><span class="line"><span class="type">TreeMap</span> <span class="variable">treeMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeMap</span>(<span class="keyword">new</span> <span class="title class_">Comparator</span>() &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Object o1, Object o2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ((String) o2).compareTo((String) o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//要往TreeMap中加入自定义的类型对象，需要该类型的对象实现comparable接口，否则会抛出类型转换异常</span></span><br></pre></td></tr></table></figure><p>基本的put, get, remove, containskey都一样；</p><ul><li>fristKey()  返回排序后的第一个</li><li>lastKey()   返回排序后的最后一个</li><li>floorKey(key1)  返回小于等于key1的最近的key</li><li>ceilingKey(key1)  返回大于等于key1的最近的key</li></ul><h3 id="Deque类"><a href="#Deque类" class="headerlink" title="Deque类"></a>Deque类</h3><p>Deque（java.util.Deque）接口代表着双向队列，意思就是可以从队列的两端增加或者删除元素，</p><ul><li>deque 是“double ended queue（双端队列）”的缩写，通常读为“deck”。</li></ul><p><strong>Deque的实现</strong>：<br>既然Deque是个接口所以初始化时就要用到其具体的实现，在 Collections API中有下面两种实现:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.LinkedList</span><br><span class="line">java.util.ArrayDeque</span><br></pre></td></tr></table></figure><p>LinkedList类是非常标准的Deque和Queue的实现，它在内部使用链接列表来建模queue或deque。</p><p>ArrayDeque类内部存储元素是数组，如果元素数超过数组中的空间，则分配一个新的数组，并移动所有元素，换句话说，ArrayDeque根据需要增长，即使它将元素存储在数组中。</p><p><strong>创建Deque</strong><br>在使用Deque之前首先要创建 Deque接口实现的实例，下面是创建 LinkedList实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new LinkedList();</span><br></pre></td></tr></table></figure><p>创建 ArrayDeque实例:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque deque = new ArrayDeque();</span><br></pre></td></tr></table></figure><p>Deque泛型<br>默认 Deque放入的Object对象，但是也可以用泛型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;MyObject&gt; deque = new LinkedList&lt;MyObject&gt;();</span><br></pre></td></tr></table></figure><p>这个Deque中只能添加 MyObject的实例对象，并且访问时不需要强制类型转换：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MyObject myObject = deque.remove();</span><br><span class="line"></span><br><span class="line">for(MyObject anObject : deque)&#123;</span><br><span class="line">   //do someting to anObject...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Deque中添加元素</strong><br>前面讲到可以在Deque 的两端增加元素，Deque 中有下面几种添加元素的方法：</p><p>add()<br>addLast()<br>addFirst()<br>offer()<br>offerFirst()<br>offerLast()</p><p>方法具体说明：</p><p>add()<br>可以使用add()方法在Deque 的尾部添加元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>如果元素不能插入到Deque，那么add()，方法将抛异常，而 offer()方法不一样，如果不能添加元素offer()方法将返回false。add()方法实际是继承Queue接口。</p><p>offer()<br>offer()方法可以在Deque的尾部添加元素，如果元素没满则添加成功返回true，否则返回false。这是和 add()抛异常方法不同的地方，下面是使用offer()方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.offer(&quot;element 1&quot;);</span><br></pre></td></tr></table></figure><p>push()<br>push()方法是在Deque的头部添加元素，如果Deque中的元素满了，则会抛异常，这和addFirst()方法比较相似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br></pre></td></tr></table></figure><p><strong>获取元素：</strong></p><p>peek()<br>peekFirst()<br>peekLast()<br>getFirst()<br>getLast()<br>peek()<br>peek()返回Deque中的第一个元素并且不删除，如果Deque是空则返回null：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line">String firstElement = deque.peek();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement将指向Deque的第一个元素： “first element”。</p><p>getFirst()<br>getFirst()方法获取Deque的第一个元素并且不删除，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;last element&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">String firstElement = deque.getFirst();</span><br></pre></td></tr></table></figure><p>执行完代码后firstElement的值是: “first element”。</p><p><strong>移除Deque中的元素</strong><br>以下几种方法可以移除Deque 中的元素：</p><p>remove()<br>removeFirst()<br>removeLast()<br>poll()<br>pollFirst()<br>pollLast()<br>remove()<br>remove()方法移除Deque中的第一个元素并返回：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.remove();</span><br></pre></td></tr></table></figure><p>如果Deque 是空则抛异常，这一点和poll()返回null不一样。 </p><p>poll()<br>poll()方法移除Deque中的第一个元素，如果Deque为空则poll()返回null，这和remove()方法抛异常不一样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.poll();</span><br></pre></td></tr></table></figure><p>pop()<br>pop()方法移除Deque的第一个元素，如果Deque是空则抛异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.push(&quot;element 0&quot;);</span><br><span class="line"></span><br><span class="line">String removedElement = deque.pop();</span><br></pre></td></tr></table></figure><p><strong>检查Deque是否包含某个元素</strong><br>可以用contains()方法检查Deque中是否包含某个元素，如果包含返回true否则返回false:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line"></span><br><span class="line">boolean containsElement1 = deque.contains(&quot;first element&quot;);</span><br><span class="line">boolean containsElement2 = deque.contains(&quot;second element&quot;);</span><br></pre></td></tr></table></figure><p>执行完代码后containsElement1的值是true ，containsElement2值是false。</p><p><strong>Deque的大小</strong><br>Deque的size()方法可以返回Deque中存储的元素个数： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;first element&quot;);</span><br><span class="line">deque.add(&quot;second element&quot;);</span><br><span class="line"></span><br><span class="line">int size = deque.size();</span><br></pre></td></tr></table></figure><p>执行完代码后size大小是2，因为Deque中包含两个元素。</p><p><strong>迭代Deque中的元素</strong><br>可以通过两种方法迭代Deque中的元素：</p><p>使用Iterator.<br>使用for-each循环.<br>具体使用哪一种迭代取决Deque的实现。</p><p>通过迭代器迭代Deque<br>第一种方法是获取Deque的Iterator，下面是代码： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = deque.iterator();</span><br><span class="line">while(iterator.hasNext()&#123;</span><br><span class="line">  String element = iterator.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过For-Each循环迭代Deque<br>第二种方法是通过for-each循环迭代Deque：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">deque.add(&quot;element 0&quot;);</span><br><span class="line">deque.add(&quot;element 1&quot;);</span><br><span class="line">deque.add(&quot;element 2&quot;);</span><br><span class="line"></span><br><span class="line">for(String element : deque) &#123;</span><br><span class="line">    System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Properties-类"><a href="#Properties-类" class="headerlink" title="Properties 类"></a>Properties 类</h3><p>Properties 继承于 Hashtable。表示一个持久的属性集.属性列表中每个键及其对应值都是一个<strong>字符串</strong>。</p><p>这个类的优势是可以从流中加载属性集，或者把属性集报错到流中。</p><p>除了从 Hashtable 中所定义的方法，Properties 还定义了以下方法：</p><table><thead><tr><th align="left"><strong>序号</strong></th><th align="left"><strong>方法描述</strong></th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>String getProperty(String key)</strong>  用指定的键在此属性列表中搜索属性。</td></tr><tr><td align="left">2</td><td align="left"><strong>String getProperty(String key, String defaultProperty)</strong> 用指定的键在属性列表中搜索属性。</td></tr><tr><td align="left">3</td><td align="left"><strong>void list(PrintStream streamOut)</strong>  将属性列表输出到指定的输出流。</td></tr><tr><td align="left">4</td><td align="left"><strong>void list(PrintWriter streamOut)</strong> 将属性列表输出到指定的输出流。</td></tr><tr><td align="left">5</td><td align="left"><strong>void load(InputStream streamIn) throws IOException</strong>  从输入流中读取属性列表（键和元素对）。</td></tr><tr><td align="left">6</td><td align="left"><strong>Enumeration propertyNames( )</strong> 按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）。</td></tr><tr><td align="left">7</td><td align="left"><strong>Object setProperty(String key, String value)</strong>  调用 Hashtable 的方法 put。</td></tr><tr><td align="left">8</td><td align="left"><strong>void store(OutputStream streamOut, String description)</strong>  以适合使用 load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表（键和元素对）写入输出流。</td></tr></tbody></table><h3 id="Iterator类"><a href="#Iterator类" class="headerlink" title="Iterator类"></a>Iterator类</h3><p>Iterator（迭代器）不是一个集合，它是一种用于访问集合的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RunoobTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建集合</span></span><br><span class="line">        ArrayList&lt;String&gt; sites = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 获取迭代器</span></span><br><span class="line">        Iterator&lt;String&gt; it = sites.iterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Number类"><a href="#Number类" class="headerlink" title="Number类"></a>Number类</h3><h5 id="xxxValue"><a href="#xxxValue" class="headerlink" title="xxxValue()"></a>xxxValue()</h5><p>以xxx类型返回指定的数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xxxValue()</span><br><span class="line">byteValue()  <span class="comment">//以byte类型返回指定的数值</span></span><br><span class="line"><span class="comment">//有byte,double,float,int,long,short</span></span><br><span class="line"><span class="comment">//此函数不接受参数</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">      <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">      <span class="comment">// 返回 byte 原生数据类型</span></span><br><span class="line">      System.out.println( x.doubleValue() );</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：5.0</span><br></pre></td></tr></table></figure><h5 id="compareTo"><a href="#compareTo" class="headerlink" title="compareTo()"></a>compareTo()</h5><p>用于两个相同数据类型的比较；</p><p>两个不同类型的数据不能用此方法来比较。</p><ul><li>如果指定的数与参数<strong>相等返回0</strong>。</li><li>如果指定的数<strong>小于</strong>参数<strong>返回 -1</strong>。</li><li>如果指定的数<strong>大于</strong>参数<strong>返回 1</strong>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(referenceName)</span></span><br><span class="line"><span class="comment">//referenceName -- 可以是一个 Byte, Double, Integer, Float, Long 或 Short 类型的参数。</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Interger</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">System.out.println(x.compareTo(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结果：1</span><br></pre></td></tr></table></figure><h5 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h5><p>判断 Number 对象与方法的参数是否相等（类型和数值）</p><ul><li>如果Number 对象不为 Null，且与方法的参数类型与数值都相等返回 True，否则返回 False。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object x)</span> <span class="comment">//x为任何对象</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">z</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">Short</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        System.out.println(x.equals(y));</span><br><span class="line">        System.out.println(x.equals(z));</span><br><span class="line">        System.out.println(x.equals(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">false</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure><h5 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h5><p>返回给定参数的原生 Number 对象值，</p><p>参数可以是原生数据类型，如String等。</p><p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的对象值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">9</span>);</span><br><span class="line">        <span class="type">Double</span> <span class="variable">c</span> <span class="operator">=</span> Double.valueOf(<span class="number">5</span>);</span><br><span class="line">        <span class="type">Float</span> <span class="variable">a</span> <span class="operator">=</span> Float.valueOf(<span class="string">&quot;80&quot;</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;444&quot;</span>, <span class="number">16</span>);   <span class="comment">// 使用 16 进制</span></span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">80.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure><h5 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h5><p>返回以一个字符串表示的 Number 对象值。</p><p>如果方法有两个参数， 返回用第二个参数指定基数表示的第一个参数的字符串表示形式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(x.toString());</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">12</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><p>将字符串参数作为有符号的十进制整数进行解析。</p><p>如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span>Integer.parseInt(<span class="string">&quot;9&quot;</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">c</span> <span class="operator">=</span> Double.parseDouble(<span class="string">&quot;5&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Integer.parseInt(<span class="string">&quot;444&quot;</span>,<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(x);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        System.out.println(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">9</span><br><span class="line">5.0</span><br><span class="line">1092</span><br></pre></td></tr></table></figure><h3 id="Math数学类"><a href="#Math数学类" class="headerlink" title="Math数学类"></a>Math数学类</h3><p>在源文件顶部加上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Math.*;</span><br></pre></td></tr></table></figure><p>Math类</p><h4 id="abs"><a href="#abs" class="headerlink" title="abs()"></a>abs()</h4><p>返回参数的<strong>绝对值</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> -<span class="number">8</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> -<span class="number">100</span>;</span><br><span class="line">                        </span><br><span class="line">        System.out.println(Math.abs(a));</span><br><span class="line">        System.out.println(Math.abs(d));   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure><h4 id="sqrt"><a href="#sqrt" class="headerlink" title="sqrt()"></a>sqrt()</h4><p>返回参数的算术平方根。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;sqrt(%.3f) 为 %.3f%n&quot;</span>, x, Math.sqrt(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqrt(<span class="number">11.635</span>) 为 <span class="number">3.411</span></span><br></pre></td></tr></table></figure><h4 id="round"><a href="#round" class="headerlink" title="round()"></a>round()</h4><p>返回一个最接近的int ,long型值，”<strong>四舍五入</strong>“，算法为**Math.floor(x+0.5)**；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        System.out.println(Math.round(d));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">101</span><br></pre></td></tr></table></figure><h4 id="min-和max"><a href="#min-和max" class="headerlink" title="min()和max()"></a>min()和max()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println(Math.min(<span class="number">12</span>,<span class="number">30</span>)); </span><br><span class="line">        System.out.println(Math.max(<span class="number">12</span>,<span class="number">30</span>));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">30</span><br></pre></td></tr></table></figure><h4 id="random"><a href="#random" class="headerlink" title="random()"></a>random()</h4><p>返回一个随机数，随机数范围为 0.0 &lt;&#x3D; x &lt; 1.0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        System.out.println( Math.random() );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5444085967267008</span><br></pre></td></tr></table></figure><h4 id="pow"><a href="#pow" class="headerlink" title="pow()"></a>pow()</h4><p>返回第一个参数的第二个参数次方。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2.76</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;pow(%.3f, %.3f) 为 %.3f%n&quot;</span>, x, y, Math.pow(x, y));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pow(11.635, 2.760) 为 874.008</span><br></pre></td></tr></table></figure><h4 id="exp"><a href="#exp" class="headerlink" title="exp()"></a>exp()</h4><p>返回自然数底数e的参数次方</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;exp(%.3f) 为 %.3f%n&quot;</span>, x, Math.exp(x));  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">exp(<span class="number">11.635</span>) 为 <span class="number">112983.831</span></span><br></pre></td></tr></table></figure><h4 id="log"><a href="#log" class="headerlink" title="log()"></a>log()</h4><p>返回参数的自然数底数的对数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">11.635</span>;</span><br><span class="line"></span><br><span class="line">        System.out.printf(<span class="string">&quot;e 的值为 %.4f%n&quot;</span>, Math.E);</span><br><span class="line">        System.out.printf(<span class="string">&quot;log(%.3f) 为 %.3f%n&quot;</span>, x, Math.log(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e 的值为 <span class="number">2.7183</span></span><br><span class="line">log(<span class="number">11.635</span>) 为 <span class="number">2.454</span></span><br></pre></td></tr></table></figure><h4 id="rint"><a href="#rint" class="headerlink" title="rint()"></a>rint()</h4><p>返回最接近参数的整数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">100.500</span>;</span><br><span class="line">        <span class="type">double</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">100.200</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.rint(d));</span><br><span class="line">        System.out.println(Math.rint(e)); </span><br><span class="line">        System.out.println(Math.rint(f)); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">101.0</span><br><span class="line">100.0</span><br><span class="line">100.0</span><br></pre></td></tr></table></figure><h4 id="floor-x2F-ceil"><a href="#floor-x2F-ceil" class="headerlink" title="floor()&#x2F;ceil()"></a>floor()&#x2F;ceil()</h4><p>floor()：对一个数进行下舍入，返回给定参数最大的整数，该整数小于或等给定的参数。</p><p>ceil()：对一个数进行上舍入，返回值大于或等于给定的参数，类型为双精度浮点型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span>&#123;</span><br><span class="line">        <span class="type">double</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">100.675</span>;</span><br><span class="line">        <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> -<span class="number">90</span>;</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.floor(d));</span><br><span class="line">        System.out.println(Math.floor(f));</span><br><span class="line"> </span><br><span class="line">        System.out.println(Math.ceil(d));</span><br><span class="line">        System.out.println(Math.ceil(f));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h3><p><strong>枚举</strong></p><table><thead><tr><th>1</th><th><strong>boolean hasMoreElements( )</strong></th><th>测试此枚举是否包含更多的元素。</th></tr></thead><tbody><tr><td>2</td><td><strong>Object nextElement( )</strong></td><td>如果此枚举对象至少还有一个可提供的元素，则返回此枚举的下一个元素。</td></tr></tbody></table><h3 id="Vector类"><a href="#Vector类" class="headerlink" title="Vector类"></a>Vector类</h3><p>Vector 类实现了一个动态数组。和 ArrayList 很相似，但是两者是不同的：</p><ul><li>Vector 是同步访问的。</li><li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li></ul><p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p><p>Vector 类支持 <strong>4 种构造方法</strong>。</p><p>第一种构造方法创建一个默认的向量，默认大小为 10：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector()</span><br></pre></td></tr></table></figure><p>第二种构造方法创建指定大小的向量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size)</span><br></pre></td></tr></table></figure><p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定。增量表示向量每次增加的元素数目。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(int size,int incr)</span><br></pre></td></tr></table></figure><p>第四种构造方法创建一个包含集合 c 元素的向量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vector(Collection c)</span><br></pre></td></tr></table></figure><p>Vector还拥有以下方法：</p><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void add(int index, Object element)   在此向量的指定位置插入指定的元素。</td></tr><tr><td align="left">2</td><td align="left">boolean add(Object o)   将指定元素添加到此向量的末尾。</td></tr><tr><td align="left">3</td><td align="left">boolean addAll(Collection c)  将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素。</td></tr><tr><td align="left">4</td><td align="left">boolean addAll(int index, Collection c)  在指定位置将指定 Collection 中的所有元素插入到此向量中。</td></tr><tr><td align="left">5</td><td align="left">void addElement(Object obj)   将指定的组件添加到此向量的末尾，将其大小增加 1。</td></tr><tr><td align="left">6</td><td align="left">int capacity()  返回此向量的当前容量。</td></tr><tr><td align="left">7</td><td align="left">void clear()  从此向量中移除所有元素。</td></tr><tr><td align="left">8</td><td align="left">Object clone()  返回向量的一个副本。</td></tr><tr><td align="left">9</td><td align="left">boolean contains(Object elem)  如果此向量包含指定的元素，则返回 true。</td></tr><tr><td align="left">10</td><td align="left">boolean containsAll(Collection c)  如果此向量包含指定 Collection 中的所有元素，则返回 true。</td></tr><tr><td align="left">11</td><td align="left">void copyInto(Object[] anArray)   将此向量的组件复制到指定的数组中。</td></tr><tr><td align="left">12</td><td align="left">Object elementAt(int index)  返回指定索引处的组件。</td></tr><tr><td align="left">13</td><td align="left">Enumeration elements()  返回此向量的组件的枚举。</td></tr><tr><td align="left">14</td><td align="left">void ensureCapacity(int minCapacity)  增加此向量的容量（如有必要），以确保其至少能够保存最小容量参数指定的组件数。</td></tr><tr><td align="left">15</td><td align="left">boolean equals(Object o)  比较指定对象与此向量的相等性。</td></tr><tr><td align="left">16</td><td align="left">Object firstElement()  返回此向量的第一个组件（位于索引 0) 处的项）。</td></tr><tr><td align="left">17</td><td align="left">Object get(int index)  返回向量中指定位置的元素。</td></tr><tr><td align="left">18</td><td align="left">int hashCode()  返回此向量的哈希码值。</td></tr><tr><td align="left">19</td><td align="left">int indexOf(Object elem)   返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1。</td></tr><tr><td align="left">20</td><td align="left">int indexOf(Object elem, int index)   返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1。</td></tr><tr><td align="left">21</td><td align="left">void insertElementAt(Object obj, int index)  将指定对象作为此向量中的组件插入到指定的 index 处。</td></tr><tr><td align="left">22</td><td align="left">boolean isEmpty()  测试此向量是否不包含组件。</td></tr><tr><td align="left">23</td><td align="left">Object lastElement()  返回此向量的最后一个组件。</td></tr><tr><td align="left">24</td><td align="left">int lastIndexOf(Object elem)   返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1。</td></tr><tr><td align="left">25</td><td align="left">int lastIndexOf(Object elem, int index)  返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1。</td></tr><tr><td align="left">26</td><td align="left">Object remove(int index)   移除此向量中指定位置的元素。</td></tr><tr><td align="left">27</td><td align="left">boolean remove(Object o)  移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变。</td></tr><tr><td align="left">28</td><td align="left">boolean removeAll(Collection c)  从此向量中移除包含在指定 Collection 中的所有元素。</td></tr><tr><td align="left">29</td><td align="left">void removeAllElements()  从此向量中移除全部组件，并将其大小设置为零。</td></tr><tr><td align="left">30</td><td align="left">boolean removeElement(Object obj)  从此向量中移除变量的第一个（索引最小的）匹配项。</td></tr><tr><td align="left">31</td><td align="left">void removeElementAt(int index)  删除指定索引处的组件。</td></tr><tr><td align="left">32</td><td align="left">protected void removeRange(int fromIndex, int toIndex) 从此 List 中移除其索引位于 fromIndex（包括）与 toIndex（不包括）之间的所有元素。</td></tr><tr><td align="left">33</td><td align="left">boolean retainAll(Collection c)  在此向量中仅保留包含在指定 Collection 中的元素。</td></tr><tr><td align="left">34</td><td align="left">Object set(int index, Object element)  用指定的元素替换此向量中指定位置处的元素。</td></tr><tr><td align="left">35</td><td align="left">void setElementAt(Object obj, int index)  将此向量指定 index 处的组件设置为指定的对象。</td></tr><tr><td align="left">36</td><td align="left">void setSize(int newSize)   设置此向量的大小。</td></tr><tr><td align="left">37</td><td align="left">int size()   返回此向量中的组件数。</td></tr><tr><td align="left">38</td><td align="left">List subList(int fromIndex, int toIndex)  返回此 List 的部分视图，元素范围为从 fromIndex（包括）到 toIndex（不包括）。</td></tr><tr><td align="left">39</td><td align="left">Object[] toArray()  返回一个数组，包含此向量中以恰当顺序存放的所有元素。</td></tr><tr><td align="left">40</td><td align="left">Object[] toArray(Object[] a)  返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型。</td></tr><tr><td align="left">41</td><td align="left">String toString()  返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式。</td></tr><tr><td align="left">42</td><td align="left">void trimToSize()   对此向量的容量进行微调，使其等于向量的当前大小。</td></tr></tbody></table><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VectorDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> &#123;</span><br><span class="line">      <span class="comment">// initial size is 3, increment is 2</span></span><br><span class="line">      <span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial size: &quot;</span> + v.size());</span><br><span class="line">      System.out.println(<span class="string">&quot;Initial capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">1</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">2</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">4</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Capacity after four additions: &quot;</span> +</span><br><span class="line">          v.capacity());</span><br><span class="line"></span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">5.45</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Double</span>(<span class="number">6.08</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">7</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">9.4</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;Current capacity: &quot;</span> +</span><br><span class="line">      v.capacity());</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">11</span>));</span><br><span class="line">      v.addElement(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">12</span>));</span><br><span class="line">      System.out.println(<span class="string">&quot;First element: &quot;</span> +</span><br><span class="line">         (Integer)v.firstElement());</span><br><span class="line">      System.out.println(<span class="string">&quot;Last element: &quot;</span> +</span><br><span class="line">         (Integer)v.lastElement());</span><br><span class="line">      <span class="keyword">if</span>(v.contains(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">3</span>)))</span><br><span class="line">         System.out.println(<span class="string">&quot;Vector contains 3.&quot;</span>);</span><br><span class="line">      <span class="comment">// enumerate the elements in the vector.</span></span><br><span class="line">      <span class="type">Enumeration</span> <span class="variable">vEnum</span> <span class="operator">=</span> v.elements();</span><br><span class="line">      System.out.println(<span class="string">&quot;\nElements in vector:&quot;</span>);</span><br><span class="line">      <span class="keyword">while</span>(vEnum.hasMoreElements())</span><br><span class="line">         System.out.print(vEnum.nextElement() + <span class="string">&quot; &quot;</span>);</span><br><span class="line">      System.out.println();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实例编译运行结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Initial size: <span class="number">0</span></span><br><span class="line">Initial capacity: <span class="number">3</span></span><br><span class="line">Capacity after four additions: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">5</span></span><br><span class="line">Current capacity: <span class="number">7</span></span><br><span class="line">Current capacity: <span class="number">9</span></span><br><span class="line">First element: <span class="number">1</span></span><br><span class="line">Last element: <span class="number">12</span></span><br><span class="line">Vector contains <span class="number">3.</span></span><br><span class="line"></span><br><span class="line">Elements in vector:</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5.45</span> <span class="number">6.08</span> <span class="number">7</span> <span class="number">9.4</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><h3 id="Bitset类"><a href="#Bitset类" class="headerlink" title="Bitset类"></a>Bitset类</h3><p>Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。这和位向量（vector of bits）比较类似。</p><p>BitSet定义了两个构造方法。</p><p>第一个构造方法创建一个默认的对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet()</span><br></pre></td></tr></table></figure><p>第二个方法允许用户指定初始大小。所有位初始化为0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BitSet(int size)</span><br></pre></td></tr></table></figure><p>BitSet中实现了Cloneable接口中定义的方法如下表所列：</p><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void and(BitSet set) 对此目标位 set 和参数位 set 执行逻辑与操作。</td></tr><tr><td align="left">2</td><td align="left">void andNot(BitSet set) 清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置。</td></tr><tr><td align="left">3</td><td align="left">int cardinality( ) 返回此 BitSet 中设置为 true 的位数。</td></tr><tr><td align="left">4</td><td align="left">void clear( ) 将此 BitSet 中的所有位设置为 false。</td></tr><tr><td align="left">5</td><td align="left">void clear(int index) 将索引指定处的位设置为 false。</td></tr><tr><td align="left">6</td><td align="left">void clear(int startIndex, int endIndex) 将指定的 startIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 false。</td></tr><tr><td align="left">7</td><td align="left">Object clone( ) 复制此 BitSet，生成一个与之相等的新 BitSet。</td></tr><tr><td align="left">8</td><td align="left">boolean equals(Object bitSet) 将此对象与指定的对象进行比较。</td></tr><tr><td align="left">9</td><td align="left">void flip(int index) 将指定索引处的位设置为其当前值的补码。</td></tr><tr><td align="left">10</td><td align="left">void flip(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的每个位设置为其当前值的补码。</td></tr><tr><td align="left">11</td><td align="left">boolean get(int index) 返回指定索引处的位值。</td></tr><tr><td align="left">12</td><td align="left">BitSet get(int startIndex, int endIndex) 返回一个新的 BitSet，它由此 BitSet 中从 fromIndex（包括）到 toIndex（不包括）范围内的位组成。</td></tr><tr><td align="left">13</td><td align="left">int hashCode( ) 返回此位 set 的哈希码值。</td></tr><tr><td align="left">14</td><td align="left">boolean intersects(BitSet bitSet) 如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true。</td></tr><tr><td align="left">15</td><td align="left">boolean isEmpty( ) 如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true。</td></tr><tr><td align="left">16</td><td align="left">int length( ) 返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1。</td></tr><tr><td align="left">17</td><td align="left">int nextClearBit(int startIndex) 返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上。</td></tr><tr><td align="left">18</td><td align="left">int nextSetBit(int startIndex) 返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上。</td></tr><tr><td align="left">19</td><td align="left">void or(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑或操作。</td></tr><tr><td align="left">20</td><td align="left">void set(int index) 将指定索引处的位设置为 true。</td></tr><tr><td align="left">21</td><td align="left">void set(int index, boolean v)  将指定索引处的位设置为指定的值。</td></tr><tr><td align="left">22</td><td align="left">void set(int startIndex, int endIndex) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为 true。</td></tr><tr><td align="left">23</td><td align="left">void set(int startIndex, int endIndex, boolean v) 将指定的 fromIndex（包括）到指定的 toIndex（不包括）范围内的位设置为指定的值。</td></tr><tr><td align="left">24</td><td align="left">int size( ) 返回此 BitSet 表示位值时实际使用空间的位数。</td></tr><tr><td align="left">25</td><td align="left">String toString( ) 返回此位 set 的字符串表示形式。</td></tr><tr><td align="left">26</td><td align="left">void xor(BitSet bitSet) 对此位 set 和位 set 参数执行逻辑异或操作。</td></tr></tbody></table><h3 id="Map接口-1"><a href="#Map接口-1" class="headerlink" title="Map接口"></a>Map接口</h3><p>Map 接口中键和值一一映射. 可以通过键来获取值。</p><ul><li>给定一个键和一个值，你可以将该值存储在一个 Map 对象。之后，你可以通过键来访问对应的值。</li><li>当访问的值不存在的时候，方法就会抛出一个 NoSuchElementException 异常。</li><li>当对象的类型和 Map 里元素类型不兼容的时候，就会抛出一个 ClassCastException 异常。</li><li>当在不允许使用 Null 对象的 Map 中使用 Null 对象，会抛出一个 NullPointerException 异常。</li><li>当尝试修改一个只读的 Map 时，会抛出一个 UnsupportedOperationException 异常。</li></ul><table><thead><tr><th align="left">序号</th><th align="left">方法描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">void clear( )  从此映射中移除所有映射关系（可选操作）。</td></tr><tr><td align="left">2</td><td align="left">boolean containsKey(Object k) 如果此映射包含指定键的映射关系，则返回 true。</td></tr><tr><td align="left">3</td><td align="left">boolean containsValue(Object v) 如果此映射将一个或多个键映射到指定值，则返回 true。</td></tr><tr><td align="left">4</td><td align="left">Set entrySet( ) 返回此映射中包含的映射关系的 Set 视图。</td></tr><tr><td align="left">5</td><td align="left">boolean equals(Object obj) 比较指定的对象与此映射是否相等。</td></tr><tr><td align="left">6</td><td align="left">Object get(Object k) 返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。</td></tr><tr><td align="left">7</td><td align="left">int hashCode( ) 返回此映射的哈希码值。</td></tr><tr><td align="left">8</td><td align="left">boolean isEmpty( ) 如果此映射未包含键-值映射关系，则返回 true。</td></tr><tr><td align="left">9</td><td align="left">Set keySet( ) 返回此映射中包含的键的 Set 视图。</td></tr><tr><td align="left">10</td><td align="left">Object put(Object k, Object v) 将指定的值与此映射中的指定键关联（可选操作）。</td></tr><tr><td align="left">11</td><td align="left">void putAll(Map m) 从指定映射中将所有映射关系复制到此映射中（可选操作）。</td></tr><tr><td align="left">12</td><td align="left">Object remove(Object k) 如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。</td></tr><tr><td align="left">13</td><td align="left">int size( ) 返回此映射中的键-值映射关系数。</td></tr><tr><td align="left">14</td><td align="left">Collection values( ) 返回此映射中包含的值的 Collection 视图。</td></tr></tbody></table><h3 id="system类"><a href="#system类" class="headerlink" title="system类"></a>system类</h3><p><strong>exit  退出当前程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.exit(<span class="number">0</span>);  <span class="comment">//表示程序退出，0表示一个正常的状态</span></span><br></pre></td></tr></table></figure><p><strong>arraycopy ：复制数组元素</strong>，比较适合底层调用，一般使用Arrays.copyOf 完成复制数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.arraycopy(src, srcPos, dest, destPos, length);</span><br><span class="line"><span class="comment">//src: 源数组</span></span><br><span class="line"><span class="comment">//srcPos: 从源数组的哪个索引开始拷贝</span></span><br><span class="line"><span class="comment">//dest: 目标数组</span></span><br><span class="line"><span class="comment">//destPos：源数组的数据拷贝到目标数组的哪个索引处</span></span><br><span class="line"><span class="comment">//length： 从源数组拷贝多少数据</span></span><br></pre></td></tr></table></figure><p><strong>currentTimeMillens ： 返回当前时间距离1970-1-1的毫秒数</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.currentTimeMillens();</span><br></pre></td></tr></table></figure><p><strong>gc：运行垃圾回收机制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.gc();</span><br></pre></td></tr></table></figure><h3 id="大数类型"><a href="#大数类型" class="headerlink" title="大数类型"></a>大数类型</h3><p><strong>BigInteger类：适合保存比较大的整型</strong></p><p><strong>BigDecimal类：适合保存进度更高的浮点型（小数）</strong></p><p>方法（算术）：</p><p>add  加</p><p>subtract   减</p><p>multiply    乘</p><p>divide    除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigInteger</span> <span class="variable">bigInteger2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigInteger</span>(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigInter.add(bigInteger2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigInter.subtract(bigInteger2); <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigInter.multiply(bigInteger2); <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigInter.divide(bigInteger2); <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"></span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.23788888899999999999999999999&quot;</span>);</span><br><span class="line"><span class="type">BigDecimal</span> <span class="variable">bigDecimal2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;100.11&quot;</span>);</span><br><span class="line"></span><br><span class="line">bigDecimal.add(bigDecimal2);  <span class="comment">//第一个数 加 第二个数</span></span><br><span class="line">bigDecimal.subtract(bigDecimal2); <span class="comment">//第一个数 减 第二个数</span></span><br><span class="line">bigDecimal.multiply(bigDecimal2); <span class="comment">//第一个数 乘 第二个数</span></span><br><span class="line">bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING); <span class="comment">//第一个数 除 第二个数</span></span><br><span class="line"><span class="comment">//因为除法可能会出现除不尽的情况，所以调用divide方法时，可以指定精度（在参数列表加上BigDecimal.ROUND_CEILING，如果出现无限循环小数，就会保留分子的进度）</span></span><br></pre></td></tr></table></figure><h3 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h3><p>第三代日期类（jdk8加入）</p><p>LocalDate（日期&#x2F;年月日）</p><p>LocalTime（时间&#x2F;时分秒）</p><p>LocalDateTime（时间&#x2F;年月日时分秒）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LocalDateTime</span> <span class="variable">ldt</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line"><span class="comment">//输出：2021-10-03T16:20:05.137</span></span><br></pre></td></tr></table></figure><p>使用DateTimeFormatter对象来进行格式化（ofPattern方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> dtf.format(ldt);</span><br><span class="line">System.out.println(<span class="string">&quot;格式化的日期 = &quot;</span> + format);</span><br><span class="line"><span class="comment">//输出：格式化的日期 = 2021-10-03 16:22:05</span></span><br></pre></td></tr></table></figure><p>日期类还有plus增加时间的某个部分，minus查看一年前和一年后的日期 …等等（具体看API文档）</p>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java—SSM&amp;Maven</title>
      <link href="/Notes/2022/04/14/Java%E2%80%94SSM&amp;Maven/"/>
      <url>/Notes/2022/04/14/Java%E2%80%94SSM&amp;Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>Maven 是专门用于<strong>管理和构建java项目的工具</strong>，它的主要功能有：</p><ul><li><p>提供了一套标准化的项目结构；</p></li><li><p>提供了一套标准化的构建流程 (编译，测试，打包，发布…)；</p></li><li><p>提供了一套依赖管理机制（指jar包，插件）；</p></li></ul><h2 id="分模块开发"><a href="#分模块开发" class="headerlink" title="分模块开发"></a>分模块开发</h2><p>多个场景的模块代码如果放入到一个项目，那么当其中某一个模块代码出现问题，就会导致整个项目无法正常启动；而且，各个模块可以单独维护，更方便团队协作。</p><p>例子：将SSM的各层分成各个模块</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232201296.png" alt="202205141022803"></p><p>步骤：</p><ol><li><p>创建新模块，将对应代码拷贝进去，删除原代码；</p></li><li><p>删除domain包后项目会报红，需要在<code>maven_ssm</code>的pom.xml 中添加<code>maven_03_pojo</code>的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于项目<code>maven_pojo</code>存在于IDEA，而Maven在本地仓库是找不到对应的jar包的，所以还要将<code>maven_pojo</code>安装到本地仓库中：</p><p>（使用maven的install命令，安装完后可以在Maven的本地仓库repository中对应的项目中查看jar包）</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232202718.png" alt="202205141022468"></p><p>同理，其他模块也是同样的操作：代码转移、添加依赖（安装项目jar包）</p></li></ol><h2 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h2><h3 id="lt-dependency-gt"><a href="#lt-dependency-gt" class="headerlink" title="&lt;dependency&gt;"></a>&lt;dependency&gt;</h3><blockquote><p>jar包查找顺序：本地仓库——远程仓库——中央仓库</p><p>远程仓库（私服）：一般由公司团队搭建的私有仓库。</p></blockquote><p>使用坐标导入jar包：</p><ol><li>在 pom.xml 中编写 &lt; dependencies &gt; 标签；</li><li>在&lt; dependencies &gt;标签中使用&lt; dependency &gt;引入坐标；</li><li>定义坐标的 groupld, artifactld, version；</li></ol><p><u>资源直接网上搜索：资源名 maven，如 mysql maven，然后会出现maven repository的网页，点进去复制坐标即可。</u></p><blockquote><p>Maven坐标：是资源的唯一标识，使用坐标来定义项目或引入项目中需要的依赖。</p><p>坐标组成：</p><ul><li>groupld：定义当前Maven项目隶属组织的名称（通常是域名反写，如：com.zzc）</li><li>artifactld：定义当前Maven项目名称（通常是模块名称，如：order-service，goods-service）</li><li>version：定义当前项目的版本号</li></ul></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置当前项目所依赖的所有jar--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置具体的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属群组id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖所属项目id--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--依赖版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>通过设置坐标的依赖范围(scope),可以设置对应ja包的作用范围：编译环境、测试环境、运行环境</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707938.png" alt="image-20220224164841772"></p><table><thead><tr><th>依赖范围</th><th>编译</th><th>测试</th><th>运行</th><th>例子</th></tr></thead><tbody><tr><td>compile</td><td>Y</td><td>Y</td><td>Y</td><td>logback</td></tr><tr><td>test</td><td>-</td><td>Y</td><td>-</td><td>Junit</td></tr><tr><td>provided</td><td>Y</td><td>Y</td><td></td><td>servlet-api</td></tr><tr><td>runtime</td><td></td><td>Y</td><td>Y</td><td>jdbc驱动</td></tr><tr><td>system</td><td>Y</td><td>Y</td><td></td><td>存储在本地的jar包</td></tr><tr><td>import</td><td></td><td></td><td></td><td></td></tr></tbody></table><h3 id="依赖管理-1"><a href="#依赖管理-1" class="headerlink" title="依赖管理"></a>依赖管理</h3><ul><li><p><strong>依赖传递</strong></p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232205409.png" alt="202205141033631" style="zoom:33%;" /><p>上图所示：A依赖了B和C，B和C有分别依赖了其他jar包，所以在A项目中就可以使用上面所有jar包，这就是所说的依赖传递。</p><p><strong>依赖冲突</strong>：项目依赖的某一个jar包，有多个不同的版本，因而造成类包版本冲突。</p><ul><li>Maven的默认管理：<ul><li>特殊优先：一个配置页中 配置了相同资源的不同版本，后配置的覆盖先配置的。</li><li>路径优先：当依赖中出现相同的资源时，层级越深，优先级越低，层级越浅，优先级越高（先出现的就选择）</li><li>声明优先：当资源在相同层级被依赖时，配置顺序靠前的覆盖配置顺序靠后的。如图中的D1和D2，层级相同，就看谁先声明。</li></ul></li></ul></li><li><p><strong>可选依赖</strong></p><p>可选依赖 指对外隐藏当前所依赖的资源——不透明，别人不需要；隐藏后将不会有依赖传递。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_03_pojo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--可选依赖是隐藏当前工程所依赖的资源，隐藏后对应资源将不具有依赖传递--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>排除依赖</strong></p><p>排除依赖指主动断开依赖的资源，被排除的资源无需指定版本——自己不需要；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_04_dao<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--排除依赖是隐藏当前资源对应的依赖关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="聚合、继承"><a href="#聚合、继承" class="headerlink" title="聚合、继承"></a>聚合、继承</h2><p>问题：分模块开发后，各模块相互依赖，可能要多次安装、编译。</p><p>对此，我们可以抽取一个项目，把所有的项目管理起来，以后我们要想操作这些项目，只需要操作这一个项目，其他所有的项目都走一样的流程，这就很省事省力。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><ul><li>概念：将多个模块组织成一个整体，同时进行项目构建的过程称为聚合</li><li>聚合工程：通常是一个不具有业务功能的”空”工程（有且仅有一个pom文件）</li><li>作用：使用聚合工程可以将多个工程编组，通过对聚合工程进行构建，实现对所包含的模块进行同步构建<ul><li>当工程中某个模块发生更新（变更）时，必须保障工程中与已更新模块关联的模块同步更新，此时可以使用聚合工程来解决批量模块同步构建的问题。</li></ul></li></ul><p>步骤：</p><ol><li><p>新建一个空的Maven工程<code>maven_01_parent</code>，将项目的打包方式改为pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>项目的打包方式，一般有三种，分别是</p><ul><li>jar：默认情况，说明该项目为java项目</li><li>war：说明该项目为web项目</li><li>pom：说明该项目为聚合或继承项目</li></ul></blockquote></li><li><p>添加要管理的项目：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>点击 compile 命令就可以让被管理的项目都会被执行编译操作。这就是聚合工程的作用。</p><blockquote><p>注：聚合工程管理的项目在进行运行的时候，执行的顺序是 按照项目与项目之间的依赖关系来自动决定的。</p></blockquote></li></ol><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>问题：多个模块中会出现重复配置的问题，同一个jar包或其不同版本 在不同模块中引入，最后汇集到一起。</p><ul><li><p>概念：描述的是两个工程间的关系，与java中的继承相似，子工程可以继承父工程中的配置信息，常见于依赖关系的继承。</p><blockquote><p><strong>父工程主要是用来快速配置依赖jar包和管理项目中所使用的资源</strong></p></blockquote></li><li><p>作用：</p><ul><li>简化配置</li><li>减少版本冲突</li></ul></li></ul><p>步骤：</p><ol><li><p>新建一个空的Maven工程<code>maven_01_parent</code>，将项目的打包方式改为pom（一般和聚合放在同一个工程，不冲突）</p></li><li><p>在子项目中设置它的父工程</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置当前工程继承自parent工程--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.zzc<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置父项目pom.xml位置路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../maven_01_parent/pom.xml<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优化子项目共有依赖的导入问题：</p><p>将子项目共同使用的jar包都抽取出来，维护在父项目的pom.xml中；</p><p>然后删除子项目中已经抽取到父项目的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_01_parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--设置管理的模块名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_02_ssm<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_03_pojo<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">module</span>&gt;</span>../maven_04_dao<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>优化</p><p>可能有的子项目并不需要 父项目的jar包，如果引入过多的jar包，也会有“负担”；</p><p>使用<code>&lt;dependencyManagement&gt;</code>，它不真正引入jar包，而是配置可供子项目选择的jar包依赖。<br>子项目要想使用它所提供的这些jar包，需要自己添加依赖，并且不需要指定版本<code>&lt;version&gt;</code></p><p>如：父项目中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义依赖管理--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子项目中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 不需要添加版本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>在Maven中的属性分为:</p><ul><li>自定义属性（常用）</li><li>内置属性</li><li>Setting属性</li><li>Java系统属性</li><li>环境变量属性</li></ul><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232203506.png" alt="202205141121299" style="zoom:50%;" /><h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>Maven中的自定义属性和变量类似，可以方便修改；</p><p>如：定义spring版本号 spring.version &#x3D; “5.2.10.RELEASE“， junit.version &#x3D; “4.12”等等</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--定义属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">junit.version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">junit.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis-spring.version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">mybatis-spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改依赖的version</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置文件加载属性"><a href="#配置文件加载属性" class="headerlink" title="配置文件加载属性"></a>配置文件加载属性</h3><p>。。。。。。。。</p><p>。。。。。。。。</p><h3 id="版本管理"><a href="#版本管理" class="headerlink" title="版本管理"></a>版本管理</h3><p>在jar包的版本定义中，有两个工程版本用的比较多:</p><ul><li>SNAPSHOT（快照版本）<ul><li>项目开发过程中临时输出的版本，称为快照版本</li><li>快照版本会随着开发的进展不断更新</li></ul></li><li>RELEASE（发布版本）<ul><li>项目开发到一定阶段里程碑后，向团队外部发布较为稳定的版本，这种版本所对应的构件文件是稳定的</li><li>即便进行功能的后续开发，也不会改变当前发布版本内容，这种版本称为发布版本</li></ul></li></ul><p>除了上面的工程版本，我们还经常能看到一些发布版本:</p><ul><li>alpha版:内测版，bug多不稳定内部版本不断添加新功能</li><li>beta版:公测版，不稳定(比alpha稳定些)，bug相对较多不断添加新功能</li><li>纯数字版</li></ul><h2 id="多环境配置"><a href="#多环境配置" class="headerlink" title="多环境配置"></a>多环境配置</h2><h3 id="多环境配置-1"><a href="#多环境配置-1" class="headerlink" title="多环境配置"></a>多环境配置</h3><p>一般项目分为若干环境，有：</p><ul><li>生产环境produce，</li><li>开发环境develop，</li><li>测试环境test，</li></ul><p>平时开发工作是在 开发环境develop进行的；开发完成后，需要把开发的功能部署到测试环境供测试人员进行测试使用；等测试人员测试通过后，会将项目部署到生成环境上线使用。</p><p>这个时候就有一个问题是，不同环境的配置是不相同的，所以会有三个数据库的url配置，需要能在不同环境进行切换：</p><p><strong>父工程配置多个环境，并指定默认激活环境</strong>，配置完记得 install</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profiles</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开发环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_dep<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.1.1.1:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--设定是否为默认启动环境--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_pro<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.2.2.2:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--测试环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span>&gt;</span>env_test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc.url</span>&gt;</span>jdbc:mysql://127.3.3.3:3306/ssm_db<span class="tag">&lt;/<span class="name">jdbc.url</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>切换不同环境： 执行Maven命令</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mvn 指令 -P 环境定义ID[环境定义中获取]</span><br><span class="line"></span><br><span class="line">//如: mvn install -P env_test    切换到测试环境</span><br></pre></td></tr></table></figure><h3 id="跳过测试"><a href="#跳过测试" class="headerlink" title="跳过测试"></a>跳过测试</h3><p>在执行<code>install</code>指令的时候，Maven都会按照顺序从上往下依次执行，每次都会执行<code>test</code>,</p><p>对于<code>test</code>来说有它存在的意义，但有些时候我们需要跳过test：</p><ul><li>可以确保每次打包或者安装的时候，程序的正确性，假如测试已经通过在我们没有修改程序的前提下再次执行打包或安装命令，由于顺序执行，测试会被再次执行，就有点耗费时间了。</li><li>功能开发过程中有部分模块还没有开发完毕，测试无法通过，但是想要把其中某一部分进行快速打包，此时由于测试环境失败就会导致打包失败。</li></ul><p>方法一：点击Maven工具里的小闪电按钮，关闭测试。</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232204173.png" alt="202205141133545" style="zoom:33%;" /><p>方法二：配置插件</p><ul><li><p>skipTests:如果为true，则跳过所有测试，如果为false，则不跳过测试</p></li><li><p>excludes：哪些测试类不参与测试，即排除，针对skipTests为false来设置的</p></li><li><p>includes: 哪些测试类要参与测试，即包含,针对skipTests为true来设置的</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>false<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--排除掉不参与测试的内容--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/BookServiceTest.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h2><h1 id="Spring5"><a href="#Spring5" class="headerlink" title="Spring5"></a>Spring5</h1><p>Spring是一个分层的 Java SE&#x2F;EE应用的 full-stack 轻量级的控制反转（IOC，Inverse Of Control）和面向切面编程（AOP，Aspect Oriented Programming）的框架.</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>IoC：<strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。</strong></p><ul><li><p>也就是说，使用对象时，在程序中不要主动使用new产生对象，将<code>对象创建控制权</code>由程序<code>转移到外部</code>，这就是<u>控制反转</u>；</p></li><li><p>Spring对IoC思想的思想：</p><ul><li><p>提供了IoC容器，充当“外部”：</p><p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在Ioc容器中统称为 <code>Bean</code>。</p></li><li><p>提供DI（Dependency Injection）依赖注入：</p><p>在容器中建立bean与bean之间的依赖关系，就是依赖注入；</p></li></ul></li></ul><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><ul><li><p>Core Container：核心容器</p></li><li><p>AOP：面向切面编程； </p><p>Aspects：AOP思想实现</p></li><li><p>Data Access：数据访问</p><p>Data Integration：数据集成</p><ul><li>Transactions：事务</li></ul></li><li><p>Web：Web开发（SpringMVC内容）</p></li><li><p>Test：单元测试、集成测试</p></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204251201927.png" alt="image-20220425120157613"></p><blockquote><p>拓展：</p><ul><li>SpringBoot<ul><li>一个快速开发的脚手架</li><li>基于SpringBoot可以快速的开发单个微服务</li><li>约定大于配置</li></ul></li><li>SpringCloud<ul><li>基于SpringBoot实现的</li></ul></li></ul><p>多数公司在使用SpringBoot进行快速开发，学习SpringBoot的前提，需要完全掌握Spring及SpringMVC，承上启下！</p><p><strong>spring弊端：发展了太久之后，违背了原来的理念！配置十分繁琐，容易出错，人称“配置地狱”，所以有了springboot，其更简单，更稳定健壮，功能更丰富。</strong></p></blockquote><h2 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h2><blockquote><p>IoC思路：</p><ul><li>管理什么？ —— Service 与 Dao</li><li>被管理的对象如何告知IoC容器？ —— 配置</li><li>如何获得IoC容器？ ——  接口</li><li>如何从容器中获取bean？ —— 接口方法</li></ul></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204251213944.png" alt="image-20220425121331702"></p><ol><li><p>导入Spring开发的基本包坐标；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写Dao接口和实现类；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzc.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zzc.dao.impl;</span><br><span class="line"><span class="keyword">import</span> com.zzc.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Spring核心配置文件；</p><p>在resources中新建spring config配置文件，一般命名为applicationContext.xml</p></li><li><p>在Spring配置文件中配置UserDaolmpl；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;useDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用Spring的API获得Bean实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">useDao</span> <span class="operator">=</span> (UserDao) app.getBean(<span class="string">&quot;useDao&quot;</span>);</span><br><span class="line">        useDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h2><h3 id="引入其他配置文件"><a href="#引入其他配置文件" class="headerlink" title="引入其他配置文件"></a>引入其他配置文件</h3><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他 配置文件中，而在Spring主配置文件通过import标签进行加载：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Bean标签"><a href="#Bean标签" class="headerlink" title="Bean标签"></a>Bean标签</h3><ul><li>用于配置对象交由Spring来创建；</li><li>默认情况下它调用的是类中的无参构造函数，如果没有则会创建失败。（反射）</li></ul><p>属性：</p><ul><li><p>id：Bean实例在Spring容器中的唯一标识</p></li><li><p>name：可以定义bean的别名，通过id和name都可以获取bean对象</p></li><li><p>class：Bean的全限定名称（全包名）</p></li><li><p>scope：指定对象的作用范围</p><table><thead><tr><th>取值范围</th><th>说明</th></tr></thead><tbody><tr><td><u>singleton</u></td><td><u>默认值，单例的</u></td></tr><tr><td><u>prototype</u></td><td><u>多例的</u></td></tr><tr><td>request</td><td>web项目中，spring创建一个Bean对象，将对象存入request域中</td></tr><tr><td>session</td><td>web项目中，spring创建一个Bean对象，将对象存入session域中</td></tr><tr><td>global session</td><td>web项目中，应用在Portlet环境，如果没有Portlet环境，那么global session相当于session</td></tr></tbody></table><blockquote><p>Bean生命周期：</p><p>scope&#x3D;”singleton”时，Bean对象在Spring核心配置文件读取时 实例化，即获取applicationContext对象时；</p><ul><li>生命周期：应用加载，容器创建时，对象就被创建了，只要容器在，对象就一直存在；<br>当应用卸载，容器销毁时，对象也跟着销毁；</li></ul><p>scope&#x3D;”prototype”时，Bean对象在配置文件读取时不会实例化，而是在获取Bean对象时才实例化，即使用 getBean() 方法时；</p><ul><li>生命周期：当使用对象时，创建新的对象实例， 当对象长时间不使用时，被java垃圾回收器回收。</li></ul><p>关闭容器（实际应用中不用自己写）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ClassPathXmlApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">app.registerShutdownHook(); <span class="comment">//方法一: 注册钩子关闭容器(放在哪都可以)</span></span><br><span class="line">app.close();   <span class="comment">//方法二: 直接关闭容器</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>init-method：指定类中的初始化方法名称</p></li><li><p>destory-menthod：指定类中销毁方法名称</p><blockquote><p>如果不想写上面的初始化或销毁的属性，可以直接让 类实现InitializingBean和DisposableBean ，这样Spring就会识别。</p></blockquote></li><li><p>autowire：自动装配（按指定的规则，如按类型，名称等自动装配）</p><blockquote><p>注：</p><p>只能用于引用类型注入，不能对简单类型进行操作；</p><p>使用按类型装配（byType）必须保障容器中相同类型的bean唯一，推荐使用；</p><p>使用按类型装配（byName）必须保障容器中有指定名称的bean，因变量名与配置耦合，不推荐使用；</p><p>自动装配优先级低于setter和构造器注入；</p></blockquote></li></ul><h3 id="Bean实例化的三种方式"><a href="#Bean实例化的三种方式" class="headerlink" title="Bean实例化的三种方式"></a>Bean实例化的三种方式</h3><ul><li><p>无参构造方法（就是上面用的，最常用）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;useDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂静态方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactoryBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.StaticFactoryBean&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>工厂实例方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactoryBean</span> &#123;</span><br><span class="line"><span class="keyword">public</span> UserDao <span class="title function_">createUserDao</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.DynamicFactoryBean&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;factoryBean&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUserDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>Spring提供了 FactoryBean 来简化工厂开发：</p><ol><li><p>创建一个实现FactoryBean接口，重写方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;UserDao&gt; &#123;</span><br><span class="line">    <span class="comment">//得到bean实例，代替原始实例工厂中创建对象的方法</span></span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//得到bean类型，返回所创建类的Class对象</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> UserDao.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//是否是单例的，返回true为单例，false为多例的</span></span><br><span class="line">     <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在配置文件中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.factory.UserDaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入 Dependency Injection：它是 Spring 框架核心 IOC 的具体实现。 </p><p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。<br>IOC 解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法。</p><blockquote><p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让 Spring 来维护了。 简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取。</p></blockquote><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>例：将 UserDao 注入道 UserService 内部，有两种方式：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204261813763.png" alt="image-20220426181345650"></p><p>都是要有一个UserDao成员变量，用构造方法或set方法将UserDao实例引入， 其配置文件的书写格式不一样；</p><ul><li><p><strong>构造器方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这里的name是形参的名字，不是成员变量的名字 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>setter方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- name是userService中的成员属性的名字，ref表示参照具体哪一个Bean  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注： property 中的 <strong>name 的值为 set方法（setUserDao）的 ”set“后的字符串，且首字母小写</strong>。 ref 的值为要注入的Bean的 id，value为简单类型注入的值，如字符数字等；</p><blockquote><p>还可以使用p命名空间注入，其本质也是set方法注入，当要写很多注入时会比set方法注入的配置文件方面要方便；</p><ol><li><p>先引入P命名空间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure></li><li><p>修改注入方式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span> <span class="attr">p:userDao-ref</span>=<span class="string">&quot;userDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li></ul><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>有三种，下面用set方式展示注入：</p><ul><li><p>普通数据类型 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量username(String)和age(Integer) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;李华&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;15&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>引用数据类型 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userService中有成员变量 useDao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;useDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>集合数据类型</p><p>数组 int[] array</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>111<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>222<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>333<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>List&lt; String &gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 strList&lt;String&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;strList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>List&lt; User &gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 userList&lt;User&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userList&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Map&lt;Stirng, User&gt;</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 userMap&lt;Stirng, User&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;u2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u1&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;user2&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;u2&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Properties</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- userDaoImpl中有成员变量 Properties --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.dao.impl.UserDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p1&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p2&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;p3&quot;</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean&gt;标签</span><br><span class="line">    id属性:在容器中Bean实例的唯一标识，不允许重复</span><br><span class="line">    class属性:要实例化的Bean的全限定名</span><br><span class="line">    scope属性:Bean的作用范围，常用是Singleton(默认)和prototype</span><br><span class="line">    &lt;property&gt;标签：属性注入</span><br><span class="line">        name属性：属性名称</span><br><span class="line">        value属性：注入的普通属性值</span><br><span class="line">        ref属性：注入的对象引用值</span><br><span class="line">        &lt;list&gt;标签</span><br><span class="line">        &lt;map&gt;标签</span><br><span class="line">        &lt;properties&gt;标签</span><br><span class="line">    &lt;constructor-arg&gt;标签</span><br><span class="line">    </span><br><span class="line">&lt;import&gt;标签:导入其他的Spring的分文件</span><br></pre></td></tr></table></figure><h3 id="相关API"><a href="#相关API" class="headerlink" title="相关API"></a>相关API</h3><p>ApplicationContext的实现类 </p><ul><li><p>ClassPathXmlApplicationContext </p><p>它是从类的根路径下加载配置文件 推荐使用这种 </p></li><li><p>FileSystemXmlApplicationContext </p><p>它是从磁盘的绝对路径上加载配置文件，配置文件可以在磁盘的任意位置。 </p></li><li><p>AnnotationConfigApplicationContext </p><p>当使用注解配置容器对象时，需要使用此类来创建 spring 容器。它用来读取注解。</p></li></ul><p>getBean的使用</p><ul><li>getBean(“id”)   根据id获取Bean实例</li><li>getBean(class)    根据类的Class类型获取Bean实例，如 getBean(UsrService.class) </li><li>getBean(“id”，class)     根据id并指定类型获取bean实例，不用强转</li></ul><h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>数据源（链接池）的作用：</p><ul><li><p>数据源(连接池)是提高程序性能如出现的 ；</p></li><li><p>事先实例化数据源，初始化部分连接资源 ；</p></li><li><p>使用连接资源时从数据源中获取 ；</p></li><li><p>使用完毕后将连接资源归还给数据源 ；</p><blockquote><p>常见的数据源(连接池)：DBCP、C3P0、BoneCP、Druid等</p></blockquote></li></ul><p>数据源的开发步骤：</p><ol><li>导入数据源的坐标和数据库驱动坐标 ；</li><li>创建数据源对象 ；</li><li>设置数据源的基本连接数据 ；</li><li>使用数据源获取连接资源和归还连接资源；</li></ol><h3 id="手动配置数据源"><a href="#手动配置数据源" class="headerlink" title="手动配置数据源"></a>手动配置数据源</h3><p>jdbc.properties文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/stu7</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">zzc</span></span><br></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">dataSourceTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidProperties</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">rb</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jdbc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(rb.getString(<span class="string">&quot;jdbc.driver&quot;</span>));</span><br><span class="line">        dataSource.setUrl(rb.getString(<span class="string">&quot;jdbc.url&quot;</span>));</span><br><span class="line">        dataSource.setUsername(rb.getString(<span class="string">&quot;jdbc.username&quot;</span>));</span><br><span class="line">        dataSource.setPassword(rb.getString(<span class="string">&quot;jdbc.password&quot;</span>));</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        System.out.println(connection);</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring配置数据源-XML"><a href="#Spring配置数据源-XML" class="headerlink" title="Spring配置数据源(XML)"></a>Spring配置数据源(XML)</h3><p>可以将DataSource的创建权交由Spring容器去完成 </p><ul><li>DataSource有无参构造方法，而Spring默认就是通过无参构造方法实例化对象的 ；</li><li>DataSource要想使用需要通过set方法设置数据库连接信息，而Spring可以通过set方法进行字符串注入；</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这里bean的class属性，填的是数据源对象的全限定名，即 DruidDataSource 的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DriverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/stu7&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="抽取jdbc配置文件"><a href="#抽取jdbc配置文件" class="headerlink" title="抽取jdbc配置文件"></a>抽取jdbc配置文件</h3><p>让applicationContext.xml加载jdbc.properties配置文件获得连接信息。</p><ol><li><p>需要先引入context命名空间和约束路径</p><ul><li>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a> </li><li>约束路径：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a>  <a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a></li></ul><blockquote><p>约束路径写在 xsi:schemaLocation&#x3D;“ ” 的双引号里面，即多个路径都写在这个双引号里面；</p></blockquote></li><li><p>格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xx.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;key&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>具体配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;DriverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;Url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用数据源的代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDruidSpring</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">    <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">    <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">    System.out.println(connection);</span><br><span class="line">    connection.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><ul><li><p>如果使用自己的properties文件有变量的名字和当前系统的环境变量冲突，会以系统的环境变量为准，如果不想要，可以加上属性 system-properties-mode&#x3D;”NEVER”，即不加载系统环境变量；</p></li><li><p>如果想加载多个properties文件，推荐写： location&#x3D;”calsspath:*properties”</p></li><li><p>前面的只能导入当前工程的properties文件，而jar包里的文件读取不了，想全部加载，可以这样写：location&#x3D;”calsspath*:*properties”</p></li></ul></blockquote><h2 id="注解开发"><a href="#注解开发" class="headerlink" title="注解开发"></a>注解开发</h2><p>Spring是轻代码而重配置的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置 文件可以简化配置，提高开发效率。</p><h4 id="原始注解"><a href="#原始注解" class="headerlink" title="原始注解"></a>原始注解</h4><p>Spring原始注解主要代替 &lt; Bean&gt; 的配置</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Component</td><td>使用在类上用于实例化Bean</td></tr><tr><td>@Controller</td><td>使用在web层类上用于实例化Bean</td></tr><tr><td>@Service</td><td>使用在service层类上用于实例化Bean</td></tr><tr><td>@Repository</td><td>使用在dao层类上用于实例化Bean</td></tr><tr><td>@Autowired</td><td>使用在字段上用于根据类型依赖注入</td></tr><tr><td>@Qualifier</td><td>结合@Autowired 一起使用用于根据名称进行依赖注入</td></tr><tr><td>@Resourse</td><td>相当于@Autowired+@Qualifier,按照名称进行注入</td></tr><tr><td>@Value</td><td>注入普通属性</td></tr><tr><td>@Scope</td><td>标注Bean的作用范围</td></tr><tr><td>@PostConstruct</td><td>使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td>@PreDestory</td><td>使用在方法上标注该方法是Bean的销毁方法</td></tr></tbody></table><p><strong>注：</strong></p><p>使用注解，需要在在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean 需要进行扫描以便识别使用注解配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用：</p><p>@Component     @Repository      @Scope      @PostConstruct</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;bean id=&quot;useDao&quot; class=&quot;com.zzc.dao.impl.UserDaoImpl&quot; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@Component(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="meta">@Scope(&quot;prototype&quot;)</span>   <span class="comment">//多例的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserDaoImpl</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象创建&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;初始化方法....&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Service    @Autowired    @Qualifier     @Resource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&lt;bean id=&quot;userService&quot; class=&quot;com.zzc.service.impl.UserServiceImpl&quot;&gt;</span></span><br><span class="line"><span class="comment">//    &lt;constructor-arg name=&quot;userDao&quot; ref=&quot;useDao&quot;&gt;&lt;/constructor-arg&gt;</span></span><br><span class="line"><span class="comment">//&lt;/bean&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//@Component(&quot;userService&quot;)</span></span><br><span class="line"><span class="meta">@Service(&quot;userService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    @Qualifier(&quot;userDao&quot;)</span></span><br><span class="line">    <span class="meta">@Resource(name=&quot;userDao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserServiceImpl) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Value</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;userDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;注入普通数据&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String str;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span>   <span class="comment">//注入变量，来自上面jdbc抽取中的数据</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(driver);</span><br><span class="line">        System.out.println(<span class="string">&quot;save running... ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="新注解"><a href="#新注解" class="headerlink" title="新注解"></a>新注解</h4><p>使用 <strong>Spring配置类</strong> 来替代 Spring核心配置文件xxx.xml，这样，配置就都从配置类中加载就行（配置类在写好后改动不大，大都是改properties文件）。</p><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>@Configuration</td><td>用于指定当前类是一个Spring配置类，当创建容器时会从该类上加载注解</td></tr><tr><td>@ComponentScan</td><td>用于指定Spring在初始化容器时要扫描的包。<br />替代了 Spring的xml配置文件中的&lt;context:component-scan base-package&#x3D;”com.zzc”&#x2F;&gt;</td></tr><tr><td>@Bean</td><td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td></tr><tr><td>@PropertySource</td><td>用于加载 .properties文件中的配置</td></tr><tr><td>@Import</td><td>用于导入其他配置类</td></tr></tbody></table><blockquote><p>扫描后，只需要将对应的bean作为方法的形参，容器会根据类型自动装配对象；</p></blockquote><p>使用：</p><p>@Confuguration     @ComponentScan      @Import</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//核心配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span> <span class="comment">//扫描某包下的注解</span></span><br><span class="line"><span class="meta">@Import(&#123;DataSourceConfiguration.class&#125;)</span> <span class="comment">//导入其他配置类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfiguration</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@PropertySource        @value           @Bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span><span class="comment">//抽取jdbc配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataSourceConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean(name = &quot;dataSource&quot;)</span><span class="comment">//将方法的返回值保存到Spring容器中，其id为&quot;dataSource&quot;</span></span><br><span class="line">    <span class="keyword">public</span> DruidDataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：使用 AnnotationConfigApplicationContext (配置类.class)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testConfiguration</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAnnoConfiguration</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">app</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfiguration.class);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> (UserService) app.getBean(<span class="string">&quot;userService&quot;</span>);</span><br><span class="line">        userService.save();</span><br><span class="line"></span><br><span class="line">        <span class="type">DataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> (DataSource) app.getBean(<span class="string">&quot;dataSource&quot;</span>);</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">connection</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">        </span><br><span class="line">        System.out.println(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h3><p>在测试类中，每个测试方法都需要获得ApplicationContext对象，然后再用getBean() 获得Bean对象；</p><p>为了省去这两行，解决思路：</p><ul><li>让SpringJunit负责创建Spring容器，但是需要将配置文件的名称告诉它 ；</li><li>将需要进行测试Bean直接在测试类中进行注入</li></ul><p><strong>步骤：</strong></p><ol><li><p>导入spring集成 Junit的坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处需要注意的是，spring5 及以上版本要求 junit 的版本必须是 4.12 及以上--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用@Runwith注解替换原来的运行期</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@ContextConfiguration指定配置文件或配置类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置文件</span></span><br><span class="line"><span class="comment">//@ContextConfiguration(value = &#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用@Autowired注入需要测试的对象 </p><p>创建测试方法进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="comment">//加载spring核心配置类</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = &#123;SpringConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringJunitTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        userService.save();</span><br><span class="line">        System.out.println(dataSource.getConnection());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Spring集成web环境"><a href="#Spring集成web环境" class="headerlink" title="Spring集成web环境"></a>Spring集成web环境</h2><p>应用上下文对象是通过new ClasspathXmlApplicationContext(spring配置文件) 或 AnnotationConfigApplicationContext(spring配置类) 方式获取的，但是每次从 容器中获得Bean时都要 new 一个 ，这样的弊端是配置 文件加载多次，应用上下文对象创建多次。</p><p>所以，在Web项目中，可以使用ServletContextListener 监听Web应用的启动，我们可以在Web应用启动时，就加载Spring的配置文件，创建应用上下文对象ApplicationContext，在将其存储到最大的域servletContext域 中，这样就可以在任意位置从域中获得应用上下文ApplicationContext对象了。</p><ul><li>对此，Spring提供了一个监听器<code>ContextLoaderListener</code> 就是对上述功能的封装，该监 听器内部加载Spring配置文件，创建应用上下文对象，并存储到ServletContext域中，提供了一个客户端工具 <code>WebApplicationContextUtils</code> 供使用者获得应用上下文对象。</li></ul><p>使用：</p><ol><li><p>在web.xml中配置ContextLoaderListener监听器（导入spring-web坐标） </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在pom.xml中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在web.xml中--&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--全局参数--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--Spring的监听器--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">      org.springframework.web.context.ContextLoaderListener</span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用WebApplicationContextUtils获得应用上下文对象ApplicationContex</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">applicationContext</span> <span class="operator">=</span> WebApplicationContextUtils.getWebApplicationContext(servletContext);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> applicationContext.getBean(<span class="string">&quot;id&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>Aspect Oriented Programming<br>意思为面向切面编程，指通过<code>预编译方式</code>和<code>运行期动态代理</code>实现程序功能的 统一维护。 </p><p>AOP 是 OOP 的延续，是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。</p><p>利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><ul><li><p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强；</p></li><li><p>优势：减少重复代码，提高开发效率，并且便于维护；</p></li></ul><blockquote><p>底层实现：</p><p>AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的 生成代理对象，代理 对象方法执行时进行增强功能的介入，再去调用目标对象的方法，从而完成功能的增强。</p></blockquote><h3 id="底层-动态代理"><a href="#底层-动态代理" class="headerlink" title="底层: 动态代理"></a>底层: 动态代理</h3><p>常用的动态代理技术：</p><ul><li>JDK代理：基于<code>接口</code>的动态代理技术</li><li>cglib代理：基于父类的动态代理技术</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204282053325.png" alt="image-20220428205334230"></p><h4 id="JDK动态代理"><a href="#JDK动态代理" class="headerlink" title="JDK动态代理"></a>JDK动态代理</h4><ol><li><p>目标类接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line"><span class="type">TargetInterface</span> <span class="variable">xxx</span> <span class="operator">=</span> (TargetInterface) Proxy.newProxyInstance(</span><br><span class="line">    target.getClass().getClassLoader(),<span class="comment">//目标对象 类加载器</span></span><br><span class="line">    target.getClass().getInterfaces(),<span class="comment">//目标对象 相同的接口字节码对象数据</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">       <span class="comment">//调用代理对象的任何方法，实质执行的都是invoke方法</span></span><br><span class="line">        <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;前置增强代码...&quot;</span>);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, args);<span class="comment">//执行目标方法</span></span><br><span class="line">            System.out.println(<span class="string">&quot;后置增强代码...&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> invoke;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>测试，调用代理对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxxMethod();</span><br></pre></td></tr></table></figure></li></ol><h4 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h4><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（后面的spring包包含了cglib，可以不用导入了）</p><ol><li><p>目标类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">xxxMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Target</span>(); <span class="comment">//创建目标对象</span></span><br><span class="line"><span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Enhancer</span>(); <span class="comment">//创建增强器</span></span><br><span class="line">enhancer.setSuperclass(Target.class); <span class="comment">//设置父类</span></span><br><span class="line">enhancer.setCallback(<span class="keyword">new</span> <span class="title class_">MethodInterceptor</span>() &#123; <span class="comment">//设置回调</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强....&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(target, objects);</span><br><span class="line">        System.out.println(<span class="string">&quot;后置代码增强....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">Target</span> <span class="variable">xxx</span> <span class="operator">=</span> (Target) enhancer.create(); <span class="comment">//创建代理对象</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.xxxMethod();</span><br></pre></td></tr></table></figure></li></ol><h3 id="AOP概念"><a href="#AOP概念" class="headerlink" title="AOP概念"></a>AOP概念</h3><p>Spring 的 AOP 实现底层就是对上面的动态代理的代码进行了封装，封装后我们只需要对需要关注的部分进行代码编写，并通过配置的方式完成指定目标的方法增强。 </p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><p>AOP 的相关常用的术语如下：</p><ul><li>Target（目标对象）：代理的目标对象 ；</li><li>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类 ；</li><li>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点  —— 指 <code>可以增强的方法</code>；</li><li>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义  ——  指 <code>将要增强的方法</code>；</li><li>Advice（通知&#x2F; 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是<code>通知/增强</code>  ；</li><li>Aspect（切面）：是切入点和通知（引介）的结合  —— <code>将要增强的方法 和 增强 的结合</code>；</li><li>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而 AspectJ采用编译期织入和类装载期织入 —— 指 <code>方法增强的过程</code>；</li></ul><p><strong>切点表达式：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">execution([修饰符] 返回值类型 包名.类名.方法名(参数))</span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">访问修饰符可以省略</span></span><br><span class="line"><span class="comment">返回值类型、包名、类名、方法名可以使用星号* 代表任意，以及任意前后缀</span></span><br><span class="line"><span class="comment">包名与类名之间一个点 . 代表当前包下的类，两个点 .. 表示当前包及其子包下的类</span></span><br><span class="line"><span class="comment">参数列表可以使用两个点 .. 表示任意个数，任意类型的参数列表</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">execution(public void com.zzc.aop.Target.method())</span><br><span class="line">execution(void com.zzc.aop.Target.*(..))</span><br><span class="line">execution(* com.zzc.aop.*.*(..))</span><br><span class="line">execution(* com.zzc.aop..*.*(..))</span><br><span class="line">execution(* *..*(..))</span><br></pre></td></tr></table></figure><p>书写规范：</p><ul><li>切入点 通常描述接口，而不描述实现类；</li><li>访问控制修饰符 针对接口开发均采用public描述（可省略修饰符）；</li><li>对于增删改类使用 精确的返回类型 可加速匹配，对查询类使用 *通配符 快速描述；</li><li>包名书写尽量不使用 .. 匹配，效率低；</li><li>接口名&#x2F;类名 的模块相关的采用 *  匹配，例如： UserService写成 *Service，绑定业务层接口名；</li><li>方法名中的 动词精准匹配，名词 * 匹配，例如：getById 写成 getBy*，selectAll 写成 selectAll；</li><li>通常不适用异常作为匹配规则；</li></ul><h4 id="开发事项"><a href="#开发事项" class="headerlink" title="开发事项"></a>开发事项</h4><ol><li><p>需要编写的内容 </p><ul><li>编写核心业务代码（<u>目标类的目标方法</u>） </li><li>编写切面类，切面类中有通知（<u>增强功能方法</u>）</li><li>在配置文件中，<u>配置织入关系</u>，即将哪些通知与哪些连接点进行结合</li></ul></li><li><p>AOP 技术实现的内容 ：</p><p>Spring 框架监控切入点方法的执行。一旦监控到切入点方法被运行，使用代理机制，动态创建目标对象的 代理对象，根据通知类别，在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑运行。 </p></li><li><p>AOP底层使用哪种代理方式？</p><p>在 spring 中，框架会根据目标类是否实现了接口来决定采用哪种动态代理的方式。</p></li></ol><h3 id="基于XML的AOP开发"><a href="#基于XML的AOP开发" class="headerlink" title="基于XML的AOP开发"></a>基于XML的AOP开发</h3><h4 id="XML配置AOP写法"><a href="#XML配置AOP写法" class="headerlink" title="XML配置AOP写法"></a>XML配置AOP写法</h4><p><strong>aop织入配置：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">“切面类”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">“通知方法名称”</span> <span class="attr">pointcut</span>=<span class="string">&quot;切点表达式&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>通知的配置语法：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:通知类型 method=“切面类中方法名” pointcut=&quot;切点表达式&quot;&gt;&lt;/aop:通知类型&gt;</span><br></pre></td></tr></table></figure><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>&lt; aop:before&gt;</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>&lt; aop:after-returning&gt;</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>&lt; aop:around&gt;</td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>&lt; aop:throwing&gt;</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>&lt; aop:after&gt;</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知的方法</span></span><br><span class="line"><span class="comment">//Proceeding JoinPoint : 正在执行的连接点，即切点</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">    <span class="comment">//环绕前增强</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">    <span class="comment">//环绕后方法</span></span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>切点表达式的抽取：</strong></p><p>如果有多个增强的切点表达式相同时，可以将切点表达式进行抽取，在增强中使用 pointcut-ref 属性代替 pointcut 属性来引用 抽取后的切点表达式。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用myAspect的Bean为切面对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.zzc.aop.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开发步骤-1"><a href="#开发步骤-1" class="headerlink" title="开发步骤"></a>开发步骤</h4><ol><li><p>导入 AOP 相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入spring的context坐标，context依赖aop--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类（内部有增强方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将目标类和切面类的对象创建权交给 spring </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置目标类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;target&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.aop.Target&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myAspect&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.aop.MyAspect&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 applicationContext.xml 中配置织入关系 </p><p>先导入aop的命名空间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line"></span><br><span class="line">http://www.springframework.org/schema/aop</span><br><span class="line">http://www.springframework.org/schema/aop/spring-aop.xsd</span><br></pre></td></tr></table></figure><p>在applicationContext.xml中配置织入关系</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明切面: 引用myAspect的Bean为切面对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;myAspect&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 切面:切点+通知; 配置Target的method方法执行时要进行myAspect的before方法前置增强--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(public void com.zzc.aop.Target.method())&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AopTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TargetInterface target;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h3><h4 id="注解写法"><a href="#注解写法" class="headerlink" title="注解写法"></a>注解写法</h4><ul><li><p><strong>@EnableAspectJAutoProxy</strong></p><p>配置类注解，开启注解格式AOP功能；</p></li><li><p><strong>@Aspect</strong></p><p>类注解，设置当前类为AOP切面类；</p></li><li><p><strong>@Pointcut</strong></p><p>方法注解，设置切入点方法，写的是 切入点表达式；</p></li></ul><p><strong>注解通知的类型：</strong></p><table><thead><tr><th>名称</th><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>前置通知</td><td>@Before</td><td>用于配置前置通知。指定增强的方法在切入点方法之前执行</td></tr><tr><td>后置通知</td><td>@AfterReturning</td><td>用于配置后置通知。指定增强的方法在切入点方法之后执行</td></tr><tr><td>环绕通知</td><td>@Around</td><td>用于配置环绕通知。指定增强的方法在切入点方法之前和之后都执行</td></tr><tr><td>异常抛出通知</td><td>@AfterThrowing</td><td>用于配置异常抛出通知。指定增强的方法在出现异常时执行</td></tr><tr><td>最终通知</td><td>@After</td><td>用于配置最终通知。无论增强方式执行是否有异常都会执行</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//环绕通知</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(void com.zzc.dao.*.update())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="comment">//表示对原始操作的调用</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**获取切入点方法的 —— **</p><p><strong>参数：</strong></p><ul><li><p>JoinPoint：前置，后置，返回后，抛出异常后通知，要设为方法的第一个形参；</p></li><li><p>ProceedingJoinPoint：环绕通知</p><blockquote><p>方法是 getArgs()</p></blockquote></li></ul><p><strong>返回值：</strong>返回后通知，环绕通知；</p><blockquote><p>如： Object  ret &#x3D; pjp.proceed();</p></blockquote><p><strong>运行异常信息：</strong> 抛出异常后通知，环绕通知；</p><hr><p><strong>切点表达式的抽取：</strong></p><p>同 xml 配置 aop 一样，可以将切点表达式抽取。抽取方式是在切面内<u>定义方法</u>，在<u>该方法上使用@Pointcut注解定义切点表达式</u>，然后在在增强注解中进行引用。具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;MyAspect.myPoint()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.zzc.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myPoint</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开发步骤-2"><a href="#开发步骤-2" class="headerlink" title="开发步骤"></a>开发步骤</h4><ol><li><p>导入坐标</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- aspectj的织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建目标接口和目标类（内部有切点） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建切面类（内部有增强方法） </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//前置增强方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将目标类和切面类的对象创建权交给 spring </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;target&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Target</span> <span class="keyword">implements</span> <span class="title class_">TargetInterface</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Target running....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在切面类中使用注解配置织入关系 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;myAspect&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAspect</span> &#123;</span><br><span class="line">    <span class="comment">//定义切入点，这里是个空方法，起什么名字都行</span></span><br><span class="line">    <span class="comment">//@pointcut(&quot;execution(* com.zzc.aop.*.*(..))&quot;)</span></span><br><span class="line">    <span class="meta">@pointcut(&quot;execution(void com.zzc.aop.Target.method())&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置代码增强.....&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者，将 “execution(…)” 直接写在 @Before 中，不写@pointcut也行 </p></li><li><p>主配置类开启注解格式AOP功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Target</span> <span class="variable">target</span> <span class="operator">=</span> ctx.getBean(Target.class);</span><br><span class="line">        target.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="声明式事务控制"><a href="#声明式事务控制" class="headerlink" title="声明式事务控制"></a>声明式事务控制</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>编程式事务控制 三大相关对象：</p><ul><li><p><strong>PlatformTransactionManager接口</strong> 是spring的事务管理器，它里面提供了我们常用的操作事务的方法。</p><p>方法：</p><ul><li>TransactionStatus  getTransaction(TransactionDefination defination)  ：获取事务的状态信息</li><li>void commit(TransactionStatus status) ：提交事务</li><li>void rollback(TransactionStatus status)：回滚事务</li></ul><blockquote><p>这个接口，不同的 Dao 层技术则有不同的实现类，例如：Dao层技术是</p><ul><li>是jdbc或mybatis时 ：org.springframework.jdbc.datasource.DataSourceTransactionManager ；</li><li>是hibernate时：org.springframework.orm.hibernate5.HibernateTransactionManage</li></ul></blockquote></li><li><p><strong>TransactionDefinition</strong> 是事务的定义信息对象。</p><p>方法：</p><ul><li><p>int getIsolationLevel() ：获得事务的隔离级别</p><p>事务隔离级别：</p><ul><li>ISOLATION_DEFAULT </li><li>ISOLATION_READ_UNCOMMITTED</li><li>ISOLATION_READ_COMMITTED</li><li>ISOLATION_REPEATABLE_READ </li><li>ISOLATION_SERIALIZABLE</li></ul></li><li><p>int getPropogationBehavior() ：获得事务的传播行为</p><p>事务传播行为：</p><ul><li>REQUIRED：<code>required</code> | 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。一般的选择（默认值）</li><li>SUPPORTS：<code>supports</code> | 支持当前事务，如果当前没有事务，就以非事务方式执行（没有事务）</li><li>MANDATORY：<code>mandatory</code> | 使用当前的事务，如果当前没有事务，就抛出异常 </li><li>REQUERS_NEW：<code>requers_new</code> | 新建事务，如果当前在事务中，把当前事务挂起。</li><li>NOT_SUPPORTED：<code>not_supported</code> | 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起 </li><li>NEVER：<code>never</code> | 以非事务方式运行，如果当前存在事务，抛出异常</li><li>NESTED： <code>nested</code> | 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行 REQUIRED 类似的操作</li><li>超时时间：默认值是-1，没有超时限制。如果有，以秒为单位进行设置 </li><li>是否只读：建议查询时设置为只读</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205061748284.png" alt="image-20220506174825069"></p></li><li><p>int getTimeout()：获得超时时间</p></li><li><p>boolean isReadOnly() ：是否只读</p></li></ul></li><li><p><strong>TransactionStatus</strong> 接口提供的是事务具体的运行状态。</p></li></ul><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul><li><strong>Spring 声明式事务控制底层就是AOP。</strong></li></ul><p>Spring 的声明式事务，顾名思义就是采用声明的方式来处理事务。这里所说的声明，就是指 使用配置文件或注解 的方式进行声明 ，以声明式的处理事务 来代替 代码式的处理事务。</p><p>作用：</p><ul><li><code>事务管理不侵入开发的组件</code>。具体来说，业务逻辑对象就不会意识到正在事务管理之中，事实上也应该如 此，因为事务管理是属于系统层面的服务，而不是业务逻辑的一部分，如果想要改变事务管理策划的话， 也只需要在定义文件中重新配置即可 </li><li>在不需要事务管理的时候，只要在设定文件上修改一下，即可移去事务管理服务，无需改变代码重新编译 ，这样<code>维护起来极其方便</code>。</li></ul><p>实现：</p><ul><li><p>切点 就是 业务方法</p></li><li><p>通知 就是 事务控制方法</p></li><li><p>切面织入</p></li></ul><h3 id="角色与属性"><a href="#角色与属性" class="headerlink" title="角色与属性"></a>角色与属性</h3><p>事务角色：</p><ul><li>事务管理员：发起事务方，在Spring中通常指代业务层开启事务的方法</li><li>事务协调员：加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</li></ul><blockquote><p>注意:</p><p>目前的事务管理是基于<code>DataSourceTransactionManager</code>和<code>SqlSessionFactoryBean</code>使用的是同一个数据源。</p></blockquote><p>事务属性：</p><p>事务属性都可以在<code>@Transactional</code>注解的参数上进行设置。</p><table><thead><tr><th>属性</th><th>作用</th><th>示例</th></tr></thead><tbody><tr><td>readOnly</td><td>设置是否为只读事务</td><td>readOnly&#x3D;true  只读事务</td></tr><tr><td>timeout</td><td>设置事务超时时间</td><td>timeout&#x3D;-1  永不超时</td></tr><tr><td>rollbackFor</td><td>设置事务回滚异常(class)</td><td>rollbackFor&#x3D;{NullPointException.class}</td></tr><tr><td>rollbackForClassName</td><td>设置事务回滚异常(String)</td><td></td></tr><tr><td>noRollbackFor</td><td>设置事务不回滚异常(class)</td><td></td></tr><tr><td>noRollbackForClassName</td><td>设置事务不回滚异常(String)</td><td></td></tr><tr><td>isolation</td><td>设置事务隔离级别</td><td>isolation&#x3D;Isolation.DEFAULT</td></tr><tr><td>propagation</td><td>设置事务传播行为</td><td>propagation &#x3D; Propagation.REQUIRES_NEW</td></tr></tbody></table><blockquote><p>rollbackFor： 并不是所有异常都会回滚事务，所以需要对一些异常额外设置事务回滚异常。</p></blockquote><p>事务传播行为：</p><h3 id="XML实现"><a href="#XML实现" class="headerlink" title="XML实现"></a>XML实现</h3><ol><li><p>引入tx命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;</span><br><span class="line">http://www.springframework.org/schema/tx </span><br><span class="line">http://www.springframework.org/schema/tx/spring-tx.xsd</span><br></pre></td></tr></table></figure></li><li><p>配置事务增强</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--平台事务管理器, 指明DAO层用了哪种技术--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--事务增强配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>其中 &lt; tx:method &gt; 代表切点方法的 事务参数 的配置，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;transfer&quot;</span> <span class="attr">isolation</span>=<span class="string">&quot;REPEATABLE_READ&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">timeout</span>=<span class="string">&quot;-1&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>name：切点方法名称 </li><li>isolation：事务的隔离级别 </li><li>propogation：事务的传播行为 </li><li>timeout：超时时间 </li><li>read-only：是否只读</li></ul></blockquote></li><li><p>配置事务AOP织入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(*com.zzc.service.impl.*.*(..))&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的aop增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;myPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(*com.zzc.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;myPointcut&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><h3 id="注解实现"><a href="#注解实现" class="headerlink" title="注解实现"></a>注解实现</h3><ol><li><p>在需要被事务管理的方法上添加注解，标明事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transfer</span><span class="params">(String out,String in ,Double money)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Spring注解式事务 通常添加在业务层接口中，而不会添加到业务层实现类中，降低耦合；</p><p>添加到接口或类上，它的所有方法都会开启事务；</p></blockquote></li><li><p>在JdbcConfig类中配置事务管理器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置事务管理器，mybatis使用的是jdbc事务</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">transactionManager</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        transactionManager.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> transactionManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>事务管理器要根据使用技术进行选择，Mybatis框架使用的是JDBC事务，可以直接使用<code>DataSourceTransactionManager</code></p></li><li><p>开启事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement //开启注解式事务驱动</span></span><br><span class="line"><span class="meta">public class SpringConfig &#123;</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><p>SpringMVC就是一个Spring内置的 实现了MVC模型的 Web框架。</p><p>它通过一套注解，让一个简单的 Java 类成为处理请求的控制器，而无须实现任何接口。</p><p><strong>SpringMVC底层就是Servlet，SpringMVC就是对Servlet进行深层次的封装。</strong></p><blockquote><p>MVC框架，它解决WEB开发中常见的问题(参数接收、文件上传、表单验证、国际化等等)，而且使用简单，与Spring无缝集成。</p></blockquote><h2 id="开发步骤-3"><a href="#开发步骤-3" class="headerlink" title="开发步骤"></a>开发步骤</h2><p>需求：客户端发起请求，服务器端接收请求，执行逻辑并进行视图跳转。</p><p>开发步骤： </p><h3 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h3><ol><li><p>导入SpringMVC相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建主配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Controller类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;info&#x27;:&#x27;springmvc&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>使用配置类替换web.xml</p><p>web.xml可以删除，换成ServletContainersInitConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现一</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="comment">//加载springmvc配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//初始化WebApplicationContext对象</span></span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        <span class="comment">//加载指定配置类</span></span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置由springmvc控制器处理的请求映射路径</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring配置类</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现二</span></span><br><span class="line"><span class="comment">//也可以继承AbstractAnnotationConfigDispatcherServletInitializer，实现更方便，作用和上面 的代码一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>运行tomcat，测试</p></li></ol><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><ol><li><p>导入SpringMVC相关坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--SpringMVC坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Servlet坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Jsp坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在web.xml 中配置SpringMVC核心控制器DispathcerServlet </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Controller类和视图页面 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h2&gt;Hello SpringMVC!&lt;/h2&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></li><li><p>使用注解配置Controller类中业务方法的映射地址 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">quickMethod</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;index&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>新建配置SpringMVC核心文件 spring-mvc.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>  <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>客户端发起请求</p></li></ol><h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><ol><li>用户发送请求至 前端控制器DispatcherServlet。 </li><li>DispatcherServlet收到请求调用HandlerMapping处理器映射器。 </li><li>处理器映射器找到具体的处理器(可以根据xml配置、注解进行查找)，生成处理器对象及处理器拦截器(如果 有则生成) 一并返回给DispatcherServlet。 </li><li>DispatcherServlet调用HandlerAdapter处理器适配器。 </li><li>HandlerAdapter经过适配调用具体的处理器(Controller，也叫后端控制器)。 </li><li>Controller执行完成返回ModelAndView。 </li><li>HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 </li><li>ViewReslover解析后返回具体View。 </li><li>DispatcherServlet根据View进行渲染视图（即将模型数据填充至视图中）。DispatcherServlet响应用户</li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204271852603.png" alt="image-20220427185241362"></p><p><strong>启动服务器初始化过程：</strong></p><ol><li><p>服务器启动，执行ServletContainersInitConfig类，初始化web容器</p><ul><li>功能类似于以前的web.xml</li></ul></li><li><p>执行createServletApplicationContext方法，创建了WebApplicationContext对象</p><ul><li>该方法加载SpringMVC的配置类SpringMvcConfig来初始化SpringMVC的容器</li></ul></li><li><p>加载SpringMvcConfig配置类</p></li><li><p>执行@ComponentScan加载对应的bean</p><ul><li>扫描指定包及其子包下所有类上的注解，如Controller类上的@Controller注解</li></ul></li><li><p>加载UserController，每个@RequestMapping的名称对应一个具体的方法</p><ul><li>此时就建立了 <code>/save</code> 和 save方法的对应关系</li></ul></li><li><p>执行getServletMappings方法，设定SpringMVC拦截请求的路径规则</p><ul><li><code>/</code>代表所拦截请求的路径规则，只有被拦截后才能交给SpringMVC来处理请求</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205070952207.png" alt="image-20220507095206842"></p><p><strong>单次请求过程：</strong></p><ol><li>发送请求<code>http://localhost/save</code></li><li>web容器发现该请求满足SpringMVC拦截规则，将请求交给SpringMVC处理</li><li>解析请求路径&#x2F;save</li><li>由&#x2F;save匹配执行对应的方法save(）<ul><li>上面的第五步已经将请求路径和方法建立了对应关系，通过&#x2F;save就能找到对应的save方法</li></ul></li><li>执行save()</li><li>检测到有@ResponseBody直接将save()方法的返回值作为响应体返回给请求方</li></ol><h2 id="组件解析"><a href="#组件解析" class="headerlink" title="组件解析"></a>组件解析</h2><ul><li><p>前端控制器：DispatcherServlet </p><p>用户请求到达前端控制器，它就相当于 MVC 模式中的 C，DispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，DispatcherServlet 的存在降低了组件之间的耦合性。 </p></li><li><p>处理器映射器：HandlerMapping HandlerMapping </p><p>负责根据用户请求 找到Handler，即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 </p></li><li><p>处理器适配器：HandlerAdapter </p><p>通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理 器进行执行。</p></li><li><p>处理器：Handler </p><p>它就是我们开发中要编写的具体业务控制器。由 DispatcherServlet 把用户请求转发到 Handler。由 Handler 对具体的用户请求进行处理。 </p></li><li><p>视图解析器：View Resolver </p><p>View Resolver 负责将处理结果生成 View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名，即 具体的页面地址，再生成 View 视图对象，最后对 View 进行渲染将处理结果通过页面展示给用户。 </p></li><li><p>视图：View </p><p>SpringMVC 框架提供了很多的 View 视图类型的支持，包括：jstlView、freemarkerView、pdfView等。最 常用的视图就是 jsp。一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程 序员根据业务需求开发具体的页面</p></li></ul><h2 id="注解解析"><a href="#注解解析" class="headerlink" title="注解解析"></a>注解解析</h2><h4 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h4><p>作用：用于建立请求 URL 和处理请求方法之间的对应关系 </p><p>位置： </p><ul><li>类上，请求URL 的第一级访问目录。此处不写的话，就相当于应用的根目录 </li><li>方法上，请求 URL 的第二级访问目录，与类上的使用@ReqquestMapping标注的一级目录一起组成访问虚拟路径</li></ul><p>属性： </p><ul><li><p><strong>value</strong>：用于指定请求的URL。它和path属性的作用是一样的 </p></li><li><p><strong>method</strong>：用于指定请求的方式 </p></li><li><p>params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的key和value必须和配置的一模一样 ；</p><p>例如：<br>params &#x3D; {“accountName”}，表示请求参数必须有<br>accountName  params &#x3D; {“moeny!100”}，表示请求参数中money不能是10</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/func&quot;)</span><span class="comment">//访问时需要加上这一级目录</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/quick&quot;, method = RequestMethod.GET, params = &#123;&quot;username&quot;&#125;)</span><span class="comment">//请求方式必须为GET，参数需带有 username</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;quickMethod running.....&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;<span class="comment">//加上&quot;/&quot;表示从默认根开始访问,否则会从/func开始找</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问路径为：http://localhost/func/quick?username=xxx</span></span><br></pre></td></tr></table></figure><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>类注解，位于类定义上方；</p><p>作用：设置spring配置类扫描路径，加载使用注解格式定义的bean</p><p>属性：</p><ul><li>excludeFilters —— 排除扫描路径中加载的bean,需要指定类别(type)和具体项(classes)</li><li>includeFilters —— 加载指定的bean，需要指定类别(type)和具体项(classes)</li></ul><h4 id="XML的"><a href="#XML的" class="headerlink" title="XML的"></a>XML的</h4><h5 id="MVC命名空间引入"><a href="#MVC命名空间引入" class="headerlink" title="MVC命名空间引入"></a>MVC命名空间引入</h5><p>命名空间：xmlns:context&#x3D;”<a href="http://www.springframework.org/schema/context&quot;">http://www.springframework.org/schema/context&quot;</a> </p><p>​xmlns:mvc&#x3D;”<a href="http://www.springframework.org/schema/mvc&quot;">http://www.springframework.org/schema/mvc&quot;</a> </p><p>约束地址：<a href="http://www.springframework.org/schema/context">http://www.springframework.org/schema/context</a> </p><p>​<a href="http://www.springframework.org/schema/context/spring-context.xsd">http://www.springframework.org/schema/context/spring-context.xsd</a> </p><p>​<a href="http://www.springframework.org/schema/mvc">http://www.springframework.org/schema/mvc</a> </p><p>​<a href="http://www.springframework.org/schema/mvc/spring-mvc.xsd">http://www.springframework.org/schema/mvc/spring-mvc.xsd</a></p><h5 id="组件扫描"><a href="#组件扫描" class="headerlink" title="组件扫描"></a>组件扫描</h5><p>SpringMVC基于Spring容器，所以在进行SpringMVC操作时，需要将Controller存储到Spring容器中，如果使用@Controller注解标注的话，就需要使用 &lt;context:component-scan base-package&#x3D;”com.zzc.controller”&#x2F;&gt;  进行组件扫描。</p><p>还可以指定扫描 某目录下指定的注解，如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.zzc.controller&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是不扫描 某目录下指定的注解，将 include-filter 改为 exclude-filter </p><h5 id="视图解析器"><a href="#视图解析器" class="headerlink" title="视图解析器"></a>视图解析器</h5><p>SpringMVC有默认组件配置，默认组件都是DispatcherServlet.properties配置文件中配置的，该配置文件地址 org&#x2F;springframework&#x2F;web&#x2F;servlet&#x2F;DispatcherServlet.properties，该文件中配置了默认的视图解析器，如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">org.springframework.web.servlet.ViewResolver</span>=<span class="string">org.springframework.web.servlet.view.InternalResourceViewResolver</span></span><br></pre></td></tr></table></figure><ul><li>redirect:        重定向前缀</li><li>forward:        转发前缀（默认）</li></ul><p>如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;redirect:/success.jsp&quot;</span>; <span class="comment">//重定向</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以修改视图解析器的前后缀：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 修改默认前缀为 /jsp/ ，默认后缀为 .jsp  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="bean加载控制"><a href="#bean加载控制" class="headerlink" title="bean加载控制"></a>bean加载控制</h2><p>设一个项目目录结构：com.zzc.</p><ul><li>config目录<ul><li>SpringConfig</li><li>SpringMvcConfig</li><li>JdbcConfig</li><li>MybatisConfig</li></ul></li><li>controller目录：放SpringMVC的controller类</li><li>service目录：service接口和实现类</li><li>dao目录：dao&#x2F;Mapper接口和实现类</li></ul><p>以上类需要被容器管理成对象：</p><ul><li>SpringMVC加载其相关bean(表现层bean),也就是controller包下的类</li><li>Spring控制的bean<ul><li>业务bean(Service)</li><li>功能bean(DataSource,SqlSessionFactoryBean,MapperScannerConfigurer等)</li></ul></li></ul><p>所以需要区分各自的加载范围：</p><ul><li><p>方式一：Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.service&quot;,&quot;com.zzc.dao&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>做开发的时候，Dao最终是交给<code>MapperScannerConfigurer</code>对象来进行扫描处理的，所以SpringConfig只需要将其扫描到service包即可。</p></blockquote></li><li><p>方式二：Spring加载的bean设定扫描范围为com.zzc,排除掉controller包中的bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(value=&quot;com.zzc&quot;,</span></span><br><span class="line"><span class="meta">    excludeFilters=@ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">    type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">        classes = Controller.class</span></span><br><span class="line"><span class="meta">    )</span></span><br><span class="line"><span class="meta">)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>excludeFilters属性：设置扫描加载bean时，排除的过滤规则</p></li><li><p>type属性：设置排除规则，当前使用按照bean定义时的注解类型进行排除</p><ul><li>ANNOTATION：按照注解排除</li><li>ASSIGNABLE_TYPE:按照指定的类型过滤</li><li>ASPECTJ:按照Aspectj表达式排除，基本上不会用</li><li>REGEX:按照正则表达式排除</li><li>CUSTOM:按照自定义规则排除</li></ul><p>一般只用到第一种ANNOTATION</p></li><li><p>classes属性：设置排除的具体注解类，当前设置排除@Controller定义的bean</p></li></ul></li><li><p>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中[了解即可]</p></li></ul><h2 id="数据响应"><a href="#数据响应" class="headerlink" title="数据响应"></a>数据响应</h2><p>SpringMVC的数据响应方式有两种：</p><ul><li>页面跳转<ul><li>直接返回字符串</li><li>通过ModelAndView对象返回</li></ul></li><li>回写数据<ul><li>直接返回字符串</li><li>返回对象或集合</li></ul></li></ul><h3 id="页面跳转"><a href="#页面跳转" class="headerlink" title="页面跳转"></a>页面跳转</h3><ul><li><p>直接返回字符串：此种方式会将返回的字符串与视图解析器的前后缀拼接后跳转；</p></li><li><p>通过ModelAndView对象返回；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/func&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">//直接返回字符串</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick1&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save1</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;/success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//通过ModelAndView对象</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick2&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save2</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">mav</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        mav.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        <span class="comment">//设置视图名称</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ModelAndView对象作为参数</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick3&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">save3</span><span class="params">(ModelAndView mav)</span>&#123;</span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        mav.addObject(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        <span class="comment">//设置视图名称</span></span><br><span class="line">        mav.setViewName(<span class="string">&quot;/success.jsp&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mav;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//模型和视图分离</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick4&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save4</span><span class="params">(Model model)</span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//也可以用request存储数据,不常用（request是框架直接注入的）</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick5&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save5</span><span class="params">(HttpServletRequest request)</span>&#123;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;zz&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="回写数据"><a href="#回写数据" class="headerlink" title="回写数据"></a>回写数据</h3><ul><li><p>直接回写字符串，需要添加注解 <strong>@ResponseBody</strong>，以告知SpringMVC框架，这个方法返回的字符串不是跳转 而是直接在http响应体中返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick7&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">save7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello SpringMVC&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发中往往要将复杂的java对象转换成json格式的字符串， 可以使用json转换工具jackson进行转换，导入jackson坐标。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--jackson--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 可以只导下面这个依赖，会自动导入前两个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相应的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乱码处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码：</p><p>实现返回对应对象的json数据，需要依赖&#x3D;&#x3D;@ResponseBody&#x3D;&#x3D;注解和&#x3D;&#x3D;@EnableWebMvc&#x3D;&#x3D;注解，然后数据直接返回，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick9&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">save9</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    user.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    user.setAge(<span class="number">18</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="获得请求数据"><a href="#获得请求数据" class="headerlink" title="获得请求数据"></a>获得请求数据</h2><h3 id="资源放行"><a href="#资源放行" class="headerlink" title="资源放行"></a>资源放行</h3><p>SpringMVC的前端控制器 DispatcherServlet的url-pattern配置的是”&#x2F;“，代表对所有的资源都进行过滤操作，如果要放行某类资源，可以通过以下两种 方式指定放行静态资源： </p><ul><li><p>注解方式：</p><p>让SpringMVC放行对应的静态资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该配置在config目录下，记得让SpringMVC扫描</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.controller&quot;,&quot;com.zzc.config&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>xml方式，在spring-mvc.xml配置文件中指定放行的资源</p></li></ul>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 当指定路径为&quot;/js/**&quot;时，就会到&quot;/js/&quot;下寻找 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">mapping</span>=<span class="string">&quot;/js/**&quot;</span> <span class="attr">location</span>=<span class="string">&quot;/js/&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>使用标签（交给tomcat自动寻找）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="四种类型参数"><a href="#四种类型参数" class="headerlink" title="四种类型参数"></a>四种类型参数</h3><p>客户端请求参数的格式是：name&#x3D;value&amp;name&#x3D;value… … </p><p>服务器端要获得请求的参数，有时还需要进行数据的封装，SpringMVC可以接收如下类型的参数：</p><ul><li>基本类型参数</li></ul>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick10?username=zhangsan&amp;age=12</span><br></pre></td></tr></table></figure>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick10&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save10</span><span class="params">(String username, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">    System.out.println(username + <span class="string">&quot; -- &quot;</span> + age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>POJO类型参数 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick11?username=zhangsan&amp;age=12</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick11&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save11</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick12?strs=aaa&amp;strs=xxx</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    System.out.println(Arrays.toString(strs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>集合类型参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick12?likes=aaa&amp;likes=xxx</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只需在形参前面加上@RequsetParam，而url与传递数组参数的一样。</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick12&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save12</span><span class="params">(<span class="meta">@RequsetParam</span> List&lt;String&gt; likes)</span> &#123;</span><br><span class="line">    System.out.println(likes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者(以前的)另一种方式，需要先将参数包装到一个POJO中才可以</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick13&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[0].age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].username&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;userList[1].age&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//参数Vo是View Object的意思，里面有一个list</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save13</span><span class="params">(Vo vo)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">System.out.println(vo.getUserList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>当使用ajax提交时，可以<strong>指定contentType为 json形式</strong>，那么在方法参数位置使用 **@RequestBody **可以 直接接收集合数据而无需使用POJO进行包装。</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="comment">//模拟数据</span></span><br><span class="line">    <span class="type">var</span> <span class="variable">userList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line">    userList.push(&#123;username: <span class="string">&quot;zhangsan&quot;</span>,age: <span class="string">&quot;20&quot;</span>&#125;);</span><br><span class="line">    userList.push(&#123;username: <span class="string">&quot;lisi&quot;</span>,age: <span class="string">&quot;20&quot;</span>&#125;);</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">        url: <span class="string">&quot;/quick14&quot;</span>,</span><br><span class="line">        data: JSON.stringify(userList),</span><br><span class="line">        contentType : <span class="string">&#x27;application/json;charset=utf-8&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick13&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod13</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; userList)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">System.out.println(userList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="请求数据乱码问题"><a href="#请求数据乱码问题" class="headerlink" title="请求数据乱码问题"></a>请求数据乱码问题</h3><p>当post请求时，数据会出现乱码，</p><p>注解方式：</p><p>在配置类中重写getServletFilters()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainersInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置过滤器，处理中文乱码</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml方式：</p><p>在<strong>web.xml</strong> 中设置一个过滤器来进行编码的过滤。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="参数绑定注解-requestParam"><a href="#参数绑定注解-requestParam" class="headerlink" title="参数绑定注解@requestParam"></a>参数绑定注解@requestParam</h3><p>当请求的参数名称与Controller的业务方法参数名称不一致时，就需要通过**@RequestParam**注解显示的绑定。</p><p>（这样前端发送的参数的名字 只需和@RequestParam中的value值相同，<br>    不用和后端定义的参数名字一样了）</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick14&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick14&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod14</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String username)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    System.out.println(username);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@RequestParam的属性：</p><ul><li>value：请求参数名称 </li><li>required：此在指定的请求参数是否必须包括，默认是true，提交时如果没有此参数则报错 </li><li>defaultValue：当没有指定请求参数时，则使用指定的默认值赋值</li></ul><h3 id="JSON数据传输参数"><a href="#JSON数据传输参数" class="headerlink" title="JSON数据传输参数"></a>JSON数据传输参数</h3><p>现在比较流行的开发方式为异步调用。前后台以异步方式进行交换，传输的数据使用的是JSON；</p><p>对于JSON数据类型，我们常见的有三种:</p><ul><li>json普通数组（[“value1”,”value2”,”value3”,…]）</li><li>json对象（{key1:value1,key2:value2,…}）</li><li>json对象数组（[{key1:value1,…},{key2:value2,…}]）</li></ul><p>使用：</p><ol><li><p>首先要添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>开启SpringMVC注解支持： @EnableWebMvc</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span></span><br><span class="line"><span class="comment">//开启json数据类型自动转换</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>参数前添加 @RequestBody</p><p>普通数组：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前端数据发送</span></span><br><span class="line"><span class="punctuation">[</span><span class="string">&quot;value1&quot;</span><span class="punctuation">,</span><span class="string">&quot;value2&quot;</span><span class="punctuation">,</span><span class="string">&quot;value3&quot;</span><span class="punctuation">,</span>...<span class="punctuation">]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后端数据接收</span></span><br><span class="line"><span class="comment">//使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;list common(json)参数传递 list ==&gt; &quot;</span>+likes);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User类中有name，age，address(province,city)三个成员参数</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;itcast&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/pojoParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">pojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;pojo(json)参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象数组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;itcast&quot;,&quot;age&quot;:15&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;zzc&quot;,&quot;age&quot;:12&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">listPojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; list)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;list pojo(json)参数传递 list ==&gt; &quot;</span>+list);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>@RequestBody与@RequestParam：</p><ul><li><p>区别</p><ul><li>@RequestParam用于接收url地址传参，表单传参【application&#x2F;x-www-form-urlencoded】</li><li>@RequestBody用于接收json数据【application&#x2F;json】</li></ul></li><li><p>应用</p><ul><li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li></ul></li></ul><h3 id="Restful风格的参数"><a href="#Restful风格的参数" class="headerlink" title="Restful风格的参数"></a>Restful风格的参数</h3><p>REST —— Representational State Transfer，表现形式状态转换，即约定了 访问网络资源的格式。</p><p>（根据REST风格对资源进行访问称为RESTful）</p><p>Restful是一种软件架构风格、设计风格，而不是标准，只是提供了一组设计原则和约束条件。主要用于客户端和服务器交互类的软件，基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存机制等。</p><p>Restful风格的请求是使用“url+请求方式”表示一次请求目的的，HTTP 协议里面四个表示操作方式的动词如下：</p><ul><li>GET：用于获取资源 </li><li>POST：用于新增&#x2F;保存资源 </li><li>PUT：用于修改&#x2F;更新资源 </li><li>DELETE：用于删除资源</li></ul><p>例如：</p><p>&#x2F;users&#x2F;1  GET ： 得到 id &#x3D; 1 的 user<br>&#x2F;users&#x2F;1  DELETE： 删除 id &#x3D; 1 的 user<br>&#x2F;users&#x2F;1  PUT： 更新 id &#x3D; 1 的 user<br>&#x2F;users  POST： 新增 user</p><blockquote><p> 可以看到，url可以是相同的，而执行的行为根据请求方式的不同进行区分，不仅简洁，更是隐藏了 资源的访问行为，无法通过地址得知对资源是何种操作。</p><p>注：</p><p>描述模块的名称通常使用复数，表示此类资源，而非单个资源，如：users</p></blockquote><p>在业务方法中我们可以使用**@PathVariable**注解进行占位符的匹配获取工作，在@RequestMapping中设置method以限定请求方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/quick20/zhangsan&amp;12</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@PathVariable占位，method = RequestMethod.GET限定只能为get请求;</span></span><br><span class="line"><span class="meta">@RequestMapping(value=&quot;/users/&#123;name&#125;&amp;&#123;age&#125;&quot;,method = RequestMethod.GET)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod19</span><span class="params">(<span class="meta">@PathVariable(value = &quot;name&quot;)</span> String name, <span class="meta">@PathVariable</span> Integer age)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        System.out.println(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于接收参数，有三个注解<code>@RequestBody</code>、<code>@RequestParam</code>、<code>@PathVariable</code></p><ul><li>区别<ul><li>@RequestParam用于接收url地址传参或表单传参</li><li>@RequestBody用于接收json数据</li><li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li></ul></li><li>应用<ul><li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li><li>如果发送非json格式数据，选用@RequestParam接收请求参数</li><li>采用RESTful进行开发，当参数数量较少时，例如1个，可以采用@PathVariable接收请求路径变量，通常用于传递id值</li></ul></li></ul><h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>SpringMVC 默认已经提供了一些常用的类型转换器，但有一些类型没有提供转换器的就需要自定义，例如：日期类型的数据就需要自定义转换器。</p><p>注解方式：日期类型有一个专门的用于转换日期格式的注解 @DateTimeFormat</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/dataParam?date=2088/08/08&amp;date1=2088-08-08&amp;date2=2088/08/08 8:08:08</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                        <span class="meta">@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date2)</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;参数传递 date ==&gt; &quot;</span>+date);</span><br><span class="line">System.out.println(<span class="string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);</span><br><span class="line">System.out.println(<span class="string">&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;</span>+date2);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>XML方式：</p><p>自定义类型转换器的开发步骤： </p><ol><li>定义转换器类实现Converter接口 </li><li>在配置文件中声明转换器 </li><li>在&lt; annotation-driven&gt;中引用转换器</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateConverter</span> <span class="keyword">implements</span> <span class="title class_">Converter</span>&lt;String,Date&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">convert</span><span class="params">(String source)</span> &#123;</span><br><span class="line">        <span class="type">SimpleDateFormat</span> <span class="variable">format</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> format.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在spring-mvc.xml中声明</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;converterService&quot;</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.converter.DateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">&quot;converterService&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>客户端要求：</p><ul><li>表单项 type&#x3D;”file“</li><li>提交方式  method&#x3D;”post”</li><li>表单的 enctype属性是多部分表单形式，即 enctype&#x3D;”multipart&#x2F;form-data”</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/quick20&quot;</span> method=<span class="string">&quot;post&quot;</span> enctype=<span class="string">&quot;multipart/form-data&quot;</span>&gt;</span><br><span class="line">    名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    文件：&lt;input type=<span class="string">&quot;file&quot;</span> name=<span class="string">&quot;file&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>服务端：</p><ul><li><p>导入fileupload和io坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置文件上传解析器 </p><p>在spring-mvc.xml中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件总大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传单个文件的大小--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;maxUploadSizePerFile&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5242800&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--上传文件的编码类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultEncoding&quot;</span> <span class="attr">value</span>=<span class="string">&quot;UTF-8&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写文件上传代码</p><p>单文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick20&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod20</span><span class="params">(String name,MultipartFile uploadFile)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//获得文件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">    <span class="comment">//保存文件</span></span><br><span class="line">    uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多文件（客户端表单 添加多个文件上传按钮）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/quick21&quot;)</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickMethod21</span><span class="params">(String name,MultipartFile[] uploadFiles)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">for</span> (MultipartFile uploadFile : uploadFiles)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">originalFilename</span> <span class="operator">=</span> uploadFile.getOriginalFilename();</span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\upload\\&quot;</span>+originalFilename));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="拦截器interceptor"><a href="#拦截器interceptor" class="headerlink" title="拦截器interceptor"></a>拦截器interceptor</h2><p>Spring MVC 的拦截器类似于 Servlet 开发中的过滤器 Filter，用于对处理器进行预处理和后处理。<br>拦截器也是AOP思想的具体实现。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205121628515.png" alt="image-20220512162807264"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205121629047.png" alt="image-20220512162817000"></p><table><thead><tr><th>区别</th><th>过滤器（Filter）</th><th>拦截器（interceptor）</th></tr></thead><tbody><tr><td>使用范围</td><td>是 servlet 规范中的一部分，任何 Java Web 工程都可以使用</td><td>只有使用了 SpringMVC 框架的工程才能用</td></tr><tr><td>拦截范围</td><td>在 <code>url-pattern</code> 中配置了 &#x2F;* 之后， 可以对所有要访问的资源拦截</td><td>在<code>&lt;mvc:mapping path=“”/&gt;</code>中配置了 &#x2F;** 之 后，可以对所有资源进行拦截，但是可以通过<code>&lt;mvc:exclude-mapping path=“”/&gt;</code>标签排除不需要拦截的资源</td></tr></tbody></table><p>方法：</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>preHandle()</td><td>方法将在请求处理之前进行调用，该方法的返回值是布尔值Boolean类型的， 当它返回为false 时，表示请求结束，后续的Interceptor 和Controller 都不会 再执行；当返回值为true 时就会继续调用下一个Interceptor 的preHandle 方 法</td></tr><tr><td>postHandle()</td><td>该方法是在当前请求进行处理之后被调用，前提是preHandle 方法的返回值为 true 时才能被调用，且它会在DispatcherServlet 进行视图返回渲染之前被调 用，所以我们可以在这个方法中对Controller 处理之后的ModelAndView 对象 进行操作</td></tr><tr><td>afterComplrtion()</td><td>该方法将在整个请求结束之后，也就是在DispatcherServlet 渲染了对应的视图 之后执行，前提是preHandle 方法的返回值为true 时才能被调用</td></tr></tbody></table><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205131027171.png" alt="image-20220513102758813"></p><p>将拦截器按一定的顺序联结成一条链，这条链称为<code>拦截器链（Interceptor Chain）</code>。在访问被拦截的方 法或字段时，拦截器链中的拦截器就会按其之前定义的顺序被调用。</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205131049477.png" alt="image-20220513104959292"></p><p>使用：</p><ul><li><p>创建拦截器类，实现HandlerInterceptor接口 </p><p>（**注意:**拦截器类要被SpringMVC容器扫描到。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">//拦截前运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;preHandle running...&quot;</span>);<span class="comment">//拦截逻辑</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// true放行，false不放行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拦截后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;postHandle running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//在整个请求结束之后运行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterCompletion running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>XML配置拦截器 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.zzc.interceptor.MyHandlerInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></blockquote></li><li><p>配置拦截器类</p><p>（<strong>注意:</strong> SpringMvcSupport类要被SpringMVC容器扫描到。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//需要拦截器类，spring容器注入</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ProjectInterceptor projectInterceptor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放行/配置 前端页面</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//放行/配置拦截器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//配置拦截器</span></span><br><span class="line">        registry.addInterceptor(projectInterceptor).addPathPatterns(<span class="string">&quot;/books,&quot;</span>/books<span class="comment">/*&quot;&quot; );</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>SpringMvcSupport的内容也可以写在 SpringMVC配置类SpringMvcConfig中，只要实现 WebMvcConfigurer 接口并重写相同的方法即可。 但这样侵入性较强，SpringMvcConfig与容器有绑定。</p></blockquote></li><li><p>测试拦截器的拦截效果</p></li></ul><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>处理思路：</p><p>系统中异常包括两类：<code>预期异常</code>和<code>运行时异常RuntimeException</code>，前者通过捕获异常从而获取异常信息，后者主要通过规范代码开发、测试等手段减少运行时异常的发生。</p><p>系统的Dao、Service、Controller出现异常都通过throws Exception向上抛出，最后由SpringMVC前端控制器交由异常处理器进行异常处理，如下图：</p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205120929169.png" alt="image-20220428201456607"></p><p>注解方式：</p><p>详情见 SSM整合-统一异常处理</p><p>XML方式：</p><p>两种处理方式：</p><ul><li><p>使用 Spring MVC 提供的简单异常处理器SimpleMappingExceptionResolver </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">“org.springframework.web.servlet.handler.SimpleMappingExceptionResolver”</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“defaultErrorView”</span> <span class="attr">value</span>=<span class="string">“error”/</span>&gt;</span>  <span class="comment">&lt;!-- 未知异常，则跳默认错误视图 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">“exceptionMappings”</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- key值为异常类型, value值为错误视图  --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;com.zzc.exception.MyException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;java.lang.ClassCastException&quot;</span> <span class="attr">value</span>=<span class="string">&quot;error&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>实现Spring的异常处理接口HandlerExceptionResolver 自定义自己的异常处理器。</p><ol><li><p>创建异常处理器类实现HandlerExceptionResolver </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title class_">HandlerExceptionResolver</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">resolveException</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> &#123;</span><br><span class="line">        <span class="comment">//创建ModelAndView对象</span></span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//处理异常的代码实现</span></span><br><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> MyException)&#123;</span><br><span class="line">            ...</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(e <span class="keyword">instanceof</span> ClassCastException)&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="comment">//添加异常时显示的视图</span></span><br><span class="line">  modelAndView.setViewName(<span class="string">&quot;exceptionPage&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置异常处理器 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;exceptionResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;com.zzc.exception.MyExceptionResolver&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写异常页面 </p></li><li><p>测试异常跳转</p></li></ol></li></ul><hr><hr><h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><p> MyBatis是一款优秀的持久层框架，用于简化 JDBC开发。</p><blockquote><p>JavaEE三层框架（MVC）：</p><ul><li>表现层：页面展示</li><li>业务层：逻辑处理</li><li>持久层：数据持久化（将数据保存到数据库）</li></ul><p>框架：相当于一个半成品软件，是一套可重用的，通用的、软件基础代码模型。</p><p>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展。</p></blockquote><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205120929393.png" alt="image-20220224170810620"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191707940.png" alt="image-20220224171023073"></p><h2 id="开发步骤-4"><a href="#开发步骤-4" class="headerlink" title="开发步骤"></a>开发步骤</h2><ol><li>添加MyBatis的坐标</li></ol>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--mysql驱动坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>   其他坐标：</p>   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--单元测试坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>创建user数据表 </p><p>user(id, username, password)</p></li><li><p>编写User实体类 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">//省略get和set方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写映射文件UserMapper.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;userMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 多条sql语句  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        select * from User</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;add&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        insert into user values(#&#123;id&#125;,#&#123;username&#125;,#&#123;password&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;update&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        update user set username=#&#123;username&#125;,password=#&#123;password&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;delete&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;java.lang.Integer&quot;</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写核心文件SqlMapConfig.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/test&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;zzc&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com.zzc.mapper/UserMapper.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写测试类 (可以使用spring进行优化)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line"><span class="comment">//获得sqlSession对象</span></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行sql查询语句</span></span><br><span class="line">List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line"><span class="comment">//打印结果</span></span><br><span class="line">System.out.println(userList);</span><br><span class="line"><span class="comment">//sql插入语句</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">6</span>, <span class="string">&quot;zzc&quot;</span>, <span class="string">&quot;1234&quot;</span>);</span><br><span class="line">sqlSession.insert(<span class="string">&quot;userMapper.add&quot;</span>, user);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//sql修改语句</span></span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="number">1</span>, <span class="string">&quot;zzl&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.update&quot;</span>, user);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"><span class="comment">//sql删除语句</span></span><br><span class="line">sqlSession.update(<span class="string">&quot;userMapper.delete&quot;</span>,<span class="number">6</span>);</span><br><span class="line">sqlSession.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line">sqlSession.close();</span><br></pre></td></tr></table></figure></li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204301521813.png" alt="image-20220430152118466"></p><p><strong>sql动态语句：</strong></p><ul><li><p>&lt;if&gt;  </p><p>select * from user where id&#x3D;?  or  username&#x3D;? or password&#x3D;? 相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;id!=0&quot;</span>&gt;</span></span><br><span class="line">        and id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username!=null&quot;</span>&gt;</span></span><br><span class="line">        and username=#&#123;username&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">        and password=#&#123;password&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>&lt;foreach&gt;</p><p>select * from user where id in(?,?,?……) 相当于：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByIds&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;list&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    select * from User</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;array&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in(&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;id&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            #&#123;id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p>标签用于遍历集合，它的属性： </p><ul><li>collection：代表要遍历的集合元素，注意编写时不要写#{} </li><li>open：代表语句的开始部分 </li><li>close：代表结束部分 </li><li>item：代表遍历集合的每个元素，生成的变量名 </li><li>sperator：代表分隔符</li></ul><p>（其中collection属性，根据传进来的数据，数组——array，集合——list  。。。）</p></li></ul><p><strong>sql片段抽取：</strong></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204302033476.png" alt="image-20220430203329385"></p><h3 id="核心配置文件-1"><a href="#核心配置文件-1" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><p>层级关系：</p><ul><li><code>configuration</code>配置<ul><li><code>properties</code>      属性</li><li><code>settings</code>      设置</li><li><code>typeHandleres </code>     类型处理器</li><li><code>objectFactory</code>       对象工厂</li><li><code>plugins </code>     插件</li><li><code>environments</code>      环境<ul><li><code>environment</code>       环境变量</li><li><code>transactionManager</code>      事务管理器</li><li><code>dataSource</code>       数据源</li></ul></li><li><code>databaseldProvider</code>        数据库厂商标识</li><li><code>mappers</code>        映射器</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202204301549635.png" alt="image-20220430154957315"></p><p><strong>mapper标签：</strong></p><ul><li>使用相对于类路径的资源引用，例如： &lt; mapper resource&#x3D;”org.mybatis.builder.AuthorMapper.xml”&#x2F;&gt;</li><li>使用完全限定资源定位符（URL），例如： &lt; mapper url&#x3D;”file:&#x2F;&#x2F;&#x2F;var&#x2F;mappers&#x2F;AuthorMapper.xml”&#x2F;&gt;</li><li>使用映射器接口实现类的完全限定类名，例如： &lt; mapper class&#x3D;”org.mybatis.builder.AuthorMapper”&#x2F;&gt;</li><li>将包内的映射器接口实现全部注册为映射器，例如：&lt; package name&#x3D;”org.mybatis.builder”&#x2F;&gt;</li></ul><p><strong>typeAliases标签</strong>：</p><p>mybatis设置了一些常用类型的别名：</p><p>String的别名为string，Long别名为long，Integer别名为int，Double别名为double，Boolean别名为boolean ……….</p><p><strong>typeHandlers标签</strong></p><p>MyBatis 不论在在预处理语句（PreparedStatement）中设置一个参数时，还是从结果集中取出一个值时， 都会用 类型处理器将获取的值以合适的方式转换成 Java 类型。</p><p>但遇到不支持或非标准的类型，就需要重写类型处理器：</p><ul><li><p>定义转换类继承类BaseTypeHandler </p></li><li><p>覆盖4个未实现的方法，其中：<br>setNonNullParameter  是java程序设置数据到数据库的回调方法，<br>getNullableResult  是查询时 mysql的字符串类型转换成 java的Type类型的方法 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyDateTypeHandler</span> <span class="keyword">extends</span> <span class="title class_">BaseTypeHandler</span>&lt;Date&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNonNullParameter</span><span class="params">(PreparedStatement preparedStatement, <span class="type">int</span> i, Date date, JdbcType type)</span> &#123;</span><br><span class="line">        preparedStatement.setString(i,date.getTime()+<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, String s)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(ResultSet resultSet, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Date</span>(resultSet.getLong(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getNullableResult</span><span class="params">(CallableStatement callableStatement, <span class="type">int</span> i)</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="keyword">return</span> callableStatement.getDate(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在MyBatis核心配置文件中进行注册 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册类型自定义转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">&quot;com.zzc.typeHandlers.MyDateTypeHandler&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">typeHandler</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试转换是否正确</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user.setBirthday(<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">userMapper.add2(user);</span><br></pre></td></tr></table></figure></li></ul><p><strong>plugins标签</strong></p><p>MyBatis可以使用第三方的插件来对功能进行扩展，分页助手PageHelper是将分页的复杂操作进行封装，使用简单的方式即 可获得分页的相关数据 开发步骤： </p><ol><li><p>导入通用PageHelper的坐标 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在mybatis核心配置文件中配置PageHelper插件 </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分页助手 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.7.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.jsqlparser<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsqlparser<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试分页数据获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testPageHelper</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">//设置分页参数</span></span><br><span class="line">    PageHelper.startPage(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    List&lt;User&gt; select = userMapper2.select(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">for</span>(User user : select)&#123;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>获得分页相关的其他参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其他分页的数据</span></span><br><span class="line">PageInfo&lt;User&gt; pageInfo = <span class="keyword">new</span> <span class="title class_">PageInfo</span>&lt;User&gt;(select);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;总条数：&quot;</span>+pageInfo.getTotal());</span><br><span class="line">System.out.println(<span class="string">&quot;总页数：&quot;</span>+pageInfo.getPages());</span><br><span class="line">System.out.println(<span class="string">&quot;当前页：&quot;</span>+pageInfo.getPageNum());</span><br><span class="line">System.out.println(<span class="string">&quot;每页显示长度：&quot;</span>+pageInfo.getPageSize());</span><br><span class="line">System.out.println(<span class="string">&quot;是否第一页：&quot;</span>+pageInfo.isIsFirstPage());</span><br><span class="line">System.out.println(<span class="string">&quot;是否最后一页：&quot;</span>+pageInfo.isIsLastPage());</span><br></pre></td></tr></table></figure><h3 id="相关API-1"><a href="#相关API-1" class="headerlink" title="相关API"></a>相关API</h3><p><strong>SqlSessionFactory build（InputStream inputStream）</strong>：通过加载mybatis的核心文件的输入流的形式构建一个SqlSessionFactory对象</p><p>（其中， Resources 工具类，这个类在 org.apache.ibatis.io 包中。Resources 类帮助你从类路径下、文件系统或 一个 web URL 中加载资源文件。）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载核心配置文件</span></span><br><span class="line"><span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;xxx.xml&quot;</span>);</span><br><span class="line"><span class="comment">//获得sqlSession工厂对象</span></span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br></pre></td></tr></table></figure><p>SqlSessionFactory工厂对象<strong>创建 SqlSession 实例</strong>：</p><ul><li>openSession()  ——  开启一个事务，但事务不会自动提交；</li><li>openSession(boolean autoCommit) —— 开启一个事务，如果参数为true，则会自动提交；</li></ul><p><strong>SqlSession会话对象：</strong></p><ul><li><p>执行语句：</p><ul><li>&lt; T&gt; selectOne(String statement, Object parameter)  </li><li>&lt; E&gt; List&lt; E&gt;  selectList(String statement, Object parameter)  </li><li>int insert(String statement, Object parameter)  </li><li>int update(String statement, Object parameter)  </li><li>int delete(String statement, Object parameter)</li></ul></li><li><p>操作事务：</p><ul><li>void commit()</li><li>void rollback()</li></ul></li></ul><h2 id="Dao层实现"><a href="#Dao层实现" class="headerlink" title="Dao层实现"></a>Dao层实现</h2><h3 id="传统开发方式"><a href="#传统开发方式" class="headerlink" title="传统开发方式"></a>传统开发方式</h3><ol><li><p>编写UserDao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写UserDaoImpl实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        </span><br><span class="line">        List&lt;User&gt; userList = sqlSession.selectList(<span class="string">&quot;userMapper.findAll&quot;</span>);</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testTraditionDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    List&lt;User&gt; all = userDao.findAll();</span><br><span class="line">    System.out.println(all);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="代理开发方式"><a href="#代理开发方式" class="headerlink" title="代理开发方式"></a>代理开发方式</h3><p>Mapper 接口开发方法只需要程序员编写 Mapper接口（相当于Dao 接口），由Mybatis 框架根据接口定义创建接口的动态代理对象，代理对象的方法体和上边Dao接口实现类方法一样。 </p><p>Mapper 接口开发需要遵循以下规范： </p><ul><li>Mapper.xml文件中的namespace与mapper接口的全限定名相同；</li><li>Mapper接口方法名和Mapper.xml中定义的每个statement的id相同；</li><li>Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同；</li><li>Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同；</li></ul><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205120929808.png" alt="image-20220430192216358"></p><ol><li><p>编写mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DaoMapper</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写映射文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com/zzc/dao/DaoMapper.java&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;User&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testProxyDao</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(resourceAsStream);</span><br><span class="line">    <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获得MyBatis框架生成的UserMapper接口的实现类</span></span><br><span class="line">    <span class="type">DaoMapper</span> <span class="variable">daoMapper</span> <span class="operator">=</span> sqlSession.getMapper(DaoMapper.class);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> doaMapper.findById(<span class="number">1</span>);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    sqlSession.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="多表操作"><a href="#多表操作" class="headerlink" title="多表操作"></a>多表操作</h2><p>使用 <strong>resultMap</strong>标签， 主要用于解决<code>实体类属性名与数据库表中字段名不一致</code>的情况，可以将查询结果映射成实体对象。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">type</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span><span class="comment">&lt;!-- 类再实例化时用来注入结果到构造方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span>/&gt;</span><span class="comment">&lt;!-- ID参数，结果为ID --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span>/&gt;</span><span class="comment">&lt;!-- 注入到构造方法的一个普通结果 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span><span class="comment">&lt;!-- 用于表示哪个列是主键 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>/&gt;</span><span class="comment">&lt;!-- 注入到字段或JavaBean属性的普通结果 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 用于一对一关联 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 用于一对多、多对多关联 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="comment">&lt;!-- 使用结果值来决定使用哪个结果映射 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>/&gt;</span><span class="comment">&lt;!-- 基于某些值的结果映射 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中id 和result 元素有以下属性：</p><ul><li>property： 映射到列结果的字段或属性。如果 POJO 的属性和 SQL 字段名（column元素）是相同的，那么 MyBatis 就会映射到 POJO 上；</li><li>column：对应sql字段；</li><li>javaType：配置 Java 类型。可以是特定的类完全限定名或 MyBatis 上下文的别名；</li><li>jdbcType：配置数据库类型。这是 JDBC 类型，MyBatis 已经为我们做了限定，基本支持所有常用数据库类型；</li><li>typeHandler：类型处理器。允许你用特定的处理器来覆盖 MyBatis 默认的处理器。需要指定 jdbcType 和 javaType 相互转化的规则；</li></ul><p><strong>一对一查询：</strong></p><ol><li><p>创建Order和User实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Date ordertime;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> total;</span><br><span class="line">    <span class="comment">//代表当前订单从属于哪一个客户</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建OrderMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderMapper</span> &#123;</span><br><span class="line">    List&lt;Order&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置OrderMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zzc.mapper.OrderMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;user.birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;orderMap&quot;</span>&gt;</span></span><br><span class="line">        select * from orders o,user u where o.uid=u.id</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的resultMap还可以这样配：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;orderMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">&quot;user&quot;</span> <span class="attr">javaType</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p><strong>一对多查询：</strong></p><ol><li><p>修改User实体：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="comment">//添加一个列表</span></span><br><span class="line">    <span class="comment">//代表当前用户具备哪些订单</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Order&gt; orderList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.zzc.mapper.UserMapper&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">&quot;userMap&quot;</span> <span class="attr">type</span>=<span class="string">&quot;com.zzc.domain.User&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span> <span class="attr">property</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span> <span class="attr">property</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">&quot;orderList&quot;</span> <span class="attr">ofType</span>=<span class="string">&quot;com.zzc.domain.Order&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;oid&quot;</span> <span class="attr">property</span>=<span class="string">&quot;id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;ordertime&quot;</span> <span class="attr">property</span>=<span class="string">&quot;ordertime&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;total&quot;</span> <span class="attr">property</span>=<span class="string">&quot;total&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">        select *,o.id oid from user u left join orders o on u.id=o.uid</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><p><strong>多对多查询：</strong></p><p>和一对多相似，主要区别在 sql 语句是查一张表还是多张表，而配置文件和一对多差不多。</p><h2 id="注解开发-1"><a href="#注解开发-1" class="headerlink" title="注解开发"></a>注解开发</h2><h2 id="Spring整合MyBatis"><a href="#Spring整合MyBatis" class="headerlink" title="Spring整合MyBatis"></a>Spring整合MyBatis</h2><p>只用MyBatis的话，在service实现类中，需要多次新建session工厂</p><h3 id="未整合前环境"><a href="#未整合前环境" class="headerlink" title="未整合前环境"></a>未整合前环境</h3><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.16<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>根据数据表 创建类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"><span class="comment">//setter...getter...toString...方法略    </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Dao接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Insert(&quot;insert into tbl_account(name,money)values(#&#123;name&#125;,#&#123;money&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_account set name = #&#123;name&#125; , money = #&#123;money&#125; where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account&quot;)</span></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_account where id = #&#123;id&#125; &quot;)</span></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Service接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    Account <span class="title function_">findById</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Account account)</span>&#123;</span><br><span class="line">        accountDao.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        accountDao.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Account <span class="title function_">findById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>添加jdbc.properties文件</p></li><li><p>添加Mybatis核心配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--读取外部properties配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--别名扫描的包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.zzc.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--映射文件扫描包路径--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.zzc.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205061127458.png" alt="image-20220506112714936"></p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205061139152.png" alt="image-20220506113908300"></p><h3 id="注解方式-1"><a href="#注解方式-1" class="headerlink" title="注解方式"></a>注解方式</h3><blockquote><p>主要用到的两个类分别是:</p><ul><li>SqlSessionFactoryBean</li><li>MapperScannerConfigurer</li></ul></blockquote><ol><li><p>导入需要的jar包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring操作数据库需要该jar包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">Spring与Mybatis整合的jar包</span></span><br><span class="line"><span class="comment">这个jar包mybatis在前面，是Mybatis提供的</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建Spring主配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置类注解</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="comment">//包扫描，主要扫描的是项目中的AccountServiceImpl类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建数据源的配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(driver);</span><br><span class="line">        ds.setUrl(url);</span><br><span class="line">        ds.setUsername(userName);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在主配置类中读properties文件，并引入数据源配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(JdbcConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建Mybatis配置类并配置SqlSessionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.zzc.domain&quot;</span>);</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.zzc.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>SqlSessionFactoryBean中的方法需要DataSource类型参数，而当前Spring容器中已经创建了Druid数据源，类型为DataSource，即容器中已经有这个对象了，且使用@Bean时，所以可以在形参列表直接写上DataSource类型的参数。</p><p>MapperScannerConfigurer 中的 basePackage 就是用于设置说扫描的包路径。</p></blockquote></li><li><p>主配置类中引入Mybatis配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc&quot;)</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class,MybatisConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h3 id="XML方法"><a href="#XML方法" class="headerlink" title="XML方法"></a>XML方法</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置MyBatis的SqlSessionFactory--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 加载mybatis的核心配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:sqlMapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置Mapper扫描, 让Spring容器产生Mapper实现类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 扫描mapper包下的多有 xxxMapper类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.zzc.mapper&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置声明式事务控制--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transacionManager&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transacionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;txPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* </span></span></span><br><span class="line"><span class="string"><span class="tag">    com.zzc.service.impl.*.*(..))&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;txPointcut&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>修改service实现类代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AccountService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountMapper accountMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Account account)</span> &#123;</span><br><span class="line">        accountMapper.save(account);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Account&gt; <span class="title function_">findAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> accountMapper.findAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SSM整合"><a href="#SSM整合" class="headerlink" title="SSM整合"></a>SSM整合</h1><h2 id="整合过程"><a href="#整合过程" class="headerlink" title="整合过程"></a>整合过程</h2><p>（1）创建工程</p><p>大体框架：</p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205232204438.png" alt="202205120929662" style="zoom:50%;" /><p>（2）SSM整合</p><ul><li><p>Spring</p><ul><li><p>SpringConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//表示该类为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.zzc.service&quot;&#125;)</span>     <span class="comment">//直接写“com.zzc”会误扫描到其他包</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class, MybatisConfig.class&#125;)</span><span class="comment">//引入Mybatis相关配置类</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span>        <span class="comment">//开启注解式事务驱动，在Service层要管理事务</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>MyBatis</p><ul><li><p>MybatisConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//构建SqlSessionFactoryBean并设置别名扫描与数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span> &#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        <span class="comment">//设置数据源</span></span><br><span class="line">        factoryBean.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">//设置模型类的别名扫描</span></span><br><span class="line">        factoryBean.setTypeAliasesPackage(<span class="string">&quot;com.zzc.domain&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建MapperScannerConfigurer并设置DAO层的包扫描</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.zzc.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>JdbcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> DataSource <span class="title function_">dataSource</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource.setDriverClassName(driver);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">DataSourceTransactionManager</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">        ds.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>jdbc.properties</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">jdbc.password</span>=<span class="string">zzc</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>SpringMVC</p><ul><li><p>ServletConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;springMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置过滤器，处理中文乱码</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Filter[] getServletFilters() &#123;</span><br><span class="line">        <span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">        filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[]&#123;filter&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SpringMvcConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span><span class="comment">//标识为配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.zzc.controller&quot;)</span><span class="comment">//扫描Controller包</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span><span class="comment">//开启SpringMVC注解支持</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">springMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>（3）功能模块</p><ul><li><p>创建数据库</p></li><li><p>表与实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    </span><br><span class="line">    .......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>dao（接口 + 实现类）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">    <span class="meta">@Insert(&quot;insert tbl_book (type, name, description) values (#&#123;type&#125;, #&#123;name&#125;, #&#123;description&#125;)&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Update(&quot;update tbl_book set type = #&#123;type&#125;, name = #&#123;name&#125;, description = #&#123;description&#125; where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delete(&quot;delete from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select(&quot;select * from tbl_book&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>service（接口 + 实现类）</p><ul><li><p>业务层接口测试（整合Junit）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span>;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(Book book)</span> &#123;</span><br><span class="line">        bookDao.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        bookDao.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getByID(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookDao.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(classes = SpringConfig.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceTest</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGetAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; all = bookService.getAll();</span><br><span class="line">        System.out.println(all);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>controller</p><ul><li><p>表现层接口测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.save(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.update(book);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Book <span class="title function_">getByID</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getByID(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Book&gt; <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bookService.getAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="统一结果封装"><a href="#统一结果封装" class="headerlink" title="统一结果封装"></a>统一结果封装</h2><p>后端返回给前端的应该是同一的数据格式，因此，这里可以统一一个结果类<code>Result(code，data，msg)</code> ，将数据封装到<code>data</code>中，操作结果封装到<code>code</code>属性中，封装特殊信息到<code>message(msg)</code>属性中；</p><p>封装结果类Result：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, Object data, String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义返回Code码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Code</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_OK</span> <span class="operator">=</span> <span class="number">20011</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_OK</span> <span class="operator">=</span> <span class="number">20021</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_OK</span> <span class="operator">=</span> <span class="number">20031</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_OK</span> <span class="operator">=</span> <span class="number">20041</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">SAVE_ERR</span> <span class="operator">=</span> <span class="number">20010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">DELETE_ERR</span> <span class="operator">=</span> <span class="number">20020</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">UPDATE_ERR</span> <span class="operator">=</span> <span class="number">20030</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">GET_ERR</span> <span class="operator">=</span> <span class="number">20040</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Controller类的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统一每个控制器方法的返回值</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/books&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">save</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.save(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.SAVE_OK : Code.SAVE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">update</span><span class="params">(<span class="meta">@RequestBody</span> Book book)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.update(book);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.UPDATE_OK : Code.UPDATE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">delete</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> bookService.delete(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(flag ? Code.DELETE_OK : Code.DELETE_ERR, flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getByID</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">        <span class="type">Book</span> <span class="variable">book</span> <span class="operator">=</span> bookService.getByID(id);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> book != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> book != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;查询失败，请重试&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, book, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">getAll</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;Book&gt; list = bookService.getAll();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">code</span> <span class="operator">=</span> list != <span class="literal">null</span> ? Code.GET_OK : Code.GET_ERR;</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> list != <span class="literal">null</span> ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;查询失败，请重试&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(code, list, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><p>项目的各个地方都有可能出现异常，这些可能出现的异常都需要进行处理。</p><p>异常的种类及出现异常的原因:</p><ul><li>框架内部抛出的异常：因使用不合规导致</li><li>数据层抛出的异常：因外部服务器故障导致（例如：服务器访问超时）</li><li>业务层抛出的异常：因业务逻辑书写错误导致（例如：遍历业务书写操作，导致索引异常等）</li><li>表现层抛出的异常：因数据收集、校验等规则导致（例如：不匹配的数据类型间导致异常）</li><li>工具类抛出的异常：因工具类书写不严谨不够健壮导致（例如：必要释放的连接长期未释放等）</li></ul><p>各个层级都会出现异常，所以，让所有异常都抛到最上面的表现层进行处理。</p><h3 id="异常处理器"><a href="#异常处理器" class="headerlink" title="异常处理器"></a>异常处理器</h3><p>通过 <code>异常分类</code> 区分不同的异常，使用AOP编写异常处理方法，SpringMVC提供了<strong>异常处理器</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="comment">//返回结果给前端</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(<span class="number">666</span>,<span class="literal">null</span>,<span class="string">&quot;有异常，进行了处理&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确保SpringMvcConfig能够扫描到异常处理器类</p><ul><li>@RestControllerAdvice<ul><li>类注解，位于Rest风格开发的控制器增强类上方；</li><li>此注解自带@ResponseBody注解与@Component注解，具备对应的功能；</li></ul></li><li>@ExceptionHandler<ul><li>方法注解，专用于异常处理的控制器方法上；</li><li>作用：设置指定异常的处理方案，出现异常后终止原始控制器执行,并转入当前方法执行。</li></ul></li></ul><h3 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h3><ul><li>业务异常（BusinessException）<ul><li>规范的用户行为产生的异常<ul><li>用户在页面输入内容的时候未按照指定格式进行数据填写，如在年龄框输入的是字符串</li></ul></li><li>不规范的用户行为操作产生的异常<ul><li>如用户故意传递错误数据</li></ul></li></ul></li></ul><ul><li><p>系统异常（SystemException）</p><ul><li>项目运行过程中可预计但无法避免的异常<ul><li>比如数据库或服务器宕机</li></ul></li></ul></li><li><p>其他异常（Exception）</p><ul><li>编程人员未预期到的异常，如:用到的文件不存在</li></ul></li></ul><p>对应的解决方案：</p><ul><li>业务异常（BusinessException）<ul><li>发送对应消息传递给用户，提醒规范操作<ul><li>常见的就是提示用户名已存在或密码格式不正确等</li></ul></li></ul></li><li>系统异常（SystemException）<ul><li>发送固定消息传递给用户，安抚用户<ul><li>系统繁忙，请稍后再试</li><li>系统正在维护升级，请稍后再试</li></ul></li><li>发送特定消息给运维人员，提醒维护<ul><li>可以发送短信、邮箱或者是公司内部通信软件</li></ul></li><li>记录日志<ul><li>发消息和记录日志对用户来说是不可见的，属于后台程序</li></ul></li></ul></li><li>其他异常（Exception）<ul><li>发送固定消息传递给用户，安抚用户</li><li>发送特定消息给编程人员，提醒维护（纳入预期范围内）<ul><li>一般是程序没有考虑全，比如未做非空校验等</li></ul></li><li>记录日志</li></ul></li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ol><li>自定义异常类：</li></ol><ul><li>让自定义异常类继承<code>RuntimeException</code>的好处是，后期在抛出这两个异常的时候，就不用在try…catch…或throws了</li><li>自定义异常类中添加<code>code</code>属性的原因是为了更好的区分异常是来自哪个业务的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义异常处理器，用于封装异常信息，对异常进行分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SystemException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义异常处理器，用于封装异常信息，对异常进行分类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusinessException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(Integer code, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BusinessException</span><span class="params">(Integer code, String message, Throwable cause)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(message, cause);</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>将其他异常包成自定义异常：</li></ol><p>具体的包装方式有：</p><ul><li>方式一:<code>try&#123;&#125;catch()&#123;&#125;</code>在catch中重新throw我们自定义异常即可。</li><li>方式二:直接throw自定义异常即可</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Book <span class="title function_">getById</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">    <span class="comment">//模拟业务异常，包装成自定义异常</span></span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BusinessException</span>(Code.BUSINESS_ERR,<span class="string">&quot;错误信息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟系统异常，将可能出现的异常进行包装，转换成自定义异常</span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>/<span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">SystemException</span>(Code.SYSTEM_TIMEOUT_ERR,<span class="string">&quot;服务器访问超时，请重试!&quot;</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bookDao.getById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>处理类中 处理自定义异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@RestControllerAdvice用于标识当前类为REST风格对应的异常处理器</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProjectExceptionAdvice</span> &#123;</span><br><span class="line">    <span class="comment">//@ExceptionHandler用于设置当前处理器类对应的异常类型</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(SystemException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doSystemException</span><span class="params">(SystemException ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(),<span class="literal">null</span>,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BusinessException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doBusinessException</span><span class="params">(BusinessException ex)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(ex.getCode(),<span class="literal">null</span>,ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除了自定义的异常处理器，保留对Exception类型的异常处理，用于处理非预期的异常</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Result <span class="title function_">doOtherException</span><span class="params">(Exception ex)</span>&#123;</span><br><span class="line">        <span class="comment">//记录日志</span></span><br><span class="line">        <span class="comment">//发送消息给运维</span></span><br><span class="line">        <span class="comment">//发送邮件给开发人员,ex对象发送给开发人员</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Result</span>(Code.SYSTEM_UNKNOW_ERR,<span class="literal">null</span>,<span class="string">&quot;系统繁忙，请稍后再试！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前后台协议联调"><a href="#前后台协议联调" class="headerlink" title="前后台协议联调"></a>前后台协议联调</h2><p>首先，SpringMVC设置“&#x2F;”过滤所有文件，要对前端页面文件放行：</p><p>（需要让SpringMVC配置类扫描下面这个 SpringMvcSupport）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcSupport</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurationSupport</span> &#123;</span><br><span class="line">    <span class="comment">//设置静态资源访问过滤，当前类需要设置为配置类，并被扫描加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">addResourceHandlers</span><span class="params">(ResourceHandlerRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">//当访问/pages/????时候，从/pages目录下查找内容</span></span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/pages/**&quot;</span>).addResourceLocations(<span class="string">&quot;/pages/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/js/**&quot;</span>).addResourceLocations(<span class="string">&quot;/js/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/css/**&quot;</span>).addResourceLocations(<span class="string">&quot;/css/&quot;</span>);</span><br><span class="line">        registry.addResourceHandler(<span class="string">&quot;/plugins/**&quot;</span>).addResourceLocations(<span class="string">&quot;/plugins/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前端html文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 页面meta --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>SpringMVC案例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no&quot;</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入样式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../plugins/elementui/index.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../plugins/font-awesome/css/font-awesome.min.css&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;../css/style.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">class</span>=<span class="string">&quot;hold-transition&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content-header&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>图书管理<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-container&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;filter-container&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">placeholder</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;pagination.queryString&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width: 200px;&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">class</span>=<span class="string">&quot;filter-item&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;getAll()&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dalfBut&quot;</span>&gt;</span>查询<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">class</span>=<span class="string">&quot;butT&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleCreate()&quot;</span>&gt;</span>新建<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">el-table</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">current-row-key</span>=<span class="string">&quot;id&quot;</span> <span class="attr">:data</span>=<span class="string">&quot;dataList&quot;</span> <span class="attr">stripe</span> <span class="attr">highlight-current-row</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">type</span>=<span class="string">&quot;index&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span> <span class="attr">label</span>=<span class="string">&quot;序号&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">prop</span>=<span class="string">&quot;description&quot;</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-table-column</span> <span class="attr">label</span>=<span class="string">&quot;操作&quot;</span> <span class="attr">align</span>=<span class="string">&quot;center&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot-scope</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleUpdate(scope.row)&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;danger&quot;</span> <span class="attr">size</span>=<span class="string">&quot;mini&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleDelete(scope.row)&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-table-column</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">el-table</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 新增标签弹层 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;add-form&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;新增图书&quot;</span> <span class="attr">:visible.sync</span>=<span class="string">&quot;dialogFormVisible&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;dataAddForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;formData&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">label-position</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">label-width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.type&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.name&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.description&quot;</span> <span class="attr">type</span>=<span class="string">&quot;textarea&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;dialogFormVisible = false&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleAdd()&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 编辑标签弹层 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;add-form&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">el-dialog</span> <span class="attr">title</span>=<span class="string">&quot;编辑检查项&quot;</span> <span class="attr">:visible.sync</span>=<span class="string">&quot;dialogFormVisible4Edit&quot;</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">ref</span>=<span class="string">&quot;dataEditForm&quot;</span> <span class="attr">:model</span>=<span class="string">&quot;formData&quot;</span> <span class="attr">:rules</span>=<span class="string">&quot;rules&quot;</span> <span class="attr">label-position</span>=<span class="string">&quot;right&quot;</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">label-width</span>=<span class="string">&quot;100px&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书类别&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;type&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.type&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;12&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;图书名称&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.name&quot;</span>/&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-row</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">el-col</span> <span class="attr">:span</span>=<span class="string">&quot;24&quot;</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;描述&quot;</span>&gt;</span></span><br><span class="line">                                    <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">v-model</span>=<span class="string">&quot;formData.description&quot;</span> <span class="attr">type</span>=<span class="string">&quot;textarea&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">                                <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;/<span class="name">el-col</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">el-row</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">slot</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;dialog-footer&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;dialogFormVisible4Edit = false&quot;</span>&gt;</span>取消<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;handleEdit()&quot;</span>&gt;</span>确定<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">el-dialog</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 引入组件库 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../plugins/elementui/index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/axios-0.18.0.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">var</span> vue = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">pagination</span>: &#123;&#125;,</span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dataList</span>: [],<span class="comment">//当前页要展示的列表数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">formData</span>: &#123;&#125;,<span class="comment">//表单数据</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dialogFormVisible</span>: <span class="literal">false</span>,<span class="comment">//控制表单是否可见</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">dialogFormVisible4Edit</span>: <span class="literal">false</span>,<span class="comment">//编辑表单是否可见</span></span></span><br><span class="line"><span class="language-javascript">            <span class="attr">rules</span>: &#123;<span class="comment">//校验规则</span></span></span><br><span class="line"><span class="language-javascript">                <span class="attr">type</span>: [&#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;图书类别为必填项&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;],</span></span><br><span class="line"><span class="language-javascript">                <span class="attr">name</span>: [&#123;<span class="attr">required</span>: <span class="literal">true</span>, <span class="attr">message</span>: <span class="string">&#x27;图书名称为必填项&#x27;</span>, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span>&#125;]</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="comment">//钩子函数，VUE对象初始化完成后自动执行</span></span></span><br><span class="line"><span class="language-javascript">        <span class="title function_">created</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//列表</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">getAll</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">get</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">dataList</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//弹出添加窗口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleCreate</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="title function_">resetForm</span>();</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//重置表单</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">resetForm</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.<span class="property">formData</span> = &#123;&#125;;</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//添加</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleAdd</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">post</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>, <span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">data</span>);</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20011</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;添加成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20010</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;添加失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//弹出编辑窗口</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleUpdate</span>(<span class="params">row</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">// console.log(row);   //row.id 查询条件</span></span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//查询数据，根据id查询</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">get</span>(<span class="string">&quot;/SSM_war_exploded/books/&quot;</span> + row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">// console.log(res.data.data);</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20041</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="comment">//展示弹层，加载数据</span></span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">formData</span> = res.<span class="property">data</span>.<span class="property">data</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">true</span>;</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//编辑</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleEdit</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//发送ajax请求</span></span></span><br><span class="line"><span class="language-javascript">                axios.<span class="title function_">put</span>(<span class="string">&quot;/SSM_war_exploded/books&quot;</span>, <span class="variable language_">this</span>.<span class="property">formData</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//如果操作成功，关闭弹层，显示数据</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20031</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">dialogFormVisible4Edit</span> = <span class="literal">false</span>;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;修改成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20030</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;修改失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(res.<span class="property">data</span>.<span class="property">msg</span>);</span></span><br><span class="line"><span class="language-javascript">                    &#125;</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;,</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">            <span class="comment">// 删除</span></span></span><br><span class="line"><span class="language-javascript">            <span class="title function_">handleDelete</span>(<span class="params">row</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//1.弹出提示框</span></span></span><br><span class="line"><span class="language-javascript">                <span class="variable language_">this</span>.$confirm(<span class="string">&quot;此操作永久删除当前数据，是否继续？&quot;</span>, <span class="string">&quot;提示&quot;</span>, &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="attr">type</span>: <span class="string">&#x27;info&#x27;</span></span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//2.做删除业务</span></span></span><br><span class="line"><span class="language-javascript">                    axios.<span class="title function_">delete</span>(<span class="string">&quot;/SSM_war_exploded/books/&quot;</span> + row.<span class="property">id</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="keyword">if</span> (res.<span class="property">data</span>.<span class="property">code</span> == <span class="number">20021</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">success</span>(<span class="string">&quot;删除成功&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                            <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">error</span>(<span class="string">&quot;删除失败&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                        &#125;</span></span><br><span class="line"><span class="language-javascript">                    &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                        <span class="variable language_">this</span>.<span class="title function_">getAll</span>();</span></span><br><span class="line"><span class="language-javascript">                    &#125;);</span></span><br><span class="line"><span class="language-javascript">                &#125;).<span class="title function_">catch</span>(<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">                    <span class="comment">//3.取消删除</span></span></span><br><span class="line"><span class="language-javascript">                    <span class="variable language_">this</span>.<span class="property">$message</span>.<span class="title function_">info</span>(<span class="string">&quot;取消删除操作&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;);</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;)</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="springBoot"><a href="#springBoot" class="headerlink" title="springBoot"></a>springBoot</h1><h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><h1 id="Redis6"><a href="#Redis6" class="headerlink" title="Redis6"></a>Redis6</h1><p>非关系型数据库，即缓存数据库，读取速度快，但保存时间有限。</p><h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><p>Zookeeper: 是一个分布式的、开源的程序协调服务，是 hadoop(分布式计算) 项目下的一个子项目。</p><p>用于<strong>分布式中一致性处理的框架</strong>。</p><h1 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h1><p>Dubbo是阿里巴巴开源的基于 Java 的高性能 RPC（一种远程调用） 分布式服务框架。</p><p>其内部使用了 Netty、Zookeeper，保证了高性能高可用性。</p><h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><p>消息中间件是基于队列与消息传递技术，在网络环境中为应用系统提供同步或异步、可靠的消息传输的支撑性软件系统。</p><p>ActiveMQ</p><p>中小型公司，万级，非常成熟，功能强大，在早些年业内大量的公司以及项目中都有应用，主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用。</p><p>RabbitMQ</p><p>万级，延时很低，是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</p><p>RocketMQ</p><p>大型公司，十万级，阿里，接口简单易用，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。</p><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1>]]></content>
      
      
      <categories>
          
          <category> javaLearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 框架 </tag>
            
            <tag> Maven&amp;SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/Notes/2022/04/14/Git/"/>
      <url>/Notes/2022/04/14/Git/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>git 是一个<strong>分布式版本控制</strong>系统，</p><blockquote><p>版本控制 是一种记录文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制其实最重要的是可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换。</p></blockquote><blockquote><p>分布式的版本控制系统出现之后，解决了集中式版本控制系统的缺陷：</p><ol><li>服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）</li><li>每个客户端保存的也都是整个完整的项目 (包含历史记录，更加安全)</li></ol></blockquote><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p><strong>工作区——git add——&gt; 暂存区——git commit——&gt; 本地库</strong></p><blockquote><p>工作区：写代码； </p><p>暂存区：临时存储；</p><p>本地库：历史版本；</p></blockquote><p><strong>代码托管中心</strong></p><p>代码托管中心是基于网络服务器的远程代码仓库，一般称为 <strong>远程库</strong>。</p><blockquote><p>局域网：GitLab</p><p>互联网：GitHub，Gitee码云</p></blockquote><h3 id="基础操作命令"><a href="#基础操作命令" class="headerlink" title="基础操作命令"></a>基础操作命令</h3><p>初始化本地仓库：git init</p><p>查看本地库状态：<strong>git status</strong></p><p>添加暂存区：<strong>git add 文件名</strong> （<strong>git add .</strong>  &#x2F;&#x2F;将所有修改加入暂存区）</p><p>提交本地库：<strong>git commit -m “日志信息” 文件名</strong></p><blockquote><p>工作区的文件是git对象，不能看作是项目，要添加到暂存区，才能形成一个项目。</p></blockquote><p>查看简易版本信息：<strong>git reflog</strong>  (参看详细版本信息：<strong>git log</strong>)</p><p>版本穿梭：<strong>git reset –hard 版本号</strong></p><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>在版本控制中，要同时推进多个任务，对每个任务就可以单独创建一个分支。</p><p>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己的分支时不会影响主线分支的运行。（分支底层是指针的引用）</p><p><strong>分支操作：</strong></p><p>创建分支：<strong>git branch 分支名</strong></p><p>查看分支：<strong>git branch -v</strong></p><p>切换分支：<strong>git checkout 分支名</strong></p><p>将指定分支合并到当前分支上：<strong>git merge 分支名</strong></p><blockquote><p>指定分支要提交本地库，合并后，当前分支才会修改。</p><p>合并冲突： </p><p>当两个分支修改了同一个文件，并都提交到本地库，那么合并时，系统发现一个文件出现两个版本，不知道应该选择哪一个，就是发生了冲突。需要手动修改，选择。</p></blockquote><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p><strong>git remote -v</strong> ：查看当前所有远程地址别名</p><p><strong>git remote add 别名 远程地址</strong>  ：添加远程库地址和别名</p><p>推送本地分支到远程仓库 ：<strong>git push 别名 分支</strong></p><p>拉取远程库到本地库 ： <strong>git pull 别名 分支</strong> （自动提交到本地库）</p><p>克隆远程库到本地库：<strong>git clone 远程地址</strong></p><blockquote><p>克隆结果：初始化本地仓库，创建别名</p></blockquote><h3 id="团队内协作"><a href="#团队内协作" class="headerlink" title="团队内协作"></a>团队内协作</h3><p>远程仓库的所有人需要在仓库的设置-成员设置中邀请其他团队成员加入，其他成员才能将本地分支推送到远程库</p><p>跨团队协作</p><p>团队外的人要先用fork获取远程库，修改后在界面的pull requests发送拉取请求。</p><blockquote><p>SSH免密登录</p><p>生成 .ssh密钥目录： <strong>ssh-keygen -t rsa -C 账号邮箱</strong></p><p>在.ssh目录下会有私钥id_rsa，公钥id_rsa.pub，将公钥添加到github上即可。</p></blockquote><h3 id="IDEA集成Git"><a href="#IDEA集成Git" class="headerlink" title="IDEA集成Git"></a>IDEA集成Git</h3><p>环境准备：</p><p>先配置忽略文件 git.ignore，避免提交无用的文件，避免开发环境差异。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//内容如下</span><br><span class="line"># Compoled class file</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># log file</span><br><span class="line">*.log</span><br><span class="line"></span><br><span class="line">#Blue files</span><br><span class="line">*.ctxt</span><br><span class="line">a</span><br><span class="line">#Mobile Tools for Java(J2ME)</span><br><span class="line">.mtj.tmp/</span><br><span class="line"></span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.nar</span><br><span class="line">*.ear</span><br><span class="line">*.zip</span><br><span class="line">*.tar.gz</span><br><span class="line">*.rar</span><br><span class="line"></span><br><span class="line"># virtual machine crash logs</span><br><span class="line">.classpath</span><br><span class="line">.project</span><br><span class="line">.settings</span><br><span class="line">target</span><br><span class="line">.idea</span><br><span class="line">*.iml</span><br></pre></td></tr></table></figure><p>然后在 .gitconfig 中添加 ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">excludesfile = C:/Users/123/git.ignore</span><br></pre></td></tr></table></figure><p>之后再idea设置的版本控制中设置git.exe路径。</p><p>初始化：</p><p>在工具栏的vcs中选择创建git仓库即可。</p><h1 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h1><p>搜索—高级搜索功能：<a href="http://github.com/search/advanced">http://github.com/search/advanced</a>  或  搜索框中使用语法进行精确搜索</p><p>快捷面板：ctrl + K</p><p>仓库内对文件搜索： T键</p><p>文件内 行号跳转： L键</p><p>查看文件改动记录： B键</p><p>仓库详情页 打开 VSCode网页版： 。键d</p><p>打开 Gitpod ： 在地址前缀前加上 gitpod.io&#x2F;#&#x2F; </p><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205081046166.png" alt="image-20220508104603843"></p><p>啊啊<img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205211118842.png"></p><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><p>前置操作已完成，现在 —— 初始化及部署博客：</p><p>新建文件夹 blog， 在blog 中使用git命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init   //初始化本地博客</span><br><span class="line">hexo clean  //清理编译文件</span><br><span class="line">hexo g   //生成对应的html文件</span><br><span class="line">hexo s//本地预览运行</span><br></pre></td></tr></table></figure><p>修改 _config.yml 文件，在文件最后，修改为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: 仓库ssh地址</span><br><span class="line">  branch: master</span><br><span class="line">  </span><br><span class="line">  //在17行左右，url下面，添加：</span><br><span class="line">  root: /仓库名</span><br></pre></td></tr></table></figure><p>上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>每次预览：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>每次上传：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br><span class="line">还要到gitee上更新pages服务，才会生效</span><br></pre></td></tr></table></figure><blockquote><p>主题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 主题地址(github地址)</span><br></pre></td></tr></table></figure><p>修改 _config.yml 文件中的 theme: 主题文件名</p></blockquote><blockquote><p>源文件上传git：<br>git push -u origin main</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">完整操作：</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin 地址</span><br><span class="line">git push -u origin main</span><br><span class="line">//推送到master分支不知为何，会出错</span><br></pre></td></tr></table></figure><p>恢复源文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone 地址</span><br><span class="line">npm install</span><br><span class="line">hexo g</span><br><span class="line">hexo s/d   //本地预览或上传</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>常用hexo命令</p><p>常见命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure><p>缩写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br></pre></td></tr></table></figure><p>组合命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo s -g #生成并本地预览</span><br><span class="line">hexo d -g #生成并上传</span><br></pre></td></tr></table></figure><p>a</p></blockquote><h2 id="hexo-butterfly"><a href="#hexo-butterfly" class="headerlink" title="hexo-butterfly"></a>hexo-butterfly</h2><h3 id="扉页"><a href="#扉页" class="headerlink" title="扉页"></a>扉页</h3><ul><li>page front-matter  用于页面的配置</li></ul><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>页面标题（必须）</td></tr><tr><td>date</td><td>创建日期（必须）</td></tr><tr><td>type</td><td>标签类型（标签，分类，友情链接三个页面必须配置）</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>description</td><td>页面描述</td></tr><tr><td>keywords</td><td>页面关键字</td></tr><tr><td>comments</td><td>显示页面评论模块（默认true）</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>mathjax</td><td></td></tr><tr><td>katex</td><td></td></tr><tr><td>aside</td><td>显示侧边栏（默认true）</td></tr><tr><td>aplayer</td><td>在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td>代码框是否展开（默认根据配置文件）</td></tr></tbody></table><ul><li>post front-matter 文章页的扉页 ，用于文章页的配置</li></ul><table><thead><tr><th>写法</th><th>解释</th></tr></thead><tbody><tr><td>title</td><td>页面标题（必须）</td></tr><tr><td>date</td><td>创建日期（必须）</td></tr><tr><td>updated</td><td>页面更新日期</td></tr><tr><td>tags</td><td>文章标签</td></tr><tr><td>categories</td><td>文章分类</td></tr><tr><td>keywords</td><td>文章关键字</td></tr><tr><td>description</td><td>页面描述</td></tr><tr><td>keywords</td><td>页面关键字</td></tr><tr><td>comments</td><td>显示页面评论模块（默认true）</td></tr><tr><td>top_img</td><td>页面顶部图片</td></tr><tr><td>cover</td><td>文章封面主图，可设 false&#x2F;图地址&#x2F;留空</td></tr><tr><td>toc</td><td>显示文章toc（默认为配置中的enable）</td></tr><tr><td>toc_number</td><td>显示toc_number</td></tr><tr><td>toc_style_simple</td><td>显示 toc 简洁模式</td></tr><tr><td>copyright_author</td><td>文章版权 作者</td></tr><tr><td>copyright_author_herf</td><td>文章版权 作者的链接</td></tr><tr><td>copyright_url</td><td>文章版权 文章的链接</td></tr><tr><td>copyright_info</td><td>文章版权 的版权声明</td></tr><tr><td>mathjax</td><td></td></tr><tr><td>katex</td><td></td></tr><tr><td>aside</td><td>显示侧边栏（默认true）</td></tr><tr><td>aplayer</td><td>在需要的页面加载aplayer的js和css</td></tr><tr><td>highlight_shrink</td><td>代码框是否展开（默认根据配置文件）</td></tr></tbody></table><h3 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h3><p>主页的图——index_img:<br>默认是文章配图——default_top_img:<br>归档页的主图—— archive_img<br>标签页的主图——tag_img<br>标签页的文章配图——tag_per_img<br>分类页的主图——category_img<br>分类页的文章配图——category_per_img</p><p>其他页面和文章页的top_img： 可以到文章的扉页 配置——top_img: xxx</p><h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><ul><li>在文章的扉页 添加 sticky：1 ，数字越大，置顶的优先级越大；</li></ul><h3 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h3><ul><li><p>在文章的扉页 添加  cover: 图片地址</p></li><li><p>可以在配置文件里配置默认图片， default_cover:  xxx</p><p>如果要配置多张图片，随机选择一张作为cover，写法为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">图片地址</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="侧边栏"><a href="#侧边栏" class="headerlink" title="侧边栏"></a>侧边栏</h3><p>在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/xxxxxx</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">  <span class="string">。。。。等等等</span></span><br></pre></td></tr></table></figure><h3 id="文章打赏"><a href="#文章打赏" class="headerlink" title="文章打赏"></a>文章打赏</h3><p>在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">QR_code:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">二维码图片</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="string">text:微信</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">img:</span> <span class="string">二维码图片</span></span><br><span class="line">      <span class="attr">link:</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">支付宝</span></span><br></pre></td></tr></table></figure><h3 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h3><p>显示目录，在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> </span><br></pre></td></tr></table></figure><h3 id="相关文章推荐"><a href="#相关文章推荐" class="headerlink" title="相关文章推荐"></a>相关文章推荐</h3><p>根据tags的比重来推荐，在配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># 显示创建或更新日期，created 或 updated</span></span><br></pre></td></tr></table></figure><h3 id="文章锚点"><a href="#文章锚点" class="headerlink" title="文章锚点"></a>文章锚点</h3><p> 开启后，在文章中滚动时，文章链接会根据标题进行变化（每替换一次，都会留下一次历史记录，锚点过多，可能导致历史记录过多）</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">anchor:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Avatar (頭像)</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">图片地址</span> <span class="string">如：</span> <span class="string">./img/avatar1.jpg</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span>  <span class="comment">#头像一直转圈</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="网站图标"><a href="#网站图标" class="headerlink" title="网站图标"></a>网站图标</h3><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span> </span><br></pre></td></tr></table></figure><h3 id="图片描述"><a href="#图片描述" class="headerlink" title="图片描述"></a>图片描述</h3><p>在图片下显示描述信息，优先 title属性，然后是 alt属性</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">photofigcaption:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># copy settings</span></span><br><span class="line"><span class="comment"># copyright: Add the copyright information after copied content (複製的內容後面加上版權信息)</span></span><br><span class="line"><span class="attr">copy:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>   <span class="comment"># 能否复制</span></span><br><span class="line">  <span class="attr">copyright:</span><span class="comment"># 复制内容后加上版权信息</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit_count:</span> <span class="number">50</span><span class="comment">#复制文字大于限制时 加版权信息</span></span><br></pre></td></tr></table></figure><h3 id="脚页自定义文本"><a href="#脚页自定义文本" class="headerlink" title="脚页自定义文本"></a>脚页自定义文本</h3><p>custom_text:  支持HTML</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_text:</span>  <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">&lt;a</span> <span class="string">href=&quot;https://butterfly.js.org/&quot;&gt;blog&lt;/a&gt;!</span></span><br></pre></td></tr></table></figure><h3 id="插入自定义代码"><a href="#插入自定义代码" class="headerlink" title="插入自定义代码"></a>插入自定义代码</h3><p>修改配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如；</span></span><br><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/footer.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/blog.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/cursors.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/opacity.css&quot;&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;./css/scrollbar.css&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="comment"># - &lt;script src=&quot;xxxx&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><h3 id="网站背景"><a href="#网站背景" class="headerlink" title="网站背景"></a>网站背景</h3><p>默认白色</p><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Website Background (設置網站背景)</span></span><br><span class="line"><span class="comment"># can set it to color or image (可設置圖片 或者 顔色)</span></span><br><span class="line"><span class="comment"># The formal of image: url(http://xxxxxx.com/xxx.jpg)</span></span><br><span class="line"><span class="attr">background:</span> </span><br></pre></td></tr></table></figure><h3 id="网站副标题"><a href="#网站副标题" class="headerlink" title="网站副标题"></a>网站副标题</h3><p>配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主页subtitle</span></span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Typewriter Effect (打字效果)</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># loop (循环打字)</span></span><br><span class="line">  <span class="attr">loop:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># source 调用第三方服务</span></span><br><span class="line">  <span class="comment"># source: false 关闭调用</span></span><br><span class="line">  <span class="comment"># source: 1  调用一言网的一句话（简体） https://hitokoto.cn/</span></span><br><span class="line">  <span class="comment"># source: 2  调用一句网（简体） http://yijuzhan.com/</span></span><br><span class="line">  <span class="comment"># source: 3  调用今日诗词（简体） https://www.jinrishici.com/</span></span><br><span class="line">  <span class="comment"># subtitle 会先显示 source , 再显示 sub 的内容</span></span><br><span class="line">  <span class="attr">source:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 如果关闭打字效果，subtitle 只会显示 sub 的第一行文字</span></span><br><span class="line">  <span class="attr">sub:</span></span><br></pre></td></tr></table></figure><h3 id="备案信息"><a href="#备案信息" class="headerlink" title="备案信息"></a>备案信息</h3><p>在页脚的custom_text也可以写代码，在此写下备案跳转链接。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2021</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">&lt;div&gt;&lt;a</span> <span class="string">onclick=&quot;window.open(&#x27;&#x27;)&quot;&gt;&lt;/a&gt;&lt;/div&gt;</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">true</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><h3 id="引擎收录"><a href="#引擎收录" class="headerlink" title="引擎收录"></a>引擎收录</h3><blockquote></blockquote><h3 id="url持久化"><a href="#url持久化" class="headerlink" title="url持久化"></a>url持久化</h3><p>hexo默认生成的文章地址路径是： 网站名&#x2F;年&#x2F;月&#x2F;日&#x2F;文章名，它的url结构超过3层，较深，对搜索爬虫不友好。</p><p>安装：npm install hexo-abbrlink –save</p><p>修改配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line"> <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment">#算法：crc16(default)and crc32</span></span><br><span class="line"> <span class="attr">rep:</span> <span class="string">hex</span>     <span class="comment">#进制：dec(default)and hex</span></span><br></pre></td></tr></table></figure><p>添加nofollow标签：</p><p>安装：npm install hexo-filter-nofollow –save</p><p>添加配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nofollow:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">site</span></span><br><span class="line">  <span class="attr">exclude:</span> <span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="标签外挂"><a href="#标签外挂" class="headerlink" title="标签外挂"></a>标签外挂</h3><p>（可能有移植问题，不是很推荐）</p><p>Gallery相册图库</p><p>写法：</p><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 例如： --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span><br><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁纸&#x27; &#x27;/Gallery/wallpaper&#x27; https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;漫威&#x27; &#x27;关于漫威的图片&#x27; &#x27;/Gallery/marvel&#x27; https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;OH MY GIRL&#x27; &#x27;关于OH MY GIRL的图片&#x27; &#x27;/Gallery/ohmygirl&#x27; https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Gallery相册</p><p>这是新的Gallery相册，会自动根据图片进行排版，书写也更方便，与markdown格式一样；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>tag-hide</p><p>可以将 一些内容隐藏起来，并提供按钮让用户点击显示；</p><p>注：内容不要用 h1~h6标题，会让目录有一些异常；</p><p>inline ——  只能隐藏文字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><ul><li><p>content: 文本内容</p></li><li><p>display: 按钮显示的文字(可选)</p></li><li><p>bg: 按钮的背景颜色(可选)</p></li><li><p>color: 按钮文字的颜色(可选)</p></li></ul><p>注：content部分不能用英文逗号，可用 <code>&amp;sbquo;</code> 代替</p><p>block ——  隐藏多个内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><ul><li>content: 文本内容</li><li>display: 按钮显示的文字(可选)</li><li>bg: 按钮的背景颜色(可选)</li><li>color: 按钮文字的颜色(可选)</li></ul><p>toggle —— 隐藏大量内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideToggle display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideToggle %&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言</title>
      <link href="/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="C语言学习"><a href="#C语言学习" class="headerlink" title="C语言学习"></a>C语言学习</h1><h2 id="1章-概述"><a href="#1章-概述" class="headerlink" title="1章 概述"></a>1章 概述</h2><p>注意点：</p><ol><li>一个函数的函数体可以没有变量定义和执行部分，函数可以是空函数。</li><li>一个C程序至少包含一个<u>主函数</u>，即<u>main函数</u>。</li><li>一个函数由两部分组成，分别是<u>函数的说明部分</u>和<u>函数体</u>。</li><li>C语言通过输入和输出函数 来进行输入输出。</li><li>主函数后的圆括号内可为空，但这个圆括号不能省略。</li></ol><h2 id="2章-数据类型、运算符、表达式"><a href="#2章-数据类型、运算符、表达式" class="headerlink" title="2章 数据类型、运算符、表达式"></a>2章 数据类型、运算符、表达式</h2><p>注意点：</p><ol><li>C语言中，数据基本类型有<u>整型，浮点型，字符型</u>；</li><li>能表示整型常量的进制有八、十、十六进制（二进制不行）；</li><li>ASCII码表：数值0——48；字母A——65；字母a——97；</li><li>所有变量，遵循<u>先定义后使用</u>的原则；</li><li>强制类型转换——将一个表达式转换成指定的类型；</li></ol><h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p><strong>整型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td>-2 147 483 648 ~ 2 147 483 647（过20亿）</td></tr><tr><td>short</td><td>2字节</td><td>-32 768 ~ 32 767</td></tr><tr><td>long</td><td>8字节</td><td>-9 223 372 036 854 775 808 ~ 9 223 372 036 854 775 807（过九百亿亿）</td></tr><tr><td>byte</td><td>1字节</td><td>-128 ~ 127</td></tr></tbody></table><p>长整型数值带一个后缀L或l，十六进制数值带前缀0x，八进制带前缀0，（但容易混淆，如010对应十进制的8，所以不建议用），二进制数前缀带0b。</p><hr><p><strong>浮点型</strong></p><table><thead><tr><th>类型</th><th>存储需求</th><th>取值范围</th></tr></thead><tbody><tr><td>float</td><td>4字节</td><td>大约+-3.402 823 47E + 38F（有效位数为6~7位）</td></tr><tr><td>double</td><td>8字节</td><td>大约+-1.797 693 134 862 315 70E + 308(有效位数为15位)</td></tr></tbody></table><p>float类型带后缀F&#x2F;f，没有后缀的浮点数值默认为double类型，double类型后缀也可以带D</p><ul><li><p>对于表示溢出和出错情况的三个特殊浮点数值：</p><p>1.正无穷大：Double.POSITIVE_INFINITY</p><p>2.负无穷大：Double.NEGATIVE_INFINITY</p><p>3.NaN(不是一个数字)：Double.NaN</p><ul><li><p>检测一个特定值是否等于Double.NaN：</p></li><li><p>整数被0除会产生异常，浮点数被0除会得到无穷大或NaN结果。</p></li></ul></li><li><p>浮点数值采用二进制系统表示，无法精确表示分数1&#x2F;10，就像十进制无法精确表示分数1&#x2F;3一样，所以，(2.0 - 1.1)将打印出 0.899999999，而不是0.9。（舍入误差）</p></li></ul><hr><p><strong>char</strong>类型</p><p>占2字节，char类型的字面量要用<strong>单引号</strong>括起来，char类型的值可以表示为16进制值，其范围为：\u0000 ~ \uFFFF</p><ul><li><p><strong>Unicode转义序列会在解析代码前得到处理，</strong>如：”\u0022+\u0022”，不是由引号包围加号的字符串，\0022表示引号，会在解析前转换为”，这会得到”“+”“，也就是一个空串。</p><p>更隐秘的，对注释中的\u也一样：&#x2F;&#x2F; \u000A is a newline   中\u000A会替换为一个换行符，</p><p>类似的：&#x2F;&#x2F; look inside c:\users中会出现一个语法错误，即\u后没有跟着4个十六进制数。</p></li></ul><hr><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>枚举类型也是算术类型，被用来定义在程序中只能赋予其一定的整数值的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span>　枚举名　&#123;</span>枚举元素<span class="number">1</span>,枚举元素<span class="number">2</span>,……&#125;;</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MON  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TUE  2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WED  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> THU  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FRI  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SAT  6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SUN  7</span></span><br><span class="line"><span class="comment">//上面的宏定义可用枚举来表示</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DAY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">      MON=<span class="number">1</span>, TUE, WED, THU, FRI, SAT, SUN</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。在这个实例中把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。</p></li><li><p>可以在定义枚举类型时改变枚举元素的值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">season</span> &#123;</span>spring, summer=<span class="number">3</span>, autumn, winter&#125;;</span><br></pre></td></tr></table></figure><p>没有指定值的枚举元素，其值为前一元素加 1。也就说 spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5</p></li></ul><p><strong>关于枚举的遍历：</strong></p><p>在C 中，枚举类型是被当做 int 或者 unsigned int 类型来处理的，所以按照 C 规范是没有办法遍历枚举类型的。不过有特殊情况，即在枚举类型中的值是连续时 可以遍历，否则不能；</p><hr><h4 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h4><p>void 类型指定没有可用的值。它通常用于以下三种情况下：</p><table><thead><tr><th>序号</th><th>类型与描述</th></tr></thead><tbody><tr><td>1</td><td><strong>函数返回为空</strong> ：C 中有各种函数都不返回值，或者您可以说它们返回空。不返回值的函数的返回类型为空。例如 <strong>void exit (int status);</strong></td></tr><tr><td>2</td><td><strong>函数参数为空</strong>： C 中有各种函数不接受任何参数。不带参数的函数可以接受一个 void。例如 <strong>int rand(void);</strong></td></tr><tr><td>3</td><td><strong>指针指向 void</strong> ：类型为 void * 的指针代表对象的地址，而不是类型。例如，内存分配函数 <strong>void *malloc( size_t size );</strong> 返回指向 void 的指针，可以转换为任何数据类型。</td></tr></tbody></table><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><p><strong>逻辑运算符</strong></p><p>假设变量 <strong>A</strong> 的值为 1，变量 <strong>B</strong> 的值为 0，则：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;&amp;</td><td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td><td>(A &amp;&amp; B) 为假。</td></tr><tr><td>||</td><td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td><td>(A || B) 为真。</td></tr><tr><td>!</td><td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td><td>!(A &amp;&amp; B) 为真。</td></tr></tbody></table><p><strong>位运算符</strong></p><p>位运算符作用于位，并逐位执行操作。&amp;、 | 和 ^ 的真值表如下所示：</p><table><thead><tr><th>p</th><th>q</th><th>p &amp; q</th><th>p | q</th><th>p ^ q</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td></tr><tr><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：</p><blockquote><p>A &#x3D; 0011 1100</p><p>B &#x3D; 0000 1101</p><p>-—————-</p><p>A&amp;B &#x3D; 0000 1100</p><p>A|B &#x3D; 0011 1101</p><p>A^B &#x3D; 0011 0001</p><p>~A &#x3D; 1100 0011</p></blockquote><p><strong>赋值运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&#x3D;</td><td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td><td>C &#x3D; A + B 将把 A + B 的值赋给 C</td></tr><tr><td>+&#x3D;</td><td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td><td>C +&#x3D; A 相当于 C &#x3D; C + A</td></tr><tr><td>-&#x3D;</td><td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td><td>C -&#x3D; A 相当于 C &#x3D; C - A</td></tr><tr><td>*&#x3D;</td><td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td><td>C *&#x3D; A 相当于 C &#x3D; C * A</td></tr><tr><td>&#x2F;&#x3D;</td><td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td><td>C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td></tr><tr><td>%&#x3D;</td><td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td><td>C %&#x3D; A 相当于 C &#x3D; C % A</td></tr><tr><td>&lt;&lt;&#x3D;</td><td>左移且赋值运算符</td><td>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td></tr><tr><td>&gt;&gt;&#x3D;</td><td>右移且赋值运算符</td><td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td></tr><tr><td>&amp;&#x3D;</td><td>按位与且赋值运算符</td><td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td></tr><tr><td>^&#x3D;</td><td>按位异或且赋值运算符</td><td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td></tr><tr><td>|&#x3D;</td><td>按位或且赋值运算符</td><td>C |&#x3D; 2 等同于 C &#x3D; C | 2</td></tr></tbody></table><p><strong>杂项运算符</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>sizeof()</td><td>返回变量的大小。</td><td>sizeof(a) 将返回 4，其中 a 是整数。</td></tr><tr><td>&amp;</td><td>返回变量的地址。</td><td>&amp;a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指向一个变量。</td><td>*a; 将指向一个变量。</td></tr><tr><td>? :</td><td>条件表达式（三元运算符）</td><td>如果条件为真 ? 则值为 X : 否则值为 Y</td></tr></tbody></table><h2 id="3章-顺序结构"><a href="#3章-顺序结构" class="headerlink" title="3章 顺序结构"></a>3章 顺序结构</h2><ol><li><p>printf函数包括“格式控制”和“输出列表”，其中“格式控制”包括：<u>格式说明、普通字符</u>；。</p><p>scanf函数包括“格式控制”和“地址列表”。</p></li><li><p>#define宏都是直接替换的，不会计算后再替换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  P  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  S(a)   P*a*a</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span>  ar;</span><br><span class="line">ar=S(<span class="number">3</span>+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n%d&quot;</span>,ar);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果为29</span></span><br><span class="line"><span class="comment">//s(3+5) = p*3+5*3+5 = 9+15+5 =29</span></span><br></pre></td></tr></table></figure></li><li><p>真  等价于  非0的数</p></li><li><p>数组中的元素具有相同的类型（数据类型，储存类型）</p></li><li><p>实型常量–指数形式：e&#x2F;E之前必须有数字，且e&#x2F;E后面必须为整数；如不能有e4，12e2.5</p></li><li><pre><code>\a:警告，蜂鸣声\b：退格，后退一个字符\f：换页\n：换行\r：回车，当前位置移到本行开头\t：水平制表符，当前位置移到下一个tab位置\v：垂直制表符，当前位置移到下一个垂直对齐点\加数字：数字为八进制，表示为数字对于的ASCII字符\x加数字：数字为十六进制，表示为数字对于的ASCII字符<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">## 4章 选择结构</span><br><span class="line"></span><br><span class="line">1. switch括号内的表达式应为整数类型，即可以是int类型、char类型、枚举类型；</span><br><span class="line"></span><br><span class="line">2. 运算符优先级：</span><br><span class="line"></span><br><span class="line">   !(逻辑非) &gt; 算数运算 &gt; 关系运算 &gt; &amp;&amp;(逻辑与) &gt; ||(逻辑或) &gt; 赋值运算</span><br><span class="line"></span><br><span class="line">3. else与它前面最近的一个未配对的if 配对</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 5章 循环结构</span><br><span class="line"></span><br><span class="line">1. ```c</span><br><span class="line">   int k = 0; </span><br><span class="line">   while(k++ &lt;= 2)&#123;</span><br><span class="line">   printf(&quot;%d &quot;,k);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>执行结果为：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>for( 表达式1；表达式2；表达式3) 中表达式2不成立后，依旧会执行完表达式3.</p></li></ol><h2 id="6章-数组"><a href="#6章-数组" class="headerlink" title="6章.数组"></a>6章.数组</h2><ol><li>全局或静态数组：未初始化的部分默认为0；<br>局部数组：如果有部分初始化，则剩下未初始化的部分为0；如完全没有初始化，则所有值均不确定。</li><li>“类型  数组名  [常量表达式]”  中常量表达式 可以包括 常量和符号常量。</li><li>二维数组中元素排列顺序为  ： 按行存放，即在内存中先存放第一行的元素，再存放第二行的元素。</li></ol><h4 id="输出“魔方阵”。"><a href="#输出“魔方阵”。" class="headerlink" title="输出“魔方阵”。"></a><strong>输出“魔方阵”。</strong></h4><p>所谓魔方阵是指这样的方阵，它的每一行、每一列和对角线之和均相等。例如，三阶魔方阵为</p><p>816</p><p>357<br>492<br>要求输出1～pow（n，2）的自然数构成的魔方阵。<br>解:魔方阵中各数的排列规律如下:<br>（1）将1放在第1行中间一列。<br>（2）从2开始直到n×n止各数依次按下列规则存放:每一个数存放的行比前一个数的<br>行数减1，列数加1（例如上面的三阶魔方阵，5在4的上一行后一列）。<br>（3）如果上一数的行数为1，则下一个数的行数为n（指最下一行）。例如，1在第1行，<br>则2应放在最下一行，列数同样加1。<br>（4）当上一个数的列数为n时，下一个数的列数应为1，行数减1。例如，2在第3行最<br>后一列，则3应放在第2行第1列。<br>（5）如果按上面规则确定的位置上已有数，或上一个数是第1行第n列时，则把下一个<br>数放在上一个数的下面。例如，按上面的规定，4应该放在第1行第2列，但该位置已被1<br>占据，所以4就放在3的下面。由于6是第1行第3列（即最后一列），故7放在6下面。</p><p>按此方法可以得到任何阶的魔方阵。注：魔方阵的阶数应为奇数。</p><h2 id="7章-函数"><a href="#7章-函数" class="headerlink" title="7章.函数"></a>7章.函数</h2><ol><li><p>变量作为实参向形参的数据传递方式是：单向值传递</p></li><li><p>函数的定义不可以嵌套，但调用可以嵌套</p></li><li><p>形参可以是常量，变量或表达式；</p></li><li><p>实参与对应的形参各占用独立的存储单元；</p></li></ol><p>函数定义的一般形式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">return_type <span class="title function_">function_name</span><span class="params">( parameter <span class="built_in">list</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">   body of the function</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，函数由一个函数头和一个函数主体组成。下面列出一个函数的所有组成部分：</p><ul><li><strong>返回类型：</strong>一个函数可以返回一个值。<strong>return_type</strong> 是函数返回的值的数据类型。有些函数执行所需的操作而不返回值，在这种情况下，return_type 是关键字 <strong>void</strong>。</li><li><strong>函数名称：</strong>这是函数的实际名称。函数名和参数列表一起构成了函数签名。</li><li><strong>参数：</strong>参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的，也就是说，函数可能不包含参数。</li><li><strong>函数主体：</strong>函数主体包含一组定义函数执行任务的语句。</li></ul><hr><p><strong>调用函数：</strong></p><ul><li><p>当程序调用函数时，程序控制权会转移给被调用的函数。被调用的函数执行已定义的任务，当函数的返回语句被执行时，或到达函数的结束括号时，会把程序控制权交还给主程序。</p></li><li><p>调用函数时，传递所需参数，如果函数返回一个值，则可以存储返回值。</p></li></ul><h4 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h4><p>用牛顿迭代法求根。方程为ax3＋b2＋cx＋d＝0，系数a，b，c，d的值依次为1，2，<br>3，4，由主函数输入。求x在1附近的一个实根。求出根后由主函数输出。</p><p><strong>牛顿迭代公式：x &#x3D; x0 - f(x0) &#x2F; f ‘(x0)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">function</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b, <span class="type">float</span> c, <span class="type">float</span> d)</span> &#123;</span><br><span class="line">    <span class="type">float</span> x1 = <span class="number">1</span>, x0, f1, f2;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        x0 = x1;</span><br><span class="line">        f1 = ((a * x0 + b) * x0 + c) * x0 + d;  <span class="comment">//将原公式化简，可减少计算时间</span></span><br><span class="line">        f2 = (<span class="number">3</span> * a * x0 + <span class="number">2</span> * b) * x0 + c;</span><br><span class="line">        x1 = x0 - f1 / f2;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">fabs</span>(x1 - x0) &gt;= <span class="number">1e-3</span>);</span><br><span class="line">    <span class="keyword">return</span> x1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> a, b, c, d;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f %f&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;x = %10.7f&quot;</span>, function(a, b, c, d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8章-指针运用"><a href="#8章-指针运用" class="headerlink" title="8章.指针运用"></a><strong>8章.指针运用</strong></h2><ol><li>&#96;&#96;&#96;<br>int a[5];<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   则数组a中首元素的地址可表示为：a  </span><br><span class="line"></span><br><span class="line">2. C中，指针变量能够赋&lt;u&gt;地址值&lt;/u&gt;或&lt;u&gt;NULL&lt;/u&gt;&lt;u&gt;值&lt;/u&gt;（或&#x27;\0&#x27;，或0，或空值）；</span><br><span class="line"></span><br><span class="line">3. 指针 p++ 指 p = p + 1，因为++有赋值操作，p的值（存放的地址）会改变；</span><br><span class="line"></span><br><span class="line">   指针 p + 1 指访问下一个地址；p本身不变。</span><br><span class="line"></span><br><span class="line">4. * int  * p[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与[]结合,因为其优先级比 * 高,所以P 是一个数组,然后再与 * 结合,说明数组里的元素是指针类型,然后再与int 结合,说明指针所指向的内容的类型是整型的,所以**P 是一个由返回整型数据的指针所组成的数组** </span><br><span class="line"></span><br><span class="line">   * int  ( *p)[3]; </span><br><span class="line"></span><br><span class="line">     //首先从P 处开始,先与*结合,说明P 是一个指针然后再与[]结合(与&quot;()&quot;这步可以忽略,只是为了改变优先级),说明指针所指向的内容是一个数组,然后再与int 结合,说明数组里的元素是整型的.所以**P 是一个指向由整型数据组成的数组的指针** </span><br><span class="line"></span><br><span class="line">   * int * * p; </span><br><span class="line"></span><br><span class="line">     //首先从P 开始,先与* 结合,说是P 是一个指针,然后再与*结合,说明指针所指向的元素是指针,然后再与int 结合,说明该指针所指向的元素是整型数据.</span><br><span class="line">   </span><br><span class="line">   * int p(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处起,先与()结合,说明P 是一个函数,然后进入()里分析,说明该函数有一个整型变量的参数,然后再与外面的int 结合,说明函数的返回值是一个整型数据 </span><br><span class="line">   </span><br><span class="line">   * Int ( *p)(**int**); </span><br><span class="line">   </span><br><span class="line">     //从P 处开始,先与指针结合,说明P 是一个指针,然后与()结合,说明指针指向的是一个函数,然后再与()里的int 结合,说明函数有一个int 型的参数,再与最外层的int 结合,说明函数的返回类型是整型,所以**P 是一个指向有一个整型参数且返回类型为整型的函数的指针** </span><br><span class="line">   </span><br><span class="line">   * int * (* p(**int**))[3]; </span><br><span class="line">   </span><br><span class="line">     从P 开始,先与()结合,说明P 是一个函数,然后进入()里面,与int 结合,说明函数有一个整型变量参数,然后再与外面的 * 结合,说明函数返回的是一个指针,,然后到最外面一层,先与[]结合,说明返回的指针指向的是一个数组,然后再与*结合,说明数组里的元素是指针,然后再与int 结合,说明指针指向的内容是整型数据.所以**P 是一个参数为一个整数据且返回一个指向由整型指针变量组成的数组的指针变量的函数.** </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 一些题解</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 求素数</span><br><span class="line"></span><br><span class="line">令变量 i 从**2**开始，看是否能被N%后等于0，i  一直到**sqrt（N）**即可。</span><br><span class="line"></span><br><span class="line">#### 将ASCII码转为字符：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">char c1;</span><br><span class="line">c1 = 33;    //对应字符ASCII码的十进制数，不需加引号；</span><br><span class="line">printf(&quot;%c&quot;,c1);</span><br><span class="line">//32以前的字符无法正常输出；</span><br></pre></td></tr></table></figure></li></ol><p>将字符转为对应ASCII码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c 的 ASCII 为 %d&quot;</span>, c, c);</span><br><span class="line"><span class="comment">//%d显示整数，%c显示对应字符</span></span><br></pre></td></tr></table></figure><h4 id="一元二次方程"><a href="#一元二次方程" class="headerlink" title="一元二次方程"></a>一元二次方程</h4><p>求<img src="https://gitee.com/ValcanoZz/typora_-image/raw/master/img/202203191708726.png" alt="image-20210409140501637" style="zoom: 50%;" />的根：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">float</span> a,b,c,x1,x2,d;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入方程的三个系数:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%f %f %f&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    <span class="keyword">if</span>(a!=<span class="number">0</span>)&#123;</span><br><span class="line">        d=<span class="built_in">sqrt</span>(b*b<span class="number">-4</span>*a*c);</span><br><span class="line">        x1=(-b+d)/(<span class="number">2</span>*a);</span><br><span class="line">        x2=(-b-d)/(<span class="number">2</span>*a);</span><br><span class="line">        <span class="keyword">if</span>(x1&lt;x2) </span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x2,x1); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">&quot;%0.2f %0.2f\n&quot;</span>,x1,x2);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="求两数的最大公约数："><a href="#求两数的最大公约数：" class="headerlink" title="求两数的最大公约数："></a>求两数的最大公约数：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n1, n2, i, gcd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;输入两个正整数，以空格分隔: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n1, &amp;n2);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i &lt;= n1 &amp;&amp; i &lt;= n2; ++i)&#123;</span><br><span class="line">        <span class="comment">// 判断 i 是否为最大公约数</span></span><br><span class="line">        <span class="keyword">if</span>(n1%i==<span class="number">0</span> &amp;&amp; n2%i==<span class="number">0</span>)</span><br><span class="line">            gcd = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最大公约数是 %d&quot;</span>, n1, n2, gcd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> rem;<span class="comment">//余数，当余数为0的时候，最后的m即为最大公约数</span></span><br><span class="line"><span class="comment">//先用较小的数对较大的数取余，再用余数对较小的数求余，直到余数为零 </span></span><br><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">rem = m % n;</span><br><span class="line">m = n;</span><br><span class="line">n = rem;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m;<span class="comment">//将结果返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> m,<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> m;</span><br><span class="line"><span class="keyword">return</span> fun(n, m % n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>求两数最小公倍数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> minMultiple;</span><br><span class="line">    minMultiple = (n1&gt;n2) ? n1 : n2;<span class="comment">// 判断两数较大的值，并赋值给 minMultiple</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>( minMultiple%n1==<span class="number">0</span> &amp;&amp; minMultiple%n2==<span class="number">0</span> )&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d 和 %d 的最小公倍数为 %d&quot;</span>, n1, n2,minMultiple);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++minMultiple;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：先记n1和n2的积为p，再求最大公约数x，则最小公倍数为p/x</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> n1,<span class="type">int</span> n2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> p = n1 * n2;</span><br><span class="line">    <span class="type">int</span> rem;</span><br><span class="line"><span class="keyword">while</span>(n2 &gt; <span class="number">0</span>)&#123;</span><br><span class="line">rem = n1 % n2;</span><br><span class="line">n1 = n2;</span><br><span class="line">n2 = rem;</span><br><span class="line">&#125;<span class="comment">//最后n1为最大公约数</span></span><br><span class="line">    <span class="type">int</span> minMultiple = p / n1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="汉诺塔问题"><a href="#汉诺塔问题" class="headerlink" title="汉诺塔问题"></a>汉诺塔问题</h4><p>有三根柱子，有若干圆盘从下面开始按大到小顺序摆在第一根柱子上，将这些圆盘原封不动移到另一根（第三根）柱子上。<br>并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。</p><p><strong>总体思想</strong><br>1.将 n-1个盘子先放到B座位上<br>2.将A座上地剩下的一个盘移动到C盘上<br>3.将n-1个盘从B座移动到C座上<br><strong>或者</strong><br>在1盘的基础上操作2盘，在2盘的基础上操作3盘………在n-1盘的基础上操作n盘</p><p>（1）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x, <span class="type">char</span> y)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">hannuo</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> one ,<span class="type">char</span> two,<span class="type">char</span> three)</span> <span class="comment">//将n个盘从one座借助two转移到three</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">        move(one, three);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        hannuo(n<span class="number">-1</span>,one ,three,two);<span class="comment">//将 n-1个盘子从A借助c放到B座位上</span></span><br><span class="line">        move(one,three);<span class="comment">//将A座上地剩下的一个盘移动到C盘上</span></span><br><span class="line">        hannuo(n<span class="number">-1</span>,two,one,three);<span class="comment">//将n-1个盘借助A从B座移动到C座上</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">char</span> y)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c---&gt;%c\n&quot;</span>,x,y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input your number&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    hannuo(n,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）（上下两段代码一样)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">move</span><span class="params">(<span class="type">char</span> x,<span class="type">int</span> i,<span class="type">char</span> y)</span></span><br><span class="line">    <span class="title function_">printf</span><span class="params">(<span class="string">&quot;move disk %d:%c-&gt;%c\n&quot;</span>,i,x,y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hanoi</span> <span class="params">(<span class="type">int</span> n, <span class="type">char</span> a,<span class="type">char</span> b, <span class="type">char</span> c)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n==<span class="number">1</span>)</span><br><span class="line">     move(a,<span class="number">1</span>,c);      <span class="comment">//将n个盘子从A移动到c</span></span><br><span class="line">  <span class="keyword">else</span>&#123;</span><br><span class="line">       hanoi(n<span class="number">-1</span>,a, c,b);<span class="comment">//将n-1个盘子从A借助C移动到B</span></span><br><span class="line">       move(a, n, c) ;<span class="comment">//将n个盘子从A移动到C</span></span><br><span class="line">       hanoi(n<span class="number">-1</span>,b, a,c) ;<span class="comment">//将n-1个盘子从B借助A移动到C</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3个字符串排序"><a href="#3个字符串排序" class="headerlink" title="3个字符串排序"></a>3个字符串排序</h4><p>输入3个字符串，按由小到大的顺序输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">char</span> *a, <span class="type">char</span> *b)</span>&#123;</span><br><span class="line">    <span class="type">char</span> temp[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(temp, a);</span><br><span class="line">    <span class="built_in">strcpy</span>(a,b);</span><br><span class="line">    <span class="built_in">strcpy</span>(b,temp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> n1[<span class="number">20</span>], n2[<span class="number">20</span>], n3[<span class="number">20</span>];</span><br><span class="line">    gets(n1);</span><br><span class="line">    gets(n2);</span><br><span class="line">    gets(n3);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n2) &gt; <span class="number">0</span>) swap(n1, n2);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n1, n3) &gt; <span class="number">0</span>) swap(n1, n3);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(n2, n3) &gt; <span class="number">0</span>) swap(n2, n3);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s &lt; %s &lt; %s&quot;</span>,n1, n2, n3);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="C一些用法"><a href="#C一些用法" class="headerlink" title="C一些用法"></a>C一些用法</h1><ol><li><pre><code class="c">int *p[3];//定义了一个指针数组p，该数组含有三个元素;//每个元素都是基类型为int的指针<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```c</span><br><span class="line">   char *s=&quot;\ta\017bc&quot;;</span><br><span class="line">   //则指针变量s指向的字符串所占的字节数是?</span><br><span class="line">   //6个，(包括结束符)</span><br><span class="line">   //\t  a  \017  b  c  \0</span><br></pre></td></tr></table></figure></code></pre></li><li><p>同类型的两个指针之间可以减运算，但不能加运算；</p><ul><li>两个相同指针变量相减可以获得在其之间相隔的同类型元素个数（可在某类型的数组中应用）；</li></ul></li><li><pre><code class="c">(j = 3, j++)//表达式的值为3，j为4；<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5. ```c</span><br><span class="line">   #define S(a,b) t=a;a=b;b=t</span><br><span class="line">   //宏就是符号定义，宏扩展时只是字符串替换，</span><br><span class="line">   //虽然变量t没定义，但此宏定义是正确的</span><br></pre></td></tr></table></figure></code></pre></li><li><p>如果函数值的类型和return语句中表达式的值不一致，则以函数类型为准</p></li><li><p>内外函数的两种理解.</p></li></ol><p>   (1)库函数是C语言的内部函数或自带函数,外部函数即程序员自定函数. </p><p>   (2)凡加写了extern 的函数是外部函数；一个函数声明为static或声明在另外一个函数内部，那么这个函数就是内部函数，它的声明在其他文件中不可见。</p><ol start="8"><li><strong>位运算符</strong>的操作数必须为<strong>整数类型</strong>；</li></ol><p>   （位运算符优先级比算数运算符低）</p><table><thead><tr><th>&amp;</th><th>（按位与）都为1，则得到1；有一个0，则得到0</th></tr></thead><tbody><tr><td>|</td><td>（按位或）有一个1，则得到1；都为0，则得到0</td></tr><tr><td>^</td><td>（按位异或）两着值不同，则得到1；值相同，则为0</td></tr><tr><td>~</td><td>（取反）~x：取反（得到x的补码）</td></tr></tbody></table><p>9. </p>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0177</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;x = %3d, x = %6d, x = %6o, x = %6x, x = %6u\n&quot;</span>, x, x, x, x, x);</span><br><span class="line"><span class="comment">//输出结果为:(0117以0开头，表示八进制数，即十进制的127，十六进制的7f)</span></span><br><span class="line"><span class="comment">//x = 127, x =    127, x =    177, x =     7f, x =    127</span></span><br></pre></td></tr></table></figure><ol start="10"><li><pre><code class="c">double a = 513.789215;printf(“a = %8.2f, a = %14.8f, a = %14.8lf\n”, a, a, a);//输出结果：a = 513.79，a = 513.78921500，a = 513.78921500//小数部分不够则补0<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">11. ```c</span><br><span class="line">    int a = 0;</span><br><span class="line">    a += (a = 8);</span><br><span class="line">    //运算后a = 16</span><br></pre></td></tr></table></figure></code></pre></li><li><p>&#96;&#96;&#96;c<br>int a[4],*p &#x3D; a;<br>*p++;<br>*(–p);<br>&#x2F;&#x2F;上述两者都是指针p地址值的改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### C运算符的优先级</span><br><span class="line"></span><br><span class="line">![img](https://pic4.zhimg.com/v2-de212d1860ead5971c56d91194f94fa1_r.jpg?source=1940ef5c)</span><br><span class="line"></span><br><span class="line">#### 四舍五入</span><br><span class="line"></span><br><span class="line">例：对小数点后四舍五入：</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">//a是x四舍五入后的结果</span><br><span class="line">a = (int)(x+0.5)&gt;(int)x?(int)x+1:(int)x;</span><br></pre></td></tr></table></figure></li></ol><h4 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="type">int</span> count1 = <span class="keyword">sizeof</span>(str);</span><br><span class="line"><span class="type">int</span> count2 = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, count2);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment">//sizeof会将\0一起计算，strlen只计算字符串本身长度</span></span><br></pre></td></tr></table></figure><h4 id="1-为类型起别名"><a href="#1-为类型起别名" class="headerlink" title="1.为类型起别名"></a>1.为类型起别名</h4><p>为常用的数据类型起一个别名，这样就实现简单的多态，如需要将int类型改为char时，只需修改定义的别名中的类型即可。</p><h4 id="2-求数中的一个数字"><a href="#2-求数中的一个数字" class="headerlink" title="2.求数中的一个数字"></a>2.求数中的一个数字</h4><p>要求一个数中的个位数字，可使用求模运算，如，149 % 10 &#x3D;  9；</p><h4 id="3-迭代自增用-i"><a href="#3-迭代自增用-i" class="headerlink" title="3.迭代自增用++i"></a>3.迭代自增用++i</h4><p>一般情况下，迭代自增请使用++ i （以减少不必要开销）；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (语句<span class="number">1</span>; 语句<span class="number">2</span>; 语句<span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  被执行的代码块</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>语句 1 在循环（代码块）开始前执行；</p><p>语句 2 定义运行循环（代码块）的条件；</p><p>语句 3 在循环（代码块）已被执行之后执行。</p><ul><li>循环里的 ++i 和 i++的结果是一样的，<strong>都要等代码块执行完毕才能执行</strong>，但是性能是不同的。在大量数据的时候++i的性能要比i++的性能好原因。</li></ul><h4 id="4-uthash"><a href="#4-uthash" class="headerlink" title="4.uthash"></a>4.uthash</h4><p>开源文件&lt;uthash.h&gt;    :    uthash 是C的比较优秀的开源代码，它实现了常见的hash操作函数，例如查找、插入、删除等待。该套开源代码采用宏的方式实现hash函数的相关功能，支持C语言的任意数据结构为key值，甚至可以采用多个值作为key，</p><h4 id="5-qsort"><a href="#5-qsort" class="headerlink" title="5.qsort"></a>5.qsort</h4><p>头文件&lt;stdlib.h&gt;  包含有    <strong>qsort</strong>    函数（即快速排序），用法：</p><p><strong>对int类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *a, <span class="type">const</span> <span class="type">void</span> *b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span> *) a - *(<span class="type">int</span> *) b;  </span><br><span class="line">    <span class="comment">//输入a，b：*(int *) a - *(int *) b为顺序排序，即从小到大排，b - a 则为逆序排序，即从大到小</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[n];</span><br><span class="line">    qsort (arr, n , <span class="keyword">sizeof</span>(<span class="type">int</span>), cmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对char类型：（同上）</p><p>对double类型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cmp</span><span class="params">( <span class="type">const</span> <span class="type">void</span> *a , <span class="type">const</span> <span class="type">void</span> *b )</span> </span><br><span class="line">&#123; </span><br><span class="line"> <span class="keyword">return</span> *(<span class="type">double</span>*)a &gt; *(<span class="type">double</span>*)b;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>对结构体类型以及字符串类型：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;NODE;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp1</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (b-&gt;num - a-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">cmp2</span><span class="params">(<span class="type">const</span> NODE* a, <span class="type">const</span> NODE* b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(a-&gt;word, b-&gt;word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>qsort  ( )  包含：</p><ul><li>arr  :  指向要排序的数组的第一个元素的指针；</li><li>n : 对应数组中元素的个数；</li><li>sizeof ( int ) : 数组中每个的元素的大小，以字节为单位；</li><li>cmp：用来比较两个元素的函数</li></ul><h4 id="6-布尔类型"><a href="#6-布尔类型" class="headerlink" title="6.布尔类型"></a>6.布尔类型</h4><p>C语言中没有布尔类型，要使用true和false，需要导入头文件&lt;stdbool.h&gt;,或使用宏定义或枚举类来设置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用宏定义布尔类型</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bool int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> true 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> false 0</span></span><br><span class="line"><span class="comment">//定义一个布尔变量</span></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以用过枚举来定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span>&#123;</span></span><br><span class="line">    <span class="literal">true</span> = <span class="number">1</span>, falsse = <span class="number">0</span></span><br><span class="line">&#125;<span class="type">bool</span>;</span><br></pre></td></tr></table></figure><h4 id="7-字符串操作"><a href="#7-字符串操作" class="headerlink" title="7.字符串操作"></a>7.字符串操作</h4><p>C中的有关字符串操作的函数：</p><ul><li>需要头文件&lt;string.h&gt;</li></ul><table><thead><tr><th align="left">序号</th><th align="left">函数 &amp; 目的</th></tr></thead><tbody><tr><td align="left">1</td><td align="left"><strong>strcpy(s1, s2);</strong> 复制字符串 s2 到字符串 s1。</td></tr><tr><td align="left">2</td><td align="left"><strong>strcat(s1, s2);</strong> 连接字符串 s2 到字符串 s1 的末尾。</td></tr><tr><td align="left">3</td><td align="left"><strong>strlen(s1);</strong> 返回字符串 s1 的长度。</td></tr><tr><td align="left">4</td><td align="left"><strong>strcmp(s1, s2);</strong> 如果 s1 和 s2 是相同的，则返回 0；如果 s1&lt;s2 则返回小于 0；如果 s1&gt;s2 则返回大于 0。</td></tr><tr><td align="left">5</td><td align="left"><strong>strchr(s1, ch);</strong> 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。</td></tr><tr><td align="left">6</td><td align="left"><strong>strstr(s1, s2);</strong> 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。</td></tr></tbody></table><h4 id="8-动态分配"><a href="#8-动态分配" class="headerlink" title="8.动态分配"></a>8.动态分配</h4><ul><li>malloc用法，如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br></pre></td></tr></table></figure><ul><li>calloc用法，如：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">20</span>,<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>malloc申请后空间的值是随机的，并没有进行初始化，而calloc却在申请后，对空间逐一进行初始化，并设置值为0;  关于效率问题，calloc函数由于给每一个空间都要初始化值，那必然效率较malloc要低，并且现实世界，很多情况的空间申请是不需要初始值的，这也就是为什么许多初学者更多的接触malloc函数的原因。</p><ul><li>realloc用于对动态内存进行扩容（即已申请的动态空间不够用，需进行空间扩容操作），如:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*<span class="number">20</span>);</span><br><span class="line"><span class="type">int</span> *pp = (<span class="type">int</span>*)<span class="built_in">realloc</span>(p, size*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br></pre></td></tr></table></figure><p>（逗号前的p是指向原来空间的指针，逗号后是需要扩容的大小）</p><h4 id="9-amp-amp-和switch注意"><a href="#9-amp-amp-和switch注意" class="headerlink" title="9.&amp;&amp;和switch注意"></a>9.&amp;&amp;和switch注意</h4><ul><li><p>（…)&amp;&amp;(…)     如果前面的语句为0，则后面的语句不执行</p></li><li><p>switch中的case后不带break的话，会一直往后执行，直到遇到break；default写在中间，也会一直往后执行语句，直到遇到break或switch结束。</p></li></ul><h4 id="10-斐波那契数通项公式："><a href="#10-斐波那契数通项公式：" class="headerlink" title="10.斐波那契数通项公式："></a>10.斐波那契数通项公式：</h4><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191708728.png" alt="image-20210407141717675"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">double</span> sqrt5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> fibN = <span class="built_in">pow</span>((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">pow</span>((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> round(fibN / sqrt5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-math-h"><a href="#11-math-h" class="headerlink" title="11.math.h"></a>11.math.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">    <span class="comment">//返回x的自然对数（基数为e的对数）</span></span><br><span class="line">如：<span class="title function_">log</span><span class="params">(<span class="number">2.700000</span>)</span> = <span class="number">0.993252</span>    </span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">log10</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">    <span class="comment">//返回x的常用对数（基数为10的对数）</span></span><br><span class="line">如：<span class="title function_">log10</span><span class="params">(<span class="number">10000.000000</span>)</span> = <span class="number">4.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="title function_">modf</span><span class="params">(<span class="type">double</span> x,<span class="type">double</span> *integer)</span></span><br><span class="line">    <span class="comment">//返回值为小数部分，并设置interger为整数部分</span></span><br><span class="line">如：x = <span class="number">8.123456</span>;</span><br><span class="line">   fractpart = <span class="built_in">modf</span>(x, &amp;intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;整数部分 = %lf\n&quot;</span>, intpart);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;小数部分 = %lf \n&quot;</span>, fractpart);</span><br><span class="line">结果为：整数部分 = <span class="number">8.000000</span></span><br><span class="line">   小数部分 = <span class="number">0.123456</span> </span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">pow</span>(<span class="type">double</span> x,<span class="type">double</span> y)</span><br><span class="line">    <span class="comment">//返回x的y次幂</span></span><br><span class="line">如：<span class="built_in">pow</span>(<span class="number">8.0</span>, <span class="number">3</span>) </span><br><span class="line">   值 <span class="number">8.0</span> ^ <span class="number">3</span> = <span class="number">512.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">sqrt</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的平方根</span></span><br><span class="line">如：<span class="built_in">sqrt</span>(<span class="number">4.0</span>)</span><br><span class="line">    值<span class="number">4.000000</span> 的平方根是 <span class="number">2.000000</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">fabs</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回x的绝对值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">ceil</span>(<span class="type">double</span> x)    </span><br><span class="line">    <span class="comment">//返回大于或等于x的最小整数值</span></span><br><span class="line">    </span><br><span class="line"><span class="type">double</span> <span class="built_in">floor</span>(<span class="type">double</span> x)</span><br><span class="line">    <span class="comment">//返回小于或等于x的最大整数值</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="built_in">fmod</span>(<span class="type">double</span> x,<span class="type">double</span> y)</span><br><span class="line">    <span class="comment">//返回x除以y的余数</span></span><br></pre></td></tr></table></figure><h4 id="12-负数补码，二-x2F-十-x2F-八进制转化"><a href="#12-负数补码，二-x2F-十-x2F-八进制转化" class="headerlink" title="12.负数补码，二&#x2F;十&#x2F;八进制转化"></a>12.负数补码，二&#x2F;十&#x2F;八进制转化</h4><p>补码来表示和存储。反码多应用于系统环境设置。</p><p>1、补码：在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。此外，补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。</p><p>2、反码：反码是数值存储的一种，但是由于补码更能有效表现数字在计算机中的形式，所以多数计算机一般都不采用反码表示数。</p><p>比如（7）+（-7）&#x3D;0</p><p>7 -&gt; 0000 0111（7的补码）</p><p>-7 -&gt; 1111 1001（-7的补码）</p><p>所以相加为1 0000 0000（超出的最高位默认去掉）</p><p>比如（2）+（-3）&#x3D;（-1）</p><p>2  -&gt; 0000 0010 （2的补码）</p><p>-3 -&gt; 1111 1101 （-3的补码）</p><p>相加为 1111 1111（-1的补码）</p><ul><li><p>1.<strong>负数的补码是在原码的基础上除符号位外其余位取反后+1</strong></p><p>例如：-8的原码为 1000 1000，通过原码求出它的反码，负数的反码就是 除符号为以外，其余的全部求反，-8 的反码为 1111 0111，其反码码 +1，就是它的补码， -8 的补码为 1111 1000</p><p><strong>或者</strong>：</p><p>2.<strong>先求出负数的绝对值的二进制，然后从右到左遍历，遇到第一个1时，将其左侧全部取反，右侧和它本身不变。</strong></p><p><strong>例如01100100 -&gt; 10011100</strong></p></li><li><p>十进制转二进制，如果十进制数是负数则取其反码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">15</span>], flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">0</span>) flag = <span class="number">1</span>, x = -x;    <span class="comment">//这里使用了上述第二种取补码方式   </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i) &#123;</span><br><span class="line">        arr[i] = x % <span class="number">2</span>;<span class="comment">//这里数组存储二进制数的1和0的顺序与其本身相反</span></span><br><span class="line">        x /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="comment">// 负数 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; ++i)        </span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="number">1</span> &amp;&amp; i &lt; <span class="number">7</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= <span class="number">7</span>; ++j)</span><br><span class="line">                    arr[j] = <span class="number">1</span> - arr[j];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; --i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="title function_">convertDecimalToBinary</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> binaryNumber = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> remainder, i = <span class="number">1</span>, step = <span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Step %d: %d/2, 余数 = %d, 商 = %d\n&quot;</span>, step++, n, remainder, n/<span class="number">2</span>);</span><br><span class="line">        n /= <span class="number">2</span>;</span><br><span class="line">        binaryNumber += remainder*i;</span><br><span class="line">        i *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> binaryNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二进制转十进制</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入的n由1和0构成，以表示二进制数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">convertBinaryToDecimal</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> decimalNumber = <span class="number">0</span>, i = <span class="number">0</span>, remainder;</span><br><span class="line">    <span class="keyword">while</span> (n!=<span class="number">0</span>)&#123;</span><br><span class="line">        remainder = n%<span class="number">10</span>;</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">        decimalNumber += remainder*<span class="built_in">pow</span>(<span class="number">2</span>,i);</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decimalNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="输入常见问题"><a href="#输入常见问题" class="headerlink" title="输入常见问题"></a>输入常见问题</h4><h6 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a>scanf</h6><p>1、scanf的返回值</p><p>scanf通常返回的是成功赋值(从标准输入设备赋值到参数列表所指定的内存区域)的数据项数，如果出错或是遇到end of file，则返回EOF，比如：</p><p>scanf(“%d%d”, &amp;x, &amp;y);</p><p> scanf函数仅在每一个数据域均有数据，并按回车后结束</p><p>如果x和y都被成功读入，那么scanf的返回值就是2;<br>如果只有x被成功读入，返回值为1;<br>如果x和y都未被成功读入，返回值为0;<br>如果遇到错误或遇到end of file，返回值为EOF</p><p>2、scanf的处理机制</p><p>scanf以删除的方式从缓冲区读入数据(来自标准输入设备的数据存储在缓冲区)，也就是说，scanf从缓冲区读入一个数据项，该数据项在缓冲区中就被清除掉了。而如果scanf需要读取一个数据项，发现缓冲区当前是空的，那么程序就会在scanf代码处阻塞，等待用户输入，scanf函数接收到相应的数据项之后，在缓冲区中将这一数据项清除，scanf函数返回，程序继续执行。</p><p>3、scanf对不同类型输入的处理方式</p><p>首先，要明确一个概念：空白字符(white space)。一般，程序中所指的空白字符是指空格(space)，回车(enter)和指标符(table)。</p><p>3.1 整数%d</p><p>对于整型数据的输入，也就是说”%d”类型的输入，scanf默认的分割符是所有的空白字符(空格，回车和指标符都行)。也就是说如果一个scanf函数中出现scanf(“%d%d”,&amp;a,&amp;b)，那么用任何一个空白字符来分隔两个整数a,b的值，变量a,b都可以接收到正确的输入。另外，要注意的是，scanf对于数字输入，会忽略输入数据项前面的空白字符。</p><p>3.2 字符串%s<br>scanf对于字符串输入的处理和对整数类似，会忽略前导的空白字符，而且默认的分隔符是所有的空白字符。但是，要注意的是，由于C语言中，没有string类型，都是用char型数组来表示。因此，scanf会为每一个输入的字符串最后加一个‘\0’。</p><p>因此，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 “this is test” 对 scanf() 来说是三个字符串。</p><p>3.3 字符%c</p><p>scanf在处理对字符数据的输入时，既不会忽略前导空白字符，默认也没有任何分隔字符。所有的字符，包括空白字符都会被当成输入字符。对此可以使用 getchar(char类型变量) ，来只读取一个字符。</p><p>1 2 4 8 16 32 64 128 256</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
