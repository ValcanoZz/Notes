<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>汇编语言 | ValcanoZz Blog</title><meta name="keywords" content="基础"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="一、访问寄存器和内存前提：此汇编语言学习以 Intel 8086 CPU作为示例。  1 寄存器和数据存储寄存器是CPU内部的信息存储单元。 一个n位寄存器能存储一个n位的数据，通用寄存器常用X表示； 有时为了向下兼容，会把寄存器分为高低位，如AX 分为 AH,  AL； AH表示AX的高位，AL表示AX的低位 （当AL中的数值大于AL所能表示的范围，AL会丢弃溢出位，而不会将溢出位加到AH上）">
<meta property="og:type" content="article">
<meta property="og:title" content="汇编语言">
<meta property="og:url" content="http://example.com/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="一、访问寄存器和内存前提：此汇编语言学习以 Intel 8086 CPU作为示例。  1 寄存器和数据存储寄存器是CPU内部的信息存储单元。 一个n位寄存器能存储一个n位的数据，通用寄存器常用X表示； 有时为了向下兼容，会把寄存器分为高低位，如AX 分为 AH,  AL； AH表示AX的高位，AL表示AX的低位 （当AL中的数值大于AL所能表示的范围，AL会丢弃溢出位，而不会将溢出位加到AH上）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151557250.jpeg">
<meta property="article:published_time" content="2022-04-14T06:55:35.260Z">
<meta property="article:modified_time" content="2022-05-21T03:46:30.503Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151557250.jpeg"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '汇编语言',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-21 11:46:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">27</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151557250.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">汇编语言</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-14T06:55:35.260Z" title="发表于 2022-04-14 14:55:35">2022-04-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-21T03:46:30.503Z" title="更新于 2022-05-21 11:46:30">2022-05-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/Notes/categories/%E5%9F%BA%E7%A1%80/">基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="汇编语言"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="一、访问寄存器和内存"><a href="#一、访问寄存器和内存" class="headerlink" title="一、访问寄存器和内存"></a>一、访问寄存器和内存</h1><p>前提：此汇编语言学习以 Intel 8086 CPU作为示例。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726634.png" alt="image-20211120210722555"></p>
<h2 id="1-寄存器和数据存储"><a href="#1-寄存器和数据存储" class="headerlink" title="1 寄存器和数据存储"></a>1 寄存器和数据存储</h2><p>寄存器是CPU内部的信息存储单元。</p>
<p>一个n位寄存器能存储一个n位的数据，通用寄存器常用X表示；</p>
<p>有时为了向下兼容，会把寄存器<strong>分为高低位</strong>，<strong>如AX 分为 AH,  AL</strong>； <strong>AH表示AX的高位，AL表示AX的低位</strong></p>
<p>（当AL中的数值大于AL所能表示的范围，AL会丢弃溢出位，而<strong>不会将溢出位加到AH上</strong>）</p>
<p>8086CPU有14个寄存器</p>
<p>通用寄存器：AX，BX，CX，DX（累加，基地址，计数，数据）</p>
<p>变址寄存器：SI，DI （源，目标）</p>
<p>指针寄存器：SP，BP（栈顶，基）</p>
<p>指令指针寄存器：IP</p>
<p>段寄存器：CS，SS，DS，ES（代码，数据，栈，附加）</p>
<p>标志寄存器：PSW</p>
<h2 id="2-mov和add指令"><a href="#2-mov和add指令" class="headerlink" title="2 mov和add指令"></a>2 mov和add指令</h2><p>示例：</p>
<blockquote>
<p>mov ax 18	-	将18放入寄存器AX中</p>
<p>add ax 8	   -	将寄存器AX中的值加上8</p>
<p>mov ax bx	-	 将BX中的值放入寄存器AX中</p>
<p>add ax bx 	-	 将AX，BX中的值相加，结果放入AX中</p>
</blockquote>
<h2 id="3-确定物理地址的方法"><a href="#3-确定物理地址的方法" class="headerlink" title="3 确定物理地址的方法"></a>3 确定物理地址的方法</h2><p>物理地址：唯一表示每个内存单元在存储体中的地址。</p>
<p>CPU访问内存单元时要给出内存单元的地址，而所有的内存单元构成的存储空间是一个一维的线性空间。</p>
<p>问题：8086有<strong>20位地址总线，可传送20位地址，寻址能力有1M</strong>；但8086是<strong>16位结构的CPU，其所能处理的地址只有16位，即寻址能力只有64KB</strong>，这就与20位地址总线的1M寻址能力产生矛盾，如何解决？</p>
<p>解决方法：使用 <strong>地址加法器</strong> 可以<strong>将两个16位地址（段地址和偏移地址 ）合成为一个20位的物理地址。</strong></p>
<p><strong>物理地址 &#x3D; 段地址 * 16 + 偏移地址</strong></p>
<p>（乘16 是将段地址左移4位，同一个物理地址可以用不同的段地址和偏移地址表示）</p>
<p>然后 地址加法器 会通过内部总线将这20位物理地址送到 输入输出控制电路，再传到地址总线。</p>
<h2 id="4-内存的分段表示法"><a href="#4-内存的分段表示法" class="headerlink" title="4 内存的分段表示法"></a>4 内存的分段表示法</h2><p>内存中并没有分段，<strong>段的划分是由CPU进行的。</strong></p>
<p>对8086来看：</p>
<ol>
<li>段地址 * 16 必然是16的倍数，所以一个段的起始地址也一定是16的倍数；</li>
<li>偏移地址为16位，16位地址的寻址能力为64k，所以一个段的长度为64k；</li>
</ol>
<p>段地址很重要，有专门的寄存器存放段地址：</p>
<p><strong>CS：代码段寄存器</strong></p>
<p><strong>DS：数据段寄存器</strong></p>
<p><strong>SS：栈段寄存器</strong></p>
<p><strong>ES：附加段寄存器</strong></p>
<h2 id="5-Debug的使用"><a href="#5-Debug的使用" class="headerlink" title="5 Debug的使用"></a>5 Debug的使用</h2><p><strong>-R</strong>：查看寄存器内容；</p>
<p><strong>-R 寄存器名 ：内容</strong>：改变CPU寄存器的内容；</p>
<p><strong>-D</strong>：查看预设地址内存处的128个字节的内容；</p>
<p><strong>-D 段地址 : 偏移地址</strong> ：列出内存中指定地址处的内容；</p>
<p><strong>-D 段地址 : 偏移地址  地址范围</strong>  ：列出内存中指定地址范围内的内容</p>
<p>**-E 段地址 : 偏移地址 数据1 数据2 …….**： 改变指定地址内存中的内容</p>
<p><strong>-E 段地址 : 偏移地址</strong> ：逐个询问式修改内容，使用空格表示接收，回车表示结束</p>
<p><strong>-U 段地址 : 偏移地址</strong>：查看数据，可以将内存中的机器指令翻译成汇编指令显示出来</p>
<p><strong>-A 段地址 : 偏移地址</strong> ：以汇编指令的格式在内存中写入机器指令</p>
<p><strong>-T</strong> ：逐条执行机器指令，从 CS : IP处开始</p>
<p><strong>-P</strong> ：类似于T命令，逐条执行指令，显示结果，但遇到子程序，中断等时，会直接执行，然后显示结果。</p>
<p><strong>-G</strong>：从地址开始处运行命令，直到遇到断点或程序正常结束。</p>
<p>。。。</p>
<h2 id="6-CS、IP与代码段"><a href="#6-CS、IP与代码段" class="headerlink" title="6 CS、IP与代码段"></a>6 CS、IP与代码段</h2><p>CS：代码段寄存器； <strong>IP：指令指针寄存器</strong></p>
<p><strong>CS : IP  —  CPU将内存中CS : IP 指向的内容当作指令执行。</strong></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726636.png" alt="image-20211120211501383"></p>
<blockquote>
<p>内存中的数据， 应该用作一般数据，还是指令？</p>
<p>答：CPU会将CS:IP指向的内存单元中的内容看作指令（CPU根据指令周期的不同阶段，可以知道取出的是指令还是数据）</p>
</blockquote>
<h2 id="7-jmp指令"><a href="#7-jmp指令" class="headerlink" title="7 jmp指令"></a>7 jmp指令</h2><p><strong>CS:IP的内容</strong>不能通过mov修改，可以在Debug中用R命令修改（调试手段），而程序手段是可以<strong>用jmp指令进行跳转</strong>：</p>
<ul>
<li><p>同时修改CS : IP 的内容： <strong>jmp 段地址 : 偏移地址</strong>（根据给出的段地址修改CS，偏移地址修改IP）</p>
</li>
<li><p>仅修改IP的内容： <strong>jmp 某一合法寄存器</strong>，如 jmp ax，jmp bx</p>
</li>
</ul>
<h2 id="8-内存中字的存储"><a href="#8-内存中字的存储" class="headerlink" title="8 内存中字的存储"></a>8 内存中字的存储</h2><p>（对8086CPU，16位作为一个字 ）</p>
<p>字单元：由两个地址连续的内存单元组成，存放一个字型数据(16位)。</p>
<blockquote>
<p>在一个字单元中，低地址单元 存放 低位字节，高地址单元 存放 高位字节。</p>
</blockquote>
<h2 id="9-用DS和-address-实现字的传送"><a href="#9-用DS和-address-实现字的传送" class="headerlink" title="9 用DS和[address] 实现字的传送"></a>9 用DS和[address] 实现字的传送</h2><p>CPU要读取一个内存单元的时候，必须先知道这个内存单元的地址：</p>
<p>解决：DS 和 [address] 配合，DS寄存器存放要访问的数据的段地址，偏移地址用[…]形式直接给出。</p>
<blockquote>
<p>注：8086CPU不支持将数据直接送入段寄存器（硬件设计的问题），所以需要<strong>先将数据放入通用寄存器，再放入段寄存器</strong>：</p>
<p>mov bx 1000H</p>
<p>mov ds  bx </p>
</blockquote>
<p>字的传送：</p>
<p>8086CPU可以一次性传送一个字（16位的数据），例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx 1000H</span><br><span class="line">mov ds bx</span><br><span class="line">mov ax [0] ;1000:0处的字型数据送入ax</span><br><span class="line">mov [0] cx ;cx中的16位数据送入1000:0处</span><br></pre></td></tr></table></figure>



<h2 id="10-DS与数据段"><a href="#10-DS与数据段" class="headerlink" title="10 DS与数据段"></a>10 DS与数据段</h2><p>对于8086 PC机，可以根据需要将一组内存单元定义为一个段。将一组长度为N (N&lt;64K)、地址连续、起始地址为16的倍数的内存单元当作专门	存储数据的内存空间，从而定义了一个数据段。</p>
<p><strong>DS : [address] —— 用DS存放数据段的段地址，用相关指令访问数据段中的具体单元，单元地址由[address]指出</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#累加数据段中的前 3个单元的数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov al, 0</span><br><span class="line">add al,[0]</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br><span class="line">#累加数据段中的前3个 字型数据</span><br><span class="line">mov ax, 1238H</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ax, 0</span><br><span class="line">add ax,[0]</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4]</span><br></pre></td></tr></table></figure>



<h2 id="11-栈及栈操作的实现"><a href="#11-栈及栈操作的实现" class="headerlink" title="11 栈及栈操作的实现"></a>11 栈及栈操作的实现</h2><p>栈：只能在一端进行插入或删除操作的数据结构</p>
<p>栈的操作规则：LIFO（Last In First Out，后进先出）</p>
<p>CPU提供的栈机制：可以将一段内存当作栈来使用，支持用栈的方式访问内存空间。（对于栈溢出的问题，8086CPU不会检查是否越界，需要程序员自己预防栈溢出）</p>
<p>在8086CPU中，有两个与栈相关的寄存器：</p>
<ul>
<li><strong>栈段寄存器SS</strong>  ： 存放栈顶的段地址</li>
<li><strong>栈顶指针寄存器SP</strong>： 存放栈顶的偏移地址</li>
<li>任意时刻，<strong>SS:SP指向栈顶元素</strong></li>
</ul>
<p>PUSH（入栈）和POP（出栈）指令：</p>
<p><strong>push ax：将ax中的数据送入栈中（以字为单位对栈进行操作）</strong></p>
<ul>
<li>(1)SP&#x3D;SP-2；<br>(2)将ax中的内容送入SS : SP指向的内存单元处，SS : SP此时指向新栈顶。</li>
</ul>
<p><strong>pop ax：从栈顶取出数据 放到ax（以字为单位对栈进行操作）</strong></p>
<ul>
<li>(1)将 SS : SP指向的内存单元处的数据送入ax中；<br>(2)SP&#x3D;SP+2，SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新的栈顶。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax		#确定栈顶位置</span><br><span class="line">mov sp 0010H	#确定栈底位置/栈空间大小</span><br><span class="line"></span><br><span class="line">mov ax,001AH	</span><br><span class="line">mov bx,001BH</span><br><span class="line"></span><br><span class="line">push ax		#存入位置从栈底开始</span><br><span class="line">push bx		#bx的值最后放入</span><br><span class="line">pop ax		#取出栈顶的值原来是bx的，现在把它放到ax中</span><br><span class="line">pop bx  #经过入栈出栈操作后，ax和bx中的值发生了交换</span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726637.png" alt="image-20211121093822410"></p>
<h1 id="二、汇编语言程序"><a href="#二、汇编语言程序" class="headerlink" title="二、汇编语言程序"></a>二、汇编语言程序</h1><h2 id="1-汇编语言写的源程序"><a href="#1-汇编语言写的源程序" class="headerlink" title="1 汇编语言写的源程序"></a>1 汇编语言写的源程序</h2><p>汇编程序：包含汇编指令和伪指令的文本</p>
<ul>
<li><p><strong>伪指令</strong>：没有对应的机器码，最终是不会被CPU所执行；伪指令是由编译器来执行的，编译器根据伪指令来执行相关的编译工作。</p>
</li>
<li><p><strong>汇编指令</strong>：对应有机器码的指令，可以被编译为机器指令，最终被CPU执行。</p>
</li>
</ul>
<p>过程：汇编程序——编译器编译——机器码——计算机运行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg	#伪指令</span><br><span class="line">codesg segment		#伪指令</span><br><span class="line">	mov ax,0123H	#汇编指令</span><br><span class="line">	mov bx,0456H</span><br><span class="line">	add ax,bx</span><br><span class="line">	add ax,ax</span><br><span class="line">	</span><br><span class="line">	#下面两句，用于程序返回(套路):程序结束运行后，将CPU控制器交还给调用自己的那个程序(常为DOS系统)。</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h		#汇编指令</span><br><span class="line">codesg ends		#伪指令</span><br><span class="line">end			#伪指令</span><br></pre></td></tr></table></figure>

<hr>
<p>程序中的三种伪指令</p>
<ul>
<li><p><strong>段定义</strong></p>
<p>一个汇编程序是由多个段组成的，这些段被用来存放代码，数据或当作栈空间来使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#定义程序中的段：每个段都需要有段名</span><br><span class="line">段名 segment 		#段的开始</span><br><span class="line">	...</span><br><span class="line">段名 ends			#段的结束</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>end</strong> (不是ends)</p>
<p>汇编程序的结束标记。若程序结尾处不加end，编译器在编译程序时，不知道程序在何处结束。</p>
</li>
<li><p><strong>assume</strong> (假设)</p>
<p>让某一个 段寄存器 和程序中的某一个  用segment…ends定义的段 相关联</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#使CS寄存器与codesg关联，将定义的codesg当作程序的代码段使用</span><br><span class="line">assume cs:codesg</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-由源程序到程序运行"><a href="#2-由源程序到程序运行" class="headerlink" title="2 由源程序到程序运行"></a>2 由源程序到程序运行</h2><p>源文件 ( .asm) ——编译——&gt; 目标文件( .obj ) ——连接——&gt; 可执行文件( .exe )</p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译命令：masm + 汇编文件名</p>
<p>编译过程产生的文件：</p>
<ul>
<li><p>目标文件（*.OBJ）**是对一个源程序进行编译后得到的最终结果；</p>
</li>
<li><p>列表文件（*.LST）是编译过程中产生的中间结果；</p>
</li>
<li><p>交叉引用文件（*.CRF）同样是编译过程产生的中间结果；</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726638.png" alt="image-20211121114115020"></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>连接命令：link + 文件名</p>
<p>连接过程产生的文件：</p>
<ul>
<li>**可执行文件(EXE)**是我们对一个程序进行连接要得到的最终结果。</li>
<li>映像文件(MAP)是连接程序将目标文件连接为可执行文件过程中产生的中间结果。</li>
<li>库文件( .LIB) 里包含了ー些可以调用的子程序，如果我们的程序中调用了某一个库文件中的子程序，就需要在连接的时候，将这个库文件和我们的目标文件连接到一起，生成可执行文件。</li>
<li>如果出现no stack segment，是一个“没有栈段”的警告错误，可以不理会这个错误。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726639.png" alt="image-20211121115724936"></p>
<h2 id="3-用Debug跟踪程序执行"><a href="#3-用Debug跟踪程序执行" class="headerlink" title="3 用Debug跟踪程序执行"></a>3 用Debug跟踪程序执行</h2><p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726640.png" alt="image-20211121144425453"></p>
<h2 id="4-…-和-…"><a href="#4-…-和-…" class="headerlink" title="4 […] 和 (…)"></a>4 […] 和 (…)</h2><p><strong>[…]  ——表示一个内存单元（汇编语法规定）</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>段地址</th>
<th>偏移地址</th>
<th>操作单位</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax，[0]</td>
<td>在DS中</td>
<td>在[0]中</td>
<td>字</td>
</tr>
<tr>
<td>mov al，[0]</td>
<td>在DS中</td>
<td>在[0]中</td>
<td>字节</td>
</tr>
<tr>
<td>mov ax，[bx]</td>
<td>在DS中</td>
<td>在[bx]中</td>
<td>字</td>
</tr>
<tr>
<td>mov al，[bx]</td>
<td>在DS中</td>
<td>在[bx]中</td>
<td>字节</td>
</tr>
</tbody></table>
<p><strong>(…) ——表示一个内存单元或寄存器中的内容（为学习交流方便做出的约定）</strong></p>
<table>
<thead>
<tr>
<th>描述对象</th>
<th>描述方法</th>
<th>描述对象</th>
<th>描述方法</th>
</tr>
</thead>
<tbody><tr>
<td>ax中的内容为0010H</td>
<td>(ax)&#x3D;0010H</td>
<td>2000: 1000处的内容为0010H</td>
<td>(21000H)&#x3D;0010H【20位地址描述只能用于寄存器和物理地址】</td>
</tr>
<tr>
<td>mov ax，[2]</td>
<td>(ax)&#x3D;((ds)*16+2)</td>
<td>mov [2], ax</td>
<td>((ds)*16+2)&#x3D;(ax)</td>
</tr>
<tr>
<td>add as，2</td>
<td>(ax)&#x3D;(ax)+2</td>
<td>add ax, bx</td>
<td>(ax)&#x3D;(ax)+(bx)</td>
</tr>
<tr>
<td>push ax</td>
<td>(sp)&#x3D;sp-2;   ((ss)*16+sp)&#x3D;(ax)</td>
<td>pop ax</td>
<td>(ax)&#x3D;((ss)*16+(sp))；                                    (sp)&#x3D;(sp)+2</td>
</tr>
</tbody></table>
<p>再约定：符号idata表示常量</p>
<p>例：mov ax，[idata] ——代表mov ax, [1]、 mov ax, [1] 等等</p>
<h2 id="5-Loop指令"><a href="#5-Loop指令" class="headerlink" title="5 Loop指令"></a>5 Loop指令</h2><p>Loop指令实现计数型循环，格式：<strong>loop 标号</strong></p>
<p>CPU执行loop指令时要进行的操作：</p>
<ul>
<li>(cx)&#x3D;(cx) - 1；</li>
<li>判断cx中的值，不为0则转至标号处执行程序，为0则向下执行</li>
</ul>
<p>注：要先<strong>定义一个标号，即指定循环开始的地方</strong>；<strong>cx中要提前存放循环次数</strong>，因为(cx) 影响loop指令的执行结果；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	mov cx,11		#</span><br><span class="line">	s:</span><br><span class="line">	add ax,ax 		#</span><br><span class="line">	loop s			#</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="6-Loop指令使用例子"><a href="#6-Loop指令使用例子" class="headerlink" title="6 Loop指令使用例子"></a>6 Loop指令使用例子</h2><p>计算ffff:0000字节单元中的数乘以3，结果存储到dx中。（取出的是字节，而结果要作为字放进dx中）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#先将内存中数据取出，连加上次，即乘以3</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh	#汇编程序中，数据不能以字母开头，所以要在ffff前加0</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov bx,6</span><br><span class="line">	mov al,[bx]		#</span><br><span class="line">	mov ah,0		#这两步相当于(ax)=((ds)*16+(bx))</span><br><span class="line">	</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov cx,3	#设置循环次数</span><br><span class="line">	s:</span><br><span class="line">	add dx,ax		#结果放在dx中</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>计算ffff:0 ~ ffff:b <strong>单元</strong>中的数据的和，结果存放在<strong>dx</strong>中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov dx,0</span><br><span class="line">	mov cx,12</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	mov ah,0</span><br><span class="line">	add dx,ax</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4x00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>





<h2 id="7-段前缀的使用"><a href="#7-段前缀的使用" class="headerlink" title="7 段前缀的使用"></a>7 段前缀的使用</h2><p>在程序中，如果使用 mov al，[0] 意思应该是将DS:0存储单元的值传给al，但实际编译后，会变成mov al，0，即把常量0放到al里。为了避免这种情况，可以在 […] 前加上段前缀</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov al [0]   	#同mov al, 0</span><br><span class="line">mov al ds:[0]	#同(al)=((ds)*16+0)</span><br></pre></td></tr></table></figure>

<p>例题：</p>
<p>将内存 ffff:0 ~ ffff:b 中的数据拷贝到 0:200 ~ 0:20b 单元中中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,0ffffh	</span><br><span class="line">	mov ds,ax	</span><br><span class="line">	mov ax,0020h</span><br><span class="line">	mov es,ax	#额外用一个寄存器放目标地址</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#初始偏移</span><br><span class="line">	mov cx,12	#循环次数</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">  	mov dl,[bx]	#默认的[bx]是ds:[bx]</span><br><span class="line">	mov es:[bx],dl	#将ds:[bx]的值拷贝到es:[bx]中去</span><br><span class="line">	inc bx		#bx自增1</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>



<h2 id="8-在代码段中使用数据"><a href="#8-在代码段中使用数据" class="headerlink" title="8 在代码段中使用数据"></a>8 在代码段中使用数据</h2><p>一般的，在程序中直接写地址是很危险的，因为可能会把数据写入到不该写的地方。</p>
<p>对策：可以在程序的段中存放数据，运行时有操作系统分配空间；（段的类别：数据段，代码段，栈段）</p>
<p>程序的一般框架：</p>
<p>当代码段前部 放的是数据而不是执行代码，应该用标号 表明代码开始的地方，不然编译器会把数据部分也当作执行代码来编译，从而造成错误。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	...</span><br><span class="line">	数据</span><br><span class="line">	...</span><br><span class="line">	start:		#定义一个标号，指示代码开始的位置</span><br><span class="line">	...</span><br><span class="line">	代码</span><br><span class="line">	...</span><br><span class="line">code ends</span><br><span class="line">end start	#end的作用：除了通知编译器程序结束外，还可以通知编译器 程序的入口在什么地方</span><br></pre></td></tr></table></figure>

<p>例题：编程计算以下8个数据的和，结果存在ax寄存器中<br>0123h，0456h，0789h，0abch，odefh，0fedh，0cbah，0987h</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	#dw：define work，定义字型数据(2字节); db定义一个字节; dd定义一个双字(4字节)</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,odefh,0fedh,0cbah,0987h	#在代码段中定义数据	</span><br><span class="line">	start:			</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	</span><br><span class="line">	s:</span><br><span class="line">	add ax,cs:[bx]	#代码段定义的数据是放在和该关联的寄存器中的，这里是cs</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="9-在代码段中使用栈"><a href="#9-在代码段中使用栈" class="headerlink" title="9 在代码段中使用栈"></a>9 在代码段中使用栈</h2><p>例题：将给定的数据逆序存放（使用栈，数据依次入栈，再依次出栈的数据就是逆序的了）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,098ZH		#给定的数据</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0		#留给栈的空余空间</span><br><span class="line">	</span><br><span class="line">	start:</span><br><span class="line">	mov ax,cs	</span><br><span class="line">	mov ss,ax		#确定栈顶位置</span><br><span class="line">	mov sp,30h		#确定栈空间大小</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	push cs:[bx]	#将cs:[bx]处的数据入栈</span><br><span class="line">	add bx,2		#数据是一个字，所以+2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s0:</span><br><span class="line">	pop cs:[bx]		#将栈中数据依次sh</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>





<h2 id="10-将数据、代码、栈放入不同段"><a href="#10-将数据、代码、栈放入不同段" class="headerlink" title="10 将数据、代码、栈放入不同段"></a>10 将数据、代码、栈放入不同段</h2><p>为了不让程序显得混乱，可以将数据，栈，代码放在不同的段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#将代码，数据，栈放入不同段</span><br><span class="line">assume cs:code,ds:data,ss:ctack</span><br><span class="line"></span><br><span class="line">data segment	#数据段</span><br><span class="line">	dw 0123H0456H,0789H, 0abch, 0defh, 0fedh0cbah, 0987H</span><br><span class="line">deta ends</span><br><span class="line"></span><br><span class="line">stack segment	#栈段</span><br><span class="line">	dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment	#代码段</span><br><span class="line">start:</span><br><span class="line">	mov ax,stack	#初始化各段寄存器</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,20h</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#入栈</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	push [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,0	#出栈</span><br><span class="line">	mov cx,8</span><br><span class="line">	s0:</span><br><span class="line">	pop [bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h1 id="三、内存寻址方式"><a href="#三、内存寻址方式" class="headerlink" title="三、内存寻址方式"></a>三、内存寻址方式</h1><h2 id="1-处理字符问题"><a href="#1-处理字符问题" class="headerlink" title="1 处理字符问题"></a>1 处理字符问题</h2><p>用 ‘ ’ 表明字符，</p>
<p>小写字母的ASCII码值比大写字母的ASCII码值大20H；所以：大写+20H &#x3D;&#x3D; 小写，小写-20H &#x3D;&#x3D; 大写 </p>
<p>问：大小写转换问题，将第一个字符串的小写字母转换为大写字母，将第二个字符串的大写字母转换为小写字母</p>
<p>（因为同一个字母大小写的ASCII码的区别只有高位第三位数不同，因此可以不用分支判断，而直接用 位运算 来变换大小写：<strong>转大写</strong>：将字母和<strong>11011111</strong>做<strong>与运算</strong>，<strong>转小写</strong>：将字母与<strong>00100000</strong>做<strong>或运算</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,5</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov bx,5</span><br><span class="line">	mov cx,11</span><br><span class="line">	s0:</span><br><span class="line">	mov al.[bx]</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s0</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>



<h2 id="2-bx-idata-方式寻址"><a href="#2-bx-idata-方式寻址" class="headerlink" title="2 [bx + idata] 方式寻址"></a>2 [bx + idata] 方式寻址</h2><p> [bx + idata] 表示一个内存单元，它的<strong>偏移地址为 (bx) + idata</strong>（是bx中的数值加上idata)</p>
<p>mov ax, [bx + 200] 的含义：将一个内存单元的内容送入ax，这个内存单元的段地址在ds中，偏移地址为bx的值加上200，*<em>数学化描述：(ax)&#x3D;( (ds)<em>16 + (bx) + 200 )</em></em></p>
<p>对上面的大小写转换问题，如果两个字符串长度相等，可以用[bx + idata] 进行代码简化：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;BaSiC&#x27;</span><br><span class="line">	db &#x27;MinIX&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:</span><br><span class="line">	mov ax,datasg</span><br><span class="line">	mov ds,ax</span><br><span class="line">	</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,5</span><br><span class="line">	s:</span><br><span class="line">	mov al,[bx]</span><br><span class="line">	and al,11011111b</span><br><span class="line">	mov [bx],al</span><br><span class="line">	</span><br><span class="line">	mov al.[bx+5]</span><br><span class="line">	or al,00100000b</span><br><span class="line">	mov [bx+5],al</span><br><span class="line">	inc bx</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">codesg end</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的程序就相当于C语言等高级语言的数组机制，实际上，[bx+idata]的方式为高级语言实现数组提供了便利机制</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">5</span>] = <span class="string">&quot;BaSiC”</span></span><br><span class="line"><span class="string">	char a[5] = &quot;</span>MinIX<span class="string">&quot;</span></span><br><span class="line"><span class="string">    int i = 0;</span></span><br><span class="line"><span class="string">    do&#123;</span></span><br><span class="line"><span class="string">        a[i]=a[i] &amp; 0xDF;</span></span><br><span class="line"><span class="string">        b[i]=b[i] | 0x20;</span></span><br><span class="line"><span class="string">        i++;</span></span><br><span class="line"><span class="string">    &#125;while(i &lt; 5)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="3-SI-和DI-寄存器"><a href="#3-SI-和DI-寄存器" class="headerlink" title="3 SI 和DI 寄存器"></a>3 SI 和DI 寄存器</h2><p> <strong>SI：source index ，源变址寄存器</strong></p>
<p><strong>DI：destination index ，目标变址寄存器</strong></p>
<p>（ SI和DI 是和BX功能相近的寄存器，区别：<strong>SI和DI不能分成两个8位寄存器来使用</strong>）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#下面三组指令实现的功能相同</span><br><span class="line">#1</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,[bx+123]</span><br><span class="line">#1</span><br><span class="line">mov si,0</span><br><span class="line">mov ax,[si+123]</span><br><span class="line">#1</span><br><span class="line">mov di,0 </span><br><span class="line">mov ax,[di+123]</span><br></pre></td></tr></table></figure>



<p>4 [bx + si] 和[bx + di] 方式寻址</p>
<p>5 [ bx + si + idata ] 和[ bx + di + idata ] 方式寻址</p>
<h2 id="6-不同的寻址方式的灵活应用"><a href="#6-不同的寻址方式的灵活应用" class="headerlink" title="6 不同的寻址方式的灵活应用"></a>6 不同的寻址方式的灵活应用</h2><table>
<thead>
<tr>
<th>形式</th>
<th>名称</th>
<th>特点</th>
<th>意义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>[idata]</td>
<td>直接寻址</td>
<td>一个常量表示地址</td>
<td>直接定位一个内存单元</td>
<td>mov ax,[200]</td>
</tr>
<tr>
<td>[bx]</td>
<td>寄存器间接寻址</td>
<td>一个变量表示地址</td>
<td>间接定位一个内存单元</td>
<td>mov bx, 0        mov ax,[bx]</td>
</tr>
<tr>
<td>[bx+idata]</td>
<td>寄存器相对寻址</td>
<td>一个常量和变量表示地址</td>
<td>可在一个起始地址的基础上用变量间接定位一个内存单元</td>
<td>mov bx, 4        mov ax,[bx+200]</td>
</tr>
<tr>
<td>[bx+si]</td>
<td>基址变址寻址</td>
<td>两个变量表示地址</td>
<td></td>
<td>mov ax,[bx+si]</td>
</tr>
<tr>
<td>[bx+si+idata]</td>
<td>相对基址变址寻址</td>
<td>两个变量和一个常量表示地址</td>
<td></td>
<td>mov ax,[bx+si+200]</td>
</tr>
</tbody></table>
<p>7 不同寻址方式演示</p>
<h2 id="8-用于内存寻址的寄存器"><a href="#8-用于内存寻址的寄存器" class="headerlink" title="8 用于内存寻址的寄存器"></a>8 用于内存寻址的寄存器</h2><p><strong>只有bx，bp，si，di可以用在 […] 内对内存单元寻址，一般将bx，bp作为基址，si，di作为变址；</strong></p>
<p>bx以外的通用寄存器和段寄存器不可以用在[…]中</p>
<p><strong>bx、bp区别：bx默认在ds段上，bp默认在ss段上</strong></p>
<h2 id="9-数据在哪里？有多长？"><a href="#9-数据在哪里？有多长？" class="headerlink" title="9 数据在哪里？有多长？"></a>9 数据在哪里？有多长？</h2><p>数据位置的表达：</p>
<ol>
<li>立即数：直接包含在机器指令中的数据idata</li>
<li>寄存器：指令要处理的数据在寄存器中</li>
<li>内存：指令要处理的数据放在内存中，内存地址由段地址和偏移地址组合确定。</li>
</ol>
<p>处理的数据有多长：</p>
<ol>
<li>字word操作：利用整个寄存器，如ax</li>
<li>字节byte操作：寄存器拆开用，如al，ah</li>
<li>没有寄存器参与的内存单元访问指令中，用word ptr或byte ptr显性地指明所要访问的内存单元的长度：如：mov word ptr ds:[0]，1 指明了是字操作，而mov byte ptr ds:[0]，1指明了是字节操作</li>
</ol>
<p>10 寻址方式的综合应用</p>
<h2 id="11-用div指令实现除法"><a href="#11-用div指令实现除法" class="headerlink" title="11 用div指令实现除法"></a>11 用div指令实现除法</h2><p><strong>div是除法指令</strong>，使用div作除法时：</p>
<ul>
<li><p><strong>被除数：默认放在AX或 DX和AX中</strong></p>
</li>
<li><p><strong>除数：8位或16位，在寄存器或内存单元中</strong></p>
</li>
<li><table>
<thead>
<tr>
<th>被除数</th>
<th>AX</th>
<th>DX和AX</th>
</tr>
</thead>
<tbody><tr>
<td>除数</td>
<td><strong>8位</strong>内存&#x2F;寄存器</td>
<td><strong>16位</strong>内存&#x2F;寄存器</td>
</tr>
<tr>
<td>商</td>
<td><strong>AL</strong></td>
<td><strong>AX</strong></td>
</tr>
<tr>
<td>余数</td>
<td><strong>AH</strong></td>
<td><strong>DX</strong></td>
</tr>
</tbody></table>
</li>
</ul>
<p>div指令格式：div 寄存器&#x2F;内存单元</p>
<p><strong>切记：提前在默认寄存器中设置好被除数，且默认寄存器不作其他用途。</strong></p>
<p>示例：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>被除数</th>
<th>除数</th>
<th>商</th>
<th>余数</th>
</tr>
</thead>
<tbody><tr>
<td>div bl</td>
<td>(ax)</td>
<td>(bl)</td>
<td>(al)</td>
<td>(ah)</td>
</tr>
<tr>
<td>div byte ptr ds:[0]</td>
<td>(ax)</td>
<td>((ds)*16+0)</td>
<td>(al)</td>
<td>(ah)</td>
</tr>
<tr>
<td>div bx</td>
<td>(dx)*10000H+(ax)</td>
<td>(bx)</td>
<td>(ax)</td>
<td>(dx)</td>
</tr>
<tr>
<td>div word ptr es:[0]</td>
<td>(dx)*10000H+(ax)</td>
<td>((ds)*16+0)</td>
<td>(ax)</td>
<td>(dx)</td>
</tr>
</tbody></table>
<p>例子：利用除法指令计算 1000001&#x2F;100</p>
<p>分析：1000001D&#x3D;186A1H，需要进行16位的除法，所以用ax和dx联合存放186A1H，用bx存放除数 100D&#x3D;64H。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">	dd 1000001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">date ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">	mov ax,data</span><br><span class="line">	mov ds,ax</span><br><span class="line">	mov ax,ds:[0]</span><br><span class="line">	mov dx,ds:[2]</span><br><span class="line">	div word prt ds:[4]</span><br><span class="line">	mov ds:[6],ax	</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure>



<h2 id="12-用dup-复制-设置内存空间"><a href="#12-用dup-复制-设置内存空间" class="headerlink" title="12 用dup(复制)设置内存空间"></a>12 用dup(复制)设置内存空间</h2><p>duplication(复制)</p>
<p><strong>功能：dup和db，dw，dd等数据定义伪指令配合，用于进行数据的重复</strong></p>
<p>如：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能</th>
<th>相当于</th>
</tr>
</thead>
<tbody><tr>
<td>bd 3 dup (0)</td>
<td>定义3个字节，值都为0</td>
<td>db 0,0,0</td>
</tr>
<tr>
<td>bd 3 dup (‘abc’,’ABC’)</td>
<td>定义了18个字节，有’abcABC’重复3次</td>
<td>db ‘abcABCabcABCabcABC’</td>
</tr>
</tbody></table>
<p>定义一个容量为200个字节的栈段：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack segment</span><br><span class="line">	db 200 dup (0)</span><br><span class="line">stack ends</span><br></pre></td></tr></table></figure>







<h1 id="四、流程转移与子程序"><a href="#四、流程转移与子程序" class="headerlink" title="四、流程转移与子程序"></a>四、流程转移与子程序</h1><h2 id="1-”转移“概述"><a href="#1-”转移“概述" class="headerlink" title="1 ”转移“概述"></a>1 ”转移“概述</h2><p> 一般情况下指令是顺序地逐条执行的，而在实际中，常需要改变程序的执行流程。</p>
<p>转移指令：</p>
<ul>
<li>可以控制CPU执行内存中某处代码的指令</li>
<li>可以修改IP，或同时修改CS和IP的指令</li>
</ul>
<p>转移指令的分类：</p>
<ul>
<li>按转移行为<ul>
<li><strong>段内转移：只修改IP</strong>，如jmp ax</li>
<li><strong>段间转移：同时修改CS和IP</strong>，如jmp 1000:0</li>
</ul>
</li>
<li>根据指令对IP修改的范围不同：<ul>
<li>段内短转移：IP修改范围为-128~127</li>
<li><strong>段内近转移</strong>：IP修改范围为-32768~32767</li>
</ul>
</li>
<li>按转移指令<ul>
<li>无条件转移指令，如jmp</li>
<li>条件转移指令，如jcxz</li>
<li>循环指令，如loop</li>
<li>过程调用</li>
<li>中断</li>
</ul>
</li>
</ul>
<h2 id="2-操作符offset"><a href="#2-操作符offset" class="headerlink" title="2 操作符offset"></a>2 操作符offset</h2><p>用<strong>offset可以取得标号的偏移地址</strong></p>
<p>格式：offset 标号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">	start:</span><br><span class="line">	mov ax,offset start	#相当于mov ax,0</span><br><span class="line">	s:</span><br><span class="line">	mov ax,offset s	#相当于mov ax,3</span><br><span class="line">codeseg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>例：使程序在运行时将s处的一条指令复制到s0处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume sc:codeseg</span><br><span class="line">codeseg segment</span><br><span class="line">	s:mov ax,bx</span><br><span class="line">	mov si,offset s	#获得s处的地址</span><br><span class="line">	mov di,offset s0 #获得s0处的地址</span><br><span class="line">	mov ax,cs:[si]	</span><br><span class="line">	mov cs:[di],ax	#将s处的数据放入s0</span><br><span class="line">	s0:nop	#nop的机器码占一个字节，起”占位“作用</span><br><span class="line">codeseg ends</span><br><span class="line">ends</span><br></pre></td></tr></table></figure>



<h2 id="3-jmp指令"><a href="#3-jmp指令" class="headerlink" title="3 jmp指令"></a>3 jmp指令</h2><p>功能：<strong>无条件转移</strong>，可以只修改IP，也可以同时修改CS和IP</p>
<p>使用jmp要给出两种信息：</p>
<ul>
<li>转移的<strong>目的地址</strong>；</li>
<li>转移的<strong>距离</strong>：<ul>
<li><strong>段间转移（远转移）</strong>：<strong>jmp far ptr 标号</strong></li>
<li>段内<strong>短转移：jmp short 标号</strong>；IP的修改范围为-128~127，8位的位移</li>
<li>段内<strong>近转移：jmp near ptr 标号</strong>；IP的修改范围为-32768~32767，16位的位移</li>
</ul>
</li>
</ul>
<p>两种段内转移</p>
<ul>
<li><p><strong>短转移：jmp short 标号</strong></p>
<p>功能：(IP)&#x3D;(ip)+8位位移</p>
<p>原理：</p>
<ol>
<li>8位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li>
<li>short指明此处的位移为8位位移；</li>
<li>8位位移的范围为-128~127，用补码表示；</li>
<li>8位<strong>位移由编译器在编译时算出</strong>。</li>
</ol>
</li>
<li><p><strong>近转移：jmp near ptr 标号</strong></p>
<p>功能：(IP)&#x3D;(ip)+<strong>16位位移（相对于当前IP的转移位移）</strong></p>
<p>原理：</p>
<ol>
<li>16位位移&#x3D;标号处的地址 — jmp指令后的第一个字节的地址；</li>
<li><strong>near ptr指明此处的位移为16位位移；</strong></li>
<li>16位位移的范围为-32768~32767，用补码表示；</li>
<li>16位位移由编译器在编译时算出。</li>
</ol>
</li>
</ul>
<p><strong>远转移：jmp far ptr 标号；</strong></p>
<ul>
<li><strong>far ptr指明了跳转到的目的地址，即包含了标号的段地址CS和偏移地址IP</strong></li>
</ul>
<hr>
<p>转移地址放在<strong>寄存器中</strong>的jmp指令</p>
<p>格式：<strong>jmp 16位寄存器</strong></p>
<p>功能：IP &#x3D; (16位寄存器)    如：jmp bx</p>
<hr>
<p>转移地址在<strong>内存中</strong>的jmp地址</p>
<p>段内转移</p>
<ul>
<li><p><strong>jmp word ptr 内存单元地址</strong></p>
</li>
<li><p>功能：从内存单元地址处开始存放的<strong>一个字</strong>，作为转移的目的的<strong>偏移地址</strong></p>
</li>
<li><p>&#96;&#96;&#96;assembly<br>mov ax,0123H<br>mov ds:[0],ax<br>jmp word ptr ds:[0]  #执行后，(IP)&#x3D;0123H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">段间转移</span><br><span class="line"></span><br><span class="line">* **jmp dword ptr 内存单元地址**</span><br><span class="line"></span><br><span class="line">* 功能：从内存单元地址开始处的**两个字**，**高地址的字**作为转移的目的**段地址**，**低地址**处是转移的目的**偏移地址**</span><br><span class="line"></span><br><span class="line">* ```assembly</span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov ds:[0],ax</span><br><span class="line">  mov word ptr ds:[2],0</span><br><span class="line">  jmp dword ptr ds:[0]   #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br><span class="line">  </span><br><span class="line">  mov ax,0123H</span><br><span class="line">  mov bx,ax</span><br><span class="line">  mov word ptr [bx+2],0</span><br><span class="line">  jmp dword ptr [bx]  #执行后，(CS)=0,(IP)=0123H，CS:IP指向0000:0123</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>jmp指令格式</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>jmp 标号</td>
<td>—段间转移（远转移）：jmp far ptr 标号                                                                                        —段内短转移：jmp short 标号（8位的位移）                                                                                            —段内近转移：jmp near ptr 标号；16位的位移</td>
</tr>
<tr>
<td>jmp 寄存器</td>
<td>—jmp bx；16位的位移</td>
</tr>
<tr>
<td>jmp 内存单元(表示跳转到的地址)</td>
<td>—段内转移：jmp word ptr 内存单元地址；jmp word ptr [bx]      —段间转移：jmp dword ptr 内存单元地址；jmp dword ptr [bx]</td>
</tr>
</tbody></table>
<p>在源程序中，不能使用 jmp 2000:0100 的转移指令进行跳转，这是在Debug中使用的汇编指令，而编译器并不认识，会报错。</p>
<h2 id="4-其他转移指令"><a href="#4-其他转移指令" class="headerlink" title="4 其他转移指令"></a>4 其他转移指令</h2><p>所有的<strong>有条件转移都是短转移</strong>，对IP的修改范围都为-128~127。</p>
<p>位移：是指”相对“转移，好处是：无论s处的指令的实际地址是多少，loop等指令转移的相对位移都是不变的。这样，方便了程序段在内存中的浮动装配。</p>
<p> jcxz指令</p>
<ul>
<li><p>格式：<strong>jcxz 标号</strong>（条件转移）</p>
<p>功能：如果**(cx)&#x3D;0，则转移到标号处执行**；当(cx) !&#x3D; 0时，什么也不做（程序向下执行）</p>
</li>
</ul>
<p>loop指令</p>
<ul>
<li><p>格式：<strong>loop 标号</strong>（条件转移）</p>
<p>功能：(cx) &#x3D; (cx) - 1; 当**(cx) !&#x3D; 0时，则转移到标号处执行**，当(cx) &#x3D; 0时，程序向下执行（cx的值先减1，再判断）</p>
</li>
</ul>
<h2 id="5-call指令和ret指令"><a href="#5-call指令和ret指令" class="headerlink" title="5 call指令和ret指令"></a>5 call指令和ret指令</h2><p>模块化程序设计：调用子程序——call指令；返回——ret指令</p>
<p>实质：流程转移指令，都修改IP，或同时修改CS:IP</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0</span><br><span class="line">call s		#调用子程序</span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">s:add ax,1</span><br><span class="line">ret		#返回</span><br></pre></td></tr></table></figure>

<p>call指令</p>
<ul>
<li><p>格式：</p>
<ol>
<li><strong>call 标号（段内转移）</strong>，</li>
<li><strong>call far ptr 标号（段间转移）</strong>，</li>
<li><strong>call 16位寄存器</strong>（转移地址放在寄存器中，段内转移），</li>
<li><strong>call word ptr 内存单元地址（单字，段内转移）；call dword ptr 内存单元地址（双字，段间转移）</strong></li>
</ol>
</li>
<li><p>CPU执行call指令，进行两步操作：</p>
<p>将当前的IP或CS和IP压入栈中；转移到标号处执行指令。</p>
</li>
</ul>
<p>ret，retf指令</p>
<ul>
<li>ret指令：<ul>
<li>功能：用栈中的数据，修改IP的内容，从而实现近转移；</li>
<li>相当pop IP</li>
</ul>
</li>
<li>retf指令( f 意思是far）：<ul>
<li>用栈中的数据，修改CS和IP的内容，从而实现远转移</li>
<li>相当于 pop IP, pop CS</li>
</ul>
</li>
</ul>
<h2 id="6-mul指令"><a href="#6-mul指令" class="headerlink" title="6 mul指令"></a>6 mul指令</h2><p>mul指令用于做乘法运算</p>
<p>格式：mul 寄存器  或者   mul 内存单元</p>
<table>
<thead>
<tr>
<th></th>
<th>8位乘法</th>
<th>16位乘法</th>
</tr>
</thead>
<tbody><tr>
<td>被除数(默认)</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td>乘法</td>
<td>8位寄存器或内存字节单元</td>
<td>16位寄存器或内存字节单元</td>
</tr>
<tr>
<td>结果</td>
<td>AX</td>
<td>DX(高位)，AX(低位)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mov al,100	#被除数先放到默认寄存器al中</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl  #结果：(ax)=1000</span><br><span class="line"></span><br><span class="line">mov ax,100	#被除数先放到默认寄存器ax中</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx   #结果：(dx)=000FH,(ax)=4240H</span><br></pre></td></tr></table></figure>



<h2 id="7-汇编语言的模块化程序设计"><a href="#7-汇编语言的模块化程序设计" class="headerlink" title="7 汇编语言的模块化程序设计"></a>7 汇编语言的模块化程序设计</h2><p><strong>模块之间的参数和结果的传递</strong>：1. 用<strong>寄存器</strong>传递参数；2. 用<strong>内存单元</strong>进行参数传递；3. 用<strong>栈</strong>传递参数</p>
<p>用寄存器来存储参数和结果：最常用，但寄存器有限，所以参数不能太多；</p>
<p>用内存单元批量传递数据：将批量数据放在内存中，然后将它们所在内存空间的首地址放在寄存器中，传递给所需的子程序；对于具有批量数据的返回结果，也可以用同样的方法。</p>
<p>用栈传递参数：由调用者将需要传递给子程序的参数压入栈中，子程序从栈中取得参数。</p>
<h2 id="8-寄存器冲突问题"><a href="#8-寄存器冲突问题" class="headerlink" title="8 寄存器冲突问题"></a>8 寄存器冲突问题</h2><p> 在调用的子程序中，如果用到了调用者已经在用的寄存器，可能会会使运行结果错误甚至程序崩溃。</p>
<p>为了不影响调用者在使用的寄存器的值，同时为了避免在编写程序时需时刻注意寄存器的使用这种麻烦情况，因此，制定了<strong>子程序的标准框架</strong>：</p>
<ul>
<li><strong>子程序开始时，将子程序会使用到的寄存器入栈</strong></li>
<li>子程序内容</li>
<li><strong>子程序使用的寄存器出栈（恢复寄存器中的数据）</strong></li>
<li>返回（ret，retf）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">capital:</span><br><span class="line">	push cx		#假设用到了cx和si</span><br><span class="line">	push si</span><br><span class="line">	#子程序内容</span><br><span class="line">	pop si</span><br><span class="line">	pop cx</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>



<h2 id="9-标志寄存器"><a href="#9-标志寄存器" class="headerlink" title="9 标志寄存器"></a>9 标志寄存器</h2><p>结构：</p>
<ul>
<li>flag寄存器是<strong>按 位 起作用的</strong>，也就是说，它的每一位都有专门的含义，记录特定的信息。</li>
<li>8086CPU的16位flag寄存器没有使用1,3,5,12,13,14,15，这些位不具有任何含义</li>
</ul>
<p>作用：</p>
<ul>
<li>用来存储相关指令的某些执行结果（溢出，进位，是否为0…）</li>
<li>用来为CPU执行相关指令提供行为依据（如传送数据的方向…）</li>
<li>用来控制CPU的相关工作方式</li>
</ul>
<p>flag寄存器的值：</p>
<table>
<thead>
<tr>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>OF</td>
<td>DF</td>
<td>IF</td>
<td>TF</td>
<td>SF</td>
<td>ZF</td>
<td></td>
<td>AF</td>
<td></td>
<td>PF</td>
<td></td>
<td>CF</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>标志</th>
<th>值为1</th>
<th>值为0</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>OF (Overflow)</td>
<td>OV</td>
<td>NV</td>
<td>溢出</td>
</tr>
<tr>
<td>DF (Direction)</td>
<td>DN</td>
<td>UP</td>
<td>方向</td>
</tr>
<tr>
<td>SF (Sign)</td>
<td>NG</td>
<td>PL</td>
<td>符号</td>
</tr>
<tr>
<td>ZF (Zero)</td>
<td>ZR</td>
<td>NZ</td>
<td>零值</td>
</tr>
<tr>
<td>PF (parity)</td>
<td>PE</td>
<td>PO</td>
<td>奇偶</td>
</tr>
<tr>
<td>CF (Carry)</td>
<td>CY</td>
<td>NC</td>
<td>进位</td>
</tr>
</tbody></table>
<p>直接访问标志寄存器的方法：</p>
<ul>
<li>pushf：将标志寄存器的值压栈。</li>
<li>popf：从栈中弹出数据，送入标志寄存器中。</li>
</ul>
<p>指令影响：</p>
<ul>
<li>在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，如：add，sub，mul，div，inc，or，and等，大都是运算指令，逻辑指令</li>
<li>有的指令的执行对标志寄存器没有影响，如：mov，push，pop等，大都是传送指令。</li>
</ul>
<hr>
<ul>
<li><p><strong>ZF—零标志</strong>（Zero Flag）</p>
<p>ZF&#x3D;<strong>1</strong>，表示 逻辑<strong>真</strong>；ZF&#x3D;<strong>0</strong>，表示逻辑<strong>假</strong></p>
</li>
<li><p><strong>PF—奇偶</strong>标志（Parity Flag）</p>
<p>PF记录指令执行后，结果的所有二进制位中<strong>1的个数</strong>；</p>
<p>1的个数为<strong>偶数</strong>，PF &#x3D; <strong>1</strong></p>
<p>1的个数为<strong>奇数</strong>，PF &#x3D; <strong>0</strong></p>
</li>
<li><p><strong>SF—符号标志</strong>（Sign Flag）</p>
<p>结果为<strong>负</strong>：SF &#x3D; <strong>1</strong></p>
<p>结果为<strong>非负</strong>：SF &#x3D; <strong>0</strong></p>
<p>（将数据当作有符号数来运算时，通过SF可知结果的正负；将数据当作无符号数来运算时，SF的值则没有意义，虽然相关的指令会影响它的值）</p>
</li>
<li><p><strong>CF—进位标志</strong>（Carry Flag）</p>
</li>
</ul>
<p>  在进行无符号数的运算时，CF记录了运算结果的 最高有效位 向更高位（这个更高位是假象的）的进位值。</p>
<p>  <strong>有进位或借位</strong>，CF &#x3D; <strong>1</strong></p>
<p>  <strong>无进位或借位</strong>，CF &#x3D; <strong>0</strong></p>
<ul>
<li><p><strong>OF—溢出标志</strong>（Overflow Flag）</p>
<p>在进行有符号数运算时，如果结果超过了机器所能表示的范围，称为溢出。</p>
<p><strong>有溢出</strong>，OF &#x3D; <strong>1</strong></p>
<p><strong>无溢出</strong>，OF &#x3D; <strong>0</strong></p>
</li>
</ul>
<h2 id="10-带进位的加减法"><a href="#10-带进位的加减法" class="headerlink" title="10 带进位的加减法"></a>10 带进位的加减法</h2><p><strong>adc—带进位加法指令</strong>，利用了CF位上记录的进位值。</p>
<p>格式：<strong>adc 操作对象1，操作对象2</strong></p>
<p>功能：<strong>操作对象1 &#x3D; 操作对象1 + 操作对象2 + CF值</strong></p>
<p>例：adc ax, bx 实现的功能：(ax) &#x3D; (ax) + (bx) + CF</p>
<p>应用：大数相加（先将低16位相加，然后将高16位和进位值相加）</p>
<hr>
<p><strong>sbb—带借位减法指令</strong></p>
<p>格式：<strong>sbb 操作对象1，操作对象2</strong></p>
<p>功能：<strong>操作对象1 &#x3D; 操作对象1 - 操作对象2 - CF值</strong></p>
<p>例：sbb ax, bx  实现的功能：(ax) &#x3D; (ax) - (bx) - CF</p>
<h2 id="11-cmp和条件转移指令"><a href="#11-cmp和条件转移指令" class="headerlink" title="11 cmp和条件转移指令"></a>11 cmp和条件转移指令</h2><p><strong>cmp</strong>指令是<strong>比较指令</strong>，功能<strong>相当于减法指令，只是不保存结果</strong>；cmp指令执行后，会对标志寄存器产生影响，可以<strong>根据标志寄存器来比较结果</strong>，而不影响原值。</p>
<p>格式： <strong>cmp 操作对象1，操作对象2</strong></p>
<p>功能：计算 操作对象1 - 操作对象2</p>
<hr>
<p><strong>无符号数比较</strong>以及标志位取值</p>
<table>
<thead>
<tr>
<th>比较关系</th>
<th>(ax)-(bx)特点</th>
<th>标志寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>(ax)-(bx) &#x3D; 0</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>不等于</td>
<td>(ax)-(bx) !&#x3D; 0</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>小于</td>
<td>(ax)-(bx) 产生借位</td>
<td>CF&#x3D;1</td>
</tr>
<tr>
<td>大于等于</td>
<td>(ax)-(bx) 不必借位</td>
<td>CF&#x3D;0</td>
</tr>
<tr>
<td>大于</td>
<td>(ax)-(bx) 即不借位，结果右不为0</td>
<td>CF&#x3D;0且ZF&#x3D;0</td>
</tr>
<tr>
<td>小于等于</td>
<td>(ax)-(bx) 借位 或者 结果为0</td>
<td>CF&#x3D;1或ZF&#x3D;1</td>
</tr>
</tbody></table>
<p> <strong>有符号数比较</strong>以及标志位取值（仅凭结果正负(SF)无法得出结论，需要配合是否溢出(OF)得到结论）</p>
<table>
<thead>
<tr>
<th>比较关系</th>
<th>(ax)-(bx)特点</th>
<th>标志寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>等于</td>
<td>(ax)-(bx) &#x3D; 0</td>
<td>ZF&#x3D;1</td>
</tr>
<tr>
<td>不等于</td>
<td>(ax)-(bx) !&#x3D; 0</td>
<td>ZF&#x3D;0</td>
</tr>
<tr>
<td>小于</td>
<td>(ax)-(bx) 为负，且不溢出</td>
<td>SF&#x3D;1且OF&#x3D;0</td>
</tr>
<tr>
<td>大于等于</td>
<td>(ax)-(bx) 为负，且溢出</td>
<td>SF&#x3D;1且OF&#x3D;1</td>
</tr>
<tr>
<td>大于</td>
<td>(ax)-(bx) 为非负，且无溢出</td>
<td>SF&#x3D;0且OF&#x3D;0</td>
</tr>
<tr>
<td>小于等于</td>
<td>(ax)-(bx) 为非负，或有溢出</td>
<td>SF&#x3D;0或OF&#x3D;1</td>
</tr>
</tbody></table>
<hr>
<p> <strong>条件转移指令</strong></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726641.png" alt="image-20211130203630863"></p>
<h2 id="12-DF标志和串传送指令，rep指令"><a href="#12-DF标志和串传送指令，rep指令" class="headerlink" title="12 DF标志和串传送指令，rep指令"></a>12 DF标志和串传送指令，rep指令</h2><p><strong>DF—方向标志位</strong>（Direction Flag）</p>
<ul>
<li><p>功能：在串处理指令中，控制每次操作后 si，di的增减</p>
<p><strong>DF &#x3D; 0，每次操作后 si，di 递增；</strong></p>
<p><strong>DF &#x3D; 1，每次操作后 si，di 递减；</strong></p>
</li>
<li><p>对DF位进行设置：</p>
<p><strong>cld 指令：将标志寄存器的DF位设为0 （clear）</strong></p>
<p><strong>std 指令：将标志寄存器的DF位设为1 （setup）</strong></p>
</li>
</ul>
<hr>
<p><strong>串传送指令：</strong></p>
<ul>
<li><p>movsb：以<strong>字节</strong>为单位传送</p>
<ul>
<li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )，复制字节</p>
</li>
<li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>1</strong>，(di) &#x3D; (di) + <strong>1</strong></p>
<p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 1，(di) &#x3D; (di) - 1</p>
</li>
</ul>
</li>
<li><p>movsw：以<strong>字</strong>为单位传送</p>
<ul>
<li><p>( (es) * 16 + (di) ) &#x3D; ( (ds) * 16 + (si) )</p>
</li>
<li><p>如果DF &#x3D; 0，则 (si) &#x3D; (si) + <strong>2</strong>，(di) &#x3D; (di) + <strong>2</strong></p>
<p>如果DF &#x3D; 1，则 (si) &#x3D; (si) - 2，(di) &#x3D; (di) - 2</p>
</li>
</ul>
</li>
</ul>
<p>rep指令：</p>
<ul>
<li><p>功能：根据cx的值，重复执行后面的指令</p>
</li>
<li><p>用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rep movsb</span><br><span class="line">#上下两段代码是等价的</span><br><span class="line">s:movsb</span><br><span class="line">  loop s</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="五、中断及外部设备操作"><a href="#五、中断及外部设备操作" class="headerlink" title="五、中断及外部设备操作"></a>五、中断及外部设备操作</h1><h2 id="直接定址表"><a href="#直接定址表" class="headerlink" title="直接定址表"></a>直接定址表</h2><h3 id="1-移位指令"><a href="#1-移位指令" class="headerlink" title="1 移位指令"></a>1 移位指令</h3><p>其中OPR为操作数，CNT为位移位数</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726642.png" alt="image-20211201183648230"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#注意点:移位位数大于1时，必须使用cl</span><br><span class="line">mov al,0101000001b</span><br><span class="line">mov cl,3</span><br><span class="line">shl al,cl   #这里位数如果要写立即数，只能写1，即shl al,1</span><br></pre></td></tr></table></figure>

<p>常用法：<strong>将x逻辑左移一位，相当于x&#x3D;x*2；右移一位，相当于x&#x3D;x&#x2F;2</strong></p>
<h3 id="2-操作显存数据"><a href="#2-操作显存数据" class="headerlink" title="2 操作显存数据"></a>2 操作显存数据</h3><p>显存数据，即屏幕上显示的内容。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726643.png" alt="image-20211201184646183"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726644.png" alt="image-20211201190344885"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726645.png" alt="image-20211201190441592"></p>
<h3 id="3-描述内存单元的标号"><a href="#3-描述内存单元的标号" class="headerlink" title="3 描述内存单元的标号"></a>3 描述内存单元的标号</h3><p>地址标号：仅仅表示地址，标号后要加冒号</p>
<p>数据标号：标记了存储数据的单元的地址和长度。</p>
<p>注意：地址标号只能在代码段中使用，数据标号在代码段，数据段等都可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	a ab 1,2,3,4,5,6	#a为数据标号，标号后面不加冒号</span><br><span class="line">	b bw 0		</span><br><span class="line">start: mov si,0</span><br><span class="line">	mov cx,8</span><br><span class="line">	s:</span><br><span class="line">	mov al,a[si]	#数据标号 可以当作 地址值 用</span><br><span class="line">	mov,ah,0</span><br><span class="line">	add b,ax	</span><br><span class="line">	inc si</span><br><span class="line">	loop s</span><br><span class="line">	....</span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">#b代表地址为code:8,长度为字的内存单元</span><br><span class="line">#mov ax,b 相当于 mov ax,cx:[8]</span><br><span class="line">#mov b,2  相当于 mov word ptr cs:[8],2</span><br><span class="line">#inc b    相当于 inc word ptr cs:[8]</span><br><span class="line">#mov al,b (error!)</span><br></pre></td></tr></table></figure>



<h3 id="4-数据的直接定址表"><a href="#4-数据的直接定址表" class="headerlink" title="4 数据的直接定址表"></a>4 数据的直接定址表</h3><p>利用表，在两个数据集合之间建立一种映射关系，用查表的方法根据给出的数据得到另一集合中的对应数据。</p>
<p>例：计算sin(x)的值（x为有限个度数值），而计算过程需要多个乘除运算，代价颇高，所以可以考虑使用映射表。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726646.png" alt="image-20211201200817089"></p>
<p>5 代码的直接定址表</p>
<p>通过查表的方式，通过依据数据，直接计算出所要找的元素的位置。</p>
<p>如：要实现一个子程序，它提供四种功能，利用定址表的方案：将<strong>4个功能写成4个子程序，将这些功能子程序的入口地址存到一个表中</strong>，其对应关系：功能号*2&#x3D;对应的功能子程序在地址表中的偏移。这样就方便许多，不用很多分支选择</p>
<h2 id="内中断"><a href="#内中断" class="headerlink" title="内中断"></a>内中断</h2><p>1 中断及其处理</p>
<p>中断：CPU不再接着（刚执行完的指令）向下执行，而是转去处理中断信息。</p>
<p>内中断：由CPU内部发生的事件而引起的中断</p>
<p>外中断：由外部设备发生的事件而引起的中断</p>
<hr>
<p>内中断：</p>
<ul>
<li>除法错误：0（中断码）</li>
<li>单步执行：1</li>
<li>执行into指令：4</li>
<li>执行int n指令：立即数n为中断类型码</li>
</ul>
<hr>
<p>CPU接到中断信息后，会立即执行中断处理程序；</p>
<p>中断处理程序在哪里？中断信息和处理程序的入口地址之间有联系，CPU根据中断信息可查找中断向量表，找到要执行的处理程序。</p>
<p>中断向量表：中断类型码 与 中断处理程序地址入口 的映射表</p>
<hr>
<p>中断过程</p>
<p>中断过程由CPU的硬件自动完成，由中断类型码找到中断向量，并用它设置CS和IP</p>
<p>8086CPU的中断过程：</p>
<ol>
<li>从中断信息中取得中断类型码；</li>
<li>标志寄存器的值入栈：中断过程要改变标志寄存器的值，所以需要先行保护；</li>
<li>设置标志寄存器的第8位TF 和第9位IF的值为 0；</li>
<li>CS的内容入栈，IP的内容入栈（先行保护）</li>
<li>从中断向量表读取处理程序的入口地址，设置IP和CS</li>
</ol>
<p>2 编制中断处理程序</p>
<ul>
<li>CPU随时可能检测到中断信息，所以中断处理程序必须常驻内存中。</li>
<li>中断处理程序的入口地址，即中断向量，必须存储在对应的 中断向量表中（入口地址为IP和CS应该修改的值）。</li>
</ul>
<p>如果是自己编制的中断处理程序，应该放在内存的确定位置，且不破坏系统（向操作系统申请获得存放 程序的内存空间）；</p>
<p>3 单步中断</p>
<p>从Debug中断的t命令，即让CPU能执行一条指令就停下来：</p>
<ul>
<li>Debug利用了CPU提供的单步中断功能；</li>
<li>使用t命令，Debug将TF标志设为1，使CPU工作在单步中断方式下。</li>
</ul>
<p>两个和中断相关的寄存器标志位：</p>
<ul>
<li>TF—陷阱标志（Trap flag）：用于调试时的单步方式操作。<ul>
<li>当TF&#x3D;1时，每条指令执行完后产生陷阱，由系统控制计算机；</li>
<li>当TF&#x3D;0时，CPU正常工作，不产生陷阱。</li>
</ul>
</li>
<li>IF—中断标志（Interrupt flag）：<ul>
<li>当IF&#x3D;1时，允许CPU响应可屏蔽中断请求；</li>
<li>当IF&#x3D;0时，关闭中断。</li>
<li>设置IP的指令：sti，置IF&#x3D;1；cli，置IF&#x3D;0。</li>
</ul>
</li>
</ul>
<p>单步中断过程：</p>
<p>CPU在执行完一条指令后，如果检测到标志寄存器的TF位为1，则产生单步中断（中断类型码为1）：</p>
<ol>
<li><p>取得中断类型码1；</p>
</li>
<li><p>标志寄存器入栈，TF和IF设置为0；</p>
<blockquote>
<p>为什么TF要设置为0？</p>
<p>因为中断处理程序也由一条条指令组成。如果在执行中断处理程序之前，TF&#x3D;1，则CPU在执行完中断处理程序的第一条指令后，又要产生单步中断，转去执行单步中断的中断处理程序的第一条指令….这样会陷入一个死循环，CPU一直在执行单步中断处理程序的第一条指令。所以，在进入中断处理程序前，设置TF为0。</p>
</blockquote>
</li>
<li><p>CS，IP入栈；</p>
</li>
<li><p>设置CS，IP的值，使CPU执行中断处理程序；</p>
</li>
</ol>
<hr>
<p>中断不响应的情况：</p>
<p>一般来说，CPU在执行完当前指令后，如果检测到中断信息，就响应中断，当有些情况下，CPU不会响应中断：</p>
<p>例：在执行完向ss寄存器传送数据的指令后，即使发生中断，CPU也不会响应。</p>
<blockquote>
<p>原因：因为ss:sp是联合指向栈顶，而对它们的设置应该连续完成，依次保证对栈的正确操作。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#设置ss寄存器后的下一条指令会连续执行，不会单步执行，所以正确操作是将 设置ss和sp寄存器的两条指令放在一起</span><br><span class="line">mov ax,1000</span><br><span class="line">mov ss,ax</span><br><span class="line">....		#不要在设置ss和sp的指令中将插入其他操作</span><br><span class="line">mov sp,10</span><br></pre></td></tr></table></figure>
</blockquote>
<p>4 由int指令引发的中断</p>
<p>格式：int n （n为中断类型码）</p>
<p>功能：引发特定中断过程。int指令的功能和call指令相似，都是调用一段程序，一般来说，系统将一些具有一定功能的子程序，以中断处理程序的方式提供给应用程序调用。</p>
<p>应用：因为int指令可以调用子程序（中断处理程序&#x2F;中断例程），所以可以自定义中断例程，由int调用，实现特定功能。</p>
<p>5 BIOS和DOS中断处理</p>
<p>BIOS和DOS在所提供的中断例程中包含了许多编程时可以用到的功能子程序。</p>
<p>BIOS——基本输入输出系统，存放在系统板的ROM中。</p>
<p>BIOS功能：</p>
<ul>
<li>硬件系统的检测和初始化程序；</li>
<li>外部中断和内部中断的中断例程；</li>
<li>用于对硬件设备进行I&#x2F;O操作的中断例程；</li>
<li>其他和硬件系统相关的中断例程。</li>
</ul>
<p>意义：使用BIOS功能调用，程序员就不用了解硬件操作细节，直接使用指令设置参数，并使用BIOS的中断例程，即可完成工作。更方便编程，写处简洁，可读性号，易于移植的程序。</p>
<p>具体的BIOS和DOS中断例程可以查看手册。</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726647.png" alt="image-20211202172321228"></p>
<p>DOS中断</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726648.png" alt="image-20211202172548837"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726649.png" alt="image-20211202172452826"></p>
<h2 id="端口及外设控制"><a href="#端口及外设控制" class="headerlink" title="端口及外设控制"></a>端口及外设控制</h2><p>1 端口的读写</p>
<p>CPU可以直接读写3个地方的数据：CPU内寄存器，内存单元，端口。（端口指各种接口卡，网卡，显卡，主板的接口芯片等等）</p>
<p>端口的地址：各种芯片工作时，芯片上的一些寄存器由CPU读写，即CPU将这些寄存器当作端口并统一编址。</p>
<p>指令格式：in：CPU从端口读取数据；out：CPU往端口写入数据</p>
<p>端口的读写：</p>
<blockquote>
<p>例 ：in al，60h   从60h号端口读入一个字节</p>
<p>执行时相关的操作：</p>
<ol>
<li>CPU通过地址线将地址信息60h发出；</li>
<li>CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知要从中读取数据；</li>
<li>端口所在的芯片将60H对应端口中的数据通过数据总线送入CPU</li>
</ol>
</blockquote>
<p>端口读写规定：</p>
<ul>
<li>对0~255以内的端口进行读写，端口号用立即数给出</li>
<li>对256~65535的端口进行读写，端口号放在dx中</li>
<li>在in和out指令中，只能使用ax或al来存放从端口中读入的数或要发送到端口中的数据：访问8位端口上时用al，访问16位端口时用ax。</li>
</ul>
<p>2 操作CMOS RAM芯片</p>
<p>CMOS RAM芯片：包含一个实时时钟和一个128个存储单元的RAM存储器。</p>
<ul>
<li>128个字节的RAM存储器包含：内部实时钟，系统配置信息，相关的程序（用于开机时配置系统信息）</li>
<li>CMOS RAM芯片靠电池供电，关机后其内部的实时钟仍可正常工作，RAM中的信息不丢失。</li>
<li>芯片内部有两个端口，端口地址为70h和71h，CPU通过这两个读写CMOS RAM。<ul>
<li>70h地址端口：存放要访问的CMOS RAM单元的地址；</li>
<li>71h数据端口：存放从选定的单元中读取的数据，或要写入到其中的数据。</li>
</ul>
</li>
</ul>
<p>读取CMOS RAM：将要读取的单元地址送入70h地址端口，再从71h数据端口读出指定单元的内容。</p>
<p>3 外设连接与中断</p>
<p>CPU在执行指令过程中，可以检测到端口(外设)发送过来的中断信息，引发中断过程，处理外设的输入。</p>
<p>外中断：由外部设备发生的事件引起的中断。</p>
<p>可屏蔽中断：</p>
<ul>
<li>可屏蔽中断是CPU可以不响应的外中断。</li>
<li>CPU是否响应可屏蔽中断，要看标志寄存器的IF位：IF&#x3D;1时，执行完当前指令后引发中断过程；IF&#x3D;0时，不响应中断。</li>
<li>几乎所有由外设引发的外中断，都是可屏蔽中断。</li>
</ul>
<p>不可屏蔽中断：</p>
<ul>
<li>不可屏蔽中断是CPU必须响应的外中断。</li>
<li>8086CPU不可屏蔽中断的中断类型码固定为2。</li>
<li>不可屏蔽中断在 系统中有必须畜栏里的经济情况发生时 用来通知CPU的中断信息，如：突然掉电时，进行保护性工作。</li>
</ul>
<p>9 磁盘读写</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726650.png" alt="image-20211202195502858"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726651.png" alt="image-20211202195721926"></p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726652.png" alt="image-20211202195822939"></p>
<h1 id="六、高级汇编语言技术"><a href="#六、高级汇编语言技术" class="headerlink" title="六、高级汇编语言技术"></a>六、高级汇编语言技术</h1><h2 id="8086拓展"><a href="#8086拓展" class="headerlink" title="8086拓展"></a>8086拓展</h2><p>子程序的<strong>可读性更好的写法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#相当于高级语言中对子程序的包装：&#123; &#125;</span><br><span class="line">名称 proc</span><br><span class="line">	.... #内容</span><br><span class="line">	(ret)</span><br><span class="line">名称 endp</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>程序的多文件组织</strong>：</p>
<p>可以将程序放到不同地方，再进行连接编译，调用者需要声明调用了其他程序，被调用程序需要声明为共有的；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#调用者</span><br><span class="line">extrn 被调用程序的名称:far  #神明有子程序来自外部</span><br><span class="line">程序....</span><br><span class="line"></span><br><span class="line">#被调用者</span><br><span class="line">public 被调用程序的名称    #声明为共有的，允许外部调用</span><br><span class="line">子程序....</span><br></pre></td></tr></table></figure>



<h2 id="8086总结"><a href="#8086总结" class="headerlink" title="8086总结"></a>8086总结</h2><h3 id="一些名词缩写"><a href="#一些名词缩写" class="headerlink" title="一些名词缩写"></a>一些名词缩写</h3><blockquote>
<p>reg：寄存器</p>
<p>src：标号</p>
<p>opr：操作数</p>
<p>flags：标志寄存器</p>
</blockquote>
<h3 id="汇编指令"><a href="#汇编指令" class="headerlink" title="汇编指令"></a>汇编指令</h3><h4 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h4><ul>
<li><p>通用数据传送指令：mov，push，pop，xchg</p>
<blockquote>
<p>xchg是交换指令：xchg  操作数1 操作数2 ——将两个操作数作交换</p>
<p>注：不影响标志位，不允许使用段寄存器</p>
</blockquote>
</li>
<li><p>累加器专用传送指令：in，out，xlat</p>
<blockquote>
<ul>
<li><p>in，out是用于端口读写的指令</p>
</li>
<li><p>xlat是换码指令：xlat 或者 xlat 操作数</p>
<p>执行的操作是： (al) &lt;— ( (bx) + (al) )</p>
<p>用法：bx放一个数据段的首地址，al放偏移量，根据基地址和偏移地址，取出对应位置的数据，放到al里。一开始 al 放偏移量，最后 al 放数据。</p>
<p>注：不影响标志位，只用于字节表格(长度不超过256)，执行指令前需要先把首地址放进bx中，位移量放进al中</p>
</li>
</ul>
</blockquote>
</li>
<li><p>地址传送指令：lea，lds，les</p>
<blockquote>
<ul>
<li><p>lea：有效地址送寄存器指令</p>
<p>lea 寄存器  标号 ，将标号的偏移地址放入寄存器中</p>
</li>
<li><p>lds：指针送寄存器和DS指令</p>
<p>lds 寄存器 标号 ，将代表标号处的4字节地址取出，低2字节放入寄存器，高2字节放入DS中</p>
</li>
<li><p>les：指针送寄存器和ES指令（与lds类似）</p>
</li>
</ul>
</blockquote>
</li>
<li><p>标志寄存器传送指令：lahf，sahf，pushf，popf</p>
<blockquote>
<p>lahf：标志送ah指令（l 指load，ah是ah寄存器，f是标志寄存器），效果：将 标志寄存器的低字节送入ah中。</p>
<p>sahf：ah送标志寄存器指令（s指 send），效果：将ah的内容送入标志寄存器的低字节。</p>
</blockquote>
</li>
<li><p>类型转换指令：cbw，cwd</p>
<blockquote>
<p>c指change，转换的意思，b指byte，w指word(单字)，d是双字</p>
<p>cbw：将一个字节数据转换为字数据—— al —&gt; ax </p>
<p>cwd：将一个字数据转换为双字数据—— ax —&gt; (dx,ax)</p>
<p>注：是无操作数指令，隐含对al或ax进行符号拓展，执行指令前先把数据放入al或ax中，不影响条件标志位</p>
</blockquote>
</li>
</ul>
<h4 id="算术指令"><a href="#算术指令" class="headerlink" title="算术指令"></a>算术指令</h4><ul>
<li><p>加法指令：add，adc，inc</p>
<blockquote>
<p>adc：带进位加法； inc：加1操作</p>
</blockquote>
</li>
<li><p>减法指令：sub，sbb，dec，neg，cmp</p>
<blockquote>
<p>sbb：带借位减法； dec：减1操作；</p>
<p>neg：取负的； cmp：比较大小(用的是减法操作)</p>
</blockquote>
</li>
<li><p>乘法指令：mul，imul</p>
<blockquote>
<p>带 i 表示有符号的</p>
</blockquote>
</li>
<li><p>除法指令：div，idiv</p>
</li>
<li><p>十进制调整指令：daa，das，aaa，aas，aam，aad</p>
<blockquote>
<p>BCD码：用二进制编码的十进制数</p>
<ul>
<li><p>压缩的BCD码：用4位二进制数表示1位十进制数</p>
<p>如： (59)<del>10</del> &#x3D; ( 0101 1001)<del>BCD</del></p>
</li>
<li><p>非压缩的BCD码：用8位二进制数表示1位十进制数</p>
<p>如：(59)<del>10</del> &#x3D; ( 0000 0101   0000 1001)<del>BCD</del></p>
</li>
</ul>
<p>当BCD码进行算术运算时，可能会出现错位，借位等问题，所以需要进行调整。</p>
<ol>
<li>压缩的BCD码调整指令：<ul>
<li>DAA：加法的十进制调整指令</li>
<li>DAS：减法的十进制调整指令</li>
</ul>
</li>
<li>非压缩的BCD码调整指令：<ul>
<li>AAA：加法的ASCII码调整指令</li>
<li>AAS：减法的ASCII码调整指令</li>
<li>AAM：乘法的ASCII码调整指令</li>
<li>AAD：除法的ASCII码调整指令</li>
</ul>
</li>
</ol>
</blockquote>
</li>
</ul>
<h4 id="逻辑指令"><a href="#逻辑指令" class="headerlink" title="逻辑指令"></a>逻辑指令</h4><ul>
<li><p>逻辑运算指令：and，or，not，xor，test</p>
<blockquote>
<p>xor——异或；</p>
<p>test——测试，做 与运算，但不保存结果，只影响标志位；</p>
</blockquote>
</li>
<li><p>移位指令：shl，shr，sal，sar，rol，ror，rcl，rcr</p>
<blockquote>
<p>shl——逻辑左移</p>
<p>shr——逻辑右移</p>
<p>sal——算术左移</p>
<p>sar——算术右移</p>
<p>rol——循环左移</p>
<p>ror——循环右移</p>
<p>rcl——带进位循环左移</p>
<p>rcr——带进位循环右移</p>
</blockquote>
</li>
</ul>
<h4 id="串处理指令"><a href="#串处理指令" class="headerlink" title="串处理指令"></a>串处理指令</h4><ul>
<li>设置方向标志指令：cld，std</li>
<li>串处理指令：movsb&#x2F;movsw，stosb&#x2F;stosw，lodsb&#x2F;lodsw，cmpsb&#x2F;cmpsw，scasb&#x2F;scasw</li>
</ul>
<h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><ul>
<li>无条件转移指令：jmp</li>
<li>条件转移指令：jz，je，js，jo，jp，jb，jl，jbe，jle，jcxz</li>
<li>循环指令：loop，loopz，loopnz</li>
<li>子程序调用和返回指令：call，ret</li>
<li>中断与中断返回指令：int，into，iret</li>
</ul>
<p>处理机控制与杂项操作指令</p>
<ul>
<li>标志处理指令：clc，stc，cmc，cld，std，cli，sti</li>
<li>其他：<ul>
<li>nop（无操作，占位1字节）</li>
<li>hlt（暂停机，等待一次外中断，之后继续执行程序）</li>
<li>wait（等待，等待外中断，之后仍继续等待）</li>
<li>esc（换码）</li>
<li>lock（封锁，维持总线的锁存信号，直到其他的指令执行完）</li>
</ul>
</li>
</ul>
<h3 id="伪操作"><a href="#伪操作" class="headerlink" title="伪操作"></a>伪操作</h3><p>汇编指令是指：与机器指令一一对应，在程序运行期间由计算机执行。</p>
<p>伪操作是指：在汇编程序对源程序汇编期间，由汇编程序处理的操作&#x2F;指令（只在汇编期间其作用，伪指令不会产生机器码），可以完成如数据定义，分配存储区，指示程序结束等功能。</p>
<p>处理器选择伪操作，段定义伪操作，程序开始和结束伪操作，数据定义及存储器分配伪操作，表达式赋值伪操作，地址计数器与对准伪操作，基数控制伪操作</p>
<p>（具体的暂略）</p>
<p>操作符</p>
<p>操作符：用于操作数中，通过操作符，将常数，寄存器，标号，变量等，组合成表达式，实现求值的目的（还是将汇编期间进行的）。</p>
<p>算术操作符：+，-，*，&#x2F;，mod</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726653.png" alt="image-20211206181250064"></p>
<p>逻辑和移位操作符：and，or，xor，not，shl，shr</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726654.png" alt="image-20211206181409612"></p>
<p>关系操作符：eq，nf，lt，le，gt，ge</p>
<p>数值回送操作符：offset，seg，type，length，size</p>
<p>属性操作符：ptr，段操作符，short，this，high，low，highword，lowword</p>
<h3 id="宏汇编"><a href="#宏汇编" class="headerlink" title="宏汇编"></a>宏汇编</h3><p>汇编过程：有两次汇编</p>
<ul>
<li>第一次汇编：确定地址，翻译成各条机器码，字符标号原样写出；</li>
<li>第二次汇编：标号代真，将字符标号用计算出的地址值或偏移量代换。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202203191726655.png" alt="image-20211206184340760"></p>
<p>32位汇编</p>
<p>实用技术</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/">http://example.com/2022/04/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151557250.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><img class="prev-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151601534.jpeg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2022/04/14/MySQL/"><img class="next-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151643159.png" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Mysql</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/Notes/2022/04/14/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="C语言"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151628461.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">C语言</div></div></a></div><div><a href="/Notes/2022/04/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151622912.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">数据结构</div></div></a></div><div><a href="/Notes/2022/04/14/%E7%AE%97%E6%B3%95/" title="算法"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">算法</div></div></a></div><div><a href="/Notes/2022/07/01/%E7%AE%97%E6%B3%95-%E7%BB%8F%E5%85%B8%E9%A2%98/" title="算法-经典题"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-01</div><div class="title">算法-经典题</div></div></a></div><div><a href="/Notes/2022/06/07/%E7%AE%97%E6%B3%952-0/" title="算法2.0"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151625051.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-07</div><div class="title">算法2.0</div></div></a></div><div><a href="/Notes/2022/04/14/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151601534.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-14</div><div class="title">操作系统</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BF%E9%97%AE%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">一、访问寄存器和内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%AF%84%E5%AD%98%E5%99%A8%E5%92%8C%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.</span> <span class="toc-text">1 寄存器和数据存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-mov%E5%92%8Cadd%E6%8C%87%E4%BB%A4"><span class="toc-number">1.2.</span> <span class="toc-text">2 mov和add指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A1%AE%E5%AE%9A%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.</span> <span class="toc-text">3 确定物理地址的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E7%9A%84%E5%88%86%E6%AE%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">4 内存的分段表示法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Debug%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5 Debug的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-CS%E3%80%81IP%E4%B8%8E%E4%BB%A3%E7%A0%81%E6%AE%B5"><span class="toc-number">1.6.</span> <span class="toc-text">6 CS、IP与代码段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">1.7.</span> <span class="toc-text">7 jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%97%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.8.</span> <span class="toc-text">8 内存中字的存储</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E7%94%A8DS%E5%92%8C-address-%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%9A%84%E4%BC%A0%E9%80%81"><span class="toc-number">1.9.</span> <span class="toc-text">9 用DS和[address] 实现字的传送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-DS%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%AE%B5"><span class="toc-number">1.10.</span> <span class="toc-text">10 DS与数据段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E6%A0%88%E5%8F%8A%E6%A0%88%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.11.</span> <span class="toc-text">11 栈及栈操作的实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">二、汇编语言程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E5%86%99%E7%9A%84%E6%BA%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.1.</span> <span class="toc-text">1 汇编语言写的源程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%94%B1%E6%BA%90%E7%A8%8B%E5%BA%8F%E5%88%B0%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C"><span class="toc-number">2.2.</span> <span class="toc-text">2 由源程序到程序运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91"><span class="toc-number">2.2.1.</span> <span class="toc-text">编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.</span> <span class="toc-text">连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%94%A8Debug%E8%B7%9F%E8%B8%AA%E7%A8%8B%E5%BA%8F%E6%89%A7%E8%A1%8C"><span class="toc-number">2.3.</span> <span class="toc-text">3 用Debug跟踪程序执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E2%80%A6-%E5%92%8C-%E2%80%A6"><span class="toc-number">2.4.</span> <span class="toc-text">4 […] 和 (…)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Loop%E6%8C%87%E4%BB%A4"><span class="toc-number">2.5.</span> <span class="toc-text">5 Loop指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Loop%E6%8C%87%E4%BB%A4%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90"><span class="toc-number">2.6.</span> <span class="toc-text">6 Loop指令使用例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%AE%B5%E5%89%8D%E7%BC%80%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.</span> <span class="toc-text">7 段前缀的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE"><span class="toc-number">2.8.</span> <span class="toc-text">8 在代码段中使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%9C%A8%E4%BB%A3%E7%A0%81%E6%AE%B5%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%A0%88"><span class="toc-number">2.9.</span> <span class="toc-text">9 在代码段中使用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B0%86%E6%95%B0%E6%8D%AE%E3%80%81%E4%BB%A3%E7%A0%81%E3%80%81%E6%A0%88%E6%94%BE%E5%85%A5%E4%B8%8D%E5%90%8C%E6%AE%B5"><span class="toc-number">2.10.</span> <span class="toc-text">10 将数据、代码、栈放入不同段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">三、内存寻址方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">1 处理字符问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-bx-idata-%E6%96%B9%E5%BC%8F%E5%AF%BB%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">2 [bx + idata] 方式寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-SI-%E5%92%8CDI-%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">3 SI 和DI 寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E5%BA%94%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">6 不同的寻址方式的灵活应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E7%94%A8%E4%BA%8E%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">3.5.</span> <span class="toc-text">8 用于内存寻址的寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%95%B0%E6%8D%AE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F%E6%9C%89%E5%A4%9A%E9%95%BF%EF%BC%9F"><span class="toc-number">3.6.</span> <span class="toc-text">9 数据在哪里？有多长？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%94%A8div%E6%8C%87%E4%BB%A4%E5%AE%9E%E7%8E%B0%E9%99%A4%E6%B3%95"><span class="toc-number">3.7.</span> <span class="toc-text">11 用div指令实现除法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%94%A8dup-%E5%A4%8D%E5%88%B6-%E8%AE%BE%E7%BD%AE%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4"><span class="toc-number">3.8.</span> <span class="toc-text">12 用dup(复制)设置内存空间</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%81%E7%A8%8B%E8%BD%AC%E7%A7%BB%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F"><span class="toc-number">4.</span> <span class="toc-text">四、流程转移与子程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E2%80%9D%E8%BD%AC%E7%A7%BB%E2%80%9C%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.</span> <span class="toc-text">1 ”转移“概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E7%AC%A6offset"><span class="toc-number">4.2.</span> <span class="toc-text">2 操作符offset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-jmp%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.</span> <span class="toc-text">3 jmp指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">4.4.</span> <span class="toc-text">4 其他转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-call%E6%8C%87%E4%BB%A4%E5%92%8Cret%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.</span> <span class="toc-text">5 call指令和ret指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-mul%E6%8C%87%E4%BB%A4"><span class="toc-number">4.6.</span> <span class="toc-text">6 mul指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.7.</span> <span class="toc-text">7 汇编语言的模块化程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%B2%E7%AA%81%E9%97%AE%E9%A2%98"><span class="toc-number">4.8.</span> <span class="toc-text">8 寄存器冲突问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">4.9.</span> <span class="toc-text">9 标志寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%B8%A6%E8%BF%9B%E4%BD%8D%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95"><span class="toc-number">4.10.</span> <span class="toc-text">10 带进位的加减法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-cmp%E5%92%8C%E6%9D%A1%E4%BB%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">4.11.</span> <span class="toc-text">11 cmp和条件转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-DF%E6%A0%87%E5%BF%97%E5%92%8C%E4%B8%B2%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4%EF%BC%8Crep%E6%8C%87%E4%BB%A4"><span class="toc-number">4.12.</span> <span class="toc-text">12 DF标志和串传送指令，rep指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%AD%E6%96%AD%E5%8F%8A%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87%E6%93%8D%E4%BD%9C"><span class="toc-number">5.</span> <span class="toc-text">五、中断及外部设备操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-number">5.1.</span> <span class="toc-text">直接定址表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4"><span class="toc-number">5.1.1.</span> <span class="toc-text">1 移位指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E6%98%BE%E5%AD%98%E6%95%B0%E6%8D%AE"><span class="toc-number">5.1.2.</span> <span class="toc-text">2 操作显存数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8F%8F%E8%BF%B0%E5%86%85%E5%AD%98%E5%8D%95%E5%85%83%E7%9A%84%E6%A0%87%E5%8F%B7"><span class="toc-number">5.1.3.</span> <span class="toc-text">3 描述内存单元的标号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8"><span class="toc-number">5.1.4.</span> <span class="toc-text">4 数据的直接定址表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.</span> <span class="toc-text">内中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E5%8F%8A%E5%A4%96%E8%AE%BE%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.</span> <span class="toc-text">端口及外设控制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%AB%98%E7%BA%A7%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%8A%80%E6%9C%AF"><span class="toc-number">6.</span> <span class="toc-text">六、高级汇编语言技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8086%E6%8B%93%E5%B1%95"><span class="toc-number">6.1.</span> <span class="toc-text">8086拓展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8086%E6%80%BB%E7%BB%93"><span class="toc-number">6.2.</span> <span class="toc-text">8086总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E7%BC%A9%E5%86%99"><span class="toc-number">6.2.1.</span> <span class="toc-text">一些名词缩写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.</span> <span class="toc-text">汇编指令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.1.</span> <span class="toc-text">数据传送指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.2.</span> <span class="toc-text">算术指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.3.</span> <span class="toc-text">逻辑指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.4.</span> <span class="toc-text">串处理指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">6.2.2.5.</span> <span class="toc-text">控制转移指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E6%93%8D%E4%BD%9C"><span class="toc-number">6.2.3.</span> <span class="toc-text">伪操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E6%B1%87%E7%BC%96"><span class="toc-number">6.2.4.</span> <span class="toc-text">宏汇编</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>