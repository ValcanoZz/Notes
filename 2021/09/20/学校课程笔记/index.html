<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>class learn | ValcanoZz Blog</title><meta name="keywords" content="学校"><meta name="author" content="ValcanoZz"><meta name="copyright" content="ValcanoZz"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据挖掘 考试要求： 1）考试题型包括单项选择题、填空题、问答题与解答题，比重约为20：20：20：40。 2）复习的主要结合课件PPT、教材以及布置的作业等资料。  1、概述 考试要求： \1. 数据挖掘任务 \2. 数据挖掘主要流程  数据挖掘： 是在大型数据存储库中，自动发现有用信息的过程。  数据挖掘是综合了统计学、最优化、机器学习、以及数据库的一门现代计算机技术，旨在发现海量数据中的模型">
<meta property="og:type" content="article">
<meta property="og:title" content="class learn">
<meta property="og:url" content="http://example.com/2021/09/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ValcanoZz Blog">
<meta property="og:description" content="数据挖掘 考试要求： 1）考试题型包括单项选择题、填空题、问答题与解答题，比重约为20：20：20：40。 2）复习的主要结合课件PPT、教材以及布置的作业等资料。  1、概述 考试要求： \1. 数据挖掘任务 \2. 数据挖掘主要流程  数据挖掘： 是在大型数据存储库中，自动发现有用信息的过程。  数据挖掘是综合了统计学、最优化、机器学习、以及数据库的一门现代计算机技术，旨在发现海量数据中的模型">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-09-20T00:57:20.000Z">
<meta property="article:modified_time" content="2023-03-09T09:12:29.496Z">
<meta property="article:author" content="ValcanoZz">
<meta property="article:tag" content="学校">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/Notes/./img/favicon7.png"><link rel="canonical" href="http://example.com/2021/09/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/Notes/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/Notes/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'class learn',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-03-09 17:12:29'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="./css/v_footer.css"><link rel="stylesheet" href="./css/v_blog.css"><link rel="stylesheet" href="./css/v_cursors.css"><link rel="stylesheet" href="./css/v_opacity.css"><link rel="stylesheet" href="./css/v_scrollbar.css"><meta name="generator" content="Hexo 6.1.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/Notes/./img/avatar1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/Notes/archives/"><div class="headline">文章</div><div class="length-num">30</div></a></div><div class="data-item"><a href="/Notes/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/Notes/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/Notes/">ValcanoZz Blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/Notes/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/Notes/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 链接</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Notes/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page child" href="/Notes/about/"><i class="fa-fw fas fa- heart"></i><span> 关于</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">class learn</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-09-20T00:57:20.000Z" title="发表于 2021-09-20 08:57:20">2021-09-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-09T09:12:29.496Z" title="更新于 2023-03-09 17:12:29">2023-03-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>47分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="class learn"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据挖掘"><a href="#数据挖掘" class="headerlink" title="数据挖掘"></a>数据挖掘</h1><blockquote>
<p>考试要求：</p>
<p>1）考试题型包括单项选择题、填空题、问答题与解答题，比重约为20：20：20：40。</p>
<p>2）复习的主要结合课件PPT、教材以及布置的作业等资料。</p>
</blockquote>
<h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><blockquote>
<p>考试要求：</p>
<p><strong>\1. 数据挖掘任务</strong></p>
<p><strong>\2. 数据挖掘主要流程</strong></p>
</blockquote>
<p>数据挖掘： 是在大型数据存储库中，自动发现有用信息的过程。</p>
<blockquote>
<p>数据挖掘是综合了统计学、最优化、机器学习、以及数据库的一门现代计算机技术，旨在<strong>发现海量数据中的模型与模式</strong>。</p>
</blockquote>
<p>数据挖掘是<code>数据库中知识发现</code>（knowledge discovery in database,KDD）不可缺少的一部分，而<code>KDD是将未加工的数据转换为有用信息的整个过程</code>。</p>
<ul>
<li>KDD过程： 输入数据——数据预处理——数据挖掘——后处理——得到信息<ul>
<li>数据预处理的方式有：特征选择，维归约，规范化，选择数据子集</li>
<li>后处理的方式有：模式过滤，可视化，模式表示</li>
</ul>
</li>
</ul>
<p>面临的问题&#x2F;挑战：</p>
<ul>
<li>可伸缩 —— 为处理海量数据，算法必须是可伸缩的，对此，可能需要新的数据结构，也可使用抽样技术，或开发并行和分布式算法。</li>
<li>高维性 ——  现在的数据集常常有非常多的属性；某些数据分析算法，随着维度（特征数）的增加，计算复杂性迅速增加 。</li>
<li>异种数据和复杂数据 —— 类型属性不同的数据集…</li>
<li>数据的所有权与分布 —— 数据分布各地，需要分布式的数据挖掘技术。</li>
<li>非传统的分析 —— 传统统计学是假设-验证模式，但当前数据分析常产生数以千计的假设，且数据集通常也不是精心设计的。</li>
</ul>
<h3 id="数据挖掘的任务"><a href="#数据挖掘的任务" class="headerlink" title="数据挖掘的任务"></a>数据挖掘的任务</h3><p>一般分为两类：</p>
<ul>
<li><strong>预测任务</strong> ：根据其他属性的值（说明变量&#x2F;自变量），预测特定属性的值（目标变量&#x2F;因变量）。<ul>
<li><p>关联分析 —— 用来发现描述数据中的强关联特征的模式</p>
<ul>
<li><p>关联规则发现</p>
</li>
<li><p>序列模式发现</p>
</li>
</ul>
</li>
<li><p>聚类 —— 发现关联紧密的观测值组群，属于同一簇的观察值相互之间尽可能类似。</p>
</li>
</ul>
</li>
<li><strong>描述任务</strong> ：为了导出 能概括数据中潜在联系 的模式。 描述任务通常是探查性的，常需要后处理区验证和解释结果。<ul>
<li><p>预测建模：</p>
<ul>
<li><p>分类 —— 预测离散的目标变量</p>
</li>
<li><p>回归 —— 预测连续的目标变量</p>
</li>
</ul>
</li>
<li><p>异常&#x2F;偏差检测 —— 识别其特征显著不同于其他数据的观测值，这样的观察值称为异常点&#x2F;离群点。</p>
</li>
</ul>
</li>
</ul>
<h3 id="数据挖掘的主要流程"><a href="#数据挖掘的主要流程" class="headerlink" title="数据挖掘的主要流程"></a>数据挖掘的主要流程</h3><ul>
<li>业务理解</li>
<li>数据获取</li>
<li>数据预处理</li>
<li>数据建模</li>
<li>模型评估</li>
<li>模型部署</li>
</ul>
<h2 id="2、数据"><a href="#2、数据" class="headerlink" title="2、数据"></a>2、数据</h2><blockquote>
<p>考试要求：</p>
<p><strong>\1. 不同的属性类型</strong></p>
<p><strong>\2. 数据质量问题</strong></p>
<p><strong>\3. 数据预处理的主要方法</strong></p>
<p><strong>\4. 连续属性离散化</strong></p>
<p><strong>\5. 相似性&#x2F;相关性度量：距离、余弦、SMC、Jaccard系数、皮尔森相关系数</strong></p>
</blockquote>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据集：是数据对象的集合。 数据对象是用一组刻画对象基本特征的属性进行描述的。</p>
<p>属性：是对象的性质&#x2F;特性，它因对象而异。</p>
<p>测量标度：是将 数值&#x2F;符号值 和 对象的属性 相关联的规则（函数）。</p>
<hr>
<p>对于用于描述属性的一些数值性质：</p>
<ul>
<li>相异性： &#x3D;  和 !&#x3D;</li>
<li>序 ：&lt; ，&lt;&#x3D; ，&gt; 和 &gt;&#x3D;</li>
<li>加法： +  和 -</li>
<li>乘法： * 和 &#x2F;</li>
</ul>
<p>根据上述性质，可以定义四种属性类型 —— 标称，序数，区间，比率</p>
<table>
<thead>
<tr>
<th>属性类型</th>
<th></th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>分类的&#x2F;定性的</td>
<td>标称</td>
<td>标称属性的值仅仅只是不同的名字，即标称值只提供足够的信息以区分对象（&#x3D;，!&#x3D;）</td>
<td>邮政编码，员工ID号，性别</td>
</tr>
<tr>
<td></td>
<td>序数</td>
<td>序数属性的值提供足够的信息确定对象的序（&gt;，&lt;）</td>
<td>成绩，街道号码</td>
</tr>
<tr>
<td>数值的&#x2F;定量的</td>
<td>区间</td>
<td>对于区间属性，值之间的差是有意义的，即存在测量单位（+，-）</td>
<td>日期，温度</td>
</tr>
<tr>
<td></td>
<td>比率</td>
<td>对于比率变量，差和比率都是有意义的（*，&#x2F;）</td>
<td>绝对温度，计数，年龄，质量</td>
</tr>
</tbody></table>
<p>还可以用值的个数描述属性：</p>
<ul>
<li>离散的</li>
<li>连续的</li>
</ul>
<hr>
<p>数据集的一般特性：</p>
<ul>
<li><p>维度 —— 即数据集中的对象具有的属性数目。</p>
<blockquote>
<p>为了避免分析高维数据时陷入维灾难，就需要数据预处理（减少维度，即维归约）</p>
</blockquote>
</li>
<li><p>稀疏性 —— 有些非对称特征的数据集，可能某些值占比非常大，另一些占比又非常小。</p>
<blockquote>
<p>比如非对称特征的数据集，其对象的大部分属性的值都为0，或者只有非零值才重要，则只存储处理非零值</p>
</blockquote>
</li>
<li><p>分辨率 —— 数据的模式依赖于分辨率，即度量尺度。</p>
<blockquote>
<p>比如在数米的尺度下，地球表面很不平坦，但在数十公里的分辨率下却是相对平坦。</p>
</blockquote>
</li>
</ul>
<p><strong>数据集的类型：</strong></p>
<ul>
<li><p>**记录数据 ** —— 有一组记录，每条记录有一组固定的属性。</p>
<ul>
<li><strong>数据矩阵</strong> —— 数据集的所有对象拥有相同的属性集，可以表示为m*n的矩阵。</li>
<li>文本矩阵（<strong>文档-词矩阵</strong> 存放每个词在每篇文章出现的次数，是稀疏数据矩阵，一般只会存放非零项）</li>
<li>**事务矩阵 ** —— 每个事务涉及一系列的项。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202209131417244.png" alt="image-20220913141727808"></p>
</li>
<li><p><strong>基于图形的数据集</strong> —— 数据对象之间存在联系。 如万维网上的超链接， 分子结构中原子的排布，等等。</p>
</li>
<li><p><strong>有序数据</strong> ——  数据涉及时间或空间序的联系</p>
<ul>
<li>空间数据：如不同地理位置的气象数据（降水，气温，气压）</li>
<li>时间数据：一个地方的温度变化时间表</li>
<li>序列数据：如基因组序列</li>
</ul>
</li>
</ul>
<h3 id="数据质量"><a href="#数据质量" class="headerlink" title="数据质量"></a>数据质量</h3><p>数据挖掘使用的数据常常是为其他用途的，或收集时未明确目的，所以其质量时常存在问题：</p>
<ol>
<li><p><strong>测量误差</strong> ：记录值与实际值不同。</p>
<p>**数据收集错误 **：遗漏或不正确地包含其他数据。</p>
<blockquote>
<p>噪声是测量误差的随机部分；</p>
<p>离群点，遗漏值，不一致的值，重复的值 都可能同时涉及测量误差和数据收集错误。</p>
</blockquote>
</li>
<li><p><strong>噪声</strong> ：可能涉及值被扭曲或加入谬误对象。</p>
<p><strong>伪像</strong> ：数据错误是某些确定性现象导致的。</p>
</li>
<li><p><strong>精度</strong> ：重复测量值之间的接近程度 —— 测量值的标准差</p>
<p>**偏移 ** ：测量值与被测量值之间的系统变差 —— |测量均值 - 被测量值|</p>
<p>**准确率 ** ：测量值与实际值的接近度 —— 受限于工具的精度，能得到的有效数字。</p>
</li>
<li><p>**离群点 ** ：不同于大部分数据对象，不寻常的值。</p>
</li>
<li><p><strong>遗漏值</strong></p>
</li>
<li><p><strong>不一致的值</strong></p>
</li>
<li><p><strong>重复的值</strong></p>
</li>
</ol>
<hr>
<p>数据质量也要从应用角度来看：</p>
<ol>
<li>时效性 ： 数据收集后的老化、过时</li>
<li>相关性</li>
</ol>
<h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><blockquote>
<ul>
<li>聚集</li>
<li>抽样</li>
<li>维归约</li>
<li>特征子集选择</li>
<li>离散化和二元化</li>
<li>变量变换</li>
</ul>
</blockquote>
<h4 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h4><p>聚集：将两个或多个对象合并成单个对象。</p>
<ul>
<li><p>目的：数据规约（规模变小但保持完整性），标度转换，更稳定的数据。</p>
</li>
<li><p>缺点：会丢失一些细节。</p>
</li>
</ul>
<h4 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h4><p>抽样：选择部分数据对象子集进行分析。</p>
<p>有效抽样的原则：代表性，保留原数据集的性质。</p>
<p>分类：</p>
<ul>
<li>简单抽样 ：分为无放回、有放回。</li>
<li>分层抽样： 每组抽相同个数，或按比例抽样。</li>
<li>自适应&#x2F;渐进抽样：从小样本开始，逐渐增大样本容量直至得到足够的样本。（因为难以预先确定样本集的大小）</li>
</ul>
<blockquote>
<p>统计学进行抽样，是因为得到整个数据集的代价太高。</p>
<p>数据挖掘进行抽样，是因为处理所有数据的代价太高。</p>
</blockquote>
<h4 id="维归约"><a href="#维归约" class="headerlink" title="维归约"></a>维归约</h4><p>维灾难： 随着数据维度的增加，许多数据分析变得非常困难。特殊地，随着维度增加，数据在它所占据的空间中越来越稀疏。</p>
<p>—— 对于分类，这可能意味没有足够的数据对象来创建模型</p>
<p>—— 对于聚类，点之间的密度和距离的定义（对聚类是至关重要的）变得不太有意义</p>
<p>分类准确率降低，聚类质量下降，这导致许多分类和聚类算法都不好处理高维数据，</p>
<p>维归约常用方法：</p>
<ol>
<li>主成分分析 —— 将高维空间的向量变换为低维空间的向量（投影）</li>
<li>奇异值分解</li>
</ol>
<h4 id="特征子集选择"><a href="#特征子集选择" class="headerlink" title="特征子集选择"></a>特征子集选择</h4><p>当存在冗余特征、不相关特征时，仅使用特征的一个子集。这能降低维度的同时避免丢失信息。</p>
<p>三种方法：</p>
<ol>
<li>嵌入方法 —— 特征选择是数据挖掘算法的内在组成（强耦合）</li>
<li>过滤方法 —— 在挖掘算法前，进行特征选择。（有耦合：特征选择依赖于具体算法，但不是算法的内在组成）</li>
<li>包装方法 —— 将挖掘算法作为黑盒，特征选择完全独立于目标算法。（无耦合）</li>
</ol>
<p>特征子集选择过程的流程图：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202209132120862.png" alt="image-20220913212019766"></p>
<p>特征创建： 可以由原来的属性创建新的属性集，更有效地捕获数据集中的重要信息。以下是三种创建新属性的方法：</p>
<ol>
<li>特征提取：如人脸检测，指纹识别</li>
<li>映射数据到新的空间： 傅里叶分析、小波分析</li>
<li>特征构造：如密度 &#x3D; 质量&#x2F;体积</li>
</ol>
<h4 id="离散化和二元化"><a href="#离散化和二元化" class="headerlink" title="离散化和二元化"></a>离散化和二元化</h4><p>为什么要离散化&#x2F;二元化：</p>
<ol>
<li>减少属性值个数，便于挖掘；</li>
<li>离散化产生概念分层结构，可以在不同抽象层进行挖掘；</li>
<li>有些算法需要离散属性或二元属性；</li>
</ol>
<p>主要情形：</p>
<ul>
<li><p><strong>离散属性二元化</strong>：如将数值转变为二进制</p>
</li>
<li><p><strong>连续属性离散化</strong></p>
<ul>
<li><p>非监督离散化 —— 不使用数据的类别信息</p>
<ul>
<li><p>等宽法 ——  将属性的值域分成具有相同宽度的区间，区间的个数由数据本身的特点决定</p>
<blockquote>
<p>等宽法对离散点很是敏感，可能会导致某些区间存在大量数据，而有的区间数据量却很少。</p>
</blockquote>
</li>
<li><p>等频法 —— 将相同数量的记录放进每个区间。</p>
<blockquote>
<p>为了保证每个区间的数据一致，很有可能将原本是相同的两个数值却被分进了不同的区间。</p>
</blockquote>
</li>
<li><p>k均值法</p>
</li>
</ul>
<p>性能：k均值法&gt;等频法&gt;等宽法</p>
</li>
<li><p>监督离散化 —— 适用数据的类别信息</p>
</li>
</ul>
</li>
</ul>
<h4 id="变量变换"><a href="#变量变换" class="headerlink" title="变量变换"></a>变量变换</h4><p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028092609103.png" alt="image-20221028092609103"></p>
<h3 id="相似性和相异性度量"><a href="#相似性和相异性度量" class="headerlink" title="相似性和相异性度量"></a>相似性和相异性度量</h3><p>两个对象的相似度：这两者的相似程度的数值度量。通常，相似度是非负的，在0（不相似）和1（完全相似）之间取值。</p>
<p>两个对象的相异度：这两者的差异程度的数值度量。通常，属于“<strong>距离</strong>”等同于相异度。相异度有时在[0,1]取值，有时在[0，无穷]取值。</p>
<ul>
<li><p><strong>||x||</strong>  是向量x的<strong>长度</strong>（<strong>范数</strong>），例：||x||是指第二范数，||x||<del>1</del>是指第一范数。</p>
<blockquote>
<p>也可以理解为： Minkowski距离d（x，y）中，y固定为原点（0，0），即坐标x到原点的距离。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>变换： 通常把相似度转换成相异度，或者把邻近度变换到一个特定区间。</p>
</blockquote>
<p>简单属性的相似度和相异度：</p>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202209132134844.png" alt="image-20220913213433773"></p>
<h4 id="数据对象之间的相异度"><a href="#数据对象之间的相异度" class="headerlink" title="数据对象之间的相异度"></a>数据对象之间的相异度</h4><ul>
<li><p><strong>距离</strong> </p>
<p>性质：如果d(x,y) 是两个点x和y之间的距离，则以下性质成立。</p>
<ul>
<li>非负性：1. 对于所有x和y，d(x,y) &gt;&#x3D; 0；2. 仅当 x&#x3D;y 时 d(x,y) &#x3D; 0 。</li>
<li>对称性 ：对于所有x和y，d(x,y) &#x3D; d(y,x)</li>
<li>三角不等式：对于所有x，y，z，d(x,z) &lt; d(x,y) + d(y,z)</li>
</ul>
<p>满足三个性质的测量称为<strong>度量</strong>。</p>
<hr>
<p>距离例子：</p>
<ul>
<li><p><strong>Minkowski距离</strong>：<br>$$<br>d(x,y) &#x3D; (\sum_{k&#x3D;1}^{n}{|x_k - y_k|^r})^{1&#x2F;r}<br>$$<br>r是参数，当r&#x3D;1是曼哈顿距离，当r&#x3D;2是欧几里得距离。</p>
</li>
<li><p><strong>Manhattan</strong> 曼哈顿距离，也叫城市街区距离：<br>$$<br>d(x,y) &#x3D; \sum_{k&#x3D;1}^{n}{|x_k - y_k|}<br>$$</p>
</li>
<li><p><strong>Euclidean</strong> 欧式距离，欧几里得距离：<br>$$<br>d(x，y) &#x3D;  \sqrt{\sum_{k&#x3D;1}^{n}{(x_k - y_k)^2}}<br>$$</p>
</li>
<li><p><strong>上确界距离</strong>，当r趋于无穷时：<br>$$<br>d(x,y) &#x3D; \lim_{r\rightarrow\infty}(\sum_{k&#x3D;1}^{n}{|x_k - y_k|^r})^{1&#x2F;r}<br>$$</p>
<p>$$<br>&#x3D; max{|x<del>k</del>-y<del>k</del>|, k &#x3D; 1,2,…,n}<br>$$</p>
</li>
</ul>
</li>
<li><p>非度量的相异度： 有些相异度无法满足度量性质。</p>
<p>例：集合差， 一般 A-B !&#x3D; B-A，所以size(A-B) !&#x3D;  size(B-A)，不满足对称性。</p>
</li>
</ul>
<h4 id="数据对象之间的相似度"><a href="#数据对象之间的相似度" class="headerlink" title="数据对象之间的相似度"></a>数据对象之间的相似度</h4><p>设<em>s</em>(x, y)是数据点x和y之间的相似度（通常, 0 &lt;&#x3D; <em>s</em>(x, y) &lt;&#x3D; 1），则相似度具有如下典型性质：</p>
<ol>
<li>规范性：如果 s(x, y)&#x3D;1, 则 x&#x3D;y </li>
<li>对称性： s(x,y)  &#x3D;  s(y,x)</li>
<li>然而，三角不等式（或类似性质）通常不成立。</li>
</ol>
<p>邻近性度量：</p>
<ol>
<li><p>简单匹配系数 SMC ：<br>$$<br>SMC &#x3D; \frac{值匹配的属性个数}{属性个数} &#x3D; \frac{f_{11}+f_{00}}{f_{01}+f_{10}+f_{11}+f_{00}}<br>$$<br>场景：作弊检测，两个考生答案的相似度（假设全是“对错题”）</p>
</li>
<li><p>Jaccard系数 ：<br>$$<br>J &#x3D; \frac{匹配的个数}{不涉及0-0匹配的属性个数} &#x3D; \frac{f_{11}}{f_{01}+f_{10}+f_{11}}<br>$$<br>场景：商品推荐，两个顾客购物记录的相似度（一个属性对应一个商品，1为买过，0为没买过）</p>
</li>
<li><p>余弦相似度：</p>
<p>设x和y是两个向量，则<br>$$<br>cos(x,y) &#x3D; \frac{x \cdot y}{||x||||y||}<br>$$</p>
</li>
<li><p>广义Jaccard系数（Tanimoto系数）<br>$$<br>EJ（x，y） &#x3D; \frac{x \cdot y}{||x||^2+||y||^2-x \cdot y}<br>$$</p>
<blockquote>
<p>第2点的系数 J 是 EJ(x,y) 的特例。</p>
</blockquote>
</li>
</ol>
<h2 id="3、探索数据"><a href="#3、探索数据" class="headerlink" title="3、探索数据"></a>3、探索数据</h2><blockquote>
<p><strong>\1. 汇总统计：众数、百分位数、中位数、极差</strong></p>
<p><strong>\2. 可视化：盒状图</strong></p>
</blockquote>
<p>数据探索，就是对数据进行初步研究，以便更好地理解它特殊性质。</p>
<p>主要目的：</p>
<ol>
<li>有助于选择合适的数据预处理和数据分析技术。</li>
<li>可以通过对数据进行直观检查来发现模式。</li>
</ol>
<p>有三个主题： <strong>汇总统计</strong>，<strong>可视化</strong>，联机分析处理OLAP（不要求）</p>
<p>汇总统计和可视化总览：</p>
<table>
<thead>
<tr>
<th>中心趋势</th>
<th>分散性</th>
<th>可视化</th>
</tr>
</thead>
<tbody><tr>
<td>均值</td>
<td>极差</td>
<td>茎叶图</td>
</tr>
<tr>
<td>中位数</td>
<td>四分位数</td>
<td>直方图</td>
</tr>
<tr>
<td>众数</td>
<td>四分位数间距IQR</td>
<td>盒装图</td>
</tr>
<tr>
<td>最小值</td>
<td>方差</td>
<td>饼图</td>
</tr>
<tr>
<td>最大值</td>
<td>标准差</td>
<td>散步图</td>
</tr>
<tr>
<td></td>
<td>峰度与偏度</td>
<td>矩阵&#x2F;热力图</td>
</tr>
</tbody></table>
<h3 id="汇总统计"><a href="#汇总统计" class="headerlink" title="汇总统计"></a>汇总统计</h3><ul>
<li><p><strong>频率：</strong><br>$$<br>frequency(v_i)&#x3D;\frac{具有属性值v_i的对像数}{m}<br>$$</p>
</li>
<li><p><strong>众数</strong>：具有最高频率的值（出现次数最多）</p>
</li>
<li><p><strong>百分位数</strong>： 对于有序数据，考虑值集的百分位数更有意义。</p>
<p>百分位数 x<del>p</del>，指在数据集中有 P% 的数据小于 x。通常约定：min(x) &#x3D; x<del>0%</del>，max(x) &#x3D; x<del>100%</del></p>
</li>
<li><p>位置度量：<strong>均值</strong>和<strong>中位数</strong></p>
<p>如果值的分布是倾斜的，或有离群值，可以考虑适用<strong>截断均值</strong>：指定一个百分位数P%，丢弃高位的 (P&#x2F;2)% 和地位的 (P&#x2F;2)%，之后再求均值，即为截断均值。</p>
<blockquote>
<p>中位数是 P &#x3D; 100% 时的截断均值，标准均值是 P &#x3D; 0% 时的截断均值。</p>
</blockquote>
</li>
<li><p>散步度量：<strong>极差</strong>和<strong>方差</strong></p>
<p>极差：最大值 - 最小值</p>
<p><strong>方差（variance）</strong>：<br>$$<br>variance(x) &#x3D; s^2_x &#x3D; \frac{1}{m-1} \sum_{i&#x3D;1}^{n}{(X_i - \overline{X})^2}<br>$$</p>
</li>
<li><p>由于均值和方差对离群值很敏感，所以常用<strong>更稳健的估计</strong>：</p>
<ul>
<li><p><strong>绝对平均偏差 ADD</strong><br>$$<br>ADD(X)&#x3D; \frac{1}{m} \sum_{i&#x3D;1}^{n}{|X_i - \overline{X}|}<br>$$</p>
</li>
<li><p><strong>中位数据对偏差 MAD</strong><br>$$<br>MAD(x) &#x3D; median({|x_1 - \overline{x}|,…,|x_m - \overline{x}|})<br>$$</p>
</li>
<li><p><strong>四分位数极差 interquartile range</strong><br>$$<br>interquartile range(x) &#x3D; x_{75%} - x_{25%}<br>$$</p>
</li>
</ul>
</li>
<li><p>多元汇总统计：（不知道用不用掌握，在 ppt Ch-3 13页）</p>
<ul>
<li>协方差矩阵</li>
<li>相关矩阵</li>
</ul>
</li>
</ul>
<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><p>可视化是以图形或表格的形式显示信息。 通过可视化，可以更方便地分析数据的特征和属性间的关系。</p>
<p>可视化的动机：</p>
<ol>
<li>人们能够快速吸收大量可视化信息，并发现其中的模式；</li>
<li>解释模式；</li>
</ol>
<p>可视化的一般概念：</p>
<ol>
<li>表示 —— 将数据映射到图形元素</li>
<li>安排 —— 安排数据项的顺序，使得更容易理解</li>
<li>选择 —— 删除或不突出某些对象和属性</li>
</ol>
<p>技术</p>
<ul>
<li><p><strong>茎叶图：</strong> 将数按位数进行比较，把高位作为主干，地位作为分枝叶。</p>
</li>
<li><p><strong>直方图：</strong> 用于显示单个变量值的分布，高度表示对象数。</p>
<p>二维直方图： 每个属性划分区间，两个区间集可以定义值的二维长方体。</p>
</li>
<li><p><strong>盒状图：</strong> 盒的下端和上端指示百分位数25%和75%，盒中的线指示50%，底部和顶部的边缘线指示10%和90%，离群值用“+”显示。</p>
</li>
<li><p>饼图：类似于直方图，但通常用于具有相对较少的值的分类属性。</p>
</li>
<li><p>经验累积分布函数和百分位数图： 显示点小于该值的概率。</p>
</li>
<li><p>散步图： 二维散步图适用xy坐标，数据对象用点在平面上表示，可以用大小、颜色、形状等来表示附加的属性。</p>
</li>
<li><p>等高线图</p>
</li>
<li><p>矩阵</p>
</li>
<li><p>平行坐标系</p>
</li>
<li><p>星形坐标</p>
</li>
<li><p>Chernoff脸</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202209141035761.png" alt="image-20220914103515241"></p>
<h2 id="4、关联分析"><a href="#4、关联分析" class="headerlink" title="4、关联分析"></a>4、关联分析</h2><blockquote>
<p><strong>\1. 基本概念：项集、K-项集、支持度计数、支持度、频繁项集、关联规则、关联规则的支持度和置信度</strong></p>
<p><strong>\2. 先验原理</strong></p>
<p><strong>\3. 产生频繁项集的Apriori算法</strong></p>
<p><strong>1）算法框架</strong></p>
<p><strong>2）产生候选频繁项集的Fk-1´Fk-1方法</strong></p>
<p><strong>\4. 序列模式发现</strong></p>
<p><strong>1）序列的基本概念</strong></p>
<p><strong>2）子序列与序列包含</strong></p>
<p><strong>3）序列模式发现的类Apriori算法</strong></p>
</blockquote>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>定义：关联分析用于<strong>发现大型数据集中的联系</strong>； 所发现的模式常用<strong>关联规则</strong>或<strong>频繁项集</strong>的形式表示。</p>
<ul>
<li><p>项集 —— 包含若干项的集合</p>
<p>k-项集 —— 包含k个项的集合</p>
</li>
<li><p><strong>支持度计数</strong>  ：包含特定项集的事务个数。（所有事务中，总共有几个事务包含了特定项集）<br>$$<br>\sigma()<br>$$</p>
</li>
<li><p>支持度  ：包含特定项集的事务数与总事务数的比值。<br>$$<br>s()<br>$$</p>
</li>
<li><p>频繁项集：满足最小支持度阈值的所有项集。</p>
</li>
<li><p>关联规则： 是指 X —&gt; Y 的蕴含表达式。如{milk, diaper} —&gt; {beer}</p>
<p>关联规则强度：</p>
<ul>
<li><p>支持度 Support，s ：项集出现的频繁程度。</p>
</li>
<li><p>置信度 Confidence，c：Y在包含X的事务中出现的频繁程度。</p>
<p>如：<br>$$<br>{milk,diaper}　—&gt;beer<br>$$</p>
<p>$$<br>s&#x3D;\frac{\sigma(milk,diaper,beer)}{总项集数}<br>$$</p>
<p>$$<br>c&#x3D;\frac{\sigma(milk,diaper,beet)}{\sigma(milk,diaper)}<br>$$</p>
</li>
</ul>
</li>
</ul>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028092809434.png" alt="image-20221028092809434"></p>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>关联规则 挖掘问题： 给定事务的集合，找出其中<strong>支持度</strong>和<strong>置信度</strong>都大于给定阈值的所有规则。</p>
<blockquote>
<p>从数据集提取的规则的数量达指数级：从包含d个项的数据集提取的<strong>可能规则的总数R&#x3D;3^d^-2^d+1^+1</strong>，如果d等于6，则R&#x3D;602</p>
<p>所以需要有效的算法。</p>
</blockquote>
<p>常将关联规则挖掘算法分解为两个主要的子任务： </p>
<ol>
<li>频繁项集产生 —— 找出<strong>满足最小支持度阈值的所有项集</strong>，这些称为<strong>频繁项集</strong>；</li>
<li>规则的产生 —— 从发现的频繁项集中提取所有<strong>高置信度的规则</strong>，这些称为<strong>强规则</strong>；</li>
</ol>
<h4 id="Apriori算法-先验原理"><a href="#Apriori算法-先验原理" class="headerlink" title="Apriori算法(先验原理)"></a>Apriori算法(先验原理)</h4><p><font color="Blue">先验原理：如果一个项集是频繁的，则它的所有子集也一定是频繁的。</font></p>
<ul>
<li>相反，<font color="Blue">如果一个项集是非频繁的，则它的所有超集也一定是非频繁的。</font></li>
</ul>
<p>基于以上原理，对于k-项集：</p>
<ol>
<li>我们从1-项集开始，找出非频繁的项集，则它的超集一定是非频繁的，去除掉这些非频繁的项集；</li>
<li>根据剩下的项集，找出它们的 2-项集（即候选项集）， 再重复第一步，去掉非频繁的2-项集….</li>
</ol>
<p>如何产生 k-候选集：</p>
<ul>
<li><p>F<del>k-1</del> * F<del>1</del> </p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093216431.png" alt="image-20221028093216431"></p>
</li>
<li><p>F<del>k-1</del> * F<del>k-1</del></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093224438.png" alt="image-20221028093224438"></p>
</li>
</ul>
<p>支持度的计算： 对于候选项集C<del>k</del>，算法需要计算每个k-项集的支持度。—— 使用Hash树存储。（看ppt：Ch4-关联分析 基本概念和算法 第29张开始）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093321538.png" alt="image-20221028093321538"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093336316.png" alt="image-20221028093336316"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093404299.png" alt="image-20221028093404299"></p>
<p>。。。。。</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028093439622.png" alt="image-20221028093439622"></p>
<h3 id="高级概念"><a href="#高级概念" class="headerlink" title="高级概念"></a>高级概念</h3><h4 id="进一步拓展"><a href="#进一步拓展" class="headerlink" title="进一步拓展"></a>进一步拓展</h4><blockquote>
<p>频繁模式： 拥有二元属性的项（即出现、不出现），且项在事务中出现比不出现更重要（非对象）。</p>
</blockquote>
<p>关联分析中，进一步的：</p>
<ul>
<li>处理具有<strong>分类属性、连续属性和多层概念</strong>的数据集</li>
<li><strong>序列模式、图模式</strong>等更复杂的实体的挖掘</li>
<li><strong>非频繁模式、负模式以及负相关模式</strong>的挖掘</li>
</ul>
<p>处理分类属性：</p>
<p>对于拥有足够频繁的属性值的属性，可以将其转换为“项”，通过为每个<strong>“属性-值”对</strong>来创建新的项。</p>
<p>如：文化程度：大学，研究生，可以转为：文化程度&#x3D;研究生（1、0），文化程度&#x3D;大学（1、0）</p>
<blockquote>
<p>注：</p>
<p>有些属性值不够频繁的话，就不能称为频繁模式的一部分（如地名，但也可以将地名笼统地汇总为少数的地理位置来减少数量）</p>
<p>某些属性值的频率非常高（分布高度偏斜），可以丢弃超高频繁的项，而采用其他度量来评价模式，如ｈ－置信度。</p>
<p>由于创建新项可能会产生更多的候选项集，所以计算时间可能增加。</p>
</blockquote>
<p>处理连续属性：</p>
<ul>
<li><p>离散化方法 —— 分组，形成有限个区间（等宽、等频、聚类）</p>
</li>
<li><p>非离散化方法 —— 发现连续属性之间的关系（非离散化之后）</p>
<p>如：找出文本文档中词的关联，在文本挖掘中，有时需要发现词之间的关联（如“数据”和“挖掘”）而不是词频区间。方法有：</p>
<ol>
<li><p>转化成0&#x2F;1矩阵，如果规范化词频超过设定的阈值t，则为1，否则为0。</p>
</li>
<li><p>采用min-apriori方法： </p>
<p>s({word1, word2}) &#x3D; min(0.3, 0.6) + min(0.1 , 0.2) +  min(0.4,0.2)+min(0.2, 0) &#x3D; 0.6</p>
<p>其中 s 是支持度</p>
</li>
</ol>
</li>
<li><p>概念分层 </p>
</li>
<li><p>基于统计学的方法</p>
</li>
</ul>
<h4 id="序列模式"><a href="#序列模式" class="headerlink" title="序列模式"></a>序列模式</h4><p>序列是<strong>元素（element）的有序列表</strong>，可记作 s &#x3D; &lt;e<del>1</del>,e<del>2</del>…e<del>n</del>&gt;，其中<strong>e<del>j</del>是一个或多个事件(event)的集族</strong>， 即e<del>j</del> &#x3D; {i<del>1</del>, i<del>2</del>, …, i<del>k</del>}。</p>
<blockquote>
<p>序列是 元素的有序列表，元素是 事件(event)的集族</p>
</blockquote>
<ul>
<li>序列的长度：指元素个数</li>
<li>k-序列： 指序列s中的事件总个数 k。</li>
</ul>
<p>序列模式发现： 给定序列数据库、指定的最小支持度阈值minsup， 任务是找出支持度大于等于minsup的所有序列。（类Apriori算法：</p>
<p>– 候选产生： 一个序列去掉头事件，一个序列去掉尾事件，若剩下的子序列相同，则可产生候选。</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221028094805113.png" alt="image-20221028094805113"></p>
<h4 id="子图模式"><a href="#子图模式" class="headerlink" title="子图模式"></a>子图模式</h4><h2 id="5、回归分析"><a href="#5、回归分析" class="headerlink" title="5、回归分析"></a>5、回归分析</h2><h3 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h3><h3 id="logistic回归"><a href="#logistic回归" class="headerlink" title="logistic回归"></a>logistic回归</h3><h2 id="6、7、分类"><a href="#6、7、分类" class="headerlink" title="6、7、分类"></a>6、7、分类</h2><blockquote>
<p><strong>分类：基本概念、决策树与模型评估</strong></p>
<p><strong>1. 建立分类模型的一般方法</strong></p>
<p><strong>2. 决策树算法</strong></p>
<p>​	<strong>1）算法框架</strong></p>
<p>​	<strong>2）划分评估：基于熵的方法、基于Gini系数的方法、基于分类误差的方法</strong></p>
<p><strong>3. 分类模型的评估方法 （部分内容见课本的第5章）</strong></p>
<p>​	<strong>1）混淆矩阵</strong></p>
<p>​	<strong>2）各种性能指标，包括准确率、错误率、Precision、Recall、P-R曲线、ROC曲线等高</strong></p>
<p>​	<strong>3）评估方法，包括保留法，K-折交叉验证法、自助法等。</strong></p>
</blockquote>
<h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>决策树是以树状结构表示数据分类的结果。</p>
<ul>
<li>非叶子节点代表 测试的条件；</li>
<li>分支代表 某个测试条件的结果，即测试输出；</li>
</ul>
<p>怎样选择最佳划分 —— 不纯性度量（impurity）</p>
<blockquote>
<p>如</p>
<p>不纯性大：</p>
<table>
<thead>
<tr>
<th>C0</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>C1</td>
<td>5</td>
</tr>
</tbody></table>
<p>不纯性小：</p>
<table>
<thead>
<tr>
<th>C0</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>C1</td>
<td>1</td>
</tr>
</tbody></table>
</blockquote>
<h4 id="划分评估"><a href="#划分评估" class="headerlink" title="划分评估"></a>划分评估</h4><h4 id="基尼指标-Gini-Index"><a href="#基尼指标-Gini-Index" class="headerlink" title="基尼指标 Gini Index"></a>基尼指标 Gini Index</h4><p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160122783.png" alt="image-20221109160122783"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160313300.png" alt="image-20221109160313300"></p>
<p>如果一个节点分割成了k个孩子，划分的质量计算公式为：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160434887.png" alt="image-20221109160434887"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160523478.png" alt="image-20221109160523478"></p>
<h4 id="熵-Entropy"><a href="#熵-Entropy" class="headerlink" title="熵 Entropy"></a>熵 Entropy</h4><p>某节点的Entropy计算公式：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160728972.png" alt="image-20221109160728972"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160743677.png" alt="image-20221109160743677"></p>
<p>如果一个节点分割成了k个孩子，划分的质量计算公式为：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160814394.png" alt="image-20221109160814394"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109160854425.png" alt="image-20221109160854425"></p>
<h4 id="分类误差-Classification-error"><a href="#分类误差-Classification-error" class="headerlink" title="分类误差 Classification error"></a>分类误差 Classification error</h4><p>某节点的 Classification error 计算公式：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109161002093.png" alt="image-20221109161002093"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109161020422.png" alt="image-20221109161020422"></p>
<p>如果一个节点分割成了k个孩子，划分的质量计算公式为：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109161035025.png" alt="image-20221109161035025"></p>
<p>例子：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109161107926.png" alt="image-20221109161107926"></p>
<h4 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h4><p>除了考虑增益Gain的大小之外，还要考虑每个划分相关联的记录数。</p>
<p><strong>GainRatio &#x3D; Gain &#x2F; SplitINFO</strong></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109203657533.png" alt="image-20221109203657533"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109203643088.png" alt="image-20221109203643088"></p>
<h3 id="模型的评估"><a href="#模型的评估" class="headerlink" title="模型的评估"></a>模型的评估</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>数据挖掘是从观察数据中归纳（学习）得到模型（知识），而一个模型是否有效、高效，就需要合理的评估（性能测评）。</p>
<p>方法主要有： 回归 、分类。</p>
<p>预估模型的误差（性能表现）主要有：</p>
<ul>
<li>训练误差：模型在训练数据上的犯错情况；</li>
<li>泛化误差：模型在未知数据上的期望误差；</li>
</ul>
<blockquote>
<p>要求：好的模型要有 低训练误差和 低泛化误差，即能 很好的拟合训练数据，对未知样本也能准确预测；</p>
</blockquote>
<p>问题挑战：</p>
<ul>
<li>过拟合： 模型复杂度过高，学习能力过强，把训练数据中的不太一般的特性也学习了。 —— 很低的训练误差，但泛化误差偏高。</li>
<li>欠拟合：模型容量（学习能力）不足，不能充分学习训练数据的一般性质。 —— 训练误差和预测能力都不理想。</li>
</ul>
<blockquote>
<p>例子： 以决策树为例，</p>
<ul>
<li>树规模太小 —— 容易欠拟合。</li>
<li>树规模逐渐增大 —— 训练误差随规模增大而减小，当检验误差在某一规模前也随之减小，但规模大到一定程度后，检验误差开始增大，出现过拟合。</li>
</ul>
</blockquote>
<p>模型评估主要有：</p>
<ul>
<li>性能指标</li>
<li>模型复杂度</li>
<li>评估方法</li>
<li>模型比较</li>
</ul>
<h4 id="回归模型的性能指标"><a href="#回归模型的性能指标" class="headerlink" title="回归模型的性能指标"></a>回归模型的性能指标</h4><ul>
<li><p>Explained variance score  （可解释方差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194013456.png" alt="image-20221109194013456"></p>
</li>
<li><p>Max error   （最大误差值）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194025949.png" alt="image-20221109194025949"></p>
</li>
<li><p>Mean absolute error    （平均绝对值误差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194033838.png" alt="image-20221109194033838"></p>
</li>
<li><p>Mean squared error   （平方误差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194042812.png" alt="image-20221109194042812"></p>
</li>
<li><p>Mean Squared logarithmic error    （对数平方误差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194055119.png" alt="image-20221109194055119"></p>
</li>
<li><p>Mean absolute percentage error     （平均绝对百分比误差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194104613.png" alt="image-20221109194104613"></p>
</li>
<li><p>Media absolute error    （中位绝对误差）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194113430.png" alt="image-20221109194113430"></p>
</li>
<li><p>R^2^ score      （决定系数）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109194121837.png" alt="image-20221109194121837"></p>
</li>
</ul>
<h4 id="分类模型的性能指标"><a href="#分类模型的性能指标" class="headerlink" title="分类模型的性能指标"></a>分类模型的性能指标</h4><h5 id="混淆矩阵-二分类"><a href="#混淆矩阵-二分类" class="headerlink" title="混淆矩阵(二分类)"></a>混淆矩阵(二分类)</h5><p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109164635027.png" alt="image-20221109164635027"></p>
<p>真实的在前，预测的在后</p>
<ul>
<li>TP：True Positive（真正例）； </li>
<li>FN：False Negative（假反例）</li>
<li>FP：False Positive（假正例）； </li>
<li>TN：True Negative（真反例）</li>
</ul>
<p>几个基本值：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109164757881.png" alt="image-20221109164757881"></p>
<ul>
<li><p>真正率TPR： 预测准确的样本中，真实的正样本的占比；</p>
</li>
<li><p>真负率TNR：预测错误的样本中，真实的正样本的占比</p>
</li>
<li><p>假正率FPR：预测错误的样本中，负样本（被错估为正）的占比</p>
</li>
</ul>
<h5 id="各种性能指标"><a href="#各种性能指标" class="headerlink" title="各种性能指标"></a>各种性能指标</h5><ul>
<li><p><strong>正确率</strong>（精度）accuracy &#x3D; <strong>（TP + TN）&#x2F; N</strong> ， 即真实的正样本占比。</p>
</li>
<li><p><strong>错误率</strong> error_rate &#x3D; <strong>（FP + FN）&#x2F; N</strong> ， 即真实的负样本占比</p>
<blockquote>
<p>N &#x3D; TP + TN + FP + FN</p>
<p>正确率 + 错误率 &#x3D; 1</p>
</blockquote>
</li>
<li><p><strong>平衡精度</strong>（即TPR与TNR的算术平均）：balanced_accuracy &#x3D; <strong>（TPR + TNR）&#x2F; 2</strong> ， </p>
</li>
<li><p><strong>几何平均Gmean</strong>（TPR与TNR的几何平均）：Gmean &#x3D; <strong>（TPR + TNR）^1&#x2F;2^</strong></p>
</li>
<li><p><strong>查准率</strong>：Precision &#x3D; <strong>TP &#x2F;（TP + FP）</strong> ，即预测出的正样本中，真实的正样本占比；</p>
</li>
<li><p><strong>查全率</strong>：Recall &#x3D; <strong>TP &#x2F;（TP + FN）</strong>， 即真实的正样本中，被正确预测的正样本的占比</p>
</li>
<li><p><strong>调和平均</strong> F<del>x</del> &#x3D; （x^2^ + 1）* Precision * Recall &#x2F; （x^2^ * Precision + Recall）</p>
<blockquote>
<p>当x&#x3D;1时，有 F<del>1</del> &#x3D; 2*Precision*Recall &#x2F; (Precision + Recall)</p>
</blockquote>
</li>
<li><p>P-R曲线与平衡点（P是查准率，R是查全率）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109170853889.png" alt="image-20221109170853889"></p>
</li>
<li><p>ROC曲线与下方图面积AUC</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109170929060-16679849699061.png" alt="image-20221109170929060"></p>
</li>
</ul>
<hr>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109170956247.png" alt="image-20221109170956247"></p>
<h5 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h5><p>因为泛化误差是未知数据的表现，所以为了顾及泛化误差，可以事先从训练样本中留出一部分数据，作为未知数据样本。即划分为<strong>训练数据</strong>和<strong>测试数据</strong>。</p>
<p>训练数据和检验数据的分类方法有：</p>
<ul>
<li><p>保持法 —— </p>
<p>将数据集划分为两个<strong>互斥</strong>的集合，一个为训练集，一个为检验集。 一般用“分层抽样”，使得分布与原数据集尽量一致。</p>
</li>
<li><p>交叉验证法 —— </p>
<p>将数据集<strong>划分为k份</strong>，抽k份中的一份作为检验集（<strong>从S1到Sk，分别当一次检验集</strong>），能训练k次模型，求出的<strong>k个泛化误差取平均值</strong>作为结果。</p>
</li>
<li><p>自助法 —— </p>
<p>对于有n个样本的数据集D， 使用<strong>有放回抽样，抽n次</strong>，形成一个包含n个样本的数据集D’（D’可能有重复数据）。 <strong>D’作为训练集， D-D’作为检验集</strong>。</p>
<p>（优点：数据集较小，或难以有效划分训练集和检验集时很有用；同时对集成学习有帮助。</p>
<p>缺点： 改变了初始数据集的分布，会引入估计偏差）</p>
</li>
</ul>
<h2 id="8、贝叶斯分类器"><a href="#8、贝叶斯分类器" class="headerlink" title="8、贝叶斯分类器"></a>8、贝叶斯分类器</h2><blockquote>
<p>1）贝叶斯公式</p>
<p>2）贝叶斯分类的一般方法</p>
<p>3）朴素贝叶斯分类器</p>
</blockquote>
<p><strong>贝叶斯公式：</strong></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109174023393.png" alt="image-20221109174023393"></p>
<p><strong>贝叶斯分类器：</strong></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109174220665.png" alt="image-20221109174220665"></p>
<p>其中 似然P(X|y&#x3D;c<del>j</del>)的计算是难点，方法有：</p>
<ul>
<li>朴素贝叶斯方法（简单情形）</li>
<li>贝叶斯置信网络（复杂情形）</li>
</ul>
<hr>
<p><strong>朴素贝叶斯分类器：</strong></p>
<p>在计算类条件概率时，假设属性之间是条件独立的，进而，将联合概率的计算简化成边缘概率的计算（“朴素”的内涵）。</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109174849217.png" alt="image-20221109174849217"></p>
<blockquote>
<p>上述公式与下面的公式原理一样（辅助理解）：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109174952459.png" alt="image-20221109174952459"></p>
</blockquote>
<p>对于各个边缘概率：</p>
<ul>
<li><p>如果是离散属性： 直接数出来即可</p>
</li>
<li><p>如果是连续属性：</p>
<ul>
<li><p>可以把连续数据离散化</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109175410133.png" alt="image-20221109175410133"></p>
</li>
<li><p>假设连续属性服从某种概率分布，然后利用训练数据集对分布参数进行估计（常用正态分布）</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109185236808.png" alt="image-20221109185236808"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109185254637.png" alt="image-20221109185254637"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109185309905.png" alt="image-20221109185309905"></p>
<p>举例：</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109185334124.png" alt="image-20221109185334124"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221109185343289.png" alt="image-20221109185343289"></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>???</p>
<p>??</p>
<p>?</p>
</blockquote>
<h2 id="9、分类算法：人工神经网络"><a href="#9、分类算法：人工神经网络" class="headerlink" title="9、分类算法：人工神经网络"></a>9、分类算法：人工神经网络</h2><blockquote>
<p>1）人工神经网络的要素：网络结构、激活函数、优化模型（损失函数）、优化算法</p>
<p>2）感知器的网络结构以及学习算法</p>
<p>3）三层前馈神经网络：网络结构、激活函数、基于均方误差损失函数的优化模型</p>
</blockquote>
<h2 id="10、集成学习"><a href="#10、集成学习" class="headerlink" title="10、集成学习"></a>10、集成学习</h2><blockquote>
<p>1）集成学习的一般框架及要素</p>
<p>2）Bagging算法（算法流程）</p>
<p>3）AdaBoost算法（基本思想）</p>
</blockquote>
<h2 id="11、聚类分析-基本概念和算法"><a href="#11、聚类分析-基本概念和算法" class="headerlink" title="11、聚类分析 基本概念和算法"></a>11、聚类分析 基本概念和算法</h2><blockquote>
<p>\1. 聚类分析的任务描述</p>
<p>\2. 聚类任务（无监督学习）与分类任务（有监督学习）的不同</p>
<p>\3. K-均值聚类算法</p>
<p>\4. 凝聚层次聚类算法</p>
<p>\5. DBSCAN算法的基本原理</p>
</blockquote>
<h2 id="12、异常检测"><a href="#12、异常检测" class="headerlink" title="12、异常检测"></a>12、异常检测</h2><blockquote>
<p>\1. 异常检测的应用</p>
<p>\2. 离群点</p>
<p>\3. 异常检测的主要技术方法</p>
</blockquote>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>作业1</p>
<ol>
<li><p>什么是数据挖掘？</p>
<p>数据挖掘是在大型数据存储库中，自动发现有用信息的过程。它是综合了统计学、最优化、机器学习、以及数据库的一门现代计算机技术，旨在发现海量数据中的模型与模式。</p>
</li>
<li><p>数据挖掘的主要流程：</p>
<p>业务理解、数据获取、数据预处理、数据建模、模型评估、模型部署</p>
</li>
<li><p>数据挖掘的任务有哪几类？</p>
<p>一般分为两类：预测任务和描述任务。</p>
<p>其中，预测任务包含：关联分析（关联规则发现，序列模式发现），聚类；  描述任务包含：预测建模（分类，回归），异常&#x2F;偏差检测</p>
</li>
<li><p>查阅资料，了解数据挖掘的现实应用。围绕一个案例，撰写一份简要的报告，内容主要包括：</p>
<p>1）领域背景</p>
<p>2）问题</p>
<p>3）数据挖掘方法</p>
<p>4）效果</p>
<p>糖尿病是世界上一种常见的疾病，全世界的糖尿病患者高达5亿。糖尿病的临床诊断往往是从身体症状和化验值异常着手的。有些异常指标包括身体质量指数（ BMI ），血压（ BP ）指数等。</p>
<p>利用聚类分析工具可以分析患者的疾病诊断数据，以进行探索性的数据分析，并考察产生的聚类结果的意义。至于糖尿病患者的数据，聚类分析工具试图按照年龄、种族、性别、体重指数和BP指数等产生聚类模式，并将数据划分到相应的自然组群中。</p>
<p>通过聚类分析，专家们在所有3个数据集中共得到4种类型的患者：</p>
<ol>
<li>患者为肥胖（体重指数&gt; 56 ），但血压正常；</li>
<li>患者基本指标（BMI，BP）是正常的 ；</li>
<li>患者血压在正常范围内，但体重指标异常 ；</li>
<li>患者基本指数（BMI，BP）异常 ；</li>
</ol>
<p>以上4种糖尿病的聚类结果揭示了糖尿病患者典型的四个分型，在临床上具有重要意义。</p>
</li>
</ol>
<h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><h2 id="第1章-软件测试概述"><a href="#第1章-软件测试概述" class="headerlink" title="第1章   软件测试概述"></a><strong>第1章   软件测试概述</strong></h2><ol>
<li><p><strong>软件测试的基本概念</strong>  </p>
<p>软件测试是为了发现错误而针对某个程序或系统的执行过程。即软件测试是以寻找系统中存在的错误为目的的。 </p>
<p>同时，也要对软件系统相关文档进行检查和评审，以确认这些文档的内容满足客户需要。</p>
</li>
<li><p><strong>软件测试用例的概念</strong></p>
<p>测试用例就是为了某个测试点而设计的操作过程序列、条件、期望结果及相关数据的一个特定的集合。</p>
<p>即 测试输入数据，和预期的输出数据 组成。</p>
</li>
<li><p><strong>软件测试与软件开发（软件的生命周期）的关系</strong></p>
<p>软件测试在软件开发过程中占有重要的地位，在传统的瀑布模型中，软件测试只成为其阶段性的一段工作（进行代码的测试）。</p>
<p>而现代软件工程思想将软件测试认为是贯穿整个软件生命周期，并且是保证软件质量的重要手段之一。</p>
</li>
</ol>
<hr>
<h2 id="第2章-软件开发过程与软件测试"><a href="#第2章-软件开发过程与软件测试" class="headerlink" title="第2章   软件开发过程与软件测试"></a><strong>第2章   软件开发过程与软件测试</strong></h2><ol>
<li><p><strong>软件开发的几种过程模型</strong></p>
<ul>
<li>线性顺序模型</li>
<li>原型模型</li>
<li>快速开发模型</li>
<li>演化软件过程模型<ul>
<li>增量模型</li>
<li>螺旋模型</li>
</ul>
</li>
</ul>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221129182118818.png" alt="image-20221129182118818"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221129182129579.png" alt="image-20221129182129579"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221129182225740.png" alt="image-20221129182225740"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221129182156260.png" alt="image-20221129182156260"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221129182203860.png" alt="image-20221129182203860"></p>
</li>
<li><p><strong>静态测试与动态测试的概念，以及静态测试与动态测试的方法</strong></p>
<ol>
<li><p>静态测试 ：</p>
<p>不需要执行被测软件，而是采用分析和查看的方式，来发现软件当中的缺陷，包括需求文档、源代码、设计文档，以及其他与软件相关文档中的二义性和错误。</p>
<p>方法： 走查，审查，静态代码分析工具</p>
<blockquote>
<p>走查是非正式的，会检查所有与源程序代码相关的文档； 审查比走查要求更正规；</p>
</blockquote>
</li>
<li><p>动态测试：</p>
<p>动态测试是指通过运行实际被测试软件，通过观察程序运行时所表现的状态、行为等来发现软件的缺陷。并对被测程序的运行情况进行分析对比，以便发现程序表现的行为与设计规格或客户需求不一致的地方。</p>
<p>方法： 黑盒测试，白盒测试，灰盒测试</p>
</li>
</ol>
</li>
</ol>
<hr>
<h2 id="第3章-白盒测试"><a href="#第3章-白盒测试" class="headerlink" title="第3章   白盒测试"></a><strong>第3章   白盒测试</strong></h2><ol>
<li><p><strong>白盒测试的定义和工作原理；</strong></p>
<p>白盒测试又称为结构测试或逻辑驱动测试，是针对被测试程序单元内部如何工作的测试；特点是基于被测试程序的源代码，而不是软件的需求规格说明。</p>
<p>工作原理：</p>
<ol>
<li>保证一个模块中的所有独立路径至少被测试一次；</li>
<li>所有逻辑值都需要测试真值和假值两种情况；</li>
<li>检查程序的内部数据结构，保证其结构的有效性；</li>
<li>在上下边界及可操作范围内运行所有循环。</li>
</ol>
</li>
<li><p><strong>动态测试是指通过运行实际被测软件，从而发现存在的缺陷；</strong></p>
</li>
<li><p><strong>对于n个变量的程序，边界值测试用例数，健壮性测试用例；</strong></p>
<p>对于有n个输入变量的程序，基本边界值分析的测试用例个数为4n+1。 </p>
<p>在健壮性测试中， 对于有n个输入变量的程序，健壮性测试的测试用例个数为<strong>6n+1</strong>。 </p>
<p>对于有n个输入变量的程序，最坏情况测试的测试用例个数为5^n^。</p>
<p>对于有n个输入变量的程序，健壮最坏情况测试的测试用例个数为7^n^。</p>
</li>
<li><p><strong>环形复杂度的概念以及公式，三种计算方式；</strong></p>
<p>环形复杂度又称为圈复杂度，是一种为程序逻辑复杂度提供定量尺度的软件度量。 它可以提供程序基本集的独立路径数量和确保<code>所有语句至少执行一次</code>的过程。常用于基本路径测试法。</p>
<p>环形复杂度的度量方法：一个强连通流图中线性无关的有向环的个数就是该程序的环形复杂度。（强连通图，是指从图中任意个结点出发都能到达图中其他结点的有向图。）</p>
<p>公式1： V(G) &#x3D; m - n + p， 即 有向边的总数 - 节点数 + 1</p>
<p>公式2： V(G) &#x3D; 强连通的流图在平面上围成的区域数</p>
<p>公式3： V(G) &#x3D; 判定节点数 + 1</p>
</li>
<li><p><strong>白盒测试的逻辑覆盖方法：语句覆盖、判定覆盖、条件覆盖、判定&#x2F;条件覆盖、条件组合覆盖、改进的判定&#x2F;条件覆盖、路径覆盖</strong></p>
<p>(选择，填空等等，可能20多分，是重点！)</p>
<ul>
<li><p><strong>语句覆盖</strong>： 使程序中的每一条可执行语句至少执行一次。</p>
</li>
<li><p><strong>判定覆盖</strong>：也叫分支覆盖，使得程序中的每个判定表达式的每种可能至少执行一次。</p>
</li>
<li><p><strong>条件覆盖</strong>：不仅每个语句至少执行一次， 且判定式中，每个条件都取到各种可能的结果（判定式中的“真”和“假”都至少取一次）。</p>
</li>
<li><p><strong>判定&#x2F;条件覆盖</strong>：每个判定表达式所有可能的值至少取一次，且其中的条件的“真”“假”也至少取一次。</p>
</li>
<li><p><strong>条件组合覆盖</strong>：使判定表达式的条件的所有可能组合至少取一次。</p>
</li>
<li><p><strong>改进的判定&#x2F;条件覆盖</strong>：</p>
<p>每一个基本块都被覆盖；</p>
<p>每一个简单条件都取过真值和假值；</p>
<p>每一个判定都得出过所有可能的输出结果；</p>
<p>每一个简单条件对表达式对表达式的输出结果的影响是独立的；</p>
</li>
<li><p><strong>路径覆盖</strong>：使得所有可能的路径都至少执行一次。</p>
</li>
</ul>
</li>
</ol>
<hr>
<h2 id="第4章-黑盒测试"><a href="#第4章-黑盒测试" class="headerlink" title="第4章   黑盒测试"></a><strong>第4章   黑盒测试</strong></h2><ol>
<li><p><strong>黑盒测试的定义和工作原理；</strong></p>
<p>黑盒测试又称功能测试、数据驱动测试，不需要了解程序的内部逻辑结构和内部特性，将被测试程序视为一个不能打开的黑盒子，而注重于程序的外部结构。</p>
<p>工作原理：</p>
<ol>
<li>检测功能是否有遗漏；</li>
<li>检测性能是否满足要求；</li>
<li>检测人机交互是否有错误；</li>
<li>检测界面是否有错误；</li>
<li>检测数据结构或外部数据库访问是否有错误；</li>
<li>检测接收数据和结果输出是否错误；</li>
<li>检测程序初始化和终止方面是否有错误；</li>
</ol>
</li>
<li><p>（给定一个题目，进行划分， 也考20多分）</p>
<p>黑盒测试是将所有的输入作为测试输入，是穷举法。但穷举法不可实现，所以需要选取软件输入域的一个子集：</p>
<p><strong>(1) 等价类的划分。一个软件的全部输入的集合可以至少分为两个子集，一个包含所有正常和合法的输入，另外一个包含所有异常和非法的输入。</strong></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213105335221.png" alt="image-20221213105335221"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213105343850.png" alt="image-20221213105343850"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213105409294.png" alt="image-20221213105409294"></p>
<p><strong>(2) 边界值分析方法；</strong></p>
<p>从数据的定义域的边界数据进行分析，对于合法和不合法的边界数据进行测试。</p>
<ul>
<li>输入变量取值：最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max)  ）<ul>
<li>健壮性测试： 略小于最小值(min-)， 略大于最大值(max+)</li>
</ul>
</li>
</ul>
<p> <img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213110149950.png" alt="image-20221213110149950"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213110156314.png" alt="image-20221213110156314"></p>
<p><strong>(3)决策表法， 条件桩、动作桩、条件项和动作项；</strong></p>
<p>  将复杂的问题按各种可能的分支情况列举出来</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213111456944.png" alt="image-20221213111456944"></p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213111505914.png" alt="image-20221213111505914"></p>
<p><strong>(4) 因果图法。</strong></p>
<p>描述软件的 输入条件（原因）于输出结果之间的依赖关系。（生成的就是判定表）</p>
</li>
</ol>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221213111614003.png" alt="image-20221213111614003"></p>
<hr>
<h2 id="第5章-单元测试、集成测试和系统测试"><a href="#第5章-单元测试、集成测试和系统测试" class="headerlink" title="第5章   单元测试、集成测试和系统测试"></a><strong>第5章   单元测试、集成测试和系统测试</strong></h2><ol>
<li><p><strong>单元测试的概念</strong>  </p>
<p>又称模块测试，是对已实现软件的最小单元进行测试，发现其中存在的软件缺陷，以保证构成软件的各个单元质量。这些最小单元可以一个类、一个函数或一个子程序。</p>
</li>
<li><p><strong>集成测试的概念</strong></p>
<p>也叫组装测试或联合测试，在单元测试的基础上，将所有模块按照设计要求组装成为子系统或系统，进行集成测试。(集成测试是单元测试的逻辑拓展)</p>
</li>
<li><p><strong>系统测试的概念</strong></p>
<p>系统测试是将集成好的软件系统，作为整个基于计算机系统的一个元素，与计算机硬件、外设、支持软件、数据等其他系统元素结合在一起，在实际运行环境下进行的一系列测试活动。</p>
</li>
<li><p><strong>单元测试和集成测试的区别</strong></p>
<p>测试的粒度不同：单元测试是最小粒度的，只测试一个工作单元；而集成测试是中等粒度的，用于测试模块或模块间的组合。</p>
<p>测试方法不同：单元测试主要是白盒测试，集成测试主要是黑盒测试。</p>
<p>测试时间不同：集成测试晚于单元测试。</p>
<p>测试内容不同：单元测试主要是工作单元内的逻辑、功能、变量使用等的测试，集成测试主要是验证各个接口之间的数据传递，及组合后是否达到预期。</p>
</li>
<li><p><strong>设计驱动模块、桩模块的功能和目的；</strong></p>
<p>驱动模块：相当于被测模块的主程序，主要用于接收测试数据，将相关数据传输给被测试模块。目的是为了访问类库的属性和方法，检测类库的功能是否正确。</p>
<p>桩模块：模拟被测模块所调用的模块。 目的是为了代替被测模块的接口，接收或传递被测模块的数据。</p>
<p><img src="D:\Note\Notes\source_posts\学校课程笔记.assets\image-20221205140801187.png" alt="image-20221205140801187"></p>
</li>
</ol>
<hr>
<h2 id="第6章-面向对象的测试"><a href="#第6章-面向对象的测试" class="headerlink" title="第6章   面向对象的测试"></a><strong>第6章   面向对象的测试</strong></h2><ol>
<li><p><strong>面向对象测试的基本概念、测试的步骤；</strong></p>
<p>面向对象的测试主要是针对面向对象程序进行的测试，因为类和对象提升了系统聚合度，增加了复杂性；因为继承的性质，要考虑父类方法是否需要在子类中重测；因为封装的信息隐蔽性，需要时刻考虑对象的状态；因为多态带来的不确定性，需要增加用例数量和执行路径。</p>
<p>测试步骤：</p>
<p>面向对象分析的测试</p>
<p>面向对象设计的测试</p>
<p>面向对象编程的测试</p>
<p>面向对象软件的系统测试</p>
</li>
<li><p><strong>面向对象的系统采用的集成策略有哪两种；</strong></p>
<p>基于线程的测试： 对某输入或事件做出回应的一个线程，分别集成并测试每个线程，同时应用回归测试保证没有产生副作用。</p>
<p>基于使用的测试： 先测试独立类（很少使用服务器类的类），再增加使用独立类的类，进行测试，一直到构成完整的系统。</p>
</li>
<li><p><strong>面向对象测试的类测试内容有哪些；</strong></p>
<p>关联和聚合关系的测试；</p>
<p>继承关系的测试；</p>
<p>多态&#x2F;动态绑定的测试</p>
</li>
</ol>
<hr>
<h2 id="第7章-自动化测试"><a href="#第7章-自动化测试" class="headerlink" title="第7章   自动化测试"></a><strong>第7章   自动化测试</strong></h2><ol>
<li><p><strong>自动化测试的概念</strong></p>
<p>软件测试自动化是通过软件测试工具，按照测试人员预定的计划和测试用例对软件产品进行自动测试。</p>
</li>
<li><p><strong>常用的自动化测试工具</strong></p>
</li>
</ol>
<p>第8章      QTP 测试工具</p>
<ol>
<li>QTP 自动化测试的概念</li>
<li>QTP 测试软件的下载和安装</li>
<li>QTP 测试软件的使用</li>
</ol>
<p>第9章      LoadRunner 测试工具</p>
<p>1、    LoadRunner的三个组成部分</p>
<p>2、    LoadRunner 测试软件的下载和安装</p>
<p>3、    LoadRunner 测试软件的使用</p>
<p>综合研讨：</p>
<p>给一个测试软件，如何设计测试</p>
<ol>
<li>查找需求文档，设计文档等，分析测试需求；</li>
<li>制定测试计划，确定测试范围和测试策略，一般有：功能性测试、界面测试、性能测试、数据库测试、安全性测试、兼容性测试；</li>
<li>设计测试用例</li>
<li>开展测试，并记录缺陷。定期评审，对测试进行评估和总结，调整测试的内容。</li>
</ol>
<h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><ol start="2">
<li><p>什么是软件测试？软件测试的基本原则是什么？</p>
<p>软件测试是为了发现错误而针对某个程序或系统的执行过程。即软件测试是以寻找系统中存在的错误为目的的。</p>
<p>基本原则：</p>
<ol>
<li>测试不是为了证明系统的正确性，而是为了证明系统存在缺陷。</li>
<li>所有的测试都应该追溯到用户的需求。</li>
<li>测试应当尽早开始和不断进行。</li>
<li>穷举测试是不可能的。（因为输入量太大，输出结果太多，软件执行路径太多，软件说明书是客观的）</li>
<li>第三方测试会更客观，更有效（程序员避免测试自己的程序）</li>
<li>pareto原则，即二八原则应用于软件测试（80%的错误 可能存在于20%的程序模块）</li>
<li>软件测试是有风险的行为；但并非所有的测试都要修复。</li>
<li>测试应从小规模开始，逐步转向大规模</li>
<li>软件测试是一项讲究条理的技术专业（需要经过训练和规范的专业测试员）</li>
</ol>
</li>
<li><p>什么是软件测试用例？良好的测试用例应该具有什么样的特性？</p>
<p>测试用例就是为了某个测试点而设计的测试操作过程序列、条件、期望结果及相关数据的一个特定的集合。</p>
<p>良好的测试用例应该具有以下三个特性：</p>
<ol>
<li>代表性：能代表并覆盖各种合法、不合法、边界内、越界的、极限数据或操作等。</li>
<li>可判定性：测试执行的结果的正确性是可以判定的。</li>
<li>可再现性：对于同样的测试用例，系统执行的结果应当相同，且相同的测试执行过程能反复操作。</li>
</ol>
</li>
</ol>
<h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><ol>
<li><p>软件测试的基本原则是什么？</p>
<ol>
<li>测试不是为了证明系统的正确性，而是为了证明系统存在缺陷。</li>
<li>所有的测试都应该追溯到用户的需求。</li>
<li>测试应当尽早开始和不断进行。</li>
<li>穷举测试是不可能的。（因为输入量太大，输出结果太多，软件执行路径太多，软件说明书是客观的）</li>
<li>第三方测试会更客观，更有效（程序员避免测试自己的程序）</li>
<li>pareto原则，即二八原则应用于软件测试（80%的错误 可能存在于20%的程序模块）</li>
<li>软件测试是有风险的行为；但并非所有的测试都要修复。</li>
<li>测试应从小规模开始，逐步转向大规模</li>
<li>软件测试是一项讲究条理的技术专业（需要经过训练和规范的专业测试员）</li>
</ol>
</li>
<li><p>软件测试方法怎样分类？</p>
<ol>
<li><p>静态测试 ：</p>
<p>不需要执行被测软件，而是采用分析和查看的方式，来发现软件当中的缺陷，包括需求文档、源代码、设计文档，以及其他与软件相关文档中的二义性和错误。</p>
</li>
<li><p>动态测试：</p>
<p>动态测试是指通过运行实际被测试软件，通过观察程序运行时所表现的状态、行为等来发现软件的缺陷。并对被测程序的运行情况进行分析对比，以便发现程序表现的行为与设计规格或客户需求不一致的地方。</p>
</li>
<li><p>黑盒测试：</p>
<p>黑盒测试又称功能测试或数据驱动测试；是将被测试软件看作一个黑盒子，完全不考虑程序的内部结构和处理过程，只考虑系统的输入和输出，在程序的接口进行测试，检查系统功能是否符合需求规格说明书的要求。</p>
</li>
<li><p>白盒测试：</p>
<p>白盒测试又称结构测试或逻辑驱动测试；是根据被测试程序源代码的内部结构来设计测试用例的方法。</p>
</li>
<li><p>灰盒测试：</p>
<p>灰盒测试结合了白盒测试和黑盒测试的要素，关注输人的正确性，同时关注内部的表现；考虑了用户端、特定的系统知识和操作环境。它在系统组件的协同环境中评价应用软件的设计。</p>
</li>
<li><p>人工测试：</p>
</li>
<li><p>自动化测试：</p>
</li>
</ol>
</li>
<li><p>常用的软件测试过程模型有哪些？在实际测试工作中，怎样选择和使用相关模型？</p>
<ol>
<li>V-model</li>
<li>W-model</li>
<li>H-model</li>
<li>X-model</li>
<li>Pretest-model</li>
</ol>
<p>在实际的工作中，要灵活地运用各种模型的优点，在W-model的框架下，运用H-model的思想进行独立的测试，并同时将测试与开发紧密结合，寻找恰当的就绪点开始测试并反复迭代测试，最终保证按期完成预定目标。</p>
</li>
</ol>
<h3 id="三"><a href="#三" class="headerlink" title="三"></a>三</h3><ol>
<li><p>什么是白盒测试？静态白盒测试有哪些方法？</p>
<p>白盒测试又称为结构测试或逻辑驱动测试，是针对被测试程序单元内部如何工作的测试；特点是基于被测试程序的源代码，而不是软件的需求规格说明。</p>
<p>静态白盒测试方法有：审查，走查，检验等。</p>
</li>
<li><p>循环测试的基本原则是什么？常考虑测试循环的哪几种情况？</p>
<p>基本原则：在循环的边界和运行界限执行循环体。</p>
<p>三种情况：简单循环，串接循环，嵌套循环。</p>
</li>
<li><p>白盒测试的流程有几种类型？常见的白盒测试问题有哪些类型？</p>
<p>流程有两种：</p>
<ul>
<li>界面对象测试 —— 界面对象-&gt;业务对象-&gt;数据管理对象-&gt;数据库</li>
<li>业务对象测试 —— 数据库-&gt;数据管理对象-&gt;业务对象-&gt;界面对象</li>
</ul>
<p>问题分为：</p>
<p>各层公用问题，Java语言规范，数据类型，SQL语句规范，界面UI，VO数值对象，BO业务对象，DMO数据管理对象，业务逻辑重点，业务处理与隔离级别测试，效率测试。</p>
</li>
</ol>
<h3 id="四"><a href="#四" class="headerlink" title="四"></a>四</h3><ol>
<li><p>什么是黑盒测试？黑盒测试的依据和流程是什么？</p>
<p>黑盒测试又称功能测试、数据驱动测试，不需要了解程序的内部逻辑结构和内部特性，将被测试程序视为一个不能打开的黑盒子，而是注重于程序的外部结构。</p>
<p>依据： 测试人员完全考虑程序内部的逻辑结构和内部特性，只依据程序的需求规格说明书，检查程序的功能是否符合它的功能说明。</p>
<p>流程：测试计划——测试设计——测试开发——测试执行——测试评估</p>
<hr>
</li>
<li><p>黑盒测试常用的方法有哪些？在具体测试过程中，怎样选择相对应的黑盒测试方法？</p>
<p>方法：等价类划分法，边界值分析法，决策表法，因果图法。</p>
<ul>
<li>等价类划分法：根据说明书对输入范围进行划分，分为互不相干的子集，所有子集的并集是整个输入域。（至少两个子集：合法正常的输入，异常非法的输入）</li>
<li>边界分析法：从数据的定义域的边界数据进行分析（对合法和不合法的边界都进行选取和测试， 输入变量取值：最小值(min)、略高于最小值(min+)、正常值(nom)、略低于最大值(max-)、最大值(max)  ）<ul>
<li>健壮性测试： 略小于最小值(min-)， 略大于最大值(max+)</li>
</ul>
</li>
<li>决策表法（判定表）：  将复杂的问题按各种可能的分支情况列举出来</li>
<li>因果图法：描述软件的 输入条件（原因）于输出结果之间的依赖关系。（生成的就是判定表）</li>
</ul>
<p>选择依据： 只要有输入输出就可用等价类划分， 输入输出有限定范围才可用边界分析法， 有多种输入条件组合或有多个逻辑条件组合的场景用判定表法或因果图法</p>
<hr>
</li>
<li><p>黑盒测试与白盒测试的主要区别是什么？</p>
<p>在程序结构上，白盒测试是已知的，黑盒测试是未知的；</p>
<p>在规模上，白盒测试是小规模的，黑盒是大规模的；</p>
<p>在依据上，白盒测试需要详细设计说明，黑盒测试则要需求说明和概要设计说明；</p>
<p>在面向上，白盒测试面向程序结构，黑盒测试面向输入输出接口&#x2F;功能要求；</p>
<p>在适用性上，白盒测试适用于单元测试，黑盒适用于组装、系统测试；</p>
<p>白盒测试需要编写额外的测试驱动程序，黑盒一般不用；</p>
<p>白盒测试需要开发人员，黑盒则需要专门测试人员或外部人员；</p>
<p>白盒优点：能够对程序内部的特定部位进行覆盖；缺点：无法检验程序的外部特性，无法检测对要求的遗漏；</p>
<p>黑盒优点：能站在用户的立场上进行测试； 缺点：不能测试程序内部特定部位，如果规格说明有误，则无法发现错误。</p>
</li>
</ol>
<h3 id="五"><a href="#五" class="headerlink" title="五"></a>五</h3><p>1.单元测试的主要任务有哪些？请简述之。</p>
<p>主要任务有：</p>
<ol>
<li>模块的接口</li>
<li>局部数据结构</li>
<li>重要的执行路径</li>
<li>错误处理</li>
<li>边界问题</li>
</ol>
<p>3.单元测试的过程分为哪几个阶段？请简述之。</p>
<p>分为四个阶段：</p>
<ul>
<li>测试计划阶段：（根据说明书、任务书、代码，确定以下内容）<ul>
<li>确定被测试单元的目标、范围、约束条件；</li>
<li>确定被测软件的覆盖程度和覆盖的方法和技术；</li>
<li>确定被测试单元的环境：软件、硬件、网络、人员配备等；</li>
<li>确定被测单元的测试结束的要求；</li>
<li>确定单元测试活动的进度；</li>
</ul>
</li>
<li>测试设计阶段：（根据测试计划，设计测试用例）<ul>
<li>设计测试用例；</li>
<li>获取测试用例的数据；</li>
<li>确定测试的顺序；</li>
<li>获取测试资源，建立测试环境；</li>
<li>编写测试程序和测试说明文档；</li>
</ul>
</li>
<li>测试执行阶段：（对用例进行测试，并记录步骤和结果）<ul>
<li>配置单元测试环境；</li>
<li>执行用例，并记录执行过程；</li>
<li>记录测试结果；</li>
</ul>
</li>
<li>生成测试报告：（分析总结，得到测试结论，写出测试报告）<ul>
<li>根据设计中的期望值和实际结果比较，判定测试是否通过，并记录结果；</li>
<li>如果测试不通过，要分析原因，填写软件问题报告，提出建议；</li>
</ul>
</li>
</ul>
<p>4.集成测试的方法有哪几种？集成测试包括哪些阶段？</p>
<p>方法：</p>
<ul>
<li>大爆炸集成： 一次性集成到一起测试，不考虑组件间的依赖性和可能存在的风险。</li>
<li>自顶向下集成：按照系统层次结构图，以主程序模块为中心，自上而下按深度或广度优先策略，对各模块一边组装一边测试。</li>
<li>自底向上集成：从系统层次结构图的最底层模块开始，逐层向上进行组装和测试。</li>
<li>三明治集成： 综合了自顶向下和自底向上两种集成方法， 把系统分为三层，中间一层为目标层，目标层上用自顶向下，目标层下用自底向上。</li>
</ul>
<p>阶段：</p>
<ul>
<li>计划阶段：</li>
<li>设计阶段：</li>
<li>实施阶段：</li>
<li>执行阶段：</li>
<li>评估阶段：</li>
</ul>
<p>5.系统测试主要测试哪些方面？</p>
<p>分别有：</p>
<ul>
<li>功能性的：<ul>
<li>适应性方面</li>
<li>准确性方面</li>
<li>互操作性方面</li>
<li>安全保密性方面</li>
</ul>
</li>
<li>可靠性：<ul>
<li>成熟性方面</li>
<li>容错性方面</li>
<li>易恢复性方面</li>
</ul>
</li>
<li>易用性<ul>
<li>易理解方面</li>
<li>易学性方面</li>
<li>易操作性方面</li>
<li>从吸引性方面</li>
</ul>
</li>
<li>效率<ul>
<li>时间特性方面</li>
<li>资源利用性方面</li>
</ul>
</li>
<li>维护性<ul>
<li>易分析性方面</li>
<li>易改变性方面</li>
<li>易测试性方面</li>
</ul>
</li>
<li>可移植性<ul>
<li>适应性方面</li>
<li>易安装性方面</li>
<li>共存性方面</li>
<li>易替换性方面</li>
<li>依从性方面</li>
</ul>
</li>
</ul>
<h3 id="六"><a href="#六" class="headerlink" title="六"></a>六</h3><p>1.面向对象的测试是什么样的测试？测试的主要对象是什么？</p>
<p>面向对象的测试主要是针对面向对象程序进行的测试，因为类和对象提升了系统聚合度，增加了复杂性；因为继承的性质，要考虑父类方法是否需要在之类中重测；因为封装的信息隐蔽性，需要时刻考虑对象的状态；因为多态带来的不确定性，需要增加用例数量和执行路径。</p>
<p>测试的主要对象由一系列类组成，这些类中封装了数据及作用在数据上的操作。</p>
<p>2.面向对象测试模型包括哪些主要内容？</p>
<p>​		面向对象分析OOA测试： 对象测试，结构测试，主体测试，属性和实例关联测试，服务和消息关联测试，</p>
<p>​		面向对象设计OOD测试：对认定类测试，对类层次结构测试，对类库支持测试</p>
<p>​		面向对象编程OOP测试：功能性和结构性测试（方法内和方法间测试），测试用例的设计和选择</p>
<p>4.面向对象的集成测试、系统测试与传统的集成测试、系统测试有什么区别？</p>
<ul>
<li><p>面向对象的集成测试，通常要在整个程序编译完成后进行黑盒测试（面向对象程序有动态特性，程序的控制流难以确定，所以只能用黑盒子）</p>
<p>传统的集成测试可以在小模块逐渐构成完整程序的过程分别进行测试。</p>
</li>
<li><p>面向对象的系统测试，是对所有类和主程序构成的整个系统进行的整体测试，以验证软件系统的正确性和性能指标是否满足规格说明书和任务书的要求。（应该尽量搭建与用户实际使用环境相同的测试平台。）</p>
<p>传统的系统测试是将集成好的软件系统，与其他硬件、外设、支持软件、数据等其他系统元素结合，进行的实际运行环境下的测试。</p>
</li>
</ul>
<h3 id="七"><a href="#七" class="headerlink" title="七"></a>七</h3><p>1、什么是自动化测试？</p>
<p>软件测试自动化是通过软件测试工具，按照测试人员预定的计划和测试用例对软件产品进行自动测试。</p>
<p>2、自动化测试的体系结构有哪些内容？</p>
<ul>
<li>外部模块： 测试用例数据库和缺陷库（包含特定公司在各种被测产品中发现的所有缺陷的详细信息）。</li>
<li>场景与配置文件模块： 配置文件包含一组在自动化中使用的变量。</li>
<li>测试用例与测试框架模块： 测试框架功能是“执行什么”-“如何执行”。</li>
<li>工具与结果模块： 工具用于辅助测试框架的执行， 结果模块用于存放每个用例的执行结果。</li>
<li>报告生成器与报告&#x2F;指标模块： 提取必要的输入并格式化报告。</li>
</ul>
<p>3、自动化测试的过程模型包括哪些方面？</p>
<p>三个阶段：</p>
<ol>
<li>自动化测试-需要分析：确定自动化测试的范围以及相应的测试用例，测试数据，并形成详细的文档。</li>
<li>自动化测试-框架的搭建：搭建的要素有 公用的对象，公用的环境，公用的方法，测试数据。</li>
<li>产品和自动化测试包的测试阶段： 即在开发的每个阶段都可以执行一组测试。</li>
</ol>
<h3 id="八"><a href="#八" class="headerlink" title="八"></a>八</h3><p>1，自动化测试工具QTP包括哪几个部分？</p>
<ol>
<li>提供给初级用户使用的关键字视图；</li>
<li>提供给熟悉VBScript脚本编写的自动化测试工程师使用的编辑视图；</li>
</ol>
<p>2，利用QTP进行测试操作的步骤是什么？</p>
<ol>
<li>启动显示界面（插件管理器界面）</li>
<li>加载插件（加载相应的QTP插件）</li>
<li>创建测试用例（选择相应的类型）</li>
<li>打开创建的测试用例</li>
</ol>
<p>4，在测试过程中为什么要插入同步点？怎么插入同步点？</p>
<p>为什么：QTP支持VBScript脚本语言，在执行脚本的过程中，执行语句之间的等待时间是短而固定的，脚本在执行当前语句后，等待固定时间后便开始执行下一条语句。QTP中的同步点技术能有效地解决由于后一条语句先于前一条语句执行而导致脚本阻塞，抛出异常的问题。</p>
<p>怎么插入：点击节点视图左边的灰色条形区域，即可添加同步点；</p>
<p>5，各类检查点有什么作用？具体怎么使用？</p>
<ol>
<li>标准检查点：用于检查对象的属性，如检查某个按钮是否被选取；</li>
<li>页面检查点：检查网页的属性，如检查网页加载时间或网页是否含有不正确的链接；</li>
<li>文本检查点：检查网页上或窗口上出现的文本是否正确，如检查登录系统后是否出现登录成功的文本；</li>
<li>表检查点：检查表格的内容是否正确；</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ValcanoZz</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/">http://example.com/2021/09/20/%E5%AD%A6%E6%A0%A1%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">ValcanoZz Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/Notes/tags/%E5%AD%A6%E6%A0%A1/">学校</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Notes/2021/11/22/Git/"><img class="prev-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151628018.png" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">git</div></div></a></div><div class="next-post pull-right"><a href="/Notes/2021/05/25/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/"><img class="next-cover" src="https://raw.githubusercontent.com/ValcanoZz/Notes_image/main/img/202205151628461.jpeg" onerror="onerror=null;src='/Notes/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C语言</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NjA4NS8zMjU0OA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98"><span class="toc-number">1.</span> <span class="toc-text">数据挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1、概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9A%84%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据挖掘的任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据挖掘的主要流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">1.2.</span> <span class="toc-text">2、数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B4%A8%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据质量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-number">1.2.3.</span> <span class="toc-text">数据预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%81%9A%E9%9B%86"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">聚集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E6%A0%B7"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">抽样</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%B4%E5%BD%92%E7%BA%A6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">维归约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%AD%90%E9%9B%86%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">特征子集选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96%E5%92%8C%E4%BA%8C%E5%85%83%E5%8C%96"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">离散化和二元化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%8F%98%E6%8D%A2"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">变量变换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E4%BC%BC%E6%80%A7%E5%92%8C%E7%9B%B8%E5%BC%82%E6%80%A7%E5%BA%A6%E9%87%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">相似性和相异性度量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E5%BC%82%E5%BA%A6"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">数据对象之间的相异度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BC%BC%E5%BA%A6"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">数据对象之间的相似度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E3%80%81%E6%8E%A2%E7%B4%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">1.3.</span> <span class="toc-text">3、探索数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B1%87%E6%80%BB%E7%BB%9F%E8%AE%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">汇总统计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">可视化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E3%80%81%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">4、关联分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Apriori%E7%AE%97%E6%B3%95-%E5%85%88%E9%AA%8C%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">Apriori算法(先验原理)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.</span> <span class="toc-text">高级概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E6%8B%93%E5%B1%95"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">进一步拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">序列模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%90%E5%9B%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">子图模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E3%80%81%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">5、回归分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92"><span class="toc-number">1.5.1.</span> <span class="toc-text">线性回归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#logistic%E5%9B%9E%E5%BD%92"><span class="toc-number">1.5.2.</span> <span class="toc-text">logistic回归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E3%80%817%E3%80%81%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.</span> <span class="toc-text">6、7、分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">1.6.1.</span> <span class="toc-text">决策树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E8%AF%84%E4%BC%B0"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">划分评估</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E5%B0%BC%E6%8C%87%E6%A0%87-Gini-Index"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">基尼指标 Gini Index</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%86%B5-Entropy"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">熵 Entropy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E8%AF%AF%E5%B7%AE-Classification-error"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">分类误差 Classification error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E7%9B%8A%E7%8E%87"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">增益率</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%9A%84%E8%AF%84%E4%BC%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">模型的评估</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">回归模型的性能指标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">分类模型的性能指标</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5-%E4%BA%8C%E5%88%86%E7%B1%BB"><span class="toc-number">1.6.2.3.1.</span> <span class="toc-text">混淆矩阵(二分类)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.6.2.3.2.</span> <span class="toc-text">各种性能指标</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"><span class="toc-number">1.6.2.3.3.</span> <span class="toc-text">评估方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8"><span class="toc-number">1.7.</span> <span class="toc-text">8、贝叶斯分类器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E3%80%81%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%EF%BC%9A%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C"><span class="toc-number">1.8.</span> <span class="toc-text">9、分类算法：人工神经网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E3%80%81%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.9.</span> <span class="toc-text">10、集成学习</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E3%80%81%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%92%8C%E7%AE%97%E6%B3%95"><span class="toc-number">1.10.</span> <span class="toc-text">11、聚类分析 基本概念和算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E3%80%81%E5%BC%82%E5%B8%B8%E6%A3%80%E6%B5%8B"><span class="toc-number">1.11.</span> <span class="toc-text">12、异常检测</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.12.</span> <span class="toc-text">练习</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.</span> <span class="toc-text">软件测试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">第1章   软件测试概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.2.</span> <span class="toc-text">第2章   软件开发过程与软件测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.</span> <span class="toc-text">第3章   白盒测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95"><span class="toc-number">2.4.</span> <span class="toc-text">第4章   黑盒测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E3%80%81%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-number">2.5.</span> <span class="toc-text">第5章   单元测试、集成测试和系统测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">2.6.</span> <span class="toc-text">第6章   面向对象的测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95"><span class="toc-number">2.7.</span> <span class="toc-text">第7章   自动化测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A0%E9%A2%98"><span class="toc-number">2.8.</span> <span class="toc-text">习题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80"><span class="toc-number">2.8.1.</span> <span class="toc-text">一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C"><span class="toc-number">2.8.2.</span> <span class="toc-text">二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89"><span class="toc-number">2.8.3.</span> <span class="toc-text">三</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B"><span class="toc-number">2.8.4.</span> <span class="toc-text">四</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94"><span class="toc-number">2.8.5.</span> <span class="toc-text">五</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD"><span class="toc-number">2.8.6.</span> <span class="toc-text">六</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83"><span class="toc-number">2.8.7.</span> <span class="toc-text">七</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB"><span class="toc-number">2.8.8.</span> <span class="toc-text">八</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By ValcanoZz</div><div class="footer_custom_text"><div><a onclick="window.open('https://beian.miit.gov.cn/#/Integrated/index')" >粤ICP备2022110986号-1</a></div></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/Notes/js/utils.js"></script><script src="/Notes/js/main.js"></script><script src="/Notes/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><script src="/Notes/js/search/local-search.js"></script><div class="js-pjax"><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["meta[property=\"og:image\"]","meta[property=\"og:title\"]","meta[property=\"og:url\"]","title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>